// Generated by @delightfuldot/codegen

import type {
  H256,
  DispatchError,
  AccountId32,
  Perbill,
  FixedBytes,
  Bytes,
  Header,
  MultiAddress,
  Percent,
  EthereumAddress,
  Data,
  PerU16,
  FixedArray,
  Perquintill,
  BitSequence,
  FixedU128,
  ResultPayload,
  FixedI64,
  Era,
} from '@delightfuldot/codecs';

export type FrameSystemAccountInfo = {
  nonce: number;
  consumers: number;
  providers: number;
  sufficients: number;
  data: PalletBalancesAccountData;
};

export type PalletBalancesAccountData = {
  free: bigint;
  reserved: bigint;
  frozen: bigint;
  flags: PalletBalancesExtraFlags;
};

export type PalletBalancesExtraFlags = bigint;

export type FrameSupportDispatchPerDispatchClass = {
  normal: SpWeightsWeightV2Weight;
  operational: SpWeightsWeightV2Weight;
  mandatory: SpWeightsWeightV2Weight;
};

export type SpWeightsWeightV2Weight = { refTime: bigint; proofSize: bigint };

export type FrameSystemEventRecord = {
  phase: FrameSystemPhase;
  event: StagingKusamaRuntimeRuntimeEvent;
  topics: Array<H256>;
};

export type StagingKusamaRuntimeRuntimeEvent =
  | { pallet: 'System'; palletEvent: FrameSystemEvent }
  | { pallet: 'Indices'; palletEvent: PalletIndicesEvent }
  | { pallet: 'Balances'; palletEvent: PalletBalancesEvent }
  | { pallet: 'TransactionPayment'; palletEvent: PalletTransactionPaymentEvent }
  | { pallet: 'Staking'; palletEvent: PalletStakingPalletEvent }
  | { pallet: 'Offences'; palletEvent: PalletOffencesEvent }
  | { pallet: 'Session'; palletEvent: PalletSessionEvent }
  | { pallet: 'Grandpa'; palletEvent: PalletGrandpaEvent }
  | { pallet: 'ImOnline'; palletEvent: PalletImOnlineEvent }
  | { pallet: 'Treasury'; palletEvent: PalletTreasuryEvent }
  | { pallet: 'ConvictionVoting'; palletEvent: PalletConvictionVotingEvent }
  | { pallet: 'Referenda'; palletEvent: PalletReferendaEvent }
  | { pallet: 'FellowshipCollective'; palletEvent: PalletRankedCollectiveEvent }
  | { pallet: 'FellowshipReferenda'; palletEvent: PalletReferendaEvent002 }
  | { pallet: 'Whitelist'; palletEvent: PalletWhitelistEvent }
  | { pallet: 'Claims'; palletEvent: PolkadotRuntimeCommonClaimsPalletEvent }
  | { pallet: 'Utility'; palletEvent: PalletUtilityEvent }
  | { pallet: 'Identity'; palletEvent: PalletIdentityEvent }
  | { pallet: 'Society'; palletEvent: PalletSocietyEvent }
  | { pallet: 'Recovery'; palletEvent: PalletRecoveryEvent }
  | { pallet: 'Vesting'; palletEvent: PalletVestingEvent }
  | { pallet: 'Scheduler'; palletEvent: PalletSchedulerEvent }
  | { pallet: 'Proxy'; palletEvent: PalletProxyEvent }
  | { pallet: 'Multisig'; palletEvent: PalletMultisigEvent }
  | { pallet: 'Preimage'; palletEvent: PalletPreimageEvent }
  | { pallet: 'Bounties'; palletEvent: PalletBountiesEvent }
  | { pallet: 'ChildBounties'; palletEvent: PalletChildBountiesEvent }
  | { pallet: 'ElectionProviderMultiPhase'; palletEvent: PalletElectionProviderMultiPhaseEvent }
  | { pallet: 'Nis'; palletEvent: PalletNisEvent }
  | { pallet: 'NisCounterpartBalances'; palletEvent: PalletBalancesEvent }
  | { pallet: 'VoterList'; palletEvent: PalletBagsListEvent }
  | { pallet: 'NominationPools'; palletEvent: PalletNominationPoolsEvent }
  | { pallet: 'FastUnstake'; palletEvent: PalletFastUnstakeEvent }
  | { pallet: 'ParaInclusion'; palletEvent: PolkadotRuntimeParachainsInclusionPalletEvent }
  | { pallet: 'Paras'; palletEvent: PolkadotRuntimeParachainsParasPalletEvent }
  | { pallet: 'Hrmp'; palletEvent: PolkadotRuntimeParachainsHrmpPalletEvent }
  | { pallet: 'ParasDisputes'; palletEvent: PolkadotRuntimeParachainsDisputesPalletEvent }
  | { pallet: 'Registrar'; palletEvent: PolkadotRuntimeCommonParasRegistrarPalletEvent }
  | { pallet: 'Slots'; palletEvent: PolkadotRuntimeCommonSlotsPalletEvent }
  | { pallet: 'Auctions'; palletEvent: PolkadotRuntimeCommonAuctionsPalletEvent }
  | { pallet: 'Crowdloan'; palletEvent: PolkadotRuntimeCommonCrowdloanPalletEvent }
  | { pallet: 'StateTrieMigration'; palletEvent: PalletStateTrieMigrationEvent }
  | { pallet: 'XcmPallet'; palletEvent: PalletXcmEvent }
  | { pallet: 'MessageQueue'; palletEvent: PalletMessageQueueEvent }
  | { pallet: 'AssetRate'; palletEvent: PalletAssetRateEvent };

/**
 * Event for the System pallet.
 **/
export type FrameSystemEvent =
  /**
   * An extrinsic completed successfully.
   **/
  | { name: 'ExtrinsicSuccess'; data: { dispatchInfo: FrameSupportDispatchDispatchInfo } }
  /**
   * An extrinsic failed.
   **/
  | { name: 'ExtrinsicFailed'; data: { dispatchError: DispatchError; dispatchInfo: FrameSupportDispatchDispatchInfo } }
  /**
   * `:code` was updated.
   **/
  | { name: 'CodeUpdated' }
  /**
   * A new account was created.
   **/
  | { name: 'NewAccount'; data: { account: AccountId32 } }
  /**
   * An account was reaped.
   **/
  | { name: 'KilledAccount'; data: { account: AccountId32 } }
  /**
   * On on-chain remark happened.
   **/
  | { name: 'Remarked'; data: { sender: AccountId32; hash: H256 } };

export type FrameSupportDispatchDispatchInfo = {
  weight: SpWeightsWeightV2Weight;
  class: FrameSupportDispatchDispatchClass;
  paysFee: FrameSupportDispatchPays;
};

export type FrameSupportDispatchDispatchClass = 'Normal' | 'Operational' | 'Mandatory';

export type FrameSupportDispatchPays = 'Yes' | 'No';

/**
 * The `Event` enum of this pallet
 **/
export type PalletIndicesEvent =
  /**
   * A account index was assigned.
   **/
  | { name: 'IndexAssigned'; data: { who: AccountId32; index: number } }
  /**
   * A account index has been freed up (unassigned).
   **/
  | { name: 'IndexFreed'; data: { index: number } }
  /**
   * A account index has been frozen to its current account ID.
   **/
  | { name: 'IndexFrozen'; data: { index: number; who: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBalancesEvent =
  /**
   * An account was created with some free balance.
   **/
  | { name: 'Endowed'; data: { account: AccountId32; freeBalance: bigint } }
  /**
   * An account was removed whose balance was non-zero but below ExistentialDeposit,
   * resulting in an outright loss.
   **/
  | { name: 'DustLost'; data: { account: AccountId32; amount: bigint } }
  /**
   * Transfer succeeded.
   **/
  | { name: 'Transfer'; data: { from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * A balance was set by root.
   **/
  | { name: 'BalanceSet'; data: { who: AccountId32; free: bigint } }
  /**
   * Some balance was reserved (moved from free to reserved).
   **/
  | { name: 'Reserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unreserved (moved from reserved to free).
   **/
  | { name: 'Unreserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was moved from the reserve of the first account to the second account.
   * Final argument indicates the destination balance type.
   **/
  | {
      name: 'ReserveRepatriated';
      data: {
        from: AccountId32;
        to: AccountId32;
        amount: bigint;
        destinationStatus: FrameSupportTokensMiscBalanceStatus;
      };
    }
  /**
   * Some amount was deposited (e.g. for transaction fees).
   **/
  | { name: 'Deposit'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was withdrawn from the account (e.g. for transaction fees).
   **/
  | { name: 'Withdraw'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was removed from the account (e.g. for misbehavior).
   **/
  | { name: 'Slashed'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was minted into an account.
   **/
  | { name: 'Minted'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was burned from an account.
   **/
  | { name: 'Burned'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was suspended from an account (it can be restored later).
   **/
  | { name: 'Suspended'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was restored into an account.
   **/
  | { name: 'Restored'; data: { who: AccountId32; amount: bigint } }
  /**
   * An account was upgraded.
   **/
  | { name: 'Upgraded'; data: { who: AccountId32 } }
  /**
   * Total issuance was increased by `amount`, creating a credit to be balanced.
   **/
  | { name: 'Issued'; data: { amount: bigint } }
  /**
   * Total issuance was decreased by `amount`, creating a debt to be balanced.
   **/
  | { name: 'Rescinded'; data: { amount: bigint } }
  /**
   * Some balance was locked.
   **/
  | { name: 'Locked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unlocked.
   **/
  | { name: 'Unlocked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was frozen.
   **/
  | { name: 'Frozen'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was thawed.
   **/
  | { name: 'Thawed'; data: { who: AccountId32; amount: bigint } };

export type FrameSupportTokensMiscBalanceStatus = 'Free' | 'Reserved';

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who`.
   **/
  { name: 'TransactionFeePaid'; data: { who: AccountId32; actualFee: bigint; tip: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletStakingPalletEvent =
  /**
   * The era payout has been set; the first balance is the validator-payout; the second is
   * the remainder from the maximum amount of reward.
   **/
  | { name: 'EraPaid'; data: { eraIndex: number; validatorPayout: bigint; remainder: bigint } }
  /**
   * The nominator has been rewarded by this amount to this destination.
   **/
  | { name: 'Rewarded'; data: { stash: AccountId32; dest: PalletStakingRewardDestination; amount: bigint } }
  /**
   * A staker (validator or nominator) has been slashed by the given amount.
   **/
  | { name: 'Slashed'; data: { staker: AccountId32; amount: bigint } }
  /**
   * A slash for the given validator, for the given percentage of their stake, at the given
   * era as been reported.
   **/
  | { name: 'SlashReported'; data: { validator: AccountId32; fraction: Perbill; slashEra: number } }
  /**
   * An old slashing report from a prior era was discarded because it could
   * not be processed.
   **/
  | { name: 'OldSlashingReportDiscarded'; data: { sessionIndex: number } }
  /**
   * A new set of stakers was elected.
   **/
  | { name: 'StakersElected' }
  /**
   * An account has bonded this amount. \[stash, amount\]
   *
   * NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,
   * it will not be emitted for staking rewards when they are added to stake.
   **/
  | { name: 'Bonded'; data: { stash: AccountId32; amount: bigint } }
  /**
   * An account has unbonded this amount.
   **/
  | { name: 'Unbonded'; data: { stash: AccountId32; amount: bigint } }
  /**
   * An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`
   * from the unlocking queue.
   **/
  | { name: 'Withdrawn'; data: { stash: AccountId32; amount: bigint } }
  /**
   * A nominator has been kicked from a validator.
   **/
  | { name: 'Kicked'; data: { nominator: AccountId32; stash: AccountId32 } }
  /**
   * The election failed. No new era is planned.
   **/
  | { name: 'StakingElectionFailed' }
  /**
   * An account has stopped participating as either a validator or nominator.
   **/
  | { name: 'Chilled'; data: { stash: AccountId32 } }
  /**
   * The stakers' rewards are getting paid.
   **/
  | { name: 'PayoutStarted'; data: { eraIndex: number; validatorStash: AccountId32 } }
  /**
   * A validator has set their preferences.
   **/
  | { name: 'ValidatorPrefsSet'; data: { stash: AccountId32; prefs: PalletStakingValidatorPrefs } }
  /**
   * Voters size limit reached.
   **/
  | { name: 'SnapshotVotersSizeExceeded'; data: { size: number } }
  /**
   * Targets size limit reached.
   **/
  | { name: 'SnapshotTargetsSizeExceeded'; data: { size: number } }
  /**
   * A new force era mode was set.
   **/
  | { name: 'ForceEra'; data: { mode: PalletStakingForcing } };

export type PalletStakingRewardDestination =
  | { tag: 'Staked' }
  | { tag: 'Stash' }
  | { tag: 'Controller' }
  | { tag: 'Account'; value: AccountId32 }
  | { tag: 'None' };

export type PalletStakingValidatorPrefs = { commission: Perbill; blocked: boolean };

export type PalletStakingForcing = 'NotForcing' | 'ForceNew' | 'ForceNone' | 'ForceAlways';

/**
 * Events type.
 **/
export type PalletOffencesEvent =
  /**
   * There is an offence reported of the given `kind` happened at the `session_index` and
   * (kind-specific) time slot. This event is not deposited for duplicate slashes.
   * \[kind, timeslot\].
   **/
  { name: 'Offence'; data: { kind: FixedBytes<16>; timeslot: Bytes } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSessionEvent =
  /**
   * New session has happened. Note that the argument is the session index, not the
   * block number as the type might suggest.
   **/
  { name: 'NewSession'; data: { sessionIndex: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletGrandpaEvent =
  /**
   * New authority set has been applied.
   **/
  | { name: 'NewAuthorities'; data: { authoritySet: Array<[SpConsensusGrandpaAppPublic, bigint]> } }
  /**
   * Current authority set has been paused.
   **/
  | { name: 'Paused' }
  /**
   * Current authority set has been resumed.
   **/
  | { name: 'Resumed' };

export type SpConsensusGrandpaAppPublic = SpCoreEd25519Public;

export type SpCoreEd25519Public = FixedBytes<32>;

/**
 * The `Event` enum of this pallet
 **/
export type PalletImOnlineEvent =
  /**
   * A new heartbeat was received from `AuthorityId`.
   **/
  | { name: 'HeartbeatReceived'; data: { authorityId: PalletImOnlineSr25519AppSr25519Public } }
  /**
   * At the end of the session, no offence was committed.
   **/
  | { name: 'AllGood' }
  /**
   * At the end of the session, at least one validator was found to be offline.
   **/
  | { name: 'SomeOffline'; data: { offline: Array<[AccountId32, PalletStakingExposure]> } };

export type PalletImOnlineSr25519AppSr25519Public = SpCoreSr25519Public;

export type SpCoreSr25519Public = FixedBytes<32>;

export type PalletStakingExposure = { total: bigint; own: bigint; others: Array<PalletStakingIndividualExposure> };

export type PalletStakingIndividualExposure = { who: AccountId32; value: bigint };

/**
 * The `Event` enum of this pallet
 **/
export type PalletTreasuryEvent =
  /**
   * New proposal.
   **/
  | { name: 'Proposed'; data: { proposalIndex: number } }
  /**
   * We have ended a spend period and will now allocate funds.
   **/
  | { name: 'Spending'; data: { budgetRemaining: bigint } }
  /**
   * Some funds have been allocated.
   **/
  | { name: 'Awarded'; data: { proposalIndex: number; award: bigint; account: AccountId32 } }
  /**
   * A proposal was rejected; funds were slashed.
   **/
  | { name: 'Rejected'; data: { proposalIndex: number; slashed: bigint } }
  /**
   * Some of our funds have been burnt.
   **/
  | { name: 'Burnt'; data: { burntFunds: bigint } }
  /**
   * Spending has finished; this is the amount that rolls over until next spend.
   **/
  | { name: 'Rollover'; data: { rolloverBalance: bigint } }
  /**
   * Some funds have been deposited.
   **/
  | { name: 'Deposit'; data: { value: bigint } }
  /**
   * A new spend proposal has been approved.
   **/
  | { name: 'SpendApproved'; data: { proposalIndex: number; amount: bigint; beneficiary: AccountId32 } }
  /**
   * The inactive funds of the pallet have been updated.
   **/
  | { name: 'UpdatedInactive'; data: { reactivated: bigint; deactivated: bigint } }
  /**
   * A new asset spend proposal has been approved.
   **/
  | {
      name: 'AssetSpendApproved';
      data: {
        index: number;
        assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset;
        amount: bigint;
        beneficiary: XcmVersionedMultiLocation;
        validFrom: number;
        expireAt: number;
      };
    }
  /**
   * An approved spend was voided.
   **/
  | { name: 'AssetSpendVoided'; data: { index: number } }
  /**
   * A payment happened.
   **/
  | { name: 'Paid'; data: { index: number; paymentId: bigint } }
  /**
   * A payment failed and can be retried.
   **/
  | { name: 'PaymentFailed'; data: { index: number; paymentId: bigint } }
  /**
   * A spend was processed and removed from the storage. It might have been successfully
   * paid or it may have expired.
   **/
  | { name: 'SpendProcessed'; data: { index: number } };

export type PolkadotRuntimeCommonImplsVersionedLocatableAsset = {
  tag: 'V3';
  value: { location: StagingXcmV3MultilocationMultiLocation; assetId: XcmV3MultiassetAssetId };
};

export type StagingXcmV3MultilocationMultiLocation = { parents: number; interior: XcmV3Junctions };

export type XcmV3Junctions =
  | { tag: 'Here' }
  | { tag: 'X1'; value: XcmV3Junction }
  | { tag: 'X2'; value: [XcmV3Junction, XcmV3Junction] }
  | { tag: 'X3'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { tag: 'X4'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { tag: 'X5'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { tag: 'X6'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | {
      tag: 'X7';
      value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction];
    }
  | {
      tag: 'X8';
      value: [
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
      ];
    };

export type XcmV3Junction =
  | { tag: 'Parachain'; value: number }
  | { tag: 'AccountId32'; value: { network?: XcmV3JunctionNetworkId | undefined; id: FixedBytes<32> } }
  | { tag: 'AccountIndex64'; value: { network?: XcmV3JunctionNetworkId | undefined; index: bigint } }
  | { tag: 'AccountKey20'; value: { network?: XcmV3JunctionNetworkId | undefined; key: FixedBytes<20> } }
  | { tag: 'PalletInstance'; value: number }
  | { tag: 'GeneralIndex'; value: bigint }
  | { tag: 'GeneralKey'; value: { length: number; data: FixedBytes<32> } }
  | { tag: 'OnlyChild' }
  | { tag: 'Plurality'; value: { id: XcmV3JunctionBodyId; part: XcmV3JunctionBodyPart } }
  | { tag: 'GlobalConsensus'; value: XcmV3JunctionNetworkId };

export type XcmV3JunctionNetworkId =
  | { tag: 'ByGenesis'; value: FixedBytes<32> }
  | { tag: 'ByFork'; value: { blockNumber: bigint; blockHash: FixedBytes<32> } }
  | { tag: 'Polkadot' }
  | { tag: 'Kusama' }
  | { tag: 'Westend' }
  | { tag: 'Rococo' }
  | { tag: 'Wococo' }
  | { tag: 'Ethereum'; value: { chainId: bigint } }
  | { tag: 'BitcoinCore' }
  | { tag: 'BitcoinCash' };

export type XcmV3JunctionBodyId =
  | { tag: 'Unit' }
  | { tag: 'Moniker'; value: FixedBytes<4> }
  | { tag: 'Index'; value: number }
  | { tag: 'Executive' }
  | { tag: 'Technical' }
  | { tag: 'Legislative' }
  | { tag: 'Judicial' }
  | { tag: 'Defense' }
  | { tag: 'Administration' }
  | { tag: 'Treasury' };

export type XcmV3JunctionBodyPart =
  | { tag: 'Voice' }
  | { tag: 'Members'; value: { count: number } }
  | { tag: 'Fraction'; value: { nom: number; denom: number } }
  | { tag: 'AtLeastProportion'; value: { nom: number; denom: number } }
  | { tag: 'MoreThanProportion'; value: { nom: number; denom: number } };

export type XcmV3MultiassetAssetId =
  | { tag: 'Concrete'; value: StagingXcmV3MultilocationMultiLocation }
  | { tag: 'Abstract'; value: FixedBytes<32> };

export type XcmVersionedMultiLocation =
  | { tag: 'V2'; value: XcmV2MultilocationMultiLocation }
  | { tag: 'V3'; value: StagingXcmV3MultilocationMultiLocation };

export type XcmV2MultilocationMultiLocation = { parents: number; interior: XcmV2MultilocationJunctions };

export type XcmV2MultilocationJunctions =
  | { tag: 'Here' }
  | { tag: 'X1'; value: XcmV2Junction }
  | { tag: 'X2'; value: [XcmV2Junction, XcmV2Junction] }
  | { tag: 'X3'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { tag: 'X4'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { tag: 'X5'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { tag: 'X6'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | {
      tag: 'X7';
      value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction];
    }
  | {
      tag: 'X8';
      value: [
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
      ];
    };

export type XcmV2Junction =
  | { tag: 'Parachain'; value: number }
  | { tag: 'AccountId32'; value: { network: XcmV2NetworkId; id: FixedBytes<32> } }
  | { tag: 'AccountIndex64'; value: { network: XcmV2NetworkId; index: bigint } }
  | { tag: 'AccountKey20'; value: { network: XcmV2NetworkId; key: FixedBytes<20> } }
  | { tag: 'PalletInstance'; value: number }
  | { tag: 'GeneralIndex'; value: bigint }
  | { tag: 'GeneralKey'; value: Bytes }
  | { tag: 'OnlyChild' }
  | { tag: 'Plurality'; value: { id: XcmV2BodyId; part: XcmV2BodyPart } };

export type XcmV2NetworkId = { tag: 'Any' } | { tag: 'Named'; value: Bytes } | { tag: 'Polkadot' } | { tag: 'Kusama' };

export type XcmV2BodyId =
  | { tag: 'Unit' }
  | { tag: 'Named'; value: Bytes }
  | { tag: 'Index'; value: number }
  | { tag: 'Executive' }
  | { tag: 'Technical' }
  | { tag: 'Legislative' }
  | { tag: 'Judicial' }
  | { tag: 'Defense' }
  | { tag: 'Administration' }
  | { tag: 'Treasury' };

export type XcmV2BodyPart =
  | { tag: 'Voice' }
  | { tag: 'Members'; value: { count: number } }
  | { tag: 'Fraction'; value: { nom: number; denom: number } }
  | { tag: 'AtLeastProportion'; value: { nom: number; denom: number } }
  | { tag: 'MoreThanProportion'; value: { nom: number; denom: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletConvictionVotingEvent =
  /**
   * An account has delegated their vote to another account. \[who, target\]
   **/
  | { name: 'Delegated'; data: [AccountId32, AccountId32] }
  /**
   * An \[account\] has cancelled a previous delegation operation.
   **/
  | { name: 'Undelegated'; data: AccountId32 };

/**
 * The `Event` enum of this pallet
 **/
export type PalletReferendaEvent =
  /**
   * A referendum has been submitted.
   **/
  | {
      name: 'Submitted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;
      };
    }
  /**
   * The decision deposit has been placed.
   **/
  | {
      name: 'DecisionDepositPlaced';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * The decision deposit has been refunded.
   **/
  | {
      name: 'DecisionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A deposit has been slashaed.
   **/
  | {
      name: 'DepositSlashed';
      data: {
        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A referendum has moved into the deciding phase.
   **/
  | {
      name: 'DecisionStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;

        /**
         * The current tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  | {
      name: 'ConfirmStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  | {
      name: 'ConfirmAborted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A referendum has ended its confirmation phase and is ready for approval.
   **/
  | {
      name: 'Confirmed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been approved and its proposal has been scheduled.
   **/
  | {
      name: 'Approved';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A proposal has been rejected by referendum.
   **/
  | {
      name: 'Rejected';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been timed out without being decided.
   **/
  | {
      name: 'TimedOut';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been cancelled.
   **/
  | {
      name: 'Cancelled';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been killed.
   **/
  | {
      name: 'Killed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * The submission deposit has been refunded.
   **/
  | {
      name: 'SubmissionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * Metadata for a referendum has been set.
   **/
  | {
      name: 'MetadataSet';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  /**
   * Metadata for a referendum has been cleared.
   **/
  | {
      name: 'MetadataCleared';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    };

export type FrameSupportPreimagesBounded =
  | { tag: 'Legacy'; value: { hash: H256 } }
  | { tag: 'Inline'; value: Bytes }
  | { tag: 'Lookup'; value: { hash: H256; len: number } };

export type StagingKusamaRuntimeRuntimeCall =
  | { tag: 'System'; value: FrameSystemCall }
  | { tag: 'Babe'; value: PalletBabeCall }
  | { tag: 'Timestamp'; value: PalletTimestampCall }
  | { tag: 'Indices'; value: PalletIndicesCall }
  | { tag: 'Balances'; value: PalletBalancesCall }
  | { tag: 'Staking'; value: PalletStakingPalletCall }
  | { tag: 'Beefy'; value: PalletBeefyCall }
  | { tag: 'Session'; value: PalletSessionCall }
  | { tag: 'Grandpa'; value: PalletGrandpaCall }
  | { tag: 'ImOnline'; value: PalletImOnlineCall }
  | { tag: 'Treasury'; value: PalletTreasuryCall }
  | { tag: 'ConvictionVoting'; value: PalletConvictionVotingCall }
  | { tag: 'Referenda'; value: PalletReferendaCall }
  | { tag: 'FellowshipCollective'; value: PalletRankedCollectiveCall }
  | { tag: 'FellowshipReferenda'; value: PalletReferendaCall }
  | { tag: 'Whitelist'; value: PalletWhitelistCall }
  | { tag: 'Claims'; value: PolkadotRuntimeCommonClaimsPalletCall }
  | { tag: 'Utility'; value: PalletUtilityCall }
  | { tag: 'Identity'; value: PalletIdentityCall }
  | { tag: 'Society'; value: PalletSocietyCall }
  | { tag: 'Recovery'; value: PalletRecoveryCall }
  | { tag: 'Vesting'; value: PalletVestingCall }
  | { tag: 'Scheduler'; value: PalletSchedulerCall }
  | { tag: 'Proxy'; value: PalletProxyCall }
  | { tag: 'Multisig'; value: PalletMultisigCall }
  | { tag: 'Preimage'; value: PalletPreimageCall }
  | { tag: 'Bounties'; value: PalletBountiesCall }
  | { tag: 'ChildBounties'; value: PalletChildBountiesCall }
  | { tag: 'ElectionProviderMultiPhase'; value: PalletElectionProviderMultiPhaseCall }
  | { tag: 'Nis'; value: PalletNisCall }
  | { tag: 'NisCounterpartBalances'; value: PalletBalancesCall }
  | { tag: 'VoterList'; value: PalletBagsListCall }
  | { tag: 'NominationPools'; value: PalletNominationPoolsCall }
  | { tag: 'FastUnstake'; value: PalletFastUnstakeCall }
  | { tag: 'Configuration'; value: PolkadotRuntimeParachainsConfigurationPalletCall }
  | { tag: 'ParasShared'; value: PolkadotRuntimeParachainsSharedPalletCall }
  | { tag: 'ParaInclusion'; value: PolkadotRuntimeParachainsInclusionPalletCall }
  | { tag: 'ParaInherent'; value: PolkadotRuntimeParachainsParasInherentPalletCall }
  | { tag: 'Paras'; value: PolkadotRuntimeParachainsParasPalletCall }
  | { tag: 'Initializer'; value: PolkadotRuntimeParachainsInitializerPalletCall }
  | { tag: 'Hrmp'; value: PolkadotRuntimeParachainsHrmpPalletCall }
  | { tag: 'ParasDisputes'; value: PolkadotRuntimeParachainsDisputesPalletCall }
  | { tag: 'ParasSlashing'; value: PolkadotRuntimeParachainsDisputesSlashingPalletCall }
  | { tag: 'Registrar'; value: PolkadotRuntimeCommonParasRegistrarPalletCall }
  | { tag: 'Slots'; value: PolkadotRuntimeCommonSlotsPalletCall }
  | { tag: 'Auctions'; value: PolkadotRuntimeCommonAuctionsPalletCall }
  | { tag: 'Crowdloan'; value: PolkadotRuntimeCommonCrowdloanPalletCall }
  | { tag: 'StateTrieMigration'; value: PalletStateTrieMigrationCall }
  | { tag: 'XcmPallet'; value: PalletXcmCall }
  | { tag: 'MessageQueue'; value: PalletMessageQueueCall }
  | { tag: 'AssetRate'; value: PalletAssetRateCall };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type FrameSystemCall =
  /**
   * See [`Pallet::remark`].
   **/
  | { tag: 'Remark'; value: { remark: Bytes } }
  /**
   * See [`Pallet::set_heap_pages`].
   **/
  | { tag: 'SetHeapPages'; value: { pages: bigint } }
  /**
   * See [`Pallet::set_code`].
   **/
  | { tag: 'SetCode'; value: { code: Bytes } }
  /**
   * See [`Pallet::set_code_without_checks`].
   **/
  | { tag: 'SetCodeWithoutChecks'; value: { code: Bytes } }
  /**
   * See [`Pallet::set_storage`].
   **/
  | { tag: 'SetStorage'; value: { items: Array<[Bytes, Bytes]> } }
  /**
   * See [`Pallet::kill_storage`].
   **/
  | { tag: 'KillStorage'; value: { keys: Array<Bytes> } }
  /**
   * See [`Pallet::kill_prefix`].
   **/
  | { tag: 'KillPrefix'; value: { prefix: Bytes; subkeys: number } }
  /**
   * See [`Pallet::remark_with_event`].
   **/
  | { tag: 'RemarkWithEvent'; value: { remark: Bytes } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBabeCall =
  /**
   * See [`Pallet::report_equivocation`].
   **/
  | {
      tag: 'ReportEquivocation';
      value: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * See [`Pallet::report_equivocation_unsigned`].
   **/
  | {
      tag: 'ReportEquivocationUnsigned';
      value: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * See [`Pallet::plan_config_change`].
   **/
  | { tag: 'PlanConfigChange'; value: { config: SpConsensusBabeDigestsNextConfigDescriptor } };

export type SpConsensusSlotsEquivocationProof = {
  offender: SpConsensusBabeAppPublic;
  slot: SpConsensusSlotsSlot;
  firstHeader: Header;
  secondHeader: Header;
};

export type SpConsensusBabeAppPublic = SpCoreSr25519Public;

export type SpConsensusSlotsSlot = bigint;

export type SpSessionMembershipProof = { session: number; trieNodes: Array<Bytes>; validatorCount: number };

export type SpConsensusBabeDigestsNextConfigDescriptor = {
  tag: 'V1';
  value: { c: [bigint, bigint]; allowedSlots: SpConsensusBabeAllowedSlots };
};

export type SpConsensusBabeAllowedSlots =
  | 'PrimarySlots'
  | 'PrimaryAndSecondaryPlainSlots'
  | 'PrimaryAndSecondaryVRFSlots';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTimestampCall =
  /**
   * See [`Pallet::set`].
   **/
  { tag: 'Set'; value: { now: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletIndicesCall =
  /**
   * See [`Pallet::claim`].
   **/
  | { tag: 'Claim'; value: { index: number } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { tag: 'Transfer'; value: { new: MultiAddress; index: number } }
  /**
   * See [`Pallet::free`].
   **/
  | { tag: 'Free'; value: { index: number } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { tag: 'ForceTransfer'; value: { new: MultiAddress; index: number; freeze: boolean } }
  /**
   * See [`Pallet::freeze`].
   **/
  | { tag: 'Freeze'; value: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBalancesCall =
  /**
   * See [`Pallet::transfer_allow_death`].
   **/
  | { tag: 'TransferAllowDeath'; value: { dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { tag: 'ForceTransfer'; value: { source: MultiAddress; dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { tag: 'TransferKeepAlive'; value: { dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::transfer_all`].
   **/
  | { tag: 'TransferAll'; value: { dest: MultiAddress; keepAlive: boolean } }
  /**
   * See [`Pallet::force_unreserve`].
   **/
  | { tag: 'ForceUnreserve'; value: { who: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::upgrade_accounts`].
   **/
  | { tag: 'UpgradeAccounts'; value: { who: Array<AccountId32> } }
  /**
   * See [`Pallet::force_set_balance`].
   **/
  | { tag: 'ForceSetBalance'; value: { who: MultiAddress; newFree: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletStakingPalletCall =
  /**
   * See [`Pallet::bond`].
   **/
  | { tag: 'Bond'; value: { value: bigint; payee: PalletStakingRewardDestination } }
  /**
   * See [`Pallet::bond_extra`].
   **/
  | { tag: 'BondExtra'; value: { maxAdditional: bigint } }
  /**
   * See [`Pallet::unbond`].
   **/
  | { tag: 'Unbond'; value: { value: bigint } }
  /**
   * See [`Pallet::withdraw_unbonded`].
   **/
  | { tag: 'WithdrawUnbonded'; value: { numSlashingSpans: number } }
  /**
   * See [`Pallet::validate`].
   **/
  | { tag: 'Validate'; value: { prefs: PalletStakingValidatorPrefs } }
  /**
   * See [`Pallet::nominate`].
   **/
  | { tag: 'Nominate'; value: { targets: Array<MultiAddress> } }
  /**
   * See [`Pallet::chill`].
   **/
  | { tag: 'Chill' }
  /**
   * See [`Pallet::set_payee`].
   **/
  | { tag: 'SetPayee'; value: { payee: PalletStakingRewardDestination } }
  /**
   * See [`Pallet::set_controller`].
   **/
  | { tag: 'SetController' }
  /**
   * See [`Pallet::set_validator_count`].
   **/
  | { tag: 'SetValidatorCount'; value: { new: number } }
  /**
   * See [`Pallet::increase_validator_count`].
   **/
  | { tag: 'IncreaseValidatorCount'; value: { additional: number } }
  /**
   * See [`Pallet::scale_validator_count`].
   **/
  | { tag: 'ScaleValidatorCount'; value: { factor: Percent } }
  /**
   * See [`Pallet::force_no_eras`].
   **/
  | { tag: 'ForceNoEras' }
  /**
   * See [`Pallet::force_new_era`].
   **/
  | { tag: 'ForceNewEra' }
  /**
   * See [`Pallet::set_invulnerables`].
   **/
  | { tag: 'SetInvulnerables'; value: { invulnerables: Array<AccountId32> } }
  /**
   * See [`Pallet::force_unstake`].
   **/
  | { tag: 'ForceUnstake'; value: { stash: AccountId32; numSlashingSpans: number } }
  /**
   * See [`Pallet::force_new_era_always`].
   **/
  | { tag: 'ForceNewEraAlways' }
  /**
   * See [`Pallet::cancel_deferred_slash`].
   **/
  | { tag: 'CancelDeferredSlash'; value: { era: number; slashIndices: Array<number> } }
  /**
   * See [`Pallet::payout_stakers`].
   **/
  | { tag: 'PayoutStakers'; value: { validatorStash: AccountId32; era: number } }
  /**
   * See [`Pallet::rebond`].
   **/
  | { tag: 'Rebond'; value: { value: bigint } }
  /**
   * See [`Pallet::reap_stash`].
   **/
  | { tag: 'ReapStash'; value: { stash: AccountId32; numSlashingSpans: number } }
  /**
   * See [`Pallet::kick`].
   **/
  | { tag: 'Kick'; value: { who: Array<MultiAddress> } }
  /**
   * See [`Pallet::set_staking_configs`].
   **/
  | {
      tag: 'SetStakingConfigs';
      value: {
        minNominatorBond: PalletStakingPalletConfigOp;
        minValidatorBond: PalletStakingPalletConfigOp;
        maxNominatorCount: PalletStakingPalletConfigOpU32;
        maxValidatorCount: PalletStakingPalletConfigOpU32;
        chillThreshold: PalletStakingPalletConfigOpPercent;
        minCommission: PalletStakingPalletConfigOpPerbill;
      };
    }
  /**
   * See [`Pallet::chill_other`].
   **/
  | { tag: 'ChillOther'; value: { controller: AccountId32 } }
  /**
   * See [`Pallet::force_apply_min_commission`].
   **/
  | { tag: 'ForceApplyMinCommission'; value: { validatorStash: AccountId32 } }
  /**
   * See [`Pallet::set_min_commission`].
   **/
  | { tag: 'SetMinCommission'; value: { new: Perbill } };

export type PalletStakingPalletConfigOp = { tag: 'Noop' } | { tag: 'Set'; value: bigint } | { tag: 'Remove' };

export type PalletStakingPalletConfigOpU32 = { tag: 'Noop' } | { tag: 'Set'; value: number } | { tag: 'Remove' };

export type PalletStakingPalletConfigOpPercent = { tag: 'Noop' } | { tag: 'Set'; value: Percent } | { tag: 'Remove' };

export type PalletStakingPalletConfigOpPerbill = { tag: 'Noop' } | { tag: 'Set'; value: Perbill } | { tag: 'Remove' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBeefyCall =
  /**
   * See [`Pallet::report_equivocation`].
   **/
  | {
      tag: 'ReportEquivocation';
      value: { equivocationProof: SpConsensusBeefyEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * See [`Pallet::report_equivocation_unsigned`].
   **/
  | {
      tag: 'ReportEquivocationUnsigned';
      value: { equivocationProof: SpConsensusBeefyEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * See [`Pallet::set_new_genesis`].
   **/
  | { tag: 'SetNewGenesis'; value: { delayInBlocks: number } };

export type SpConsensusBeefyEquivocationProof = {
  first: SpConsensusBeefyVoteMessage;
  second: SpConsensusBeefyVoteMessage;
};

export type SpConsensusBeefyEcdsaCryptoPublic = SpCoreEcdsaPublic;

export type SpCoreEcdsaPublic = FixedBytes<33>;

export type SpConsensusBeefyEcdsaCryptoSignature = SpCoreEcdsaSignature;

export type SpCoreEcdsaSignature = FixedBytes<65>;

export type SpConsensusBeefyVoteMessage = {
  commitment: SpConsensusBeefyCommitment;
  id: SpConsensusBeefyEcdsaCryptoPublic;
  signature: SpConsensusBeefyEcdsaCryptoSignature;
};

export type SpConsensusBeefyCommitment = {
  payload: SpConsensusBeefyPayload;
  blockNumber: number;
  validatorSetId: bigint;
};

export type SpConsensusBeefyPayload = Array<[FixedBytes<2>, Bytes]>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSessionCall =
  /**
   * See [`Pallet::set_keys`].
   **/
  | { tag: 'SetKeys'; value: { keys: StagingKusamaRuntimeSessionKeys; proof: Bytes } }
  /**
   * See [`Pallet::purge_keys`].
   **/
  | { tag: 'PurgeKeys' };

export type StagingKusamaRuntimeSessionKeys = {
  grandpa: SpConsensusGrandpaAppPublic;
  babe: SpConsensusBabeAppPublic;
  imOnline: PalletImOnlineSr25519AppSr25519Public;
  paraValidator: PolkadotPrimitivesV6ValidatorAppPublic;
  paraAssignment: PolkadotPrimitivesV6AssignmentAppPublic;
  authorityDiscovery: SpAuthorityDiscoveryAppPublic;
  beefy: SpConsensusBeefyEcdsaCryptoPublic;
};

export type PolkadotPrimitivesV6ValidatorAppPublic = SpCoreSr25519Public;

export type PolkadotPrimitivesV6AssignmentAppPublic = SpCoreSr25519Public;

export type SpAuthorityDiscoveryAppPublic = SpCoreSr25519Public;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletGrandpaCall =
  /**
   * See [`Pallet::report_equivocation`].
   **/
  | {
      tag: 'ReportEquivocation';
      value: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * See [`Pallet::report_equivocation_unsigned`].
   **/
  | {
      tag: 'ReportEquivocationUnsigned';
      value: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * See [`Pallet::note_stalled`].
   **/
  | { tag: 'NoteStalled'; value: { delay: number; bestFinalizedBlockNumber: number } };

export type SpConsensusGrandpaEquivocationProof = { setId: bigint; equivocation: SpConsensusGrandpaEquivocation };

export type SpConsensusGrandpaEquivocation =
  | { tag: 'Prevote'; value: FinalityGrandpaEquivocation }
  | { tag: 'Precommit'; value: FinalityGrandpaEquivocationPrecommit };

export type FinalityGrandpaEquivocation = {
  roundNumber: bigint;
  identity: SpConsensusGrandpaAppPublic;
  first: [FinalityGrandpaPrevote, SpConsensusGrandpaAppSignature];
  second: [FinalityGrandpaPrevote, SpConsensusGrandpaAppSignature];
};

export type FinalityGrandpaPrevote = { targetHash: H256; targetNumber: number };

export type SpConsensusGrandpaAppSignature = SpCoreEd25519Signature;

export type SpCoreEd25519Signature = FixedBytes<64>;

export type FinalityGrandpaEquivocationPrecommit = {
  roundNumber: bigint;
  identity: SpConsensusGrandpaAppPublic;
  first: [FinalityGrandpaPrecommit, SpConsensusGrandpaAppSignature];
  second: [FinalityGrandpaPrecommit, SpConsensusGrandpaAppSignature];
};

export type FinalityGrandpaPrecommit = { targetHash: H256; targetNumber: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletImOnlineCall =
  /**
   * See [`Pallet::heartbeat`].
   **/
  {
    tag: 'Heartbeat';
    value: { heartbeat: PalletImOnlineHeartbeat; signature: PalletImOnlineSr25519AppSr25519Signature };
  };

export type PalletImOnlineHeartbeat = {
  blockNumber: number;
  sessionIndex: number;
  authorityIndex: number;
  validatorsLen: number;
};

export type PalletImOnlineSr25519AppSr25519Signature = SpCoreSr25519Signature;

export type SpCoreSr25519Signature = FixedBytes<64>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTreasuryCall =
  /**
   * See [`Pallet::propose_spend`].
   **/
  | { tag: 'ProposeSpend'; value: { value: bigint; beneficiary: MultiAddress } }
  /**
   * See [`Pallet::reject_proposal`].
   **/
  | { tag: 'RejectProposal'; value: { proposalId: number } }
  /**
   * See [`Pallet::approve_proposal`].
   **/
  | { tag: 'ApproveProposal'; value: { proposalId: number } }
  /**
   * See [`Pallet::spend_local`].
   **/
  | { tag: 'SpendLocal'; value: { amount: bigint; beneficiary: MultiAddress } }
  /**
   * See [`Pallet::remove_approval`].
   **/
  | { tag: 'RemoveApproval'; value: { proposalId: number } }
  /**
   * See [`Pallet::spend`].
   **/
  | {
      tag: 'Spend';
      value: {
        assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset;
        amount: bigint;
        beneficiary: XcmVersionedMultiLocation;
        validFrom?: number | undefined;
      };
    }
  /**
   * See [`Pallet::payout`].
   **/
  | { tag: 'Payout'; value: { index: number } }
  /**
   * See [`Pallet::check_status`].
   **/
  | { tag: 'CheckStatus'; value: { index: number } }
  /**
   * See [`Pallet::void_spend`].
   **/
  | { tag: 'VoidSpend'; value: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletConvictionVotingCall =
  /**
   * See [`Pallet::vote`].
   **/
  | { tag: 'Vote'; value: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote } }
  /**
   * See [`Pallet::delegate`].
   **/
  | {
      tag: 'Delegate';
      value: { class: number; to: MultiAddress; conviction: PalletConvictionVotingConviction; balance: bigint };
    }
  /**
   * See [`Pallet::undelegate`].
   **/
  | { tag: 'Undelegate'; value: { class: number } }
  /**
   * See [`Pallet::unlock`].
   **/
  | { tag: 'Unlock'; value: { class: number; target: MultiAddress } }
  /**
   * See [`Pallet::remove_vote`].
   **/
  | { tag: 'RemoveVote'; value: { class?: number | undefined; index: number } }
  /**
   * See [`Pallet::remove_other_vote`].
   **/
  | { tag: 'RemoveOtherVote'; value: { target: MultiAddress; class: number; index: number } };

export type PalletConvictionVotingVoteAccountVote =
  | { tag: 'Standard'; value: { vote: PalletConvictionVotingVote; balance: bigint } }
  | { tag: 'Split'; value: { aye: bigint; nay: bigint } }
  | { tag: 'SplitAbstain'; value: { aye: bigint; nay: bigint; abstain: bigint } };

export type PalletConvictionVotingVote = number;

export type PalletConvictionVotingConviction =
  | 'None'
  | 'Locked1x'
  | 'Locked2x'
  | 'Locked3x'
  | 'Locked4x'
  | 'Locked5x'
  | 'Locked6x';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletReferendaCall =
  /**
   * See [`Pallet::submit`].
   **/
  | {
      tag: 'Submit';
      value: {
        proposalOrigin: StagingKusamaRuntimeOriginCaller;
        proposal: FrameSupportPreimagesBounded;
        enactmentMoment: FrameSupportScheduleDispatchTime;
      };
    }
  /**
   * See [`Pallet::place_decision_deposit`].
   **/
  | { tag: 'PlaceDecisionDeposit'; value: { index: number } }
  /**
   * See [`Pallet::refund_decision_deposit`].
   **/
  | { tag: 'RefundDecisionDeposit'; value: { index: number } }
  /**
   * See [`Pallet::cancel`].
   **/
  | { tag: 'Cancel'; value: { index: number } }
  /**
   * See [`Pallet::kill`].
   **/
  | { tag: 'Kill'; value: { index: number } }
  /**
   * See [`Pallet::nudge_referendum`].
   **/
  | { tag: 'NudgeReferendum'; value: { index: number } }
  /**
   * See [`Pallet::one_fewer_deciding`].
   **/
  | { tag: 'OneFewerDeciding'; value: { track: number } }
  /**
   * See [`Pallet::refund_submission_deposit`].
   **/
  | { tag: 'RefundSubmissionDeposit'; value: { index: number } }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { tag: 'SetMetadata'; value: { index: number; maybeHash?: H256 | undefined } };

export type StagingKusamaRuntimeOriginCaller =
  | { tag: 'System'; value: FrameSupportDispatchRawOrigin }
  | { tag: 'Origins'; value: StagingKusamaRuntimeGovernanceOriginsPalletCustomOriginsOrigin }
  | { tag: 'ParachainsOrigin'; value: PolkadotRuntimeParachainsOriginPalletOrigin }
  | { tag: 'XcmPallet'; value: PalletXcmOrigin }
  | { tag: 'Void'; value: SpCoreVoid };

export type FrameSupportDispatchRawOrigin = { tag: 'Root' } | { tag: 'Signed'; value: AccountId32 } | { tag: 'None' };

export type StagingKusamaRuntimeGovernanceOriginsPalletCustomOriginsOrigin =
  | 'StakingAdmin'
  | 'Treasurer'
  | 'FellowshipAdmin'
  | 'GeneralAdmin'
  | 'AuctionAdmin'
  | 'LeaseAdmin'
  | 'ReferendumCanceller'
  | 'ReferendumKiller'
  | 'SmallTipper'
  | 'BigTipper'
  | 'SmallSpender'
  | 'MediumSpender'
  | 'BigSpender'
  | 'WhitelistedCaller'
  | 'FellowshipInitiates'
  | 'Fellows'
  | 'FellowshipExperts'
  | 'FellowshipMasters'
  | 'Fellowship1Dan'
  | 'Fellowship2Dan'
  | 'Fellowship3Dan'
  | 'Fellowship4Dan'
  | 'Fellowship5Dan'
  | 'Fellowship6Dan'
  | 'Fellowship7Dan'
  | 'Fellowship8Dan'
  | 'Fellowship9Dan';

export type PolkadotRuntimeParachainsOriginPalletOrigin = {
  tag: 'Parachain';
  value: PolkadotParachainPrimitivesPrimitivesId;
};

export type PolkadotParachainPrimitivesPrimitivesId = number;

export type PalletXcmOrigin =
  | { tag: 'Xcm'; value: StagingXcmV3MultilocationMultiLocation }
  | { tag: 'Response'; value: StagingXcmV3MultilocationMultiLocation };

export type SpCoreVoid = null;

export type FrameSupportScheduleDispatchTime = { tag: 'At'; value: number } | { tag: 'After'; value: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRankedCollectiveCall =
  /**
   * See [`Pallet::add_member`].
   **/
  | { tag: 'AddMember'; value: { who: MultiAddress } }
  /**
   * See [`Pallet::promote_member`].
   **/
  | { tag: 'PromoteMember'; value: { who: MultiAddress } }
  /**
   * See [`Pallet::demote_member`].
   **/
  | { tag: 'DemoteMember'; value: { who: MultiAddress } }
  /**
   * See [`Pallet::remove_member`].
   **/
  | { tag: 'RemoveMember'; value: { who: MultiAddress; minRank: number } }
  /**
   * See [`Pallet::vote`].
   **/
  | { tag: 'Vote'; value: { poll: number; aye: boolean } }
  /**
   * See [`Pallet::cleanup_poll`].
   **/
  | { tag: 'CleanupPoll'; value: { pollIndex: number; max: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletWhitelistCall =
  /**
   * See [`Pallet::whitelist_call`].
   **/
  | { tag: 'WhitelistCall'; value: { callHash: H256 } }
  /**
   * See [`Pallet::remove_whitelisted_call`].
   **/
  | { tag: 'RemoveWhitelistedCall'; value: { callHash: H256 } }
  /**
   * See [`Pallet::dispatch_whitelisted_call`].
   **/
  | {
      tag: 'DispatchWhitelistedCall';
      value: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
    }
  /**
   * See [`Pallet::dispatch_whitelisted_call_with_preimage`].
   **/
  | { tag: 'DispatchWhitelistedCallWithPreimage'; value: { call: StagingKusamaRuntimeRuntimeCall } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeCommonClaimsPalletCall =
  /**
   * See [`Pallet::claim`].
   **/
  | { tag: 'Claim'; value: { dest: AccountId32; ethereumSignature: PolkadotRuntimeCommonClaimsEcdsaSignature } }
  /**
   * See [`Pallet::mint_claim`].
   **/
  | {
      tag: 'MintClaim';
      value: {
        who: EthereumAddress;
        value: bigint;
        vestingSchedule?: [bigint, bigint, number] | undefined;
        statement?: PolkadotRuntimeCommonClaimsStatementKind | undefined;
      };
    }
  /**
   * See [`Pallet::claim_attest`].
   **/
  | {
      tag: 'ClaimAttest';
      value: { dest: AccountId32; ethereumSignature: PolkadotRuntimeCommonClaimsEcdsaSignature; statement: Bytes };
    }
  /**
   * See [`Pallet::attest`].
   **/
  | { tag: 'Attest'; value: { statement: Bytes } }
  /**
   * See [`Pallet::move_claim`].
   **/
  | {
      tag: 'MoveClaim';
      value: { old: EthereumAddress; new: EthereumAddress; maybePreclaim?: AccountId32 | undefined };
    };

export type PolkadotRuntimeCommonClaimsEcdsaSignature = FixedBytes<65>;

export type PolkadotRuntimeCommonClaimsStatementKind = 'Regular' | 'Saft';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUtilityCall =
  /**
   * See [`Pallet::batch`].
   **/
  | { tag: 'Batch'; value: { calls: Array<StagingKusamaRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::as_derivative`].
   **/
  | { tag: 'AsDerivative'; value: { index: number; call: StagingKusamaRuntimeRuntimeCall } }
  /**
   * See [`Pallet::batch_all`].
   **/
  | { tag: 'BatchAll'; value: { calls: Array<StagingKusamaRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::dispatch_as`].
   **/
  | { tag: 'DispatchAs'; value: { asOrigin: StagingKusamaRuntimeOriginCaller; call: StagingKusamaRuntimeRuntimeCall } }
  /**
   * See [`Pallet::force_batch`].
   **/
  | { tag: 'ForceBatch'; value: { calls: Array<StagingKusamaRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::with_weight`].
   **/
  | { tag: 'WithWeight'; value: { call: StagingKusamaRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight } };

/**
 * Identity pallet declaration.
 **/
export type PalletIdentityCall =
  /**
   * See [`Pallet::add_registrar`].
   **/
  | { tag: 'AddRegistrar'; value: { account: MultiAddress } }
  /**
   * See [`Pallet::set_identity`].
   **/
  | { tag: 'SetIdentity'; value: { info: PalletIdentitySimpleIdentityInfo } }
  /**
   * See [`Pallet::set_subs`].
   **/
  | { tag: 'SetSubs'; value: { subs: Array<[AccountId32, Data]> } }
  /**
   * See [`Pallet::clear_identity`].
   **/
  | { tag: 'ClearIdentity' }
  /**
   * See [`Pallet::request_judgement`].
   **/
  | { tag: 'RequestJudgement'; value: { regIndex: number; maxFee: bigint } }
  /**
   * See [`Pallet::cancel_request`].
   **/
  | { tag: 'CancelRequest'; value: { regIndex: number } }
  /**
   * See [`Pallet::set_fee`].
   **/
  | { tag: 'SetFee'; value: { index: number; fee: bigint } }
  /**
   * See [`Pallet::set_account_id`].
   **/
  | { tag: 'SetAccountId'; value: { index: number; new: MultiAddress } }
  /**
   * See [`Pallet::set_fields`].
   **/
  | { tag: 'SetFields'; value: { index: number; fields: PalletIdentityBitFlags } }
  /**
   * See [`Pallet::provide_judgement`].
   **/
  | {
      tag: 'ProvideJudgement';
      value: { regIndex: number; target: MultiAddress; judgement: PalletIdentityJudgement; identity: H256 };
    }
  /**
   * See [`Pallet::kill_identity`].
   **/
  | { tag: 'KillIdentity'; value: { target: MultiAddress } }
  /**
   * See [`Pallet::add_sub`].
   **/
  | { tag: 'AddSub'; value: { sub: MultiAddress; data: Data } }
  /**
   * See [`Pallet::rename_sub`].
   **/
  | { tag: 'RenameSub'; value: { sub: MultiAddress; data: Data } }
  /**
   * See [`Pallet::remove_sub`].
   **/
  | { tag: 'RemoveSub'; value: { sub: MultiAddress } }
  /**
   * See [`Pallet::quit_sub`].
   **/
  | { tag: 'QuitSub' };

export type PalletIdentitySimpleIdentityInfo = {
  additional: Array<[Data, Data]>;
  display: Data;
  legal: Data;
  web: Data;
  riot: Data;
  email: Data;
  pgpFingerprint?: FixedBytes<20> | undefined;
  image: Data;
  twitter: Data;
};

export type PalletIdentityBitFlags = bigint;

export type PalletIdentitySimpleIdentityField =
  | 'Display'
  | 'Legal'
  | 'Web'
  | 'Riot'
  | 'Email'
  | 'PgpFingerprint'
  | 'Image'
  | 'Twitter';

export type PalletIdentityJudgement =
  | { tag: 'Unknown' }
  | { tag: 'FeePaid'; value: bigint }
  | { tag: 'Reasonable' }
  | { tag: 'KnownGood' }
  | { tag: 'OutOfDate' }
  | { tag: 'LowQuality' }
  | { tag: 'Erroneous' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSocietyCall =
  /**
   * See [`Pallet::bid`].
   **/
  | { tag: 'Bid'; value: { value: bigint } }
  /**
   * See [`Pallet::unbid`].
   **/
  | { tag: 'Unbid' }
  /**
   * See [`Pallet::vouch`].
   **/
  | { tag: 'Vouch'; value: { who: MultiAddress; value: bigint; tip: bigint } }
  /**
   * See [`Pallet::unvouch`].
   **/
  | { tag: 'Unvouch' }
  /**
   * See [`Pallet::vote`].
   **/
  | { tag: 'Vote'; value: { candidate: MultiAddress; approve: boolean } }
  /**
   * See [`Pallet::defender_vote`].
   **/
  | { tag: 'DefenderVote'; value: { approve: boolean } }
  /**
   * See [`Pallet::payout`].
   **/
  | { tag: 'Payout' }
  /**
   * See [`Pallet::waive_repay`].
   **/
  | { tag: 'WaiveRepay'; value: { amount: bigint } }
  /**
   * See [`Pallet::found_society`].
   **/
  | {
      tag: 'FoundSociety';
      value: {
        founder: MultiAddress;
        maxMembers: number;
        maxIntake: number;
        maxStrikes: number;
        candidateDeposit: bigint;
        rules: Bytes;
      };
    }
  /**
   * See [`Pallet::dissolve`].
   **/
  | { tag: 'Dissolve' }
  /**
   * See [`Pallet::judge_suspended_member`].
   **/
  | { tag: 'JudgeSuspendedMember'; value: { who: MultiAddress; forgive: boolean } }
  /**
   * See [`Pallet::set_parameters`].
   **/
  | {
      tag: 'SetParameters';
      value: { maxMembers: number; maxIntake: number; maxStrikes: number; candidateDeposit: bigint };
    }
  /**
   * See [`Pallet::punish_skeptic`].
   **/
  | { tag: 'PunishSkeptic' }
  /**
   * See [`Pallet::claim_membership`].
   **/
  | { tag: 'ClaimMembership' }
  /**
   * See [`Pallet::bestow_membership`].
   **/
  | { tag: 'BestowMembership'; value: { candidate: AccountId32 } }
  /**
   * See [`Pallet::kick_candidate`].
   **/
  | { tag: 'KickCandidate'; value: { candidate: AccountId32 } }
  /**
   * See [`Pallet::resign_candidacy`].
   **/
  | { tag: 'ResignCandidacy' }
  /**
   * See [`Pallet::drop_candidate`].
   **/
  | { tag: 'DropCandidate'; value: { candidate: AccountId32 } }
  /**
   * See [`Pallet::cleanup_candidacy`].
   **/
  | { tag: 'CleanupCandidacy'; value: { candidate: AccountId32; max: number } }
  /**
   * See [`Pallet::cleanup_challenge`].
   **/
  | { tag: 'CleanupChallenge'; value: { challengeRound: number; max: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRecoveryCall =
  /**
   * See [`Pallet::as_recovered`].
   **/
  | { tag: 'AsRecovered'; value: { account: MultiAddress; call: StagingKusamaRuntimeRuntimeCall } }
  /**
   * See [`Pallet::set_recovered`].
   **/
  | { tag: 'SetRecovered'; value: { lost: MultiAddress; rescuer: MultiAddress } }
  /**
   * See [`Pallet::create_recovery`].
   **/
  | { tag: 'CreateRecovery'; value: { friends: Array<AccountId32>; threshold: number; delayPeriod: number } }
  /**
   * See [`Pallet::initiate_recovery`].
   **/
  | { tag: 'InitiateRecovery'; value: { account: MultiAddress } }
  /**
   * See [`Pallet::vouch_recovery`].
   **/
  | { tag: 'VouchRecovery'; value: { lost: MultiAddress; rescuer: MultiAddress } }
  /**
   * See [`Pallet::claim_recovery`].
   **/
  | { tag: 'ClaimRecovery'; value: { account: MultiAddress } }
  /**
   * See [`Pallet::close_recovery`].
   **/
  | { tag: 'CloseRecovery'; value: { rescuer: MultiAddress } }
  /**
   * See [`Pallet::remove_recovery`].
   **/
  | { tag: 'RemoveRecovery' }
  /**
   * See [`Pallet::cancel_recovered`].
   **/
  | { tag: 'CancelRecovered'; value: { account: MultiAddress } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletVestingCall =
  /**
   * See [`Pallet::vest`].
   **/
  | { tag: 'Vest' }
  /**
   * See [`Pallet::vest_other`].
   **/
  | { tag: 'VestOther'; value: { target: MultiAddress } }
  /**
   * See [`Pallet::vested_transfer`].
   **/
  | { tag: 'VestedTransfer'; value: { target: MultiAddress; schedule: PalletVestingVestingInfo } }
  /**
   * See [`Pallet::force_vested_transfer`].
   **/
  | {
      tag: 'ForceVestedTransfer';
      value: { source: MultiAddress; target: MultiAddress; schedule: PalletVestingVestingInfo };
    }
  /**
   * See [`Pallet::merge_schedules`].
   **/
  | { tag: 'MergeSchedules'; value: { schedule1Index: number; schedule2Index: number } };

export type PalletVestingVestingInfo = { locked: bigint; perBlock: bigint; startingBlock: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSchedulerCall =
  /**
   * See [`Pallet::schedule`].
   **/
  | {
      tag: 'Schedule';
      value: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: StagingKusamaRuntimeRuntimeCall;
      };
    }
  /**
   * See [`Pallet::cancel`].
   **/
  | { tag: 'Cancel'; value: { when: number; index: number } }
  /**
   * See [`Pallet::schedule_named`].
   **/
  | {
      tag: 'ScheduleNamed';
      value: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: StagingKusamaRuntimeRuntimeCall;
      };
    }
  /**
   * See [`Pallet::cancel_named`].
   **/
  | { tag: 'CancelNamed'; value: { id: FixedBytes<32> } }
  /**
   * See [`Pallet::schedule_after`].
   **/
  | {
      tag: 'ScheduleAfter';
      value: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: StagingKusamaRuntimeRuntimeCall;
      };
    }
  /**
   * See [`Pallet::schedule_named_after`].
   **/
  | {
      tag: 'ScheduleNamedAfter';
      value: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: StagingKusamaRuntimeRuntimeCall;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletProxyCall =
  /**
   * See [`Pallet::proxy`].
   **/
  | {
      tag: 'Proxy';
      value: {
        real: MultiAddress;
        forceProxyType?: StagingKusamaRuntimeProxyType | undefined;
        call: StagingKusamaRuntimeRuntimeCall;
      };
    }
  /**
   * See [`Pallet::add_proxy`].
   **/
  | { tag: 'AddProxy'; value: { delegate: MultiAddress; proxyType: StagingKusamaRuntimeProxyType; delay: number } }
  /**
   * See [`Pallet::remove_proxy`].
   **/
  | { tag: 'RemoveProxy'; value: { delegate: MultiAddress; proxyType: StagingKusamaRuntimeProxyType; delay: number } }
  /**
   * See [`Pallet::remove_proxies`].
   **/
  | { tag: 'RemoveProxies' }
  /**
   * See [`Pallet::create_pure`].
   **/
  | { tag: 'CreatePure'; value: { proxyType: StagingKusamaRuntimeProxyType; delay: number; index: number } }
  /**
   * See [`Pallet::kill_pure`].
   **/
  | {
      tag: 'KillPure';
      value: {
        spawner: MultiAddress;
        proxyType: StagingKusamaRuntimeProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * See [`Pallet::announce`].
   **/
  | { tag: 'Announce'; value: { real: MultiAddress; callHash: H256 } }
  /**
   * See [`Pallet::remove_announcement`].
   **/
  | { tag: 'RemoveAnnouncement'; value: { real: MultiAddress; callHash: H256 } }
  /**
   * See [`Pallet::reject_announcement`].
   **/
  | { tag: 'RejectAnnouncement'; value: { delegate: MultiAddress; callHash: H256 } }
  /**
   * See [`Pallet::proxy_announced`].
   **/
  | {
      tag: 'ProxyAnnounced';
      value: {
        delegate: MultiAddress;
        real: MultiAddress;
        forceProxyType?: StagingKusamaRuntimeProxyType | undefined;
        call: StagingKusamaRuntimeRuntimeCall;
      };
    };

export type StagingKusamaRuntimeProxyType =
  | 'Any'
  | 'NonTransfer'
  | 'Governance'
  | 'Staking'
  | 'IdentityJudgement'
  | 'CancelProxy'
  | 'Auction'
  | 'Society'
  | 'NominationPools';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMultisigCall =
  /**
   * See [`Pallet::as_multi_threshold_1`].
   **/
  | { tag: 'AsMultiThreshold1'; value: { otherSignatories: Array<AccountId32>; call: StagingKusamaRuntimeRuntimeCall } }
  /**
   * See [`Pallet::as_multi`].
   **/
  | {
      tag: 'AsMulti';
      value: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: StagingKusamaRuntimeRuntimeCall;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::approve_as_multi`].
   **/
  | {
      tag: 'ApproveAsMulti';
      value: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::cancel_as_multi`].
   **/
  | {
      tag: 'CancelAsMulti';
      value: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigTimepoint = { height: number; index: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletPreimageCall =
  /**
   * See [`Pallet::note_preimage`].
   **/
  | { tag: 'NotePreimage'; value: { bytes: Bytes } }
  /**
   * See [`Pallet::unnote_preimage`].
   **/
  | { tag: 'UnnotePreimage'; value: { hash: H256 } }
  /**
   * See [`Pallet::request_preimage`].
   **/
  | { tag: 'RequestPreimage'; value: { hash: H256 } }
  /**
   * See [`Pallet::unrequest_preimage`].
   **/
  | { tag: 'UnrequestPreimage'; value: { hash: H256 } }
  /**
   * See [`Pallet::ensure_updated`].
   **/
  | { tag: 'EnsureUpdated'; value: { hashes: Array<H256> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBountiesCall =
  /**
   * See [`Pallet::propose_bounty`].
   **/
  | { tag: 'ProposeBounty'; value: { value: bigint; description: Bytes } }
  /**
   * See [`Pallet::approve_bounty`].
   **/
  | { tag: 'ApproveBounty'; value: { bountyId: number } }
  /**
   * See [`Pallet::propose_curator`].
   **/
  | { tag: 'ProposeCurator'; value: { bountyId: number; curator: MultiAddress; fee: bigint } }
  /**
   * See [`Pallet::unassign_curator`].
   **/
  | { tag: 'UnassignCurator'; value: { bountyId: number } }
  /**
   * See [`Pallet::accept_curator`].
   **/
  | { tag: 'AcceptCurator'; value: { bountyId: number } }
  /**
   * See [`Pallet::award_bounty`].
   **/
  | { tag: 'AwardBounty'; value: { bountyId: number; beneficiary: MultiAddress } }
  /**
   * See [`Pallet::claim_bounty`].
   **/
  | { tag: 'ClaimBounty'; value: { bountyId: number } }
  /**
   * See [`Pallet::close_bounty`].
   **/
  | { tag: 'CloseBounty'; value: { bountyId: number } }
  /**
   * See [`Pallet::extend_bounty_expiry`].
   **/
  | { tag: 'ExtendBountyExpiry'; value: { bountyId: number; remark: Bytes } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletChildBountiesCall =
  /**
   * See [`Pallet::add_child_bounty`].
   **/
  | { tag: 'AddChildBounty'; value: { parentBountyId: number; value: bigint; description: Bytes } }
  /**
   * See [`Pallet::propose_curator`].
   **/
  | {
      tag: 'ProposeCurator';
      value: { parentBountyId: number; childBountyId: number; curator: MultiAddress; fee: bigint };
    }
  /**
   * See [`Pallet::accept_curator`].
   **/
  | { tag: 'AcceptCurator'; value: { parentBountyId: number; childBountyId: number } }
  /**
   * See [`Pallet::unassign_curator`].
   **/
  | { tag: 'UnassignCurator'; value: { parentBountyId: number; childBountyId: number } }
  /**
   * See [`Pallet::award_child_bounty`].
   **/
  | { tag: 'AwardChildBounty'; value: { parentBountyId: number; childBountyId: number; beneficiary: MultiAddress } }
  /**
   * See [`Pallet::claim_child_bounty`].
   **/
  | { tag: 'ClaimChildBounty'; value: { parentBountyId: number; childBountyId: number } }
  /**
   * See [`Pallet::close_child_bounty`].
   **/
  | { tag: 'CloseChildBounty'; value: { parentBountyId: number; childBountyId: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletElectionProviderMultiPhaseCall =
  /**
   * See [`Pallet::submit_unsigned`].
   **/
  | {
      tag: 'SubmitUnsigned';
      value: {
        rawSolution: PalletElectionProviderMultiPhaseRawSolution;
        witness: PalletElectionProviderMultiPhaseSolutionOrSnapshotSize;
      };
    }
  /**
   * See [`Pallet::set_minimum_untrusted_score`].
   **/
  | { tag: 'SetMinimumUntrustedScore'; value: { maybeNextScore?: SpNposElectionsElectionScore | undefined } }
  /**
   * See [`Pallet::set_emergency_election_result`].
   **/
  | { tag: 'SetEmergencyElectionResult'; value: { supports: Array<[AccountId32, SpNposElectionsSupport]> } }
  /**
   * See [`Pallet::submit`].
   **/
  | { tag: 'Submit'; value: { rawSolution: PalletElectionProviderMultiPhaseRawSolution } }
  /**
   * See [`Pallet::governance_fallback`].
   **/
  | { tag: 'GovernanceFallback'; value: { maybeMaxVoters?: number | undefined; maybeMaxTargets?: number | undefined } };

export type PalletElectionProviderMultiPhaseRawSolution = {
  solution: StagingKusamaRuntimeNposCompactSolution24;
  score: SpNposElectionsElectionScore;
  round: number;
};

export type StagingKusamaRuntimeNposCompactSolution24 = {
  votes1: Array<[number, number]>;
  votes2: Array<[number, [number, PerU16], number]>;
  votes3: Array<[number, FixedArray<[number, PerU16], 2>, number]>;
  votes4: Array<[number, FixedArray<[number, PerU16], 3>, number]>;
  votes5: Array<[number, FixedArray<[number, PerU16], 4>, number]>;
  votes6: Array<[number, FixedArray<[number, PerU16], 5>, number]>;
  votes7: Array<[number, FixedArray<[number, PerU16], 6>, number]>;
  votes8: Array<[number, FixedArray<[number, PerU16], 7>, number]>;
  votes9: Array<[number, FixedArray<[number, PerU16], 8>, number]>;
  votes10: Array<[number, FixedArray<[number, PerU16], 9>, number]>;
  votes11: Array<[number, FixedArray<[number, PerU16], 10>, number]>;
  votes12: Array<[number, FixedArray<[number, PerU16], 11>, number]>;
  votes13: Array<[number, FixedArray<[number, PerU16], 12>, number]>;
  votes14: Array<[number, FixedArray<[number, PerU16], 13>, number]>;
  votes15: Array<[number, FixedArray<[number, PerU16], 14>, number]>;
  votes16: Array<[number, FixedArray<[number, PerU16], 15>, number]>;
  votes17: Array<[number, FixedArray<[number, PerU16], 16>, number]>;
  votes18: Array<[number, FixedArray<[number, PerU16], 17>, number]>;
  votes19: Array<[number, FixedArray<[number, PerU16], 18>, number]>;
  votes20: Array<[number, FixedArray<[number, PerU16], 19>, number]>;
  votes21: Array<[number, FixedArray<[number, PerU16], 20>, number]>;
  votes22: Array<[number, FixedArray<[number, PerU16], 21>, number]>;
  votes23: Array<[number, FixedArray<[number, PerU16], 22>, number]>;
  votes24: Array<[number, FixedArray<[number, PerU16], 23>, number]>;
};

export type SpNposElectionsElectionScore = { minimalStake: bigint; sumStake: bigint; sumStakeSquared: bigint };

export type PalletElectionProviderMultiPhaseSolutionOrSnapshotSize = { voters: number; targets: number };

export type SpNposElectionsSupport = { total: bigint; voters: Array<[AccountId32, bigint]> };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletNisCall =
  /**
   * See [`Pallet::place_bid`].
   **/
  | { tag: 'PlaceBid'; value: { amount: bigint; duration: number } }
  /**
   * See [`Pallet::retract_bid`].
   **/
  | { tag: 'RetractBid'; value: { amount: bigint; duration: number } }
  /**
   * See [`Pallet::fund_deficit`].
   **/
  | { tag: 'FundDeficit' }
  /**
   * See [`Pallet::thaw_private`].
   **/
  | { tag: 'ThawPrivate'; value: { index: number; maybeProportion?: Perquintill | undefined } }
  /**
   * See [`Pallet::thaw_communal`].
   **/
  | { tag: 'ThawCommunal'; value: { index: number } }
  /**
   * See [`Pallet::communify`].
   **/
  | { tag: 'Communify'; value: { index: number } }
  /**
   * See [`Pallet::privatize`].
   **/
  | { tag: 'Privatize'; value: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBagsListCall =
  /**
   * See [`Pallet::rebag`].
   **/
  | { tag: 'Rebag'; value: { dislocated: MultiAddress } }
  /**
   * See [`Pallet::put_in_front_of`].
   **/
  | { tag: 'PutInFrontOf'; value: { lighter: MultiAddress } }
  /**
   * See [`Pallet::put_in_front_of_other`].
   **/
  | { tag: 'PutInFrontOfOther'; value: { heavier: MultiAddress; lighter: MultiAddress } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletNominationPoolsCall =
  /**
   * See [`Pallet::join`].
   **/
  | { tag: 'Join'; value: { amount: bigint; poolId: number } }
  /**
   * See [`Pallet::bond_extra`].
   **/
  | { tag: 'BondExtra'; value: { extra: PalletNominationPoolsBondExtra } }
  /**
   * See [`Pallet::claim_payout`].
   **/
  | { tag: 'ClaimPayout' }
  /**
   * See [`Pallet::unbond`].
   **/
  | { tag: 'Unbond'; value: { memberAccount: MultiAddress; unbondingPoints: bigint } }
  /**
   * See [`Pallet::pool_withdraw_unbonded`].
   **/
  | { tag: 'PoolWithdrawUnbonded'; value: { poolId: number; numSlashingSpans: number } }
  /**
   * See [`Pallet::withdraw_unbonded`].
   **/
  | { tag: 'WithdrawUnbonded'; value: { memberAccount: MultiAddress; numSlashingSpans: number } }
  /**
   * See [`Pallet::create`].
   **/
  | { tag: 'Create'; value: { amount: bigint; root: MultiAddress; nominator: MultiAddress; bouncer: MultiAddress } }
  /**
   * See [`Pallet::create_with_pool_id`].
   **/
  | {
      tag: 'CreateWithPoolId';
      value: { amount: bigint; root: MultiAddress; nominator: MultiAddress; bouncer: MultiAddress; poolId: number };
    }
  /**
   * See [`Pallet::nominate`].
   **/
  | { tag: 'Nominate'; value: { poolId: number; validators: Array<AccountId32> } }
  /**
   * See [`Pallet::set_state`].
   **/
  | { tag: 'SetState'; value: { poolId: number; state: PalletNominationPoolsPoolState } }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { tag: 'SetMetadata'; value: { poolId: number; metadata: Bytes } }
  /**
   * See [`Pallet::set_configs`].
   **/
  | {
      tag: 'SetConfigs';
      value: {
        minJoinBond: PalletNominationPoolsConfigOp;
        minCreateBond: PalletNominationPoolsConfigOp;
        maxPools: PalletNominationPoolsConfigOpU32;
        maxMembers: PalletNominationPoolsConfigOpU32;
        maxMembersPerPool: PalletNominationPoolsConfigOpU32;
        globalMaxCommission: PalletNominationPoolsConfigOpPerbill;
      };
    }
  /**
   * See [`Pallet::update_roles`].
   **/
  | {
      tag: 'UpdateRoles';
      value: {
        poolId: number;
        newRoot: PalletNominationPoolsConfigOp004;
        newNominator: PalletNominationPoolsConfigOp004;
        newBouncer: PalletNominationPoolsConfigOp004;
      };
    }
  /**
   * See [`Pallet::chill`].
   **/
  | { tag: 'Chill'; value: { poolId: number } }
  /**
   * See [`Pallet::bond_extra_other`].
   **/
  | { tag: 'BondExtraOther'; value: { member: MultiAddress; extra: PalletNominationPoolsBondExtra } }
  /**
   * See [`Pallet::set_claim_permission`].
   **/
  | { tag: 'SetClaimPermission'; value: { permission: PalletNominationPoolsClaimPermission } }
  /**
   * See [`Pallet::claim_payout_other`].
   **/
  | { tag: 'ClaimPayoutOther'; value: { other: AccountId32 } }
  /**
   * See [`Pallet::set_commission`].
   **/
  | { tag: 'SetCommission'; value: { poolId: number; newCommission?: [Perbill, AccountId32] | undefined } }
  /**
   * See [`Pallet::set_commission_max`].
   **/
  | { tag: 'SetCommissionMax'; value: { poolId: number; maxCommission: Perbill } }
  /**
   * See [`Pallet::set_commission_change_rate`].
   **/
  | { tag: 'SetCommissionChangeRate'; value: { poolId: number; changeRate: PalletNominationPoolsCommissionChangeRate } }
  /**
   * See [`Pallet::claim_commission`].
   **/
  | { tag: 'ClaimCommission'; value: { poolId: number } }
  /**
   * See [`Pallet::adjust_pool_deposit`].
   **/
  | { tag: 'AdjustPoolDeposit'; value: { poolId: number } };

export type PalletNominationPoolsBondExtra = { tag: 'FreeBalance'; value: bigint } | { tag: 'Rewards' };

export type PalletNominationPoolsPoolState = 'Open' | 'Blocked' | 'Destroying';

export type PalletNominationPoolsConfigOp = { tag: 'Noop' } | { tag: 'Set'; value: bigint } | { tag: 'Remove' };

export type PalletNominationPoolsConfigOpU32 = { tag: 'Noop' } | { tag: 'Set'; value: number } | { tag: 'Remove' };

export type PalletNominationPoolsConfigOpPerbill = { tag: 'Noop' } | { tag: 'Set'; value: Perbill } | { tag: 'Remove' };

export type PalletNominationPoolsConfigOp004 = { tag: 'Noop' } | { tag: 'Set'; value: AccountId32 } | { tag: 'Remove' };

export type PalletNominationPoolsClaimPermission =
  | 'Permissioned'
  | 'PermissionlessCompound'
  | 'PermissionlessWithdraw'
  | 'PermissionlessAll';

export type PalletNominationPoolsCommissionChangeRate = { maxIncrease: Perbill; minDelay: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletFastUnstakeCall =
  /**
   * See [`Pallet::register_fast_unstake`].
   **/
  | { tag: 'RegisterFastUnstake' }
  /**
   * See [`Pallet::deregister`].
   **/
  | { tag: 'Deregister' }
  /**
   * See [`Pallet::control`].
   **/
  | { tag: 'Control'; value: { erasToCheck: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsConfigurationPalletCall =
  /**
   * See [`Pallet::set_validation_upgrade_cooldown`].
   **/
  | { tag: 'SetValidationUpgradeCooldown'; value: { new: number } }
  /**
   * See [`Pallet::set_validation_upgrade_delay`].
   **/
  | { tag: 'SetValidationUpgradeDelay'; value: { new: number } }
  /**
   * See [`Pallet::set_code_retention_period`].
   **/
  | { tag: 'SetCodeRetentionPeriod'; value: { new: number } }
  /**
   * See [`Pallet::set_max_code_size`].
   **/
  | { tag: 'SetMaxCodeSize'; value: { new: number } }
  /**
   * See [`Pallet::set_max_pov_size`].
   **/
  | { tag: 'SetMaxPovSize'; value: { new: number } }
  /**
   * See [`Pallet::set_max_head_data_size`].
   **/
  | { tag: 'SetMaxHeadDataSize'; value: { new: number } }
  /**
   * See [`Pallet::set_on_demand_cores`].
   **/
  | { tag: 'SetOnDemandCores'; value: { new: number } }
  /**
   * See [`Pallet::set_on_demand_retries`].
   **/
  | { tag: 'SetOnDemandRetries'; value: { new: number } }
  /**
   * See [`Pallet::set_group_rotation_frequency`].
   **/
  | { tag: 'SetGroupRotationFrequency'; value: { new: number } }
  /**
   * See [`Pallet::set_paras_availability_period`].
   **/
  | { tag: 'SetParasAvailabilityPeriod'; value: { new: number } }
  /**
   * See [`Pallet::set_scheduling_lookahead`].
   **/
  | { tag: 'SetSchedulingLookahead'; value: { new: number } }
  /**
   * See [`Pallet::set_max_validators_per_core`].
   **/
  | { tag: 'SetMaxValidatorsPerCore'; value: { new?: number | undefined } }
  /**
   * See [`Pallet::set_max_validators`].
   **/
  | { tag: 'SetMaxValidators'; value: { new?: number | undefined } }
  /**
   * See [`Pallet::set_dispute_period`].
   **/
  | { tag: 'SetDisputePeriod'; value: { new: number } }
  /**
   * See [`Pallet::set_dispute_post_conclusion_acceptance_period`].
   **/
  | { tag: 'SetDisputePostConclusionAcceptancePeriod'; value: { new: number } }
  /**
   * See [`Pallet::set_no_show_slots`].
   **/
  | { tag: 'SetNoShowSlots'; value: { new: number } }
  /**
   * See [`Pallet::set_n_delay_tranches`].
   **/
  | { tag: 'SetNDelayTranches'; value: { new: number } }
  /**
   * See [`Pallet::set_zeroth_delay_tranche_width`].
   **/
  | { tag: 'SetZerothDelayTrancheWidth'; value: { new: number } }
  /**
   * See [`Pallet::set_needed_approvals`].
   **/
  | { tag: 'SetNeededApprovals'; value: { new: number } }
  /**
   * See [`Pallet::set_relay_vrf_modulo_samples`].
   **/
  | { tag: 'SetRelayVrfModuloSamples'; value: { new: number } }
  /**
   * See [`Pallet::set_max_upward_queue_count`].
   **/
  | { tag: 'SetMaxUpwardQueueCount'; value: { new: number } }
  /**
   * See [`Pallet::set_max_upward_queue_size`].
   **/
  | { tag: 'SetMaxUpwardQueueSize'; value: { new: number } }
  /**
   * See [`Pallet::set_max_downward_message_size`].
   **/
  | { tag: 'SetMaxDownwardMessageSize'; value: { new: number } }
  /**
   * See [`Pallet::set_max_upward_message_size`].
   **/
  | { tag: 'SetMaxUpwardMessageSize'; value: { new: number } }
  /**
   * See [`Pallet::set_max_upward_message_num_per_candidate`].
   **/
  | { tag: 'SetMaxUpwardMessageNumPerCandidate'; value: { new: number } }
  /**
   * See [`Pallet::set_hrmp_open_request_ttl`].
   **/
  | { tag: 'SetHrmpOpenRequestTtl'; value: { new: number } }
  /**
   * See [`Pallet::set_hrmp_sender_deposit`].
   **/
  | { tag: 'SetHrmpSenderDeposit'; value: { new: bigint } }
  /**
   * See [`Pallet::set_hrmp_recipient_deposit`].
   **/
  | { tag: 'SetHrmpRecipientDeposit'; value: { new: bigint } }
  /**
   * See [`Pallet::set_hrmp_channel_max_capacity`].
   **/
  | { tag: 'SetHrmpChannelMaxCapacity'; value: { new: number } }
  /**
   * See [`Pallet::set_hrmp_channel_max_total_size`].
   **/
  | { tag: 'SetHrmpChannelMaxTotalSize'; value: { new: number } }
  /**
   * See [`Pallet::set_hrmp_max_parachain_inbound_channels`].
   **/
  | { tag: 'SetHrmpMaxParachainInboundChannels'; value: { new: number } }
  /**
   * See [`Pallet::set_hrmp_channel_max_message_size`].
   **/
  | { tag: 'SetHrmpChannelMaxMessageSize'; value: { new: number } }
  /**
   * See [`Pallet::set_hrmp_max_parachain_outbound_channels`].
   **/
  | { tag: 'SetHrmpMaxParachainOutboundChannels'; value: { new: number } }
  /**
   * See [`Pallet::set_hrmp_max_message_num_per_candidate`].
   **/
  | { tag: 'SetHrmpMaxMessageNumPerCandidate'; value: { new: number } }
  /**
   * See [`Pallet::set_pvf_voting_ttl`].
   **/
  | { tag: 'SetPvfVotingTtl'; value: { new: number } }
  /**
   * See [`Pallet::set_minimum_validation_upgrade_delay`].
   **/
  | { tag: 'SetMinimumValidationUpgradeDelay'; value: { new: number } }
  /**
   * See [`Pallet::set_bypass_consistency_check`].
   **/
  | { tag: 'SetBypassConsistencyCheck'; value: { new: boolean } }
  /**
   * See [`Pallet::set_async_backing_params`].
   **/
  | { tag: 'SetAsyncBackingParams'; value: { new: PolkadotPrimitivesV6AsyncBackingAsyncBackingParams } }
  /**
   * See [`Pallet::set_executor_params`].
   **/
  | { tag: 'SetExecutorParams'; value: { new: PolkadotPrimitivesV6ExecutorParams } }
  /**
   * See [`Pallet::set_on_demand_base_fee`].
   **/
  | { tag: 'SetOnDemandBaseFee'; value: { new: bigint } }
  /**
   * See [`Pallet::set_on_demand_fee_variability`].
   **/
  | { tag: 'SetOnDemandFeeVariability'; value: { new: Perbill } }
  /**
   * See [`Pallet::set_on_demand_queue_max_size`].
   **/
  | { tag: 'SetOnDemandQueueMaxSize'; value: { new: number } }
  /**
   * See [`Pallet::set_on_demand_target_queue_utilization`].
   **/
  | { tag: 'SetOnDemandTargetQueueUtilization'; value: { new: Perbill } }
  /**
   * See [`Pallet::set_on_demand_ttl`].
   **/
  | { tag: 'SetOnDemandTtl'; value: { new: number } }
  /**
   * See [`Pallet::set_minimum_backing_votes`].
   **/
  | { tag: 'SetMinimumBackingVotes'; value: { new: number } };

export type PolkadotPrimitivesV6AsyncBackingAsyncBackingParams = {
  maxCandidateDepth: number;
  allowedAncestryLen: number;
};

export type PolkadotPrimitivesV6ExecutorParams = Array<PolkadotPrimitivesV6ExecutorParamsExecutorParam>;

export type PolkadotPrimitivesV6ExecutorParamsExecutorParam =
  | { tag: 'MaxMemoryPages'; value: number }
  | { tag: 'StackLogicalMax'; value: number }
  | { tag: 'StackNativeMax'; value: number }
  | { tag: 'PrecheckingMaxMemory'; value: bigint }
  | { tag: 'PvfPrepTimeout'; value: [PolkadotPrimitivesV6PvfPrepTimeoutKind, bigint] }
  | { tag: 'PvfExecTimeout'; value: [PolkadotPrimitivesV6PvfExecTimeoutKind, bigint] }
  | { tag: 'WasmExtBulkMemory' };

export type PolkadotPrimitivesV6PvfPrepTimeoutKind = 'Precheck' | 'Lenient';

export type PolkadotPrimitivesV6PvfExecTimeoutKind = 'Backing' | 'Approval';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsSharedPalletCall = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsInclusionPalletCall = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsParasInherentPalletCall =
  /**
   * See [`Pallet::enter`].
   **/
  { tag: 'Enter'; value: { data: PolkadotPrimitivesV6InherentData } };

export type PolkadotPrimitivesV6InherentData = {
  bitfields: Array<PolkadotPrimitivesV6SignedUncheckedSigned>;
  backedCandidates: Array<PolkadotPrimitivesV6BackedCandidate>;
  disputes: Array<PolkadotPrimitivesV6DisputeStatementSet>;
  parentHeader: Header;
};

export type PolkadotPrimitivesV6SignedUncheckedSigned = {
  payload: PolkadotPrimitivesV6AvailabilityBitfield;
  validatorIndex: PolkadotPrimitivesV6ValidatorIndex;
  signature: PolkadotPrimitivesV6ValidatorAppSignature;
};

export type PolkadotPrimitivesV6AvailabilityBitfield = BitSequence;

export type BitvecOrderLsb0 = {};

export type PolkadotPrimitivesV6ValidatorIndex = number;

export type PolkadotPrimitivesV6ValidatorAppSignature = SpCoreSr25519Signature;

export type PolkadotPrimitivesV6BackedCandidate = {
  candidate: PolkadotPrimitivesV6CommittedCandidateReceipt;
  validityVotes: Array<PolkadotPrimitivesV6ValidityAttestation>;
  validatorIndices: BitSequence;
};

export type PolkadotPrimitivesV6CommittedCandidateReceipt = {
  descriptor: PolkadotPrimitivesV6CandidateDescriptor;
  commitments: PolkadotPrimitivesV6CandidateCommitments;
};

export type PolkadotPrimitivesV6CandidateDescriptor = {
  paraId: PolkadotParachainPrimitivesPrimitivesId;
  relayParent: H256;
  collator: PolkadotPrimitivesV6CollatorAppPublic;
  persistedValidationDataHash: H256;
  povHash: H256;
  erasureRoot: H256;
  signature: PolkadotPrimitivesV6CollatorAppSignature;
  paraHead: H256;
  validationCodeHash: PolkadotParachainPrimitivesPrimitivesValidationCodeHash;
};

export type PolkadotPrimitivesV6CollatorAppPublic = SpCoreSr25519Public;

export type PolkadotPrimitivesV6CollatorAppSignature = SpCoreSr25519Signature;

export type PolkadotParachainPrimitivesPrimitivesValidationCodeHash = H256;

export type PolkadotPrimitivesV6CandidateCommitments = {
  upwardMessages: Array<Bytes>;
  horizontalMessages: Array<PolkadotCorePrimitivesOutboundHrmpMessage>;
  newValidationCode?: PolkadotParachainPrimitivesPrimitivesValidationCode | undefined;
  headData: PolkadotParachainPrimitivesPrimitivesHeadData;
  processedDownwardMessages: number;
  hrmpWatermark: number;
};

export type PolkadotCorePrimitivesOutboundHrmpMessage = {
  recipient: PolkadotParachainPrimitivesPrimitivesId;
  data: Bytes;
};

export type PolkadotParachainPrimitivesPrimitivesValidationCode = Bytes;

export type PolkadotParachainPrimitivesPrimitivesHeadData = Bytes;

export type PolkadotPrimitivesV6ValidityAttestation =
  | { tag: 'Implicit'; value: PolkadotPrimitivesV6ValidatorAppSignature }
  | { tag: 'Explicit'; value: PolkadotPrimitivesV6ValidatorAppSignature };

export type PolkadotPrimitivesV6DisputeStatementSet = {
  candidateHash: PolkadotCorePrimitivesCandidateHash;
  session: number;
  statements: Array<
    [
      PolkadotPrimitivesV6DisputeStatement,
      PolkadotPrimitivesV6ValidatorIndex,
      PolkadotPrimitivesV6ValidatorAppSignature,
    ]
  >;
};

export type PolkadotCorePrimitivesCandidateHash = H256;

export type PolkadotPrimitivesV6DisputeStatement =
  | { tag: 'Valid'; value: PolkadotPrimitivesV6ValidDisputeStatementKind }
  | { tag: 'Invalid'; value: PolkadotPrimitivesV6InvalidDisputeStatementKind };

export type PolkadotPrimitivesV6ValidDisputeStatementKind =
  | { tag: 'Explicit' }
  | { tag: 'BackingSeconded'; value: H256 }
  | { tag: 'BackingValid'; value: H256 }
  | { tag: 'ApprovalChecking' };

export type PolkadotPrimitivesV6InvalidDisputeStatementKind = 'Explicit';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsParasPalletCall =
  /**
   * See [`Pallet::force_set_current_code`].
   **/
  | {
      tag: 'ForceSetCurrentCode';
      value: {
        para: PolkadotParachainPrimitivesPrimitivesId;
        newCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
      };
    }
  /**
   * See [`Pallet::force_set_current_head`].
   **/
  | {
      tag: 'ForceSetCurrentHead';
      value: { para: PolkadotParachainPrimitivesPrimitivesId; newHead: PolkadotParachainPrimitivesPrimitivesHeadData };
    }
  /**
   * See [`Pallet::force_schedule_code_upgrade`].
   **/
  | {
      tag: 'ForceScheduleCodeUpgrade';
      value: {
        para: PolkadotParachainPrimitivesPrimitivesId;
        newCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
        relayParentNumber: number;
      };
    }
  /**
   * See [`Pallet::force_note_new_head`].
   **/
  | {
      tag: 'ForceNoteNewHead';
      value: { para: PolkadotParachainPrimitivesPrimitivesId; newHead: PolkadotParachainPrimitivesPrimitivesHeadData };
    }
  /**
   * See [`Pallet::force_queue_action`].
   **/
  | { tag: 'ForceQueueAction'; value: { para: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * See [`Pallet::add_trusted_validation_code`].
   **/
  | { tag: 'AddTrustedValidationCode'; value: { validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode } }
  /**
   * See [`Pallet::poke_unused_validation_code`].
   **/
  | {
      tag: 'PokeUnusedValidationCode';
      value: { validationCodeHash: PolkadotParachainPrimitivesPrimitivesValidationCodeHash };
    }
  /**
   * See [`Pallet::include_pvf_check_statement`].
   **/
  | {
      tag: 'IncludePvfCheckStatement';
      value: { stmt: PolkadotPrimitivesV6PvfCheckStatement; signature: PolkadotPrimitivesV6ValidatorAppSignature };
    }
  /**
   * See [`Pallet::force_set_most_recent_context`].
   **/
  | { tag: 'ForceSetMostRecentContext'; value: { para: PolkadotParachainPrimitivesPrimitivesId; context: number } };

export type PolkadotPrimitivesV6PvfCheckStatement = {
  accept: boolean;
  subject: PolkadotParachainPrimitivesPrimitivesValidationCodeHash;
  sessionIndex: number;
  validatorIndex: PolkadotPrimitivesV6ValidatorIndex;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsInitializerPalletCall =
  /**
   * See [`Pallet::force_approve`].
   **/
  { tag: 'ForceApprove'; value: { upTo: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsHrmpPalletCall =
  /**
   * See [`Pallet::hrmp_init_open_channel`].
   **/
  | {
      tag: 'HrmpInitOpenChannel';
      value: {
        recipient: PolkadotParachainPrimitivesPrimitivesId;
        proposedMaxCapacity: number;
        proposedMaxMessageSize: number;
      };
    }
  /**
   * See [`Pallet::hrmp_accept_open_channel`].
   **/
  | { tag: 'HrmpAcceptOpenChannel'; value: { sender: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * See [`Pallet::hrmp_close_channel`].
   **/
  | { tag: 'HrmpCloseChannel'; value: { channelId: PolkadotParachainPrimitivesPrimitivesHrmpChannelId } }
  /**
   * See [`Pallet::force_clean_hrmp`].
   **/
  | {
      tag: 'ForceCleanHrmp';
      value: { para: PolkadotParachainPrimitivesPrimitivesId; numInbound: number; numOutbound: number };
    }
  /**
   * See [`Pallet::force_process_hrmp_open`].
   **/
  | { tag: 'ForceProcessHrmpOpen'; value: { channels: number } }
  /**
   * See [`Pallet::force_process_hrmp_close`].
   **/
  | { tag: 'ForceProcessHrmpClose'; value: { channels: number } }
  /**
   * See [`Pallet::hrmp_cancel_open_request`].
   **/
  | {
      tag: 'HrmpCancelOpenRequest';
      value: { channelId: PolkadotParachainPrimitivesPrimitivesHrmpChannelId; openRequests: number };
    }
  /**
   * See [`Pallet::force_open_hrmp_channel`].
   **/
  | {
      tag: 'ForceOpenHrmpChannel';
      value: {
        sender: PolkadotParachainPrimitivesPrimitivesId;
        recipient: PolkadotParachainPrimitivesPrimitivesId;
        maxCapacity: number;
        maxMessageSize: number;
      };
    }
  /**
   * See [`Pallet::establish_system_channel`].
   **/
  | {
      tag: 'EstablishSystemChannel';
      value: { sender: PolkadotParachainPrimitivesPrimitivesId; recipient: PolkadotParachainPrimitivesPrimitivesId };
    }
  /**
   * See [`Pallet::poke_channel_deposits`].
   **/
  | {
      tag: 'PokeChannelDeposits';
      value: { sender: PolkadotParachainPrimitivesPrimitivesId; recipient: PolkadotParachainPrimitivesPrimitivesId };
    };

export type PolkadotParachainPrimitivesPrimitivesHrmpChannelId = {
  sender: PolkadotParachainPrimitivesPrimitivesId;
  recipient: PolkadotParachainPrimitivesPrimitivesId;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsDisputesPalletCall =
  /**
   * See [`Pallet::force_unfreeze`].
   **/
  'force_unfreeze';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsDisputesSlashingPalletCall =
  /**
   * See [`Pallet::report_dispute_lost_unsigned`].
   **/
  {
    tag: 'ReportDisputeLostUnsigned';
    value: { disputeProof: PolkadotPrimitivesV6SlashingDisputeProof; keyOwnerProof: SpSessionMembershipProof };
  };

export type PolkadotPrimitivesV6SlashingDisputeProof = {
  timeSlot: PolkadotPrimitivesV6SlashingDisputesTimeSlot;
  kind: PolkadotPrimitivesV6SlashingSlashingOffenceKind;
  validatorIndex: PolkadotPrimitivesV6ValidatorIndex;
  validatorId: PolkadotPrimitivesV6ValidatorAppPublic;
};

export type PolkadotPrimitivesV6SlashingDisputesTimeSlot = {
  sessionIndex: number;
  candidateHash: PolkadotCorePrimitivesCandidateHash;
};

export type PolkadotPrimitivesV6SlashingSlashingOffenceKind = 'ForInvalid' | 'AgainstValid';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeCommonParasRegistrarPalletCall =
  /**
   * See [`Pallet::register`].
   **/
  | {
      tag: 'Register';
      value: {
        id: PolkadotParachainPrimitivesPrimitivesId;
        genesisHead: PolkadotParachainPrimitivesPrimitivesHeadData;
        validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
      };
    }
  /**
   * See [`Pallet::force_register`].
   **/
  | {
      tag: 'ForceRegister';
      value: {
        who: AccountId32;
        deposit: bigint;
        id: PolkadotParachainPrimitivesPrimitivesId;
        genesisHead: PolkadotParachainPrimitivesPrimitivesHeadData;
        validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
      };
    }
  /**
   * See [`Pallet::deregister`].
   **/
  | { tag: 'Deregister'; value: { id: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * See [`Pallet::swap`].
   **/
  | {
      tag: 'Swap';
      value: { id: PolkadotParachainPrimitivesPrimitivesId; other: PolkadotParachainPrimitivesPrimitivesId };
    }
  /**
   * See [`Pallet::remove_lock`].
   **/
  | { tag: 'RemoveLock'; value: { para: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * See [`Pallet::reserve`].
   **/
  | { tag: 'Reserve' }
  /**
   * See [`Pallet::add_lock`].
   **/
  | { tag: 'AddLock'; value: { para: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * See [`Pallet::schedule_code_upgrade`].
   **/
  | {
      tag: 'ScheduleCodeUpgrade';
      value: {
        para: PolkadotParachainPrimitivesPrimitivesId;
        newCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
      };
    }
  /**
   * See [`Pallet::set_current_head`].
   **/
  | {
      tag: 'SetCurrentHead';
      value: { para: PolkadotParachainPrimitivesPrimitivesId; newHead: PolkadotParachainPrimitivesPrimitivesHeadData };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeCommonSlotsPalletCall =
  /**
   * See [`Pallet::force_lease`].
   **/
  | {
      tag: 'ForceLease';
      value: {
        para: PolkadotParachainPrimitivesPrimitivesId;
        leaser: AccountId32;
        amount: bigint;
        periodBegin: number;
        periodCount: number;
      };
    }
  /**
   * See [`Pallet::clear_all_leases`].
   **/
  | { tag: 'ClearAllLeases'; value: { para: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * See [`Pallet::trigger_onboard`].
   **/
  | { tag: 'TriggerOnboard'; value: { para: PolkadotParachainPrimitivesPrimitivesId } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeCommonAuctionsPalletCall =
  /**
   * See [`Pallet::new_auction`].
   **/
  | { tag: 'NewAuction'; value: { duration: number; leasePeriodIndex: number } }
  /**
   * See [`Pallet::bid`].
   **/
  | {
      tag: 'Bid';
      value: {
        para: PolkadotParachainPrimitivesPrimitivesId;
        auctionIndex: number;
        firstSlot: number;
        lastSlot: number;
        amount: bigint;
      };
    }
  /**
   * See [`Pallet::cancel_auction`].
   **/
  | { tag: 'CancelAuction' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeCommonCrowdloanPalletCall =
  /**
   * See [`Pallet::create`].
   **/
  | {
      tag: 'Create';
      value: {
        index: PolkadotParachainPrimitivesPrimitivesId;
        cap: bigint;
        firstPeriod: number;
        lastPeriod: number;
        end: number;
        verifier?: SpRuntimeMultiSigner | undefined;
      };
    }
  /**
   * See [`Pallet::contribute`].
   **/
  | {
      tag: 'Contribute';
      value: {
        index: PolkadotParachainPrimitivesPrimitivesId;
        value: bigint;
        signature?: SpRuntimeMultiSignature | undefined;
      };
    }
  /**
   * See [`Pallet::withdraw`].
   **/
  | { tag: 'Withdraw'; value: { who: AccountId32; index: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * See [`Pallet::refund`].
   **/
  | { tag: 'Refund'; value: { index: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * See [`Pallet::dissolve`].
   **/
  | { tag: 'Dissolve'; value: { index: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * See [`Pallet::edit`].
   **/
  | {
      tag: 'Edit';
      value: {
        index: PolkadotParachainPrimitivesPrimitivesId;
        cap: bigint;
        firstPeriod: number;
        lastPeriod: number;
        end: number;
        verifier?: SpRuntimeMultiSigner | undefined;
      };
    }
  /**
   * See [`Pallet::add_memo`].
   **/
  | { tag: 'AddMemo'; value: { index: PolkadotParachainPrimitivesPrimitivesId; memo: Bytes } }
  /**
   * See [`Pallet::poke`].
   **/
  | { tag: 'Poke'; value: { index: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * See [`Pallet::contribute_all`].
   **/
  | {
      tag: 'ContributeAll';
      value: { index: PolkadotParachainPrimitivesPrimitivesId; signature?: SpRuntimeMultiSignature | undefined };
    };

export type SpRuntimeMultiSigner =
  | { tag: 'Ed25519'; value: SpCoreEd25519Public }
  | { tag: 'Sr25519'; value: SpCoreSr25519Public }
  | { tag: 'Ecdsa'; value: SpCoreEcdsaPublic };

export type SpRuntimeMultiSignature =
  | { tag: 'Ed25519'; value: SpCoreEd25519Signature }
  | { tag: 'Sr25519'; value: SpCoreSr25519Signature }
  | { tag: 'Ecdsa'; value: SpCoreEcdsaSignature };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletStateTrieMigrationCall =
  /**
   * See [`Pallet::control_auto_migration`].
   **/
  | { tag: 'ControlAutoMigration'; value: { maybeConfig?: PalletStateTrieMigrationMigrationLimits | undefined } }
  /**
   * See [`Pallet::continue_migrate`].
   **/
  | {
      tag: 'ContinueMigrate';
      value: {
        limits: PalletStateTrieMigrationMigrationLimits;
        realSizeUpper: number;
        witnessTask: PalletStateTrieMigrationMigrationTask;
      };
    }
  /**
   * See [`Pallet::migrate_custom_top`].
   **/
  | { tag: 'MigrateCustomTop'; value: { keys: Array<Bytes>; witnessSize: number } }
  /**
   * See [`Pallet::migrate_custom_child`].
   **/
  | { tag: 'MigrateCustomChild'; value: { root: Bytes; childKeys: Array<Bytes>; totalSize: number } }
  /**
   * See [`Pallet::set_signed_max_limits`].
   **/
  | { tag: 'SetSignedMaxLimits'; value: { limits: PalletStateTrieMigrationMigrationLimits } }
  /**
   * See [`Pallet::force_set_progress`].
   **/
  | {
      tag: 'ForceSetProgress';
      value: { progressTop: PalletStateTrieMigrationProgress; progressChild: PalletStateTrieMigrationProgress };
    };

export type PalletStateTrieMigrationMigrationLimits = { size: number; item: number };

export type PalletStateTrieMigrationMigrationTask = {
  progressTop: PalletStateTrieMigrationProgress;
  progressChild: PalletStateTrieMigrationProgress;
  size: number;
  topItems: number;
  childItems: number;
};

export type PalletStateTrieMigrationProgress =
  | { tag: 'ToStart' }
  | { tag: 'LastKey'; value: Bytes }
  | { tag: 'Complete' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletXcmCall =
  /**
   * See [`Pallet::send`].
   **/
  | { tag: 'Send'; value: { dest: XcmVersionedMultiLocation; message: XcmVersionedXcm } }
  /**
   * See [`Pallet::teleport_assets`].
   **/
  | {
      tag: 'TeleportAssets';
      value: {
        dest: XcmVersionedMultiLocation;
        beneficiary: XcmVersionedMultiLocation;
        assets: XcmVersionedMultiAssets;
        feeAssetItem: number;
      };
    }
  /**
   * See [`Pallet::reserve_transfer_assets`].
   **/
  | {
      tag: 'ReserveTransferAssets';
      value: {
        dest: XcmVersionedMultiLocation;
        beneficiary: XcmVersionedMultiLocation;
        assets: XcmVersionedMultiAssets;
        feeAssetItem: number;
      };
    }
  /**
   * See [`Pallet::execute`].
   **/
  | { tag: 'Execute'; value: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::force_xcm_version`].
   **/
  | { tag: 'ForceXcmVersion'; value: { location: StagingXcmV3MultilocationMultiLocation; version: number } }
  /**
   * See [`Pallet::force_default_xcm_version`].
   **/
  | { tag: 'ForceDefaultXcmVersion'; value: { maybeXcmVersion?: number | undefined } }
  /**
   * See [`Pallet::force_subscribe_version_notify`].
   **/
  | { tag: 'ForceSubscribeVersionNotify'; value: { location: XcmVersionedMultiLocation } }
  /**
   * See [`Pallet::force_unsubscribe_version_notify`].
   **/
  | { tag: 'ForceUnsubscribeVersionNotify'; value: { location: XcmVersionedMultiLocation } }
  /**
   * See [`Pallet::limited_reserve_transfer_assets`].
   **/
  | {
      tag: 'LimitedReserveTransferAssets';
      value: {
        dest: XcmVersionedMultiLocation;
        beneficiary: XcmVersionedMultiLocation;
        assets: XcmVersionedMultiAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::limited_teleport_assets`].
   **/
  | {
      tag: 'LimitedTeleportAssets';
      value: {
        dest: XcmVersionedMultiLocation;
        beneficiary: XcmVersionedMultiLocation;
        assets: XcmVersionedMultiAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::force_suspension`].
   **/
  | { tag: 'ForceSuspension'; value: { suspended: boolean } };

export type XcmVersionedXcm = { tag: 'V2'; value: XcmV2Xcm } | { tag: 'V3'; value: XcmV3Xcm };

export type XcmV2Xcm = Array<XcmV2Instruction>;

export type XcmV2Instruction =
  | { tag: 'WithdrawAsset'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'ReserveAssetDeposited'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'ReceiveTeleportedAsset'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'QueryResponse'; value: { queryId: bigint; response: XcmV2Response; maxWeight: bigint } }
  | {
      tag: 'TransferAsset';
      value: { assets: XcmV2MultiassetMultiAssets; beneficiary: XcmV2MultilocationMultiLocation };
    }
  | {
      tag: 'TransferReserveAsset';
      value: { assets: XcmV2MultiassetMultiAssets; dest: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | { tag: 'Transact'; value: { originType: XcmV2OriginKind; requireWeightAtMost: bigint; call: XcmDoubleEncoded } }
  | { tag: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { tag: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { tag: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { tag: 'ClearOrigin' }
  | { tag: 'DescendOrigin'; value: XcmV2MultilocationJunctions }
  | { tag: 'ReportError'; value: { queryId: bigint; dest: XcmV2MultilocationMultiLocation; maxResponseWeight: bigint } }
  | {
      tag: 'DepositAsset';
      value: {
        assets: XcmV2MultiassetMultiAssetFilter;
        maxAssets: number;
        beneficiary: XcmV2MultilocationMultiLocation;
      };
    }
  | {
      tag: 'DepositReserveAsset';
      value: {
        assets: XcmV2MultiassetMultiAssetFilter;
        maxAssets: number;
        dest: XcmV2MultilocationMultiLocation;
        xcm: XcmV2Xcm;
      };
    }
  | { tag: 'ExchangeAsset'; value: { give: XcmV2MultiassetMultiAssetFilter; receive: XcmV2MultiassetMultiAssets } }
  | {
      tag: 'InitiateReserveWithdraw';
      value: { assets: XcmV2MultiassetMultiAssetFilter; reserve: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | {
      tag: 'InitiateTeleport';
      value: { assets: XcmV2MultiassetMultiAssetFilter; dest: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | {
      tag: 'QueryHolding';
      value: {
        queryId: bigint;
        dest: XcmV2MultilocationMultiLocation;
        assets: XcmV2MultiassetMultiAssetFilter;
        maxResponseWeight: bigint;
      };
    }
  | { tag: 'BuyExecution'; value: { fees: XcmV2MultiassetMultiAsset; weightLimit: XcmV2WeightLimit } }
  | { tag: 'RefundSurplus' }
  | { tag: 'SetErrorHandler'; value: XcmV2Xcm }
  | { tag: 'SetAppendix'; value: XcmV2Xcm }
  | { tag: 'ClearError' }
  | { tag: 'ClaimAsset'; value: { assets: XcmV2MultiassetMultiAssets; ticket: XcmV2MultilocationMultiLocation } }
  | { tag: 'Trap'; value: bigint }
  | { tag: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: bigint } }
  | { tag: 'UnsubscribeVersion' };

export type XcmV2MultiassetMultiAssets = Array<XcmV2MultiassetMultiAsset>;

export type XcmV2MultiassetMultiAsset = { id: XcmV2MultiassetAssetId; fun: XcmV2MultiassetFungibility };

export type XcmV2MultiassetAssetId =
  | { tag: 'Concrete'; value: XcmV2MultilocationMultiLocation }
  | { tag: 'Abstract'; value: Bytes };

export type XcmV2MultiassetFungibility =
  | { tag: 'Fungible'; value: bigint }
  | { tag: 'NonFungible'; value: XcmV2MultiassetAssetInstance };

export type XcmV2MultiassetAssetInstance =
  | { tag: 'Undefined' }
  | { tag: 'Index'; value: bigint }
  | { tag: 'Array4'; value: FixedBytes<4> }
  | { tag: 'Array8'; value: FixedBytes<8> }
  | { tag: 'Array16'; value: FixedBytes<16> }
  | { tag: 'Array32'; value: FixedBytes<32> }
  | { tag: 'Blob'; value: Bytes };

export type XcmV2Response =
  | { tag: 'Null' }
  | { tag: 'Assets'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'ExecutionResult'; value?: [number, XcmV2TraitsError] | undefined }
  | { tag: 'Version'; value: number };

export type XcmV2TraitsError =
  | { tag: 'Overflow' }
  | { tag: 'Unimplemented' }
  | { tag: 'UntrustedReserveLocation' }
  | { tag: 'UntrustedTeleportLocation' }
  | { tag: 'MultiLocationFull' }
  | { tag: 'MultiLocationNotInvertible' }
  | { tag: 'BadOrigin' }
  | { tag: 'InvalidLocation' }
  | { tag: 'AssetNotFound' }
  | { tag: 'FailedToTransactAsset' }
  | { tag: 'NotWithdrawable' }
  | { tag: 'LocationCannotHold' }
  | { tag: 'ExceedsMaxMessageSize' }
  | { tag: 'DestinationUnsupported' }
  | { tag: 'Transport' }
  | { tag: 'Unroutable' }
  | { tag: 'UnknownClaim' }
  | { tag: 'FailedToDecode' }
  | { tag: 'MaxWeightInvalid' }
  | { tag: 'NotHoldingFees' }
  | { tag: 'TooExpensive' }
  | { tag: 'Trap'; value: bigint }
  | { tag: 'UnhandledXcmVersion' }
  | { tag: 'WeightLimitReached'; value: bigint }
  | { tag: 'Barrier' }
  | { tag: 'WeightNotComputable' };

export type XcmV2OriginKind = 'Native' | 'SovereignAccount' | 'Superuser' | 'Xcm';

export type XcmDoubleEncoded = { encoded: Bytes };

export type XcmV2MultiassetMultiAssetFilter =
  | { tag: 'Definite'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'Wild'; value: XcmV2MultiassetWildMultiAsset };

export type XcmV2MultiassetWildMultiAsset =
  | { tag: 'All' }
  | { tag: 'AllOf'; value: { id: XcmV2MultiassetAssetId; fun: XcmV2MultiassetWildFungibility } };

export type XcmV2MultiassetWildFungibility = 'Fungible' | 'NonFungible';

export type XcmV2WeightLimit = { tag: 'Unlimited' } | { tag: 'Limited'; value: bigint };

export type XcmV3Xcm = Array<XcmV3Instruction>;

export type XcmV3Instruction =
  | { tag: 'WithdrawAsset'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'ReserveAssetDeposited'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'ReceiveTeleportedAsset'; value: XcmV3MultiassetMultiAssets }
  | {
      tag: 'QueryResponse';
      value: {
        queryId: bigint;
        response: XcmV3Response;
        maxWeight: SpWeightsWeightV2Weight;
        querier?: StagingXcmV3MultilocationMultiLocation | undefined;
      };
    }
  | {
      tag: 'TransferAsset';
      value: { assets: XcmV3MultiassetMultiAssets; beneficiary: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      tag: 'TransferReserveAsset';
      value: { assets: XcmV3MultiassetMultiAssets; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | {
      tag: 'Transact';
      value: { originKind: XcmV2OriginKind; requireWeightAtMost: SpWeightsWeightV2Weight; call: XcmDoubleEncoded };
    }
  | { tag: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { tag: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { tag: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { tag: 'ClearOrigin' }
  | { tag: 'DescendOrigin'; value: XcmV3Junctions }
  | { tag: 'ReportError'; value: XcmV3QueryResponseInfo }
  | {
      tag: 'DepositAsset';
      value: { assets: XcmV3MultiassetMultiAssetFilter; beneficiary: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      tag: 'DepositReserveAsset';
      value: { assets: XcmV3MultiassetMultiAssetFilter; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | {
      tag: 'ExchangeAsset';
      value: { give: XcmV3MultiassetMultiAssetFilter; want: XcmV3MultiassetMultiAssets; maximal: boolean };
    }
  | {
      tag: 'InitiateReserveWithdraw';
      value: {
        assets: XcmV3MultiassetMultiAssetFilter;
        reserve: StagingXcmV3MultilocationMultiLocation;
        xcm: XcmV3Xcm;
      };
    }
  | {
      tag: 'InitiateTeleport';
      value: { assets: XcmV3MultiassetMultiAssetFilter; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | { tag: 'ReportHolding'; value: { responseInfo: XcmV3QueryResponseInfo; assets: XcmV3MultiassetMultiAssetFilter } }
  | { tag: 'BuyExecution'; value: { fees: XcmV3MultiassetMultiAsset; weightLimit: XcmV3WeightLimit } }
  | { tag: 'RefundSurplus' }
  | { tag: 'SetErrorHandler'; value: XcmV3Xcm }
  | { tag: 'SetAppendix'; value: XcmV3Xcm }
  | { tag: 'ClearError' }
  | { tag: 'ClaimAsset'; value: { assets: XcmV3MultiassetMultiAssets; ticket: StagingXcmV3MultilocationMultiLocation } }
  | { tag: 'Trap'; value: bigint }
  | { tag: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: SpWeightsWeightV2Weight } }
  | { tag: 'UnsubscribeVersion' }
  | { tag: 'BurnAsset'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'ExpectAsset'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'ExpectOrigin'; value?: StagingXcmV3MultilocationMultiLocation | undefined }
  | { tag: 'ExpectError'; value?: [number, XcmV3TraitsError] | undefined }
  | { tag: 'ExpectTransactStatus'; value: XcmV3MaybeErrorCode }
  | { tag: 'QueryPallet'; value: { moduleName: Bytes; responseInfo: XcmV3QueryResponseInfo } }
  | {
      tag: 'ExpectPallet';
      value: { index: number; name: Bytes; moduleName: Bytes; crateMajor: number; minCrateMinor: number };
    }
  | { tag: 'ReportTransactStatus'; value: XcmV3QueryResponseInfo }
  | { tag: 'ClearTransactStatus' }
  | { tag: 'UniversalOrigin'; value: XcmV3Junction }
  | { tag: 'ExportMessage'; value: { network: XcmV3JunctionNetworkId; destination: XcmV3Junctions; xcm: XcmV3Xcm } }
  | { tag: 'LockAsset'; value: { asset: XcmV3MultiassetMultiAsset; unlocker: StagingXcmV3MultilocationMultiLocation } }
  | { tag: 'UnlockAsset'; value: { asset: XcmV3MultiassetMultiAsset; target: StagingXcmV3MultilocationMultiLocation } }
  | {
      tag: 'NoteUnlockable';
      value: { asset: XcmV3MultiassetMultiAsset; owner: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      tag: 'RequestUnlock';
      value: { asset: XcmV3MultiassetMultiAsset; locker: StagingXcmV3MultilocationMultiLocation };
    }
  | { tag: 'SetFeesMode'; value: { jitWithdraw: boolean } }
  | { tag: 'SetTopic'; value: FixedBytes<32> }
  | { tag: 'ClearTopic' }
  | { tag: 'AliasOrigin'; value: StagingXcmV3MultilocationMultiLocation }
  | {
      tag: 'UnpaidExecution';
      value: { weightLimit: XcmV3WeightLimit; checkOrigin?: StagingXcmV3MultilocationMultiLocation | undefined };
    };

export type XcmV3MultiassetMultiAssets = Array<XcmV3MultiassetMultiAsset>;

export type XcmV3MultiassetMultiAsset = { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetFungibility };

export type XcmV3MultiassetFungibility =
  | { tag: 'Fungible'; value: bigint }
  | { tag: 'NonFungible'; value: XcmV3MultiassetAssetInstance };

export type XcmV3MultiassetAssetInstance =
  | { tag: 'Undefined' }
  | { tag: 'Index'; value: bigint }
  | { tag: 'Array4'; value: FixedBytes<4> }
  | { tag: 'Array8'; value: FixedBytes<8> }
  | { tag: 'Array16'; value: FixedBytes<16> }
  | { tag: 'Array32'; value: FixedBytes<32> };

export type XcmV3Response =
  | { tag: 'Null' }
  | { tag: 'Assets'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'ExecutionResult'; value?: [number, XcmV3TraitsError] | undefined }
  | { tag: 'Version'; value: number }
  | { tag: 'PalletsInfo'; value: Array<XcmV3PalletInfo> }
  | { tag: 'DispatchResult'; value: XcmV3MaybeErrorCode };

export type XcmV3TraitsError =
  | { tag: 'Overflow' }
  | { tag: 'Unimplemented' }
  | { tag: 'UntrustedReserveLocation' }
  | { tag: 'UntrustedTeleportLocation' }
  | { tag: 'LocationFull' }
  | { tag: 'LocationNotInvertible' }
  | { tag: 'BadOrigin' }
  | { tag: 'InvalidLocation' }
  | { tag: 'AssetNotFound' }
  | { tag: 'FailedToTransactAsset' }
  | { tag: 'NotWithdrawable' }
  | { tag: 'LocationCannotHold' }
  | { tag: 'ExceedsMaxMessageSize' }
  | { tag: 'DestinationUnsupported' }
  | { tag: 'Transport' }
  | { tag: 'Unroutable' }
  | { tag: 'UnknownClaim' }
  | { tag: 'FailedToDecode' }
  | { tag: 'MaxWeightInvalid' }
  | { tag: 'NotHoldingFees' }
  | { tag: 'TooExpensive' }
  | { tag: 'Trap'; value: bigint }
  | { tag: 'ExpectationFalse' }
  | { tag: 'PalletNotFound' }
  | { tag: 'NameMismatch' }
  | { tag: 'VersionIncompatible' }
  | { tag: 'HoldingWouldOverflow' }
  | { tag: 'ExportError' }
  | { tag: 'ReanchorFailed' }
  | { tag: 'NoDeal' }
  | { tag: 'FeesNotMet' }
  | { tag: 'LockError' }
  | { tag: 'NoPermission' }
  | { tag: 'Unanchored' }
  | { tag: 'NotDepositable' }
  | { tag: 'UnhandledXcmVersion' }
  | { tag: 'WeightLimitReached'; value: SpWeightsWeightV2Weight }
  | { tag: 'Barrier' }
  | { tag: 'WeightNotComputable' }
  | { tag: 'ExceedsStackLimit' };

export type XcmV3PalletInfo = {
  index: number;
  name: Bytes;
  moduleName: Bytes;
  major: number;
  minor: number;
  patch: number;
};

export type XcmV3MaybeErrorCode =
  | { tag: 'Success' }
  | { tag: 'Error'; value: Bytes }
  | { tag: 'TruncatedError'; value: Bytes };

export type XcmV3QueryResponseInfo = {
  destination: StagingXcmV3MultilocationMultiLocation;
  queryId: bigint;
  maxWeight: SpWeightsWeightV2Weight;
};

export type XcmV3MultiassetMultiAssetFilter =
  | { tag: 'Definite'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'Wild'; value: XcmV3MultiassetWildMultiAsset };

export type XcmV3MultiassetWildMultiAsset =
  | { tag: 'All' }
  | { tag: 'AllOf'; value: { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetWildFungibility } }
  | { tag: 'AllCounted'; value: number }
  | { tag: 'AllOfCounted'; value: { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetWildFungibility; count: number } };

export type XcmV3MultiassetWildFungibility = 'Fungible' | 'NonFungible';

export type XcmV3WeightLimit = { tag: 'Unlimited' } | { tag: 'Limited'; value: SpWeightsWeightV2Weight };

export type XcmVersionedMultiAssets =
  | { tag: 'V2'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'V3'; value: XcmV3MultiassetMultiAssets };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMessageQueueCall =
  /**
   * See [`Pallet::reap_page`].
   **/
  | {
      tag: 'ReapPage';
      value: { messageOrigin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin; pageIndex: number };
    }
  /**
   * See [`Pallet::execute_overweight`].
   **/
  | {
      tag: 'ExecuteOverweight';
      value: {
        messageOrigin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin;
        page: number;
        index: number;
        weightLimit: SpWeightsWeightV2Weight;
      };
    };

export type PolkadotRuntimeParachainsInclusionAggregateMessageOrigin = {
  tag: 'Ump';
  value: PolkadotRuntimeParachainsInclusionUmpQueueId;
};

export type PolkadotRuntimeParachainsInclusionUmpQueueId = {
  tag: 'Para';
  value: PolkadotParachainPrimitivesPrimitivesId;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAssetRateCall =
  /**
   * See [`Pallet::create`].
   **/
  | { tag: 'Create'; value: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset; rate: FixedU128 } }
  /**
   * See [`Pallet::update`].
   **/
  | { tag: 'Update'; value: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset; rate: FixedU128 } }
  /**
   * See [`Pallet::remove`].
   **/
  | { tag: 'Remove'; value: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset } };

export type SpRuntimeBlakeTwo256 = {};

export type PalletConvictionVotingTally = { ayes: bigint; nays: bigint; support: bigint };

/**
 * The `Event` enum of this pallet
 **/
export type PalletRankedCollectiveEvent =
  /**
   * A member `who` has been added.
   **/
  | { name: 'MemberAdded'; data: { who: AccountId32 } }
  /**
   * The member `who`se rank has been changed to the given `rank`.
   **/
  | { name: 'RankChanged'; data: { who: AccountId32; rank: number } }
  /**
   * The member `who` of given `rank` has been removed from the collective.
   **/
  | { name: 'MemberRemoved'; data: { who: AccountId32; rank: number } }
  /**
   * The member `who` has voted for the `poll` with the given `vote` leading to an updated
   * `tally`.
   **/
  | {
      name: 'Voted';
      data: {
        who: AccountId32;
        poll: number;
        vote: PalletRankedCollectiveVoteRecord;
        tally: PalletRankedCollectiveTally;
      };
    };

export type PalletRankedCollectiveVoteRecord = { tag: 'Aye'; value: number } | { tag: 'Nay'; value: number };

export type PalletRankedCollectiveTally = { bareAyes: number; ayes: number; nays: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletReferendaEvent002 =
  /**
   * A referendum has been submitted.
   **/
  | {
      name: 'Submitted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;
      };
    }
  /**
   * The decision deposit has been placed.
   **/
  | {
      name: 'DecisionDepositPlaced';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * The decision deposit has been refunded.
   **/
  | {
      name: 'DecisionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A deposit has been slashaed.
   **/
  | {
      name: 'DepositSlashed';
      data: {
        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A referendum has moved into the deciding phase.
   **/
  | {
      name: 'DecisionStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;

        /**
         * The current tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  | {
      name: 'ConfirmStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  | {
      name: 'ConfirmAborted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A referendum has ended its confirmation phase and is ready for approval.
   **/
  | {
      name: 'Confirmed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * A referendum has been approved and its proposal has been scheduled.
   **/
  | {
      name: 'Approved';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A proposal has been rejected by referendum.
   **/
  | {
      name: 'Rejected';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * A referendum has been timed out without being decided.
   **/
  | {
      name: 'TimedOut';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * A referendum has been cancelled.
   **/
  | {
      name: 'Cancelled';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * A referendum has been killed.
   **/
  | {
      name: 'Killed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * The submission deposit has been refunded.
   **/
  | {
      name: 'SubmissionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * Metadata for a referendum has been set.
   **/
  | {
      name: 'MetadataSet';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  /**
   * Metadata for a referendum has been cleared.
   **/
  | {
      name: 'MetadataCleared';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletWhitelistEvent =
  | { name: 'CallWhitelisted'; data: { callHash: H256 } }
  | { name: 'WhitelistedCallRemoved'; data: { callHash: H256 } }
  | {
      name: 'WhitelistedCallDispatched';
      data: {
        callHash: H256;
        result: ResultPayload<FrameSupportDispatchPostDispatchInfo, SpRuntimeDispatchErrorWithPostInfo>;
      };
    };

export type FrameSupportDispatchPostDispatchInfo = {
  actualWeight?: SpWeightsWeightV2Weight | undefined;
  paysFee: FrameSupportDispatchPays;
};

export type SpRuntimeDispatchErrorWithPostInfo = {
  postInfo: FrameSupportDispatchPostDispatchInfo;
  error: DispatchError;
};

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeCommonClaimsPalletEvent =
  /**
   * Someone claimed some DOTs.
   **/
  { name: 'Claimed'; data: { who: AccountId32; ethereumAddress: EthereumAddress; amount: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletUtilityEvent =
  /**
   * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
   * well as the error.
   **/
  | { name: 'BatchInterrupted'; data: { index: number; error: DispatchError } }
  /**
   * Batch of dispatches completed fully with no error.
   **/
  | { name: 'BatchCompleted' }
  /**
   * Batch of dispatches completed but has errors.
   **/
  | { name: 'BatchCompletedWithErrors' }
  /**
   * A single item within a Batch of dispatches has completed with no error.
   **/
  | { name: 'ItemCompleted' }
  /**
   * A single item within a Batch of dispatches has completed with error.
   **/
  | { name: 'ItemFailed'; data: { error: DispatchError } }
  /**
   * A call was dispatched.
   **/
  | { name: 'DispatchedAs'; data: { result: ResultPayload<[], DispatchError> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletIdentityEvent =
  /**
   * A name was set or reset (which will remove all judgements).
   **/
  | { name: 'IdentitySet'; data: { who: AccountId32 } }
  /**
   * A name was cleared, and the given balance returned.
   **/
  | { name: 'IdentityCleared'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A name was removed and the given balance slashed.
   **/
  | { name: 'IdentityKilled'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A judgement was asked from a registrar.
   **/
  | { name: 'JudgementRequested'; data: { who: AccountId32; registrarIndex: number } }
  /**
   * A judgement request was retracted.
   **/
  | { name: 'JudgementUnrequested'; data: { who: AccountId32; registrarIndex: number } }
  /**
   * A judgement was given by a registrar.
   **/
  | { name: 'JudgementGiven'; data: { target: AccountId32; registrarIndex: number } }
  /**
   * A registrar was added.
   **/
  | { name: 'RegistrarAdded'; data: { registrarIndex: number } }
  /**
   * A sub-identity was added to an identity and the deposit paid.
   **/
  | { name: 'SubIdentityAdded'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A sub-identity was removed from an identity and the deposit freed.
   **/
  | { name: 'SubIdentityRemoved'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A sub-identity was cleared, and the given deposit repatriated from the
   * main identity account to the sub-identity account.
   **/
  | { name: 'SubIdentityRevoked'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSocietyEvent =
  /**
   * The society is founded by the given identity.
   **/
  | { name: 'Founded'; data: { founder: AccountId32 } }
  /**
   * A membership bid just happened. The given account is the candidate's ID and their offer
   * is the second.
   **/
  | { name: 'Bid'; data: { candidateId: AccountId32; offer: bigint } }
  /**
   * A membership bid just happened by vouching. The given account is the candidate's ID and
   * their offer is the second. The vouching party is the third.
   **/
  | { name: 'Vouch'; data: { candidateId: AccountId32; offer: bigint; vouching: AccountId32 } }
  /**
   * A candidate was dropped (due to an excess of bids in the system).
   **/
  | { name: 'AutoUnbid'; data: { candidate: AccountId32 } }
  /**
   * A candidate was dropped (by their request).
   **/
  | { name: 'Unbid'; data: { candidate: AccountId32 } }
  /**
   * A candidate was dropped (by request of who vouched for them).
   **/
  | { name: 'Unvouch'; data: { candidate: AccountId32 } }
  /**
   * A group of candidates have been inducted. The batch's primary is the first value, the
   * batch in full is the second.
   **/
  | { name: 'Inducted'; data: { primary: AccountId32; candidates: Array<AccountId32> } }
  /**
   * A suspended member has been judged.
   **/
  | { name: 'SuspendedMemberJudgement'; data: { who: AccountId32; judged: boolean } }
  /**
   * A candidate has been suspended
   **/
  | { name: 'CandidateSuspended'; data: { candidate: AccountId32 } }
  /**
   * A member has been suspended
   **/
  | { name: 'MemberSuspended'; data: { member: AccountId32 } }
  /**
   * A member has been challenged
   **/
  | { name: 'Challenged'; data: { member: AccountId32 } }
  /**
   * A vote has been placed
   **/
  | { name: 'Vote'; data: { candidate: AccountId32; voter: AccountId32; vote: boolean } }
  /**
   * A vote has been placed for a defending member
   **/
  | { name: 'DefenderVote'; data: { voter: AccountId32; vote: boolean } }
  /**
   * A new set of \[params\] has been set for the group.
   **/
  | { name: 'NewParams'; data: { params: PalletSocietyGroupParams } }
  /**
   * Society is unfounded.
   **/
  | { name: 'Unfounded'; data: { founder: AccountId32 } }
  /**
   * Some funds were deposited into the society account.
   **/
  | { name: 'Deposit'; data: { value: bigint } }
  /**
   * A \[member\] got elevated to \[rank\].
   **/
  | { name: 'Elevated'; data: { member: AccountId32; rank: number } };

export type PalletSocietyGroupParams = {
  maxMembers: number;
  maxIntake: number;
  maxStrikes: number;
  candidateDeposit: bigint;
};

/**
 * Events type.
 **/
export type PalletRecoveryEvent =
  /**
   * A recovery process has been set up for an account.
   **/
  | { name: 'RecoveryCreated'; data: { account: AccountId32 } }
  /**
   * A recovery process has been initiated for lost account by rescuer account.
   **/
  | { name: 'RecoveryInitiated'; data: { lostAccount: AccountId32; rescuerAccount: AccountId32 } }
  /**
   * A recovery process for lost account by rescuer account has been vouched for by sender.
   **/
  | { name: 'RecoveryVouched'; data: { lostAccount: AccountId32; rescuerAccount: AccountId32; sender: AccountId32 } }
  /**
   * A recovery process for lost account by rescuer account has been closed.
   **/
  | { name: 'RecoveryClosed'; data: { lostAccount: AccountId32; rescuerAccount: AccountId32 } }
  /**
   * Lost account has been successfully recovered by rescuer account.
   **/
  | { name: 'AccountRecovered'; data: { lostAccount: AccountId32; rescuerAccount: AccountId32 } }
  /**
   * A recovery process has been removed for an account.
   **/
  | { name: 'RecoveryRemoved'; data: { lostAccount: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletVestingEvent =
  /**
   * The amount vested has been updated. This could indicate a change in funds available.
   * The balance given is the amount which is left unvested (and thus locked).
   **/
  | { name: 'VestingUpdated'; data: { account: AccountId32; unvested: bigint } }
  /**
   * An \[account\] has become fully vested.
   **/
  | { name: 'VestingCompleted'; data: { account: AccountId32 } };

/**
 * Events type.
 **/
export type PalletSchedulerEvent =
  /**
   * Scheduled some task.
   **/
  | { name: 'Scheduled'; data: { when: number; index: number } }
  /**
   * Canceled some task.
   **/
  | { name: 'Canceled'; data: { when: number; index: number } }
  /**
   * Dispatched some task.
   **/
  | {
      name: 'Dispatched';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined; result: ResultPayload<[], DispatchError> };
    }
  /**
   * The call for the provided hash was not found so the task has been aborted.
   **/
  | { name: 'CallUnavailable'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task was unable to be renewed since the agenda is full at that block.
   **/
  | { name: 'PeriodicFailed'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task can never be executed since it is overweight.
   **/
  | { name: 'PermanentlyOverweight'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletProxyEvent =
  /**
   * A proxy was executed correctly, with the given.
   **/
  | { name: 'ProxyExecuted'; data: { result: ResultPayload<[], DispatchError> } }
  /**
   * A pure account has been created by new proxy with given
   * disambiguation index and proxy type.
   **/
  | {
      name: 'PureCreated';
      data: {
        pure: AccountId32;
        who: AccountId32;
        proxyType: StagingKusamaRuntimeProxyType;
        disambiguationIndex: number;
      };
    }
  /**
   * An announcement was placed to make a call in the future.
   **/
  | { name: 'Announced'; data: { real: AccountId32; proxy: AccountId32; callHash: H256 } }
  /**
   * A proxy was added.
   **/
  | {
      name: 'ProxyAdded';
      data: { delegator: AccountId32; delegatee: AccountId32; proxyType: StagingKusamaRuntimeProxyType; delay: number };
    }
  /**
   * A proxy was removed.
   **/
  | {
      name: 'ProxyRemoved';
      data: { delegator: AccountId32; delegatee: AccountId32; proxyType: StagingKusamaRuntimeProxyType; delay: number };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMultisigEvent =
  /**
   * A new multisig operation has begun.
   **/
  | { name: 'NewMultisig'; data: { approving: AccountId32; multisig: AccountId32; callHash: FixedBytes<32> } }
  /**
   * A multisig operation has been approved by someone.
   **/
  | {
      name: 'MultisigApproval';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been executed.
   **/
  | {
      name: 'MultisigExecuted';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
        result: ResultPayload<[], DispatchError>;
      };
    }
  /**
   * A multisig operation has been cancelled.
   **/
  | {
      name: 'MultisigCancelled';
      data: {
        cancelling: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletPreimageEvent =
  /**
   * A preimage has been noted.
   **/
  | { name: 'Noted'; data: { hash: H256 } }
  /**
   * A preimage has been requested.
   **/
  | { name: 'Requested'; data: { hash: H256 } }
  /**
   * A preimage has ben cleared.
   **/
  | { name: 'Cleared'; data: { hash: H256 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBountiesEvent =
  /**
   * New bounty proposal.
   **/
  | { name: 'BountyProposed'; data: { index: number } }
  /**
   * A bounty proposal was rejected; funds were slashed.
   **/
  | { name: 'BountyRejected'; data: { index: number; bond: bigint } }
  /**
   * A bounty proposal is funded and became active.
   **/
  | { name: 'BountyBecameActive'; data: { index: number } }
  /**
   * A bounty is awarded to a beneficiary.
   **/
  | { name: 'BountyAwarded'; data: { index: number; beneficiary: AccountId32 } }
  /**
   * A bounty is claimed by beneficiary.
   **/
  | { name: 'BountyClaimed'; data: { index: number; payout: bigint; beneficiary: AccountId32 } }
  /**
   * A bounty is cancelled.
   **/
  | { name: 'BountyCanceled'; data: { index: number } }
  /**
   * A bounty expiry is extended.
   **/
  | { name: 'BountyExtended'; data: { index: number } }
  /**
   * A bounty is approved.
   **/
  | { name: 'BountyApproved'; data: { index: number } }
  /**
   * A bounty curator is proposed.
   **/
  | { name: 'CuratorProposed'; data: { bountyId: number; curator: AccountId32 } }
  /**
   * A bounty curator is unassigned.
   **/
  | { name: 'CuratorUnassigned'; data: { bountyId: number } }
  /**
   * A bounty curator is accepted.
   **/
  | { name: 'CuratorAccepted'; data: { bountyId: number; curator: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletChildBountiesEvent =
  /**
   * A child-bounty is added.
   **/
  | { name: 'Added'; data: { index: number; childIndex: number } }
  /**
   * A child-bounty is awarded to a beneficiary.
   **/
  | { name: 'Awarded'; data: { index: number; childIndex: number; beneficiary: AccountId32 } }
  /**
   * A child-bounty is claimed by beneficiary.
   **/
  | { name: 'Claimed'; data: { index: number; childIndex: number; payout: bigint; beneficiary: AccountId32 } }
  /**
   * A child-bounty is cancelled.
   **/
  | { name: 'Canceled'; data: { index: number; childIndex: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletElectionProviderMultiPhaseEvent =
  /**
   * A solution was stored with the given compute.
   *
   * The `origin` indicates the origin of the solution. If `origin` is `Some(AccountId)`,
   * the stored solution was submited in the signed phase by a miner with the `AccountId`.
   * Otherwise, the solution was stored either during the unsigned phase or by
   * `T::ForceOrigin`. The `bool` is `true` when a previous solution was ejected to make
   * room for this one.
   **/
  | {
      name: 'SolutionStored';
      data: {
        compute: PalletElectionProviderMultiPhaseElectionCompute;
        origin?: AccountId32 | undefined;
        prevEjected: boolean;
      };
    }
  /**
   * The election has been finalized, with the given computation and score.
   **/
  | {
      name: 'ElectionFinalized';
      data: { compute: PalletElectionProviderMultiPhaseElectionCompute; score: SpNposElectionsElectionScore };
    }
  /**
   * An election failed.
   *
   * Not much can be said about which computes failed in the process.
   **/
  | { name: 'ElectionFailed' }
  /**
   * An account has been rewarded for their signed submission being finalized.
   **/
  | { name: 'Rewarded'; data: { account: AccountId32; value: bigint } }
  /**
   * An account has been slashed for submitting an invalid signed submission.
   **/
  | { name: 'Slashed'; data: { account: AccountId32; value: bigint } }
  /**
   * There was a phase transition in a given round.
   **/
  | {
      name: 'PhaseTransitioned';
      data: { from: PalletElectionProviderMultiPhasePhase; to: PalletElectionProviderMultiPhasePhase; round: number };
    };

export type PalletElectionProviderMultiPhaseElectionCompute =
  | 'OnChain'
  | 'Signed'
  | 'Unsigned'
  | 'Fallback'
  | 'Emergency';

export type PalletElectionProviderMultiPhasePhase =
  | { tag: 'Off' }
  | { tag: 'Signed' }
  | { tag: 'Unsigned'; value: [boolean, number] }
  | { tag: 'Emergency' };

/**
 * The `Event` enum of this pallet
 **/
export type PalletNisEvent =
  /**
   * A bid was successfully placed.
   **/
  | { name: 'BidPlaced'; data: { who: AccountId32; amount: bigint; duration: number } }
  /**
   * A bid was successfully removed (before being accepted).
   **/
  | { name: 'BidRetracted'; data: { who: AccountId32; amount: bigint; duration: number } }
  /**
   * A bid was dropped from a queue because of another, more substantial, bid was present.
   **/
  | { name: 'BidDropped'; data: { who: AccountId32; amount: bigint; duration: number } }
  /**
   * A bid was accepted. The balance may not be released until expiry.
   **/
  | {
      name: 'Issued';
      data: {
        /**
         * The identity of the receipt.
         **/
        index: number;

        /**
         * The block number at which the receipt may be thawed.
         **/
        expiry: number;

        /**
         * The owner of the receipt.
         **/
        who: AccountId32;

        /**
         * The proportion of the effective total issuance which the receipt represents.
         **/
        proportion: Perquintill;

        /**
         * The amount of funds which were debited from the owner.
         **/
        amount: bigint;
      };
    }
  /**
   * An receipt has been (at least partially) thawed.
   **/
  | {
      name: 'Thawed';
      data: {
        /**
         * The identity of the receipt.
         **/
        index: number;

        /**
         * The owner.
         **/
        who: AccountId32;

        /**
         * The proportion of the effective total issuance by which the owner was debited.
         **/
        proportion: Perquintill;

        /**
         * The amount by which the owner was credited.
         **/
        amount: bigint;

        /**
         * If `true` then the receipt is done.
         **/
        dropped: boolean;
      };
    }
  /**
   * An automatic funding of the deficit was made.
   **/
  | { name: 'Funded'; data: { deficit: bigint } }
  /**
   * A receipt was transfered.
   **/
  | { name: 'Transferred'; data: { from: AccountId32; to: AccountId32; index: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBagsListEvent =
  /**
   * Moved an account from one bag to another.
   **/
  | { name: 'Rebagged'; data: { who: AccountId32; from: bigint; to: bigint } }
  /**
   * Updated the score of some account to the given amount.
   **/
  | { name: 'ScoreUpdated'; data: { who: AccountId32; newScore: bigint } };

/**
 * Events of this pallet.
 **/
export type PalletNominationPoolsEvent =
  /**
   * A pool has been created.
   **/
  | { name: 'Created'; data: { depositor: AccountId32; poolId: number } }
  /**
   * A member has became bonded in a pool.
   **/
  | { name: 'Bonded'; data: { member: AccountId32; poolId: number; bonded: bigint; joined: boolean } }
  /**
   * A payout has been made to a member.
   **/
  | { name: 'PaidOut'; data: { member: AccountId32; poolId: number; payout: bigint } }
  /**
   * A member has unbonded from their pool.
   *
   * - `balance` is the corresponding balance of the number of points that has been
   * requested to be unbonded (the argument of the `unbond` transaction) from the bonded
   * pool.
   * - `points` is the number of points that are issued as a result of `balance` being
   * dissolved into the corresponding unbonding pool.
   * - `era` is the era in which the balance will be unbonded.
   * In the absence of slashing, these values will match. In the presence of slashing, the
   * number of points that are issued in the unbonding pool will be less than the amount
   * requested to be unbonded.
   **/
  | { name: 'Unbonded'; data: { member: AccountId32; poolId: number; balance: bigint; points: bigint; era: number } }
  /**
   * A member has withdrawn from their pool.
   *
   * The given number of `points` have been dissolved in return of `balance`.
   *
   * Similar to `Unbonded` event, in the absence of slashing, the ratio of point to balance
   * will be 1.
   **/
  | { name: 'Withdrawn'; data: { member: AccountId32; poolId: number; balance: bigint; points: bigint } }
  /**
   * A pool has been destroyed.
   **/
  | { name: 'Destroyed'; data: { poolId: number } }
  /**
   * The state of a pool has changed
   **/
  | { name: 'StateChanged'; data: { poolId: number; newState: PalletNominationPoolsPoolState } }
  /**
   * A member has been removed from a pool.
   *
   * The removal can be voluntary (withdrawn all unbonded funds) or involuntary (kicked).
   **/
  | { name: 'MemberRemoved'; data: { poolId: number; member: AccountId32 } }
  /**
   * The roles of a pool have been updated to the given new roles. Note that the depositor
   * can never change.
   **/
  | {
      name: 'RolesUpdated';
      data: { root?: AccountId32 | undefined; bouncer?: AccountId32 | undefined; nominator?: AccountId32 | undefined };
    }
  /**
   * The active balance of pool `pool_id` has been slashed to `balance`.
   **/
  | { name: 'PoolSlashed'; data: { poolId: number; balance: bigint } }
  /**
   * The unbond pool at `era` of pool `pool_id` has been slashed to `balance`.
   **/
  | { name: 'UnbondingPoolSlashed'; data: { poolId: number; era: number; balance: bigint } }
  /**
   * A pool's commission setting has been changed.
   **/
  | { name: 'PoolCommissionUpdated'; data: { poolId: number; current?: [Perbill, AccountId32] | undefined } }
  /**
   * A pool's maximum commission setting has been changed.
   **/
  | { name: 'PoolMaxCommissionUpdated'; data: { poolId: number; maxCommission: Perbill } }
  /**
   * A pool's commission `change_rate` has been changed.
   **/
  | {
      name: 'PoolCommissionChangeRateUpdated';
      data: { poolId: number; changeRate: PalletNominationPoolsCommissionChangeRate };
    }
  /**
   * Pool commission has been claimed.
   **/
  | { name: 'PoolCommissionClaimed'; data: { poolId: number; commission: bigint } }
  /**
   * Topped up deficit in frozen ED of the reward pool.
   **/
  | { name: 'MinBalanceDeficitAdjusted'; data: { poolId: number; amount: bigint } }
  /**
   * Claimed excess frozen ED of af the reward pool.
   **/
  | { name: 'MinBalanceExcessAdjusted'; data: { poolId: number; amount: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletFastUnstakeEvent =
  /**
   * A staker was unstaked.
   **/
  | { name: 'Unstaked'; data: { stash: AccountId32; result: ResultPayload<[], DispatchError> } }
  /**
   * A staker was slashed for requesting fast-unstake whilst being exposed.
   **/
  | { name: 'Slashed'; data: { stash: AccountId32; amount: bigint } }
  /**
   * A batch was partially checked for the given eras, but the process did not finish.
   **/
  | { name: 'BatchChecked'; data: { eras: Array<number> } }
  /**
   * A batch of a given size was terminated.
   *
   * This is always follows by a number of `Unstaked` or `Slashed` events, marking the end
   * of the batch. A new batch will be created upon next block.
   **/
  | { name: 'BatchFinished'; data: { size: number } }
  /**
   * An internal error happened. Operations will be paused now.
   **/
  | { name: 'InternalError' };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeParachainsInclusionPalletEvent =
  /**
   * A candidate was backed. `[candidate, head_data]`
   **/
  | {
      name: 'CandidateBacked';
      data: [
        PolkadotPrimitivesV6CandidateReceipt,
        PolkadotParachainPrimitivesPrimitivesHeadData,
        PolkadotPrimitivesV6CoreIndex,
        PolkadotPrimitivesV6GroupIndex,
      ];
    }
  /**
   * A candidate was included. `[candidate, head_data]`
   **/
  | {
      name: 'CandidateIncluded';
      data: [
        PolkadotPrimitivesV6CandidateReceipt,
        PolkadotParachainPrimitivesPrimitivesHeadData,
        PolkadotPrimitivesV6CoreIndex,
        PolkadotPrimitivesV6GroupIndex,
      ];
    }
  /**
   * A candidate timed out. `[candidate, head_data]`
   **/
  | {
      name: 'CandidateTimedOut';
      data: [
        PolkadotPrimitivesV6CandidateReceipt,
        PolkadotParachainPrimitivesPrimitivesHeadData,
        PolkadotPrimitivesV6CoreIndex,
      ];
    }
  /**
   * Some upward messages have been received and will be processed.
   **/
  | { name: 'UpwardMessagesReceived'; data: { from: PolkadotParachainPrimitivesPrimitivesId; count: number } };

export type PolkadotPrimitivesV6CandidateReceipt = {
  descriptor: PolkadotPrimitivesV6CandidateDescriptor;
  commitmentsHash: H256;
};

export type PolkadotPrimitivesV6CoreIndex = number;

export type PolkadotPrimitivesV6GroupIndex = number;

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeParachainsParasPalletEvent =
  /**
   * Current code has been updated for a Para. `para_id`
   **/
  | { name: 'CurrentCodeUpdated'; data: PolkadotParachainPrimitivesPrimitivesId }
  /**
   * Current head has been updated for a Para. `para_id`
   **/
  | { name: 'CurrentHeadUpdated'; data: PolkadotParachainPrimitivesPrimitivesId }
  /**
   * A code upgrade has been scheduled for a Para. `para_id`
   **/
  | { name: 'CodeUpgradeScheduled'; data: PolkadotParachainPrimitivesPrimitivesId }
  /**
   * A new head has been noted for a Para. `para_id`
   **/
  | { name: 'NewHeadNoted'; data: PolkadotParachainPrimitivesPrimitivesId }
  /**
   * A para has been queued to execute pending actions. `para_id`
   **/
  | { name: 'ActionQueued'; data: [PolkadotParachainPrimitivesPrimitivesId, number] }
  /**
   * The given para either initiated or subscribed to a PVF check for the given validation
   * code. `code_hash` `para_id`
   **/
  | {
      name: 'PvfCheckStarted';
      data: [PolkadotParachainPrimitivesPrimitivesValidationCodeHash, PolkadotParachainPrimitivesPrimitivesId];
    }
  /**
   * The given validation code was accepted by the PVF pre-checking vote.
   * `code_hash` `para_id`
   **/
  | {
      name: 'PvfCheckAccepted';
      data: [PolkadotParachainPrimitivesPrimitivesValidationCodeHash, PolkadotParachainPrimitivesPrimitivesId];
    }
  /**
   * The given validation code was rejected by the PVF pre-checking vote.
   * `code_hash` `para_id`
   **/
  | {
      name: 'PvfCheckRejected';
      data: [PolkadotParachainPrimitivesPrimitivesValidationCodeHash, PolkadotParachainPrimitivesPrimitivesId];
    };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeParachainsHrmpPalletEvent =
  /**
   * Open HRMP channel requested.
   **/
  | {
      name: 'OpenChannelRequested';
      data: {
        sender: PolkadotParachainPrimitivesPrimitivesId;
        recipient: PolkadotParachainPrimitivesPrimitivesId;
        proposedMaxCapacity: number;
        proposedMaxMessageSize: number;
      };
    }
  /**
   * An HRMP channel request sent by the receiver was canceled by either party.
   **/
  | {
      name: 'OpenChannelCanceled';
      data: {
        byParachain: PolkadotParachainPrimitivesPrimitivesId;
        channelId: PolkadotParachainPrimitivesPrimitivesHrmpChannelId;
      };
    }
  /**
   * Open HRMP channel accepted.
   **/
  | {
      name: 'OpenChannelAccepted';
      data: { sender: PolkadotParachainPrimitivesPrimitivesId; recipient: PolkadotParachainPrimitivesPrimitivesId };
    }
  /**
   * HRMP channel closed.
   **/
  | {
      name: 'ChannelClosed';
      data: {
        byParachain: PolkadotParachainPrimitivesPrimitivesId;
        channelId: PolkadotParachainPrimitivesPrimitivesHrmpChannelId;
      };
    }
  /**
   * An HRMP channel was opened via Root origin.
   **/
  | {
      name: 'HrmpChannelForceOpened';
      data: {
        sender: PolkadotParachainPrimitivesPrimitivesId;
        recipient: PolkadotParachainPrimitivesPrimitivesId;
        proposedMaxCapacity: number;
        proposedMaxMessageSize: number;
      };
    }
  /**
   * An HRMP channel was opened between two system chains.
   **/
  | {
      name: 'HrmpSystemChannelOpened';
      data: {
        sender: PolkadotParachainPrimitivesPrimitivesId;
        recipient: PolkadotParachainPrimitivesPrimitivesId;
        proposedMaxCapacity: number;
        proposedMaxMessageSize: number;
      };
    }
  /**
   * An HRMP channel's deposits were updated.
   **/
  | {
      name: 'OpenChannelDepositsUpdated';
      data: { sender: PolkadotParachainPrimitivesPrimitivesId; recipient: PolkadotParachainPrimitivesPrimitivesId };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeParachainsDisputesPalletEvent =
  /**
   * A dispute has been initiated. \[candidate hash, dispute location\]
   **/
  | {
      name: 'DisputeInitiated';
      data: [PolkadotCorePrimitivesCandidateHash, PolkadotRuntimeParachainsDisputesDisputeLocation];
    }
  /**
   * A dispute has concluded for or against a candidate.
   * `\[para id, candidate hash, dispute result\]`
   **/
  | {
      name: 'DisputeConcluded';
      data: [PolkadotCorePrimitivesCandidateHash, PolkadotRuntimeParachainsDisputesDisputeResult];
    }
  /**
   * A dispute has concluded with supermajority against a candidate.
   * Block authors should no longer build on top of this head and should
   * instead revert the block at the given height. This should be the
   * number of the child of the last known valid block in the chain.
   **/
  | { name: 'Revert'; data: number };

export type PolkadotRuntimeParachainsDisputesDisputeLocation = 'Local' | 'Remote';

export type PolkadotRuntimeParachainsDisputesDisputeResult = 'Valid' | 'Invalid';

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeCommonParasRegistrarPalletEvent =
  | { name: 'Registered'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId; manager: AccountId32 } }
  | { name: 'Deregistered'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId } }
  | { name: 'Reserved'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId; who: AccountId32 } }
  | {
      name: 'Swapped';
      data: { paraId: PolkadotParachainPrimitivesPrimitivesId; otherId: PolkadotParachainPrimitivesPrimitivesId };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeCommonSlotsPalletEvent =
  /**
   * A new `[lease_period]` is beginning.
   **/
  | { name: 'NewLeasePeriod'; data: { leasePeriod: number } }
  /**
   * A para has won the right to a continuous set of lease periods as a parachain.
   * First balance is any extra amount reserved on top of the para's existing deposit.
   * Second balance is the total amount reserved.
   **/
  | {
      name: 'Leased';
      data: {
        paraId: PolkadotParachainPrimitivesPrimitivesId;
        leaser: AccountId32;
        periodBegin: number;
        periodCount: number;
        extraReserved: bigint;
        totalAmount: bigint;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeCommonAuctionsPalletEvent =
  /**
   * An auction started. Provides its index and the block number where it will begin to
   * close and the first lease period of the quadruplet that is auctioned.
   **/
  | { name: 'AuctionStarted'; data: { auctionIndex: number; leasePeriod: number; ending: number } }
  /**
   * An auction ended. All funds become unreserved.
   **/
  | { name: 'AuctionClosed'; data: { auctionIndex: number } }
  /**
   * Funds were reserved for a winning bid. First balance is the extra amount reserved.
   * Second is the total.
   **/
  | { name: 'Reserved'; data: { bidder: AccountId32; extraReserved: bigint; totalAmount: bigint } }
  /**
   * Funds were unreserved since bidder is no longer active. `[bidder, amount]`
   **/
  | { name: 'Unreserved'; data: { bidder: AccountId32; amount: bigint } }
  /**
   * Someone attempted to lease the same slot twice for a parachain. The amount is held in
   * reserve but no parachain slot has been leased.
   **/
  | {
      name: 'ReserveConfiscated';
      data: { paraId: PolkadotParachainPrimitivesPrimitivesId; leaser: AccountId32; amount: bigint };
    }
  /**
   * A new bid has been accepted as the current winner.
   **/
  | {
      name: 'BidAccepted';
      data: {
        bidder: AccountId32;
        paraId: PolkadotParachainPrimitivesPrimitivesId;
        amount: bigint;
        firstSlot: number;
        lastSlot: number;
      };
    }
  /**
   * The winning offset was chosen for an auction. This will map into the `Winning` storage
   * map.
   **/
  | { name: 'WinningOffset'; data: { auctionIndex: number; blockNumber: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeCommonCrowdloanPalletEvent =
  /**
   * Create a new crowdloaning campaign.
   **/
  | { name: 'Created'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Contributed to a crowd sale.
   **/
  | {
      name: 'Contributed';
      data: { who: AccountId32; fundIndex: PolkadotParachainPrimitivesPrimitivesId; amount: bigint };
    }
  /**
   * Withdrew full balance of a contributor.
   **/
  | { name: 'Withdrew'; data: { who: AccountId32; fundIndex: PolkadotParachainPrimitivesPrimitivesId; amount: bigint } }
  /**
   * The loans in a fund have been partially dissolved, i.e. there are some left
   * over child keys that still need to be killed.
   **/
  | { name: 'PartiallyRefunded'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * All loans in a fund have been refunded.
   **/
  | { name: 'AllRefunded'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Fund is dissolved.
   **/
  | { name: 'Dissolved'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * The result of trying to submit a new bid to the Slots pallet.
   **/
  | {
      name: 'HandleBidResult';
      data: { paraId: PolkadotParachainPrimitivesPrimitivesId; result: ResultPayload<[], DispatchError> };
    }
  /**
   * The configuration to a crowdloan has been edited.
   **/
  | { name: 'Edited'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * A memo has been updated.
   **/
  | { name: 'MemoUpdated'; data: { who: AccountId32; paraId: PolkadotParachainPrimitivesPrimitivesId; memo: Bytes } }
  /**
   * A parachain has been moved to `NewRaise`
   **/
  | { name: 'AddedToNewRaise'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId } };

/**
 * Inner events of this pallet.
 **/
export type PalletStateTrieMigrationEvent =
  /**
   * Given number of `(top, child)` keys were migrated respectively, with the given
   * `compute`.
   **/
  | { name: 'Migrated'; data: { top: number; child: number; compute: PalletStateTrieMigrationMigrationCompute } }
  /**
   * Some account got slashed by the given amount.
   **/
  | { name: 'Slashed'; data: { who: AccountId32; amount: bigint } }
  /**
   * The auto migration task finished.
   **/
  | { name: 'AutoMigrationFinished' }
  /**
   * Migration got halted due to an error or miss-configuration.
   **/
  | { name: 'Halted'; data: { error: PalletStateTrieMigrationError } };

export type PalletStateTrieMigrationMigrationCompute = 'Signed' | 'Auto';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletStateTrieMigrationError =
  /**
   * Max signed limits not respected.
   **/
  | 'MaxSignedLimits'
  /**
   * A key was longer than the configured maximum.
   *
   * This means that the migration halted at the current [`Progress`] and
   * can be resumed with a larger [`crate::Config::MaxKeyLen`] value.
   * Retrying with the same [`crate::Config::MaxKeyLen`] value will not work.
   * The value should only be increased to avoid a storage migration for the currently
   * stored [`crate::Progress::LastKey`].
   **/
  | 'KeyTooLong'
  /**
   * submitter does not have enough funds.
   **/
  | 'NotEnoughFunds'
  /**
   * Bad witness data provided.
   **/
  | 'BadWitness'
  /**
   * Signed migration is not allowed because the maximum limit is not set yet.
   **/
  | 'SignedMigrationNotAllowed'
  /**
   * Bad child root provided.
   **/
  | 'BadChildRoot';

/**
 * The `Event` enum of this pallet
 **/
export type PalletXcmEvent =
  /**
   * Execution of an XCM message was attempted.
   **/
  | { name: 'Attempted'; data: { outcome: XcmV3TraitsOutcome } }
  /**
   * A XCM message was sent.
   **/
  | {
      name: 'Sent';
      data: {
        origin: StagingXcmV3MultilocationMultiLocation;
        destination: StagingXcmV3MultilocationMultiLocation;
        message: XcmV3Xcm;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * Query response received which does not match a registered query. This may be because a
   * matching query was never registered, it may be because it is a duplicate response, or
   * because the query timed out.
   **/
  | { name: 'UnexpectedResponse'; data: { origin: StagingXcmV3MultilocationMultiLocation; queryId: bigint } }
  /**
   * Query response has been received and is ready for taking with `take_response`. There is
   * no registered notification call.
   **/
  | { name: 'ResponseReady'; data: { queryId: bigint; response: XcmV3Response } }
  /**
   * Query response has been received and query is removed. The registered notification has
   * been dispatched and executed successfully.
   **/
  | { name: 'Notified'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Query response has been received and query is removed. The registered notification
   * could not be dispatched because the dispatch weight is greater than the maximum weight
   * originally budgeted by this runtime for the query result.
   **/
  | {
      name: 'NotifyOverweight';
      data: {
        queryId: bigint;
        palletIndex: number;
        callIndex: number;
        actualWeight: SpWeightsWeightV2Weight;
        maxBudgetedWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Query response has been received and query is removed. There was a general error with
   * dispatching the notification call.
   **/
  | { name: 'NotifyDispatchError'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Query response has been received and query is removed. The dispatch was unable to be
   * decoded into a `Call`; this might be due to dispatch function having a signature which
   * is not `(origin, QueryId, Response)`.
   **/
  | { name: 'NotifyDecodeFailed'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Expected query response has been received but the origin location of the response does
   * not match that expected. The query remains registered for a later, valid, response to
   * be received and acted upon.
   **/
  | {
      name: 'InvalidResponder';
      data: {
        origin: StagingXcmV3MultilocationMultiLocation;
        queryId: bigint;
        expectedLocation?: StagingXcmV3MultilocationMultiLocation | undefined;
      };
    }
  /**
   * Expected query response has been received but the expected origin location placed in
   * storage by this runtime previously cannot be decoded. The query remains registered.
   *
   * This is unexpected (since a location placed in storage in a previously executing
   * runtime should be readable prior to query timeout) and dangerous since the possibly
   * valid response will be dropped. Manual governance intervention is probably going to be
   * needed.
   **/
  | { name: 'InvalidResponderVersion'; data: { origin: StagingXcmV3MultilocationMultiLocation; queryId: bigint } }
  /**
   * Received query response has been read and removed.
   **/
  | { name: 'ResponseTaken'; data: { queryId: bigint } }
  /**
   * Some assets have been placed in an asset trap.
   **/
  | {
      name: 'AssetsTrapped';
      data: { hash: H256; origin: StagingXcmV3MultilocationMultiLocation; assets: XcmVersionedMultiAssets };
    }
  /**
   * An XCM version change notification message has been attempted to be sent.
   *
   * The cost of sending it (borne by the chain) is included.
   **/
  | {
      name: 'VersionChangeNotified';
      data: {
        destination: StagingXcmV3MultilocationMultiLocation;
        result: number;
        cost: XcmV3MultiassetMultiAssets;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * The supported version of a location has been changed. This might be through an
   * automatic notification or a manual intervention.
   **/
  | { name: 'SupportedVersionChanged'; data: { location: StagingXcmV3MultilocationMultiLocation; version: number } }
  /**
   * A given location which had a version change subscription was dropped owing to an error
   * sending the notification to it.
   **/
  | {
      name: 'NotifyTargetSendFail';
      data: { location: StagingXcmV3MultilocationMultiLocation; queryId: bigint; error: XcmV3TraitsError };
    }
  /**
   * A given location which had a version change subscription was dropped owing to an error
   * migrating the location to our new XCM format.
   **/
  | { name: 'NotifyTargetMigrationFail'; data: { location: XcmVersionedMultiLocation; queryId: bigint } }
  /**
   * Expected query response has been received but the expected querier location placed in
   * storage by this runtime previously cannot be decoded. The query remains registered.
   *
   * This is unexpected (since a location placed in storage in a previously executing
   * runtime should be readable prior to query timeout) and dangerous since the possibly
   * valid response will be dropped. Manual governance intervention is probably going to be
   * needed.
   **/
  | { name: 'InvalidQuerierVersion'; data: { origin: StagingXcmV3MultilocationMultiLocation; queryId: bigint } }
  /**
   * Expected query response has been received but the querier location of the response does
   * not match the expected. The query remains registered for a later, valid, response to
   * be received and acted upon.
   **/
  | {
      name: 'InvalidQuerier';
      data: {
        origin: StagingXcmV3MultilocationMultiLocation;
        queryId: bigint;
        expectedQuerier: StagingXcmV3MultilocationMultiLocation;
        maybeActualQuerier?: StagingXcmV3MultilocationMultiLocation | undefined;
      };
    }
  /**
   * A remote has requested XCM version change notification from us and we have honored it.
   * A version information message is sent to them and its cost is included.
   **/
  | {
      name: 'VersionNotifyStarted';
      data: {
        destination: StagingXcmV3MultilocationMultiLocation;
        cost: XcmV3MultiassetMultiAssets;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * We have requested that a remote chain send us XCM version change notifications.
   **/
  | {
      name: 'VersionNotifyRequested';
      data: {
        destination: StagingXcmV3MultilocationMultiLocation;
        cost: XcmV3MultiassetMultiAssets;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * We have requested that a remote chain stops sending us XCM version change
   * notifications.
   **/
  | {
      name: 'VersionNotifyUnrequested';
      data: {
        destination: StagingXcmV3MultilocationMultiLocation;
        cost: XcmV3MultiassetMultiAssets;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * Fees were paid from a location for an operation (often for using `SendXcm`).
   **/
  | { name: 'FeesPaid'; data: { paying: StagingXcmV3MultilocationMultiLocation; fees: XcmV3MultiassetMultiAssets } }
  /**
   * Some assets have been claimed from an asset trap
   **/
  | {
      name: 'AssetsClaimed';
      data: { hash: H256; origin: StagingXcmV3MultilocationMultiLocation; assets: XcmVersionedMultiAssets };
    };

export type XcmV3TraitsOutcome =
  | { tag: 'Complete'; value: SpWeightsWeightV2Weight }
  | { tag: 'Incomplete'; value: [SpWeightsWeightV2Weight, XcmV3TraitsError] }
  | { tag: 'Error'; value: XcmV3TraitsError };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMessageQueueEvent =
  /**
   * Message discarded due to an error in the `MessageProcessor` (usually a format error).
   **/
  | {
      name: 'ProcessingFailed';
      data: {
        id: FixedBytes<32>;
        origin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin;
        error: FrameSupportMessagesProcessMessageError;
      };
    }
  /**
   * Message is processed.
   **/
  | {
      name: 'Processed';
      data: {
        id: FixedBytes<32>;
        origin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin;
        weightUsed: SpWeightsWeightV2Weight;
        success: boolean;
      };
    }
  /**
   * Message placed in overweight queue.
   **/
  | {
      name: 'OverweightEnqueued';
      data: {
        id: FixedBytes<32>;
        origin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin;
        pageIndex: number;
        messageIndex: number;
      };
    }
  /**
   * This page was reaped.
   **/
  | { name: 'PageReaped'; data: { origin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin; index: number } };

export type FrameSupportMessagesProcessMessageError =
  | { tag: 'BadFormat' }
  | { tag: 'Corrupt' }
  | { tag: 'Unsupported' }
  | { tag: 'Overweight'; value: SpWeightsWeightV2Weight }
  | { tag: 'Yield' };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetRateEvent =
  | {
      name: 'AssetRateCreated';
      data: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset; rate: FixedU128 };
    }
  | { name: 'AssetRateRemoved'; data: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset } }
  | {
      name: 'AssetRateUpdated';
      data: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset; old: FixedU128; new: FixedU128 };
    };

export type FrameSystemPhase =
  | { tag: 'ApplyExtrinsic'; value: number }
  | { tag: 'Finalization' }
  | { tag: 'Initialization' };

export type FrameSystemLastRuntimeUpgradeInfo = { specVersion: number; specName: string };

export type FrameSystemLimitsBlockWeights = {
  baseBlock: SpWeightsWeightV2Weight;
  maxBlock: SpWeightsWeightV2Weight;
  perClass: FrameSupportDispatchPerDispatchClassWeightsPerClass;
};

export type FrameSupportDispatchPerDispatchClassWeightsPerClass = {
  normal: FrameSystemLimitsWeightsPerClass;
  operational: FrameSystemLimitsWeightsPerClass;
  mandatory: FrameSystemLimitsWeightsPerClass;
};

export type FrameSystemLimitsWeightsPerClass = {
  baseExtrinsic: SpWeightsWeightV2Weight;
  maxExtrinsic?: SpWeightsWeightV2Weight | undefined;
  maxTotal?: SpWeightsWeightV2Weight | undefined;
  reserved?: SpWeightsWeightV2Weight | undefined;
};

export type FrameSystemLimitsBlockLength = { max: FrameSupportDispatchPerDispatchClassU32 };

export type FrameSupportDispatchPerDispatchClassU32 = { normal: number; operational: number; mandatory: number };

export type SpWeightsRuntimeDbWeight = { read: bigint; write: bigint };

export type SpVersionRuntimeVersion = {
  specName: string;
  implName: string;
  authoringVersion: number;
  specVersion: number;
  implVersion: number;
  apis: Array<[FixedBytes<8>, number]>;
  transactionVersion: number;
  stateVersion: number;
};

/**
 * Error for the System pallet
 **/
export type FrameSystemError =
  /**
   * The name of specification does not match between the current runtime
   * and the new runtime.
   **/
  | 'InvalidSpecName'
  /**
   * The specification version is not allowed to decrease between the current runtime
   * and the new runtime.
   **/
  | 'SpecVersionNeedsToIncrease'
  /**
   * Failed to extract the runtime version from the new runtime.
   *
   * Either calling `Core_version` or decoding `RuntimeVersion` failed.
   **/
  | 'FailedToExtractRuntimeVersion'
  /**
   * Suicide called when the account has non-default composite data.
   **/
  | 'NonDefaultComposite'
  /**
   * There is a non-zero reference count preventing the account from being purged.
   **/
  | 'NonZeroRefCount'
  /**
   * The origin filter prevent the call to be dispatched.
   **/
  | 'CallFiltered';

export type SpConsensusBabeDigestsPreDigest =
  | { tag: 'Primary'; value: SpConsensusBabeDigestsPrimaryPreDigest }
  | { tag: 'SecondaryPlain'; value: SpConsensusBabeDigestsSecondaryPlainPreDigest }
  | { tag: 'SecondaryVRF'; value: SpConsensusBabeDigestsSecondaryVRFPreDigest };

export type SpConsensusBabeDigestsPrimaryPreDigest = {
  authorityIndex: number;
  slot: SpConsensusSlotsSlot;
  vrfSignature: SpCoreSr25519VrfVrfSignature;
};

export type SpCoreSr25519VrfVrfSignature = { output: FixedBytes<32>; proof: FixedBytes<64> };

export type SpConsensusBabeDigestsSecondaryPlainPreDigest = { authorityIndex: number; slot: SpConsensusSlotsSlot };

export type SpConsensusBabeDigestsSecondaryVRFPreDigest = {
  authorityIndex: number;
  slot: SpConsensusSlotsSlot;
  vrfSignature: SpCoreSr25519VrfVrfSignature;
};

export type SpConsensusBabeBabeEpochConfiguration = { c: [bigint, bigint]; allowedSlots: SpConsensusBabeAllowedSlots };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBabeError =
  /**
   * An equivocation proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidEquivocationProof'
  /**
   * A key ownership proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidKeyOwnershipProof'
  /**
   * A given equivocation report is valid but already previously reported.
   **/
  | 'DuplicateOffenceReport'
  /**
   * Submitted configuration is invalid.
   **/
  | 'InvalidConfiguration';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIndicesError =
  /**
   * The index was not already assigned.
   **/
  | 'NotAssigned'
  /**
   * The index is assigned to another account.
   **/
  | 'NotOwner'
  /**
   * The index was not available.
   **/
  | 'InUse'
  /**
   * The source and destination accounts are identical.
   **/
  | 'NotTransfer'
  /**
   * The index is permanent and may not be freed/changed.
   **/
  | 'Permanent';

export type PalletBalancesBalanceLock = { id: FixedBytes<8>; amount: bigint; reasons: PalletBalancesReasons };

export type PalletBalancesReasons = 'Fee' | 'Misc' | 'All';

export type PalletBalancesReserveData = { id: FixedBytes<8>; amount: bigint };

export type PalletBalancesIdAmount = { id: StagingKusamaRuntimeRuntimeHoldReason; amount: bigint };

export type StagingKusamaRuntimeRuntimeHoldReason =
  | { tag: 'Preimage'; value: PalletPreimageHoldReason }
  | { tag: 'Nis'; value: PalletNisHoldReason };

export type PalletPreimageHoldReason = 'Preimage';

export type PalletNisHoldReason = 'NftReceipt';

export type PalletBalancesIdAmountRuntimeFreezeReason = { id: StagingKusamaRuntimeRuntimeFreezeReason; amount: bigint };

export type StagingKusamaRuntimeRuntimeFreezeReason = {
  tag: 'NominationPools';
  value: PalletNominationPoolsFreezeReason;
};

export type PalletNominationPoolsFreezeReason = 'PoolMinBalance';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBalancesError =
  /**
   * Vesting balance too high to send value.
   **/
  | 'VestingBalance'
  /**
   * Account liquidity restrictions prevent withdrawal.
   **/
  | 'LiquidityRestrictions'
  /**
   * Balance too low to send value.
   **/
  | 'InsufficientBalance'
  /**
   * Value too low to create account due to existential deposit.
   **/
  | 'ExistentialDeposit'
  /**
   * Transfer/payment would kill account.
   **/
  | 'Expendability'
  /**
   * A vesting schedule already exists for this account.
   **/
  | 'ExistingVestingSchedule'
  /**
   * Beneficiary account must pre-exist.
   **/
  | 'DeadAccount'
  /**
   * Number of named reserves exceed `MaxReserves`.
   **/
  | 'TooManyReserves'
  /**
   * Number of holds exceed `MaxHolds`.
   **/
  | 'TooManyHolds'
  /**
   * Number of freezes exceed `MaxFreezes`.
   **/
  | 'TooManyFreezes';

export type PalletTransactionPaymentReleases = 'V1Ancient' | 'V2';

export type PalletStakingStakingLedger = {
  stash: AccountId32;
  total: bigint;
  active: bigint;
  unlocking: Array<PalletStakingUnlockChunk>;
  claimedRewards: Array<number>;
};

export type PalletStakingUnlockChunk = { value: bigint; era: number };

export type PalletStakingNominations = { targets: Array<AccountId32>; submittedIn: number; suppressed: boolean };

export type PalletStakingActiveEraInfo = { index: number; start?: bigint | undefined };

export type PalletStakingEraRewardPoints = { total: number; individual: Array<[AccountId32, number]> };

export type PalletStakingUnappliedSlash = {
  validator: AccountId32;
  own: bigint;
  others: Array<[AccountId32, bigint]>;
  reporters: Array<AccountId32>;
  payout: bigint;
};

export type PalletStakingSlashingSlashingSpans = {
  spanIndex: number;
  lastStart: number;
  lastNonzeroSlash: number;
  prior: Array<number>;
};

export type PalletStakingSlashingSpanRecord = { slashed: bigint; paidOut: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletStakingPalletError =
  /**
   * Not a controller account.
   **/
  | 'NotController'
  /**
   * Not a stash account.
   **/
  | 'NotStash'
  /**
   * Stash is already bonded.
   **/
  | 'AlreadyBonded'
  /**
   * Controller is already paired.
   **/
  | 'AlreadyPaired'
  /**
   * Targets cannot be empty.
   **/
  | 'EmptyTargets'
  /**
   * Duplicate index.
   **/
  | 'DuplicateIndex'
  /**
   * Slash record index out of bounds.
   **/
  | 'InvalidSlashIndex'
  /**
   * Cannot have a validator or nominator role, with value less than the minimum defined by
   * governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
   * intention, `chill` first to remove one's role as validator/nominator.
   **/
  | 'InsufficientBond'
  /**
   * Can not schedule more unlock chunks.
   **/
  | 'NoMoreChunks'
  /**
   * Can not rebond without unlocking chunks.
   **/
  | 'NoUnlockChunk'
  /**
   * Attempting to target a stash that still has funds.
   **/
  | 'FundedTarget'
  /**
   * Invalid era to reward.
   **/
  | 'InvalidEraToReward'
  /**
   * Invalid number of nominations.
   **/
  | 'InvalidNumberOfNominations'
  /**
   * Items are not sorted and unique.
   **/
  | 'NotSortedAndUnique'
  /**
   * Rewards for this era have already been claimed for this validator.
   **/
  | 'AlreadyClaimed'
  /**
   * Incorrect previous history depth input provided.
   **/
  | 'IncorrectHistoryDepth'
  /**
   * Incorrect number of slashing spans provided.
   **/
  | 'IncorrectSlashingSpans'
  /**
   * Internal state has become somehow corrupted and the operation cannot continue.
   **/
  | 'BadState'
  /**
   * Too many nomination targets supplied.
   **/
  | 'TooManyTargets'
  /**
   * A nomination target was supplied that was blocked or otherwise not a validator.
   **/
  | 'BadTarget'
  /**
   * The user has enough bond and thus cannot be chilled forcefully by an external person.
   **/
  | 'CannotChillOther'
  /**
   * There are too many nominators in the system. Governance needs to adjust the staking
   * settings to keep things safe for the runtime.
   **/
  | 'TooManyNominators'
  /**
   * There are too many validator candidates in the system. Governance needs to adjust the
   * staking settings to keep things safe for the runtime.
   **/
  | 'TooManyValidators'
  /**
   * Commission is too low. Must be at least `MinCommission`.
   **/
  | 'CommissionTooLow'
  /**
   * Some bound is not met.
   **/
  | 'BoundNotMet';

export type SpStakingOffenceOffenceDetails = {
  offender: [AccountId32, PalletStakingExposure];
  reporters: Array<AccountId32>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBeefyError =
  /**
   * A key ownership proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidKeyOwnershipProof'
  /**
   * An equivocation proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidEquivocationProof'
  /**
   * A given equivocation report is valid but already previously reported.
   **/
  | 'DuplicateOffenceReport'
  /**
   * Submitted configuration is invalid.
   **/
  | 'InvalidConfiguration';

export type SpConsensusBeefyMmrBeefyAuthoritySet = { id: bigint; len: number; keysetCommitment: H256 };

export type SpCoreCryptoKeyTypeId = FixedBytes<4>;

/**
 * Error for the session pallet.
 **/
export type PalletSessionError =
  /**
   * Invalid ownership proof.
   **/
  | 'InvalidProof'
  /**
   * No associated validator ID for account.
   **/
  | 'NoAssociatedValidatorId'
  /**
   * Registered duplicate key.
   **/
  | 'DuplicatedKey'
  /**
   * No keys are associated with this account.
   **/
  | 'NoKeys'
  /**
   * Key setting account is not live, so it's impossible to associate keys.
   **/
  | 'NoAccount';

export type PalletGrandpaStoredState =
  | { tag: 'Live' }
  | { tag: 'PendingPause'; value: { scheduledAt: number; delay: number } }
  | { tag: 'Paused' }
  | { tag: 'PendingResume'; value: { scheduledAt: number; delay: number } };

export type PalletGrandpaStoredPendingChange = {
  scheduledAt: number;
  delay: number;
  nextAuthorities: Array<[SpConsensusGrandpaAppPublic, bigint]>;
  forced?: number | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletGrandpaError =
  /**
   * Attempt to signal GRANDPA pause when the authority set isn't live
   * (either paused or already pending pause).
   **/
  | 'PauseFailed'
  /**
   * Attempt to signal GRANDPA resume when the authority set isn't paused
   * (either live or already pending resume).
   **/
  | 'ResumeFailed'
  /**
   * Attempt to signal GRANDPA change with one already pending.
   **/
  | 'ChangePending'
  /**
   * Cannot signal forced change so soon after last.
   **/
  | 'TooSoon'
  /**
   * A key ownership proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidKeyOwnershipProof'
  /**
   * An equivocation proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidEquivocationProof'
  /**
   * A given equivocation report is valid but already previously reported.
   **/
  | 'DuplicateOffenceReport';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletImOnlineError =
  /**
   * Non existent public key.
   **/
  | 'InvalidKey'
  /**
   * Duplicated heartbeat.
   **/
  | 'DuplicatedHeartbeat';

export type PalletTreasuryProposal = { proposer: AccountId32; value: bigint; beneficiary: AccountId32; bond: bigint };

export type PalletTreasurySpendStatus = {
  assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset;
  amount: bigint;
  beneficiary: XcmVersionedMultiLocation;
  validFrom: number;
  expireAt: number;
  status: PalletTreasuryPaymentState;
};

export type PalletTreasuryPaymentState =
  | { tag: 'Pending' }
  | { tag: 'Attempted'; value: { id: bigint } }
  | { tag: 'Failed' };

export type FrameSupportPalletId = FixedBytes<8>;

/**
 * Error for the treasury pallet.
 **/
export type PalletTreasuryError =
  /**
   * Proposer's balance is too low.
   **/
  | 'InsufficientProposersBalance'
  /**
   * No proposal, bounty or spend at that index.
   **/
  | 'InvalidIndex'
  /**
   * Too many approvals in the queue.
   **/
  | 'TooManyApprovals'
  /**
   * The spend origin is valid but the amount it is allowed to spend is lower than the
   * amount to be spent.
   **/
  | 'InsufficientPermission'
  /**
   * Proposal has not been approved.
   **/
  | 'ProposalNotApproved'
  /**
   * The balance of the asset kind is not convertible to the balance of the native asset.
   **/
  | 'FailedToConvertBalance'
  /**
   * The spend has expired and cannot be claimed.
   **/
  | 'SpendExpired'
  /**
   * The spend is not yet eligible for payout.
   **/
  | 'EarlyPayout'
  /**
   * The payment has already been attempted.
   **/
  | 'AlreadyAttempted'
  /**
   * There was some issue with the mechanism of payment.
   **/
  | 'PayoutError'
  /**
   * The payout was not yet attempted/claimed.
   **/
  | 'NotAttempted'
  /**
   * The payment has neither failed nor succeeded yet.
   **/
  | 'Inconclusive';

export type PalletConvictionVotingVoteVoting =
  | { tag: 'Casting'; value: PalletConvictionVotingVoteCasting }
  | { tag: 'Delegating'; value: PalletConvictionVotingVoteDelegating };

export type PalletConvictionVotingVoteCasting = {
  votes: Array<[number, PalletConvictionVotingVoteAccountVote]>;
  delegations: PalletConvictionVotingDelegations;
  prior: PalletConvictionVotingVotePriorLock;
};

export type PalletConvictionVotingDelegations = { votes: bigint; capital: bigint };

export type PalletConvictionVotingVotePriorLock = [number, bigint];

export type PalletConvictionVotingVoteDelegating = {
  balance: bigint;
  target: AccountId32;
  conviction: PalletConvictionVotingConviction;
  delegations: PalletConvictionVotingDelegations;
  prior: PalletConvictionVotingVotePriorLock;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletConvictionVotingError =
  /**
   * Poll is not ongoing.
   **/
  | 'NotOngoing'
  /**
   * The given account did not vote on the poll.
   **/
  | 'NotVoter'
  /**
   * The actor has no permission to conduct the action.
   **/
  | 'NoPermission'
  /**
   * The actor has no permission to conduct the action right now but will do in the future.
   **/
  | 'NoPermissionYet'
  /**
   * The account is already delegating.
   **/
  | 'AlreadyDelegating'
  /**
   * The account currently has votes attached to it and the operation cannot succeed until
   * these are removed, either through `unvote` or `reap_vote`.
   **/
  | 'AlreadyVoting'
  /**
   * Too high a balance was provided that the account cannot afford.
   **/
  | 'InsufficientFunds'
  /**
   * The account is not currently delegating.
   **/
  | 'NotDelegating'
  /**
   * Delegation to oneself makes no sense.
   **/
  | 'Nonsense'
  /**
   * Maximum number of votes reached.
   **/
  | 'MaxVotesReached'
  /**
   * The class must be supplied since it is not easily determinable from the state.
   **/
  | 'ClassNeeded'
  /**
   * The class ID supplied is invalid.
   **/
  | 'BadClass';

export type PalletReferendaReferendumInfo =
  | { tag: 'Ongoing'; value: PalletReferendaReferendumStatus }
  | { tag: 'Approved'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Rejected'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Cancelled'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'TimedOut'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Killed'; value: number };

export type PalletReferendaReferendumStatus = {
  track: number;
  origin: StagingKusamaRuntimeOriginCaller;
  proposal: FrameSupportPreimagesBounded;
  enactment: FrameSupportScheduleDispatchTime;
  submitted: number;
  submissionDeposit: PalletReferendaDeposit;
  decisionDeposit?: PalletReferendaDeposit | undefined;
  deciding?: PalletReferendaDecidingStatus | undefined;
  tally: PalletConvictionVotingTally;
  inQueue: boolean;
  alarm?: [number, [number, number]] | undefined;
};

export type PalletReferendaDeposit = { who: AccountId32; amount: bigint };

export type PalletReferendaDecidingStatus = { since: number; confirming?: number | undefined };

export type PalletReferendaTrackInfo = {
  name: string;
  maxDeciding: number;
  decisionDeposit: bigint;
  preparePeriod: number;
  decisionPeriod: number;
  confirmPeriod: number;
  minEnactmentPeriod: number;
  minApproval: PalletReferendaCurve;
  minSupport: PalletReferendaCurve;
};

export type PalletReferendaCurve =
  | { tag: 'LinearDecreasing'; value: { length: Perbill; floor: Perbill; ceil: Perbill } }
  | { tag: 'SteppedDecreasing'; value: { begin: Perbill; end: Perbill; step: Perbill; period: Perbill } }
  | { tag: 'Reciprocal'; value: { factor: FixedI64; xOffset: FixedI64; yOffset: FixedI64 } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletReferendaError =
  /**
   * Referendum is not ongoing.
   **/
  | 'NotOngoing'
  /**
   * Referendum's decision deposit is already paid.
   **/
  | 'HasDeposit'
  /**
   * The track identifier given was invalid.
   **/
  | 'BadTrack'
  /**
   * There are already a full complement of referenda in progress for this track.
   **/
  | 'Full'
  /**
   * The queue of the track is empty.
   **/
  | 'QueueEmpty'
  /**
   * The referendum index provided is invalid in this context.
   **/
  | 'BadReferendum'
  /**
   * There was nothing to do in the advancement.
   **/
  | 'NothingToDo'
  /**
   * No track exists for the proposal origin.
   **/
  | 'NoTrack'
  /**
   * Any deposit cannot be refunded until after the decision is over.
   **/
  | 'Unfinished'
  /**
   * The deposit refunder is not the depositor.
   **/
  | 'NoPermission'
  /**
   * The deposit cannot be refunded since none was made.
   **/
  | 'NoDeposit'
  /**
   * The referendum status is invalid for this operation.
   **/
  | 'BadStatus'
  /**
   * The preimage does not exist.
   **/
  | 'PreimageNotExist';

export type PalletRankedCollectiveMemberRecord = { rank: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRankedCollectiveError =
  /**
   * Account is already a member.
   **/
  | 'AlreadyMember'
  /**
   * Account is not a member.
   **/
  | 'NotMember'
  /**
   * The given poll index is unknown or has closed.
   **/
  | 'NotPolling'
  /**
   * The given poll is still ongoing.
   **/
  | 'Ongoing'
  /**
   * There are no further records to be removed.
   **/
  | 'NoneRemaining'
  /**
   * Unexpected error in state.
   **/
  | 'Corruption'
  /**
   * The member's rank is too low to vote.
   **/
  | 'RankTooLow'
  /**
   * The information provided is incorrect.
   **/
  | 'InvalidWitness'
  /**
   * The origin is not sufficiently privileged to do the operation.
   **/
  | 'NoPermission';

export type PalletReferendaReferendumInfoTally =
  | { tag: 'Ongoing'; value: PalletReferendaReferendumStatusTally }
  | { tag: 'Approved'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Rejected'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Cancelled'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'TimedOut'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Killed'; value: number };

export type PalletReferendaReferendumStatusTally = {
  track: number;
  origin: StagingKusamaRuntimeOriginCaller;
  proposal: FrameSupportPreimagesBounded;
  enactment: FrameSupportScheduleDispatchTime;
  submitted: number;
  submissionDeposit: PalletReferendaDeposit;
  decisionDeposit?: PalletReferendaDeposit | undefined;
  deciding?: PalletReferendaDecidingStatus | undefined;
  tally: PalletRankedCollectiveTally;
  inQueue: boolean;
  alarm?: [number, [number, number]] | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletWhitelistError =
  /**
   * The preimage of the call hash could not be loaded.
   **/
  | 'UnavailablePreImage'
  /**
   * The call could not be decoded.
   **/
  | 'UndecodableCall'
  /**
   * The weight of the decoded call was higher than the witness.
   **/
  | 'InvalidCallWeightWitness'
  /**
   * The call was not whitelisted.
   **/
  | 'CallIsNotWhitelisted'
  /**
   * The call was already whitelisted; No-Op.
   **/
  | 'CallAlreadyWhitelisted';

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeCommonClaimsPalletError =
  /**
   * Invalid Ethereum signature.
   **/
  | 'InvalidEthereumSignature'
  /**
   * Ethereum address has no claim.
   **/
  | 'SignerHasNoClaim'
  /**
   * Account ID sending transaction has no claim.
   **/
  | 'SenderHasNoClaim'
  /**
   * There's not enough in the pot to pay out some unvested amount. Generally implies a
   * logic error.
   **/
  | 'PotUnderflow'
  /**
   * A needed statement was not included.
   **/
  | 'InvalidStatement'
  /**
   * The account already has a vested balance.
   **/
  | 'VestedBalanceExists';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUtilityError =
  /**
   * Too many calls batched.
   **/
  'TooManyCalls';

export type PalletIdentityRegistration = {
  judgements: Array<[number, PalletIdentityJudgement]>;
  deposit: bigint;
  info: PalletIdentitySimpleIdentityInfo;
};

export type PalletIdentityRegistrarInfo = { account: AccountId32; fee: bigint; fields: PalletIdentityBitFlags };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIdentityError =
  /**
   * Too many subs-accounts.
   **/
  | 'TooManySubAccounts'
  /**
   * Account isn't found.
   **/
  | 'NotFound'
  /**
   * Account isn't named.
   **/
  | 'NotNamed'
  /**
   * Empty index.
   **/
  | 'EmptyIndex'
  /**
   * Fee is changed.
   **/
  | 'FeeChanged'
  /**
   * No identity found.
   **/
  | 'NoIdentity'
  /**
   * Sticky judgement.
   **/
  | 'StickyJudgement'
  /**
   * Judgement given.
   **/
  | 'JudgementGiven'
  /**
   * Invalid judgement.
   **/
  | 'InvalidJudgement'
  /**
   * The index is invalid.
   **/
  | 'InvalidIndex'
  /**
   * The target is invalid.
   **/
  | 'InvalidTarget'
  /**
   * Too many additional fields.
   **/
  | 'TooManyFields'
  /**
   * Maximum amount of registrars reached. Cannot add any more.
   **/
  | 'TooManyRegistrars'
  /**
   * Account ID is already named.
   **/
  | 'AlreadyClaimed'
  /**
   * Sender is not a sub-account.
   **/
  | 'NotSub'
  /**
   * Sub-account isn't owned by sender.
   **/
  | 'NotOwned'
  /**
   * The provided judgement was for a different identity.
   **/
  | 'JudgementForDifferentIdentity'
  /**
   * Error that occurs when there is an issue paying for judgement.
   **/
  | 'JudgementPaymentFailed';

export type PalletSocietyMemberRecord = {
  rank: number;
  strikes: number;
  vouching?: PalletSocietyVouchingStatus | undefined;
  index: number;
};

export type PalletSocietyVouchingStatus = 'Vouching' | 'Banned';

export type PalletSocietyPayoutRecord = { paid: bigint; payouts: Array<[number, bigint]> };

export type PalletSocietyBid = { who: AccountId32; kind: PalletSocietyBidKind; value: bigint };

export type PalletSocietyBidKind = { tag: 'Deposit'; value: bigint } | { tag: 'Vouch'; value: [AccountId32, bigint] };

export type PalletSocietyCandidacy = {
  round: number;
  kind: PalletSocietyBidKind;
  bid: bigint;
  tally: PalletSocietyTally;
  skepticStruck: boolean;
};

export type PalletSocietyTally = { approvals: number; rejections: number };

export type PalletSocietyVote = { approve: boolean; weight: number };

export type PalletSocietyIntakeRecord = { who: AccountId32; bid: bigint; round: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSocietyError =
  /**
   * User is not a member.
   **/
  | 'NotMember'
  /**
   * User is already a member.
   **/
  | 'AlreadyMember'
  /**
   * User is suspended.
   **/
  | 'Suspended'
  /**
   * User is not suspended.
   **/
  | 'NotSuspended'
  /**
   * Nothing to payout.
   **/
  | 'NoPayout'
  /**
   * Society already founded.
   **/
  | 'AlreadyFounded'
  /**
   * Not enough in pot to accept candidate.
   **/
  | 'InsufficientPot'
  /**
   * Member is already vouching or banned from vouching again.
   **/
  | 'AlreadyVouching'
  /**
   * Member is not vouching.
   **/
  | 'NotVouchingOnBidder'
  /**
   * Cannot remove the head of the chain.
   **/
  | 'Head'
  /**
   * Cannot remove the founder.
   **/
  | 'Founder'
  /**
   * User has already made a bid.
   **/
  | 'AlreadyBid'
  /**
   * User is already a candidate.
   **/
  | 'AlreadyCandidate'
  /**
   * User is not a candidate.
   **/
  | 'NotCandidate'
  /**
   * Too many members in the society.
   **/
  | 'MaxMembers'
  /**
   * The caller is not the founder.
   **/
  | 'NotFounder'
  /**
   * The caller is not the head.
   **/
  | 'NotHead'
  /**
   * The membership cannot be claimed as the candidate was not clearly approved.
   **/
  | 'NotApproved'
  /**
   * The candidate cannot be kicked as the candidate was not clearly rejected.
   **/
  | 'NotRejected'
  /**
   * The candidacy cannot be dropped as the candidate was clearly approved.
   **/
  | 'Approved'
  /**
   * The candidacy cannot be bestowed as the candidate was clearly rejected.
   **/
  | 'Rejected'
  /**
   * The candidacy cannot be concluded as the voting is still in progress.
   **/
  | 'InProgress'
  /**
   * The candidacy cannot be pruned until a full additional intake period has passed.
   **/
  | 'TooEarly'
  /**
   * The skeptic already voted.
   **/
  | 'Voted'
  /**
   * The skeptic need not vote on candidates from expired rounds.
   **/
  | 'Expired'
  /**
   * User is not a bidder.
   **/
  | 'NotBidder'
  /**
   * There is no defender currently.
   **/
  | 'NoDefender'
  /**
   * Group doesn't exist.
   **/
  | 'NotGroup'
  /**
   * The member is already elevated to this rank.
   **/
  | 'AlreadyElevated'
  /**
   * The skeptic has already been punished for this offence.
   **/
  | 'AlreadyPunished'
  /**
   * Funds are insufficient to pay off society debts.
   **/
  | 'InsufficientFunds'
  /**
   * The candidate/defender has no stale votes to remove.
   **/
  | 'NoVotes';

export type PalletRecoveryRecoveryConfig = {
  delayPeriod: number;
  deposit: bigint;
  friends: Array<AccountId32>;
  threshold: number;
};

export type PalletRecoveryActiveRecovery = { created: number; deposit: bigint; friends: Array<AccountId32> };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRecoveryError =
  /**
   * User is not allowed to make a call on behalf of this account
   **/
  | 'NotAllowed'
  /**
   * Threshold must be greater than zero
   **/
  | 'ZeroThreshold'
  /**
   * Friends list must be greater than zero and threshold
   **/
  | 'NotEnoughFriends'
  /**
   * Friends list must be less than max friends
   **/
  | 'MaxFriends'
  /**
   * Friends list must be sorted and free of duplicates
   **/
  | 'NotSorted'
  /**
   * This account is not set up for recovery
   **/
  | 'NotRecoverable'
  /**
   * This account is already set up for recovery
   **/
  | 'AlreadyRecoverable'
  /**
   * A recovery process has already started for this account
   **/
  | 'AlreadyStarted'
  /**
   * A recovery process has not started for this rescuer
   **/
  | 'NotStarted'
  /**
   * This account is not a friend who can vouch
   **/
  | 'NotFriend'
  /**
   * The friend must wait until the delay period to vouch for this recovery
   **/
  | 'DelayPeriod'
  /**
   * This user has already vouched for this recovery
   **/
  | 'AlreadyVouched'
  /**
   * The threshold for recovering this account has not been met
   **/
  | 'Threshold'
  /**
   * There are still active recovery attempts that need to be closed
   **/
  | 'StillActive'
  /**
   * This account is already set up for recovery
   **/
  | 'AlreadyProxy'
  /**
   * Some internal state is broken.
   **/
  | 'BadState';

export type PalletVestingReleases = 'V0' | 'V1';

/**
 * Error for the vesting pallet.
 **/
export type PalletVestingError =
  /**
   * The account given is not vesting.
   **/
  | 'NotVesting'
  /**
   * The account already has `MaxVestingSchedules` count of schedules and thus
   * cannot add another one. Consider merging existing schedules in order to add another.
   **/
  | 'AtMaxVestingSchedules'
  /**
   * Amount being transferred is too low to create a vesting schedule.
   **/
  | 'AmountLow'
  /**
   * An index was out of bounds of the vesting schedules.
   **/
  | 'ScheduleIndexOutOfBounds'
  /**
   * Failed to create a new schedule because some parameter was invalid.
   **/
  | 'InvalidScheduleParams';

export type PalletSchedulerScheduled = {
  maybeId?: FixedBytes<32> | undefined;
  priority: number;
  call: FrameSupportPreimagesBounded;
  maybePeriodic?: [number, number] | undefined;
  origin: StagingKusamaRuntimeOriginCaller;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSchedulerError =
  /**
   * Failed to schedule a call
   **/
  | 'FailedToSchedule'
  /**
   * Cannot find the scheduled call.
   **/
  | 'NotFound'
  /**
   * Given target block number is in the past.
   **/
  | 'TargetBlockNumberInPast'
  /**
   * Reschedule failed because it does not change scheduled time.
   **/
  | 'RescheduleNoChange'
  /**
   * Attempt to use a non-named function on a named task.
   **/
  | 'Named';

export type PalletProxyProxyDefinition = {
  delegate: AccountId32;
  proxyType: StagingKusamaRuntimeProxyType;
  delay: number;
};

export type PalletProxyAnnouncement = { real: AccountId32; callHash: H256; height: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletProxyError =
  /**
   * There are too many proxies registered or too many announcements pending.
   **/
  | 'TooMany'
  /**
   * Proxy registration not found.
   **/
  | 'NotFound'
  /**
   * Sender is not a proxy of the account to be proxied.
   **/
  | 'NotProxy'
  /**
   * A call which is incompatible with the proxy type's filter was attempted.
   **/
  | 'Unproxyable'
  /**
   * Account is already a proxy.
   **/
  | 'Duplicate'
  /**
   * Call may not be made by proxy because it may escalate its privileges.
   **/
  | 'NoPermission'
  /**
   * Announcement, if made at all, was made too recently.
   **/
  | 'Unannounced'
  /**
   * Cannot add self as proxy.
   **/
  | 'NoSelfProxy';

export type PalletMultisigMultisig = {
  when: PalletMultisigTimepoint;
  deposit: bigint;
  depositor: AccountId32;
  approvals: Array<AccountId32>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMultisigError =
  /**
   * Threshold must be 2 or greater.
   **/
  | 'MinimumThreshold'
  /**
   * Call is already approved by this signatory.
   **/
  | 'AlreadyApproved'
  /**
   * Call doesn't need any (more) approvals.
   **/
  | 'NoApprovalsNeeded'
  /**
   * There are too few signatories in the list.
   **/
  | 'TooFewSignatories'
  /**
   * There are too many signatories in the list.
   **/
  | 'TooManySignatories'
  /**
   * The signatories were provided out of order; they should be ordered.
   **/
  | 'SignatoriesOutOfOrder'
  /**
   * The sender was contained in the other signatories; it shouldn't be.
   **/
  | 'SenderInSignatories'
  /**
   * Multisig operation not found when attempting to cancel.
   **/
  | 'NotFound'
  /**
   * Only the account that originally created the multisig is able to cancel it.
   **/
  | 'NotOwner'
  /**
   * No timepoint was given, yet the multisig operation is already underway.
   **/
  | 'NoTimepoint'
  /**
   * A different timepoint was given to the multisig operation that is underway.
   **/
  | 'WrongTimepoint'
  /**
   * A timepoint was given, yet no multisig operation is underway.
   **/
  | 'UnexpectedTimepoint'
  /**
   * The maximum weight information provided was too low.
   **/
  | 'MaxWeightTooLow'
  /**
   * The data to be stored is already stored.
   **/
  | 'AlreadyStored';

export type PalletPreimageOldRequestStatus =
  | { tag: 'Unrequested'; value: { deposit: [AccountId32, bigint]; len: number } }
  | {
      tag: 'Requested';
      value: { deposit?: [AccountId32, bigint] | undefined; count: number; len?: number | undefined };
    };

export type PalletPreimageRequestStatus =
  | { tag: 'Unrequested'; value: { ticket: [AccountId32, FrameSupportTokensFungibleHoldConsideration]; len: number } }
  | {
      tag: 'Requested';
      value: {
        maybeTicket?: [AccountId32, FrameSupportTokensFungibleHoldConsideration] | undefined;
        count: number;
        maybeLen?: number | undefined;
      };
    };

export type FrameSupportTokensFungibleHoldConsideration = bigint;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletPreimageError =
  /**
   * Preimage is too large to store on-chain.
   **/
  | 'TooBig'
  /**
   * Preimage has already been noted on-chain.
   **/
  | 'AlreadyNoted'
  /**
   * The user is not authorized to perform this action.
   **/
  | 'NotAuthorized'
  /**
   * The preimage cannot be removed since it has not yet been noted.
   **/
  | 'NotNoted'
  /**
   * A preimage may not be removed when there are outstanding requests.
   **/
  | 'Requested'
  /**
   * The preimage request cannot be removed since no outstanding requests exist.
   **/
  | 'NotRequested'
  /**
   * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
   **/
  | 'TooMany'
  /**
   * Too few hashes were requested to be upgraded (i.e. zero).
   **/
  | 'TooFew';

export type PalletBountiesBounty = {
  proposer: AccountId32;
  value: bigint;
  fee: bigint;
  curatorDeposit: bigint;
  bond: bigint;
  status: PalletBountiesBountyStatus;
};

export type PalletBountiesBountyStatus =
  | { tag: 'Proposed' }
  | { tag: 'Approved' }
  | { tag: 'Funded' }
  | { tag: 'CuratorProposed'; value: { curator: AccountId32 } }
  | { tag: 'Active'; value: { curator: AccountId32; updateDue: number } }
  | { tag: 'PendingPayout'; value: { curator: AccountId32; beneficiary: AccountId32; unlockAt: number } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBountiesError =
  /**
   * Proposer's balance is too low.
   **/
  | 'InsufficientProposersBalance'
  /**
   * No proposal or bounty at that index.
   **/
  | 'InvalidIndex'
  /**
   * The reason given is just too big.
   **/
  | 'ReasonTooBig'
  /**
   * The bounty status is unexpected.
   **/
  | 'UnexpectedStatus'
  /**
   * Require bounty curator.
   **/
  | 'RequireCurator'
  /**
   * Invalid bounty value.
   **/
  | 'InvalidValue'
  /**
   * Invalid bounty fee.
   **/
  | 'InvalidFee'
  /**
   * A bounty payout is pending.
   * To cancel the bounty, you must unassign and slash the curator.
   **/
  | 'PendingPayout'
  /**
   * The bounties cannot be claimed/closed because it's still in the countdown period.
   **/
  | 'Premature'
  /**
   * The bounty cannot be closed because it has active child bounties.
   **/
  | 'HasActiveChildBounty'
  /**
   * Too many approvals are already queued.
   **/
  | 'TooManyQueued';

export type PalletChildBountiesChildBounty = {
  parentBounty: number;
  value: bigint;
  fee: bigint;
  curatorDeposit: bigint;
  status: PalletChildBountiesChildBountyStatus;
};

export type PalletChildBountiesChildBountyStatus =
  | { tag: 'Added' }
  | { tag: 'CuratorProposed'; value: { curator: AccountId32 } }
  | { tag: 'Active'; value: { curator: AccountId32 } }
  | { tag: 'PendingPayout'; value: { curator: AccountId32; beneficiary: AccountId32; unlockAt: number } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletChildBountiesError =
  /**
   * The parent bounty is not in active state.
   **/
  | 'ParentBountyNotActive'
  /**
   * The bounty balance is not enough to add new child-bounty.
   **/
  | 'InsufficientBountyBalance'
  /**
   * Number of child bounties exceeds limit `MaxActiveChildBountyCount`.
   **/
  | 'TooManyChildBounties';

export type PalletElectionProviderMultiPhaseReadySolution = {
  supports: Array<[AccountId32, SpNposElectionsSupport]>;
  score: SpNposElectionsElectionScore;
  compute: PalletElectionProviderMultiPhaseElectionCompute;
};

export type PalletElectionProviderMultiPhaseRoundSnapshot = {
  voters: Array<[AccountId32, bigint, Array<AccountId32>]>;
  targets: Array<AccountId32>;
};

export type PalletElectionProviderMultiPhaseSignedSignedSubmission = {
  who: AccountId32;
  deposit: bigint;
  rawSolution: PalletElectionProviderMultiPhaseRawSolution;
  callFee: bigint;
};

/**
 * Error of the pallet that can be returned in response to dispatches.
 **/
export type PalletElectionProviderMultiPhaseError =
  /**
   * Submission was too early.
   **/
  | 'PreDispatchEarlySubmission'
  /**
   * Wrong number of winners presented.
   **/
  | 'PreDispatchWrongWinnerCount'
  /**
   * Submission was too weak, score-wise.
   **/
  | 'PreDispatchWeakSubmission'
  /**
   * The queue was full, and the solution was not better than any of the existing ones.
   **/
  | 'SignedQueueFull'
  /**
   * The origin failed to pay the deposit.
   **/
  | 'SignedCannotPayDeposit'
  /**
   * Witness data to dispatchable is invalid.
   **/
  | 'SignedInvalidWitness'
  /**
   * The signed submission consumes too much weight
   **/
  | 'SignedTooMuchWeight'
  /**
   * OCW submitted solution for wrong round
   **/
  | 'OcwCallWrongEra'
  /**
   * Snapshot metadata should exist but didn't.
   **/
  | 'MissingSnapshotMetadata'
  /**
   * `Self::insert_submission` returned an invalid index.
   **/
  | 'InvalidSubmissionIndex'
  /**
   * The call is not allowed at this point.
   **/
  | 'CallNotAllowed'
  /**
   * The fallback failed
   **/
  | 'FallbackFailed'
  /**
   * Some bound not met
   **/
  | 'BoundNotMet'
  /**
   * Submitted solution has too many winners
   **/
  | 'TooManyWinners';

export type PalletNisBid = { amount: bigint; who: AccountId32 };

export type PalletNisSummaryRecord = {
  proportionOwed: Perquintill;
  index: number;
  thawed: Perquintill;
  lastPeriod: number;
  receiptsOnHold: bigint;
};

export type PalletNisReceiptRecord = {
  proportion: Perquintill;
  owner?: [AccountId32, bigint] | undefined;
  expiry: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletNisError =
  /**
   * The duration of the bid is less than one.
   **/
  | 'DurationTooSmall'
  /**
   * The duration is the bid is greater than the number of queues.
   **/
  | 'DurationTooBig'
  /**
   * The amount of the bid is less than the minimum allowed.
   **/
  | 'AmountTooSmall'
  /**
   * The queue for the bid's duration is full and the amount bid is too low to get in
   * through replacing an existing bid.
   **/
  | 'BidTooLow'
  /**
   * Receipt index is unknown.
   **/
  | 'UnknownReceipt'
  /**
   * Not the owner of the receipt.
   **/
  | 'NotOwner'
  /**
   * Bond not yet at expiry date.
   **/
  | 'NotExpired'
  /**
   * The given bid for retraction is not found.
   **/
  | 'UnknownBid'
  /**
   * The portion supplied is beyond the value of the receipt.
   **/
  | 'PortionTooBig'
  /**
   * Not enough funds are held to pay out.
   **/
  | 'Unfunded'
  /**
   * There are enough funds for what is required.
   **/
  | 'AlreadyFunded'
  /**
   * The thaw throttle has been reached for this period.
   **/
  | 'Throttled'
  /**
   * The operation would result in a receipt worth an insignficant value.
   **/
  | 'MakesDust'
  /**
   * The receipt is already communal.
   **/
  | 'AlreadyCommunal'
  /**
   * The receipt is already private.
   **/
  | 'AlreadyPrivate';

export type PalletBalancesIdAmount003 = { id: []; amount: bigint };

export type PalletBagsListListNode = {
  id: AccountId32;
  prev?: AccountId32 | undefined;
  next?: AccountId32 | undefined;
  bagUpper: bigint;
  score: bigint;
};

export type PalletBagsListListBag = { head?: AccountId32 | undefined; tail?: AccountId32 | undefined };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBagsListError =
  /**
   * A error in the list interface implementation.
   **/
  { tag: 'List'; value: PalletBagsListListListError };

export type PalletBagsListListListError = 'Duplicate' | 'NotHeavier' | 'NotInSameBag' | 'NodeNotFound';

export type PalletNominationPoolsPoolMember = {
  poolId: number;
  points: bigint;
  lastRecordedRewardCounter: FixedU128;
  unbondingEras: Array<[number, bigint]>;
};

export type PalletNominationPoolsBondedPoolInner = {
  commission: PalletNominationPoolsCommission;
  memberCounter: number;
  points: bigint;
  roles: PalletNominationPoolsPoolRoles;
  state: PalletNominationPoolsPoolState;
};

export type PalletNominationPoolsCommission = {
  current?: [Perbill, AccountId32] | undefined;
  max?: Perbill | undefined;
  changeRate?: PalletNominationPoolsCommissionChangeRate | undefined;
  throttleFrom?: number | undefined;
};

export type PalletNominationPoolsPoolRoles = {
  depositor: AccountId32;
  root?: AccountId32 | undefined;
  nominator?: AccountId32 | undefined;
  bouncer?: AccountId32 | undefined;
};

export type PalletNominationPoolsRewardPool = {
  lastRecordedRewardCounter: FixedU128;
  lastRecordedTotalPayouts: bigint;
  totalRewardsClaimed: bigint;
  totalCommissionPending: bigint;
  totalCommissionClaimed: bigint;
};

export type PalletNominationPoolsSubPools = {
  noEra: PalletNominationPoolsUnbondPool;
  withEra: Array<[number, PalletNominationPoolsUnbondPool]>;
};

export type PalletNominationPoolsUnbondPool = { points: bigint; balance: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletNominationPoolsError =
  /**
   * A (bonded) pool id does not exist.
   **/
  | { tag: 'PoolNotFound' }
  /**
   * An account is not a member.
   **/
  | { tag: 'PoolMemberNotFound' }
  /**
   * A reward pool does not exist. In all cases this is a system logic error.
   **/
  | { tag: 'RewardPoolNotFound' }
  /**
   * A sub pool does not exist.
   **/
  | { tag: 'SubPoolsNotFound' }
  /**
   * An account is already delegating in another pool. An account may only belong to one
   * pool at a time.
   **/
  | { tag: 'AccountBelongsToOtherPool' }
  /**
   * The member is fully unbonded (and thus cannot access the bonded and reward pool
   * anymore to, for example, collect rewards).
   **/
  | { tag: 'FullyUnbonding' }
  /**
   * The member cannot unbond further chunks due to reaching the limit.
   **/
  | { tag: 'MaxUnbondingLimit' }
  /**
   * None of the funds can be withdrawn yet because the bonding duration has not passed.
   **/
  | { tag: 'CannotWithdrawAny' }
  /**
   * The amount does not meet the minimum bond to either join or create a pool.
   *
   * The depositor can never unbond to a value less than `Pallet::depositor_min_bond`. The
   * caller does not have nominating permissions for the pool. Members can never unbond to a
   * value below `MinJoinBond`.
   **/
  | { tag: 'MinimumBondNotMet' }
  /**
   * The transaction could not be executed due to overflow risk for the pool.
   **/
  | { tag: 'OverflowRisk' }
  /**
   * A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
   * other members to be permissionlessly unbonded.
   **/
  | { tag: 'NotDestroying' }
  /**
   * The caller does not have nominating permissions for the pool.
   **/
  | { tag: 'NotNominator' }
  /**
   * Either a) the caller cannot make a valid kick or b) the pool is not destroying.
   **/
  | { tag: 'NotKickerOrDestroying' }
  /**
   * The pool is not open to join
   **/
  | { tag: 'NotOpen' }
  /**
   * The system is maxed out on pools.
   **/
  | { tag: 'MaxPools' }
  /**
   * Too many members in the pool or system.
   **/
  | { tag: 'MaxPoolMembers' }
  /**
   * The pools state cannot be changed.
   **/
  | { tag: 'CanNotChangeState' }
  /**
   * The caller does not have adequate permissions.
   **/
  | { tag: 'DoesNotHavePermission' }
  /**
   * Metadata exceeds [`Config::MaxMetadataLen`]
   **/
  | { tag: 'MetadataExceedsMaxLen' }
  /**
   * Some error occurred that should never happen. This should be reported to the
   * maintainers.
   **/
  | { tag: 'Defensive'; value: PalletNominationPoolsDefensiveError }
  /**
   * Partial unbonding now allowed permissionlessly.
   **/
  | { tag: 'PartialUnbondNotAllowedPermissionlessly' }
  /**
   * The pool's max commission cannot be set higher than the existing value.
   **/
  | { tag: 'MaxCommissionRestricted' }
  /**
   * The supplied commission exceeds the max allowed commission.
   **/
  | { tag: 'CommissionExceedsMaximum' }
  /**
   * The supplied commission exceeds global maximum commission.
   **/
  | { tag: 'CommissionExceedsGlobalMaximum' }
  /**
   * Not enough blocks have surpassed since the last commission update.
   **/
  | { tag: 'CommissionChangeThrottled' }
  /**
   * The submitted changes to commission change rate are not allowed.
   **/
  | { tag: 'CommissionChangeRateNotAllowed' }
  /**
   * There is no pending commission to claim.
   **/
  | { tag: 'NoPendingCommission' }
  /**
   * No commission current has been set.
   **/
  | { tag: 'NoCommissionCurrentSet' }
  /**
   * Pool id currently in use.
   **/
  | { tag: 'PoolIdInUse' }
  /**
   * Pool id provided is not correct/usable.
   **/
  | { tag: 'InvalidPoolId' }
  /**
   * Bonding extra is restricted to the exact pending reward amount.
   **/
  | { tag: 'BondExtraRestricted' }
  /**
   * No imbalance in the ED deposit for the pool.
   **/
  | { tag: 'NothingToAdjust' };

export type PalletNominationPoolsDefensiveError =
  | 'NotEnoughSpaceInUnbondPool'
  | 'PoolNotFound'
  | 'RewardPoolNotFound'
  | 'SubPoolsNotFound'
  | 'BondedStashKilledPrematurely';

export type PalletFastUnstakeUnstakeRequest = { stashes: Array<[AccountId32, bigint]>; checked: Array<number> };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletFastUnstakeError =
  /**
   * The provided Controller account was not found.
   *
   * This means that the given account is not bonded.
   **/
  | 'NotController'
  /**
   * The bonded account has already been queued.
   **/
  | 'AlreadyQueued'
  /**
   * The bonded account has active unlocking chunks.
   **/
  | 'NotFullyBonded'
  /**
   * The provided un-staker is not in the `Queue`.
   **/
  | 'NotQueued'
  /**
   * The provided un-staker is already in Head, and cannot deregister.
   **/
  | 'AlreadyHead'
  /**
   * The call is not allowed at this point because the pallet is not active.
   **/
  | 'CallNotAllowed';

export type PolkadotRuntimeParachainsConfigurationHostConfiguration = {
  maxCodeSize: number;
  maxHeadDataSize: number;
  maxUpwardQueueCount: number;
  maxUpwardQueueSize: number;
  maxUpwardMessageSize: number;
  maxUpwardMessageNumPerCandidate: number;
  hrmpMaxMessageNumPerCandidate: number;
  validationUpgradeCooldown: number;
  validationUpgradeDelay: number;
  asyncBackingParams: PolkadotPrimitivesV6AsyncBackingAsyncBackingParams;
  maxPovSize: number;
  maxDownwardMessageSize: number;
  hrmpMaxParachainOutboundChannels: number;
  hrmpSenderDeposit: bigint;
  hrmpRecipientDeposit: bigint;
  hrmpChannelMaxCapacity: number;
  hrmpChannelMaxTotalSize: number;
  hrmpMaxParachainInboundChannels: number;
  hrmpChannelMaxMessageSize: number;
  executorParams: PolkadotPrimitivesV6ExecutorParams;
  codeRetentionPeriod: number;
  onDemandCores: number;
  onDemandRetries: number;
  onDemandQueueMaxSize: number;
  onDemandTargetQueueUtilization: Perbill;
  onDemandFeeVariability: Perbill;
  onDemandBaseFee: bigint;
  onDemandTtl: number;
  groupRotationFrequency: number;
  parasAvailabilityPeriod: number;
  schedulingLookahead: number;
  maxValidatorsPerCore?: number | undefined;
  maxValidators?: number | undefined;
  disputePeriod: number;
  disputePostConclusionAcceptancePeriod: number;
  noShowSlots: number;
  nDelayTranches: number;
  zerothDelayTrancheWidth: number;
  neededApprovals: number;
  relayVrfModuloSamples: number;
  pvfVotingTtl: number;
  minimumValidationUpgradeDelay: number;
  minimumBackingVotes: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsConfigurationPalletError =
  /**
   * The new value for a configuration parameter is invalid.
   **/
  'InvalidNewValue';

export type PolkadotRuntimeParachainsSharedAllowedRelayParentsTracker = {
  buffer: Array<[H256, H256]>;
  latestNumber: number;
};

export type PolkadotRuntimeParachainsInclusionAvailabilityBitfieldRecord = {
  bitfield: PolkadotPrimitivesV6AvailabilityBitfield;
  submittedAt: number;
};

export type PolkadotRuntimeParachainsInclusionCandidatePendingAvailability = {
  core: PolkadotPrimitivesV6CoreIndex;
  hash: PolkadotCorePrimitivesCandidateHash;
  descriptor: PolkadotPrimitivesV6CandidateDescriptor;
  availabilityVotes: BitSequence;
  backers: BitSequence;
  relayParentNumber: number;
  backedInNumber: number;
  backingGroup: PolkadotPrimitivesV6GroupIndex;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsInclusionPalletError =
  /**
   * Validator indices are out of order or contains duplicates.
   **/
  | 'UnsortedOrDuplicateValidatorIndices'
  /**
   * Dispute statement sets are out of order or contain duplicates.
   **/
  | 'UnsortedOrDuplicateDisputeStatementSet'
  /**
   * Backed candidates are out of order (core index) or contain duplicates.
   **/
  | 'UnsortedOrDuplicateBackedCandidates'
  /**
   * A different relay parent was provided compared to the on-chain stored one.
   **/
  | 'UnexpectedRelayParent'
  /**
   * Availability bitfield has unexpected size.
   **/
  | 'WrongBitfieldSize'
  /**
   * Bitfield consists of zeros only.
   **/
  | 'BitfieldAllZeros'
  /**
   * Multiple bitfields submitted by same validator or validators out of order by index.
   **/
  | 'BitfieldDuplicateOrUnordered'
  /**
   * Validator index out of bounds.
   **/
  | 'ValidatorIndexOutOfBounds'
  /**
   * Invalid signature
   **/
  | 'InvalidBitfieldSignature'
  /**
   * Candidate submitted but para not scheduled.
   **/
  | 'UnscheduledCandidate'
  /**
   * Candidate scheduled despite pending candidate already existing for the para.
   **/
  | 'CandidateScheduledBeforeParaFree'
  /**
   * Scheduled cores out of order.
   **/
  | 'ScheduledOutOfOrder'
  /**
   * Head data exceeds the configured maximum.
   **/
  | 'HeadDataTooLarge'
  /**
   * Code upgrade prematurely.
   **/
  | 'PrematureCodeUpgrade'
  /**
   * Output code is too large
   **/
  | 'NewCodeTooLarge'
  /**
   * The candidate's relay-parent was not allowed. Either it was
   * not recent enough or it didn't advance based on the last parachain block.
   **/
  | 'DisallowedRelayParent'
  /**
   * Failed to compute group index for the core: either it's out of bounds
   * or the relay parent doesn't belong to the current session.
   **/
  | 'InvalidAssignment'
  /**
   * Invalid group index in core assignment.
   **/
  | 'InvalidGroupIndex'
  /**
   * Insufficient (non-majority) backing.
   **/
  | 'InsufficientBacking'
  /**
   * Invalid (bad signature, unknown validator, etc.) backing.
   **/
  | 'InvalidBacking'
  /**
   * Collator did not sign PoV.
   **/
  | 'NotCollatorSigned'
  /**
   * The validation data hash does not match expected.
   **/
  | 'ValidationDataHashMismatch'
  /**
   * The downward message queue is not processed correctly.
   **/
  | 'IncorrectDownwardMessageHandling'
  /**
   * At least one upward message sent does not pass the acceptance criteria.
   **/
  | 'InvalidUpwardMessages'
  /**
   * The candidate didn't follow the rules of HRMP watermark advancement.
   **/
  | 'HrmpWatermarkMishandling'
  /**
   * The HRMP messages sent by the candidate is not valid.
   **/
  | 'InvalidOutboundHrmp'
  /**
   * The validation code hash of the candidate is not valid.
   **/
  | 'InvalidValidationCodeHash'
  /**
   * The `para_head` hash in the candidate descriptor doesn't match the hash of the actual
   * para head in the commitments.
   **/
  | 'ParaHeadMismatch'
  /**
   * A bitfield that references a freed core,
   * either intentionally or as part of a concluded
   * invalid dispute.
   **/
  | 'BitfieldReferencesFreedCore';

export type PolkadotPrimitivesV6ScrapedOnChainVotes = {
  session: number;
  backingValidatorsPerCandidate: Array<
    [
      PolkadotPrimitivesV6CandidateReceipt,
      Array<[PolkadotPrimitivesV6ValidatorIndex, PolkadotPrimitivesV6ValidityAttestation]>,
    ]
  >;
  disputes: Array<PolkadotPrimitivesV6DisputeStatementSet>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsParasInherentPalletError =
  /**
   * Inclusion inherent called more than once per block.
   **/
  | 'TooManyInclusionInherents'
  /**
   * The hash of the submitted parent header doesn't correspond to the saved block hash of
   * the parent.
   **/
  | 'InvalidParentHeader'
  /**
   * Disputed candidate that was concluded invalid.
   **/
  | 'CandidateConcludedInvalid'
  /**
   * The data given to the inherent will result in an overweight block.
   **/
  | 'InherentOverweight'
  /**
   * The ordering of dispute statements was invalid.
   **/
  | 'DisputeStatementsUnsortedOrDuplicates'
  /**
   * A dispute statement was invalid.
   **/
  | 'DisputeInvalid';

export type PolkadotRuntimeParachainsSchedulerPalletCoreOccupied =
  | { tag: 'Free' }
  | { tag: 'Paras'; value: PolkadotRuntimeParachainsSchedulerPalletParasEntry };

export type PolkadotRuntimeParachainsSchedulerPalletParasEntry = {
  assignment: PolkadotRuntimeParachainsSchedulerCommonAssignment;
  availabilityTimeouts: number;
  ttl: number;
};

export type PolkadotRuntimeParachainsSchedulerCommonAssignment = { paraId: PolkadotParachainPrimitivesPrimitivesId };

export type PolkadotRuntimeParachainsParasPvfCheckActiveVoteState = {
  votesAccept: BitSequence;
  votesReject: BitSequence;
  age: number;
  createdAt: number;
  causes: Array<PolkadotRuntimeParachainsParasPvfCheckCause>;
};

export type PolkadotRuntimeParachainsParasPvfCheckCause =
  | { tag: 'Onboarding'; value: PolkadotParachainPrimitivesPrimitivesId }
  | {
      tag: 'Upgrade';
      value: {
        id: PolkadotParachainPrimitivesPrimitivesId;
        includedAt: number;
        setGoAhead: PolkadotRuntimeParachainsParasSetGoAhead;
      };
    };

export type PolkadotRuntimeParachainsParasSetGoAhead = 'Yes' | 'No';

export type PolkadotRuntimeParachainsParasParaLifecycle =
  | 'Onboarding'
  | 'Parathread'
  | 'Parachain'
  | 'UpgradingParathread'
  | 'DowngradingParachain'
  | 'OffboardingParathread'
  | 'OffboardingParachain';

export type PolkadotRuntimeParachainsParasParaPastCodeMeta = {
  upgradeTimes: Array<PolkadotRuntimeParachainsParasReplacementTimes>;
  lastPruned?: number | undefined;
};

export type PolkadotRuntimeParachainsParasReplacementTimes = { expectedAt: number; activatedAt: number };

export type PolkadotPrimitivesV6UpgradeGoAhead = 'Abort' | 'GoAhead';

export type PolkadotPrimitivesV6UpgradeRestriction = 'Present';

export type PolkadotRuntimeParachainsParasParaGenesisArgs = {
  genesisHead: PolkadotParachainPrimitivesPrimitivesHeadData;
  validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
  paraKind: boolean;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsParasPalletError =
  /**
   * Para is not registered in our system.
   **/
  | 'NotRegistered'
  /**
   * Para cannot be onboarded because it is already tracked by our system.
   **/
  | 'CannotOnboard'
  /**
   * Para cannot be offboarded at this time.
   **/
  | 'CannotOffboard'
  /**
   * Para cannot be upgraded to a lease holding parachain.
   **/
  | 'CannotUpgrade'
  /**
   * Para cannot be downgraded to an on-demand parachain.
   **/
  | 'CannotDowngrade'
  /**
   * The statement for PVF pre-checking is stale.
   **/
  | 'PvfCheckStatementStale'
  /**
   * The statement for PVF pre-checking is for a future session.
   **/
  | 'PvfCheckStatementFuture'
  /**
   * Claimed validator index is out of bounds.
   **/
  | 'PvfCheckValidatorIndexOutOfBounds'
  /**
   * The signature for the PVF pre-checking is invalid.
   **/
  | 'PvfCheckInvalidSignature'
  /**
   * The given validator already has cast a vote.
   **/
  | 'PvfCheckDoubleVote'
  /**
   * The given PVF does not exist at the moment of process a vote.
   **/
  | 'PvfCheckSubjectInvalid'
  /**
   * Parachain cannot currently schedule a code upgrade.
   **/
  | 'CannotUpgradeCode';

export type PolkadotRuntimeParachainsInitializerBufferedSessionChange = {
  validators: Array<PolkadotPrimitivesV6ValidatorAppPublic>;
  queued: Array<PolkadotPrimitivesV6ValidatorAppPublic>;
  sessionIndex: number;
};

export type PolkadotCorePrimitivesInboundDownwardMessage = { sentAt: number; msg: Bytes };

export type PolkadotRuntimeParachainsHrmpHrmpOpenChannelRequest = {
  confirmed: boolean;
  age: number;
  senderDeposit: bigint;
  maxMessageSize: number;
  maxCapacity: number;
  maxTotalSize: number;
};

export type PolkadotRuntimeParachainsHrmpHrmpChannel = {
  maxCapacity: number;
  maxTotalSize: number;
  maxMessageSize: number;
  msgCount: number;
  totalSize: number;
  mqcHead?: H256 | undefined;
  senderDeposit: bigint;
  recipientDeposit: bigint;
};

export type PolkadotCorePrimitivesInboundHrmpMessage = { sentAt: number; data: Bytes };

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsHrmpPalletError =
  /**
   * The sender tried to open a channel to themselves.
   **/
  | 'OpenHrmpChannelToSelf'
  /**
   * The recipient is not a valid para.
   **/
  | 'OpenHrmpChannelInvalidRecipient'
  /**
   * The requested capacity is zero.
   **/
  | 'OpenHrmpChannelZeroCapacity'
  /**
   * The requested capacity exceeds the global limit.
   **/
  | 'OpenHrmpChannelCapacityExceedsLimit'
  /**
   * The requested maximum message size is 0.
   **/
  | 'OpenHrmpChannelZeroMessageSize'
  /**
   * The open request requested the message size that exceeds the global limit.
   **/
  | 'OpenHrmpChannelMessageSizeExceedsLimit'
  /**
   * The channel already exists
   **/
  | 'OpenHrmpChannelAlreadyExists'
  /**
   * There is already a request to open the same channel.
   **/
  | 'OpenHrmpChannelAlreadyRequested'
  /**
   * The sender already has the maximum number of allowed outbound channels.
   **/
  | 'OpenHrmpChannelLimitExceeded'
  /**
   * The channel from the sender to the origin doesn't exist.
   **/
  | 'AcceptHrmpChannelDoesntExist'
  /**
   * The channel is already confirmed.
   **/
  | 'AcceptHrmpChannelAlreadyConfirmed'
  /**
   * The recipient already has the maximum number of allowed inbound channels.
   **/
  | 'AcceptHrmpChannelLimitExceeded'
  /**
   * The origin tries to close a channel where it is neither the sender nor the recipient.
   **/
  | 'CloseHrmpChannelUnauthorized'
  /**
   * The channel to be closed doesn't exist.
   **/
  | 'CloseHrmpChannelDoesntExist'
  /**
   * The channel close request is already requested.
   **/
  | 'CloseHrmpChannelAlreadyUnderway'
  /**
   * Canceling is requested by neither the sender nor recipient of the open channel request.
   **/
  | 'CancelHrmpOpenChannelUnauthorized'
  /**
   * The open request doesn't exist.
   **/
  | 'OpenHrmpChannelDoesntExist'
  /**
   * Cannot cancel an HRMP open channel request because it is already confirmed.
   **/
  | 'OpenHrmpChannelAlreadyConfirmed'
  /**
   * The provided witness data is wrong.
   **/
  | 'WrongWitness'
  /**
   * The channel between these two chains cannot be authorized.
   **/
  | 'ChannelCreationNotAuthorized';

export type PolkadotPrimitivesV6SessionInfo = {
  activeValidatorIndices: Array<PolkadotPrimitivesV6ValidatorIndex>;
  randomSeed: FixedBytes<32>;
  disputePeriod: number;
  validators: PolkadotPrimitivesV6IndexedVec;
  discoveryKeys: Array<SpAuthorityDiscoveryAppPublic>;
  assignmentKeys: Array<PolkadotPrimitivesV6AssignmentAppPublic>;
  validatorGroups: PolkadotPrimitivesV6IndexedVecGroupIndex;
  nCores: number;
  zerothDelayTrancheWidth: number;
  relayVrfModuloSamples: number;
  nDelayTranches: number;
  noShowSlots: number;
  neededApprovals: number;
};

export type PolkadotPrimitivesV6IndexedVec = Array<PolkadotPrimitivesV6ValidatorAppPublic>;

export type PolkadotPrimitivesV6IndexedVecGroupIndex = Array<Array<PolkadotPrimitivesV6ValidatorIndex>>;

export type PolkadotPrimitivesV6DisputeState = {
  validatorsFor: BitSequence;
  validatorsAgainst: BitSequence;
  start: number;
  concludedAt?: number | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsDisputesPalletError =
  /**
   * Duplicate dispute statement sets provided.
   **/
  | 'DuplicateDisputeStatementSets'
  /**
   * Ancient dispute statement provided.
   **/
  | 'AncientDisputeStatement'
  /**
   * Validator index on statement is out of bounds for session.
   **/
  | 'ValidatorIndexOutOfBounds'
  /**
   * Invalid signature on statement.
   **/
  | 'InvalidSignature'
  /**
   * Validator vote submitted more than once to dispute.
   **/
  | 'DuplicateStatement'
  /**
   * A dispute where there are only votes on one side.
   **/
  | 'SingleSidedDispute'
  /**
   * A dispute vote from a malicious backer.
   **/
  | 'MaliciousBacker'
  /**
   * No backing votes were provides along dispute statements.
   **/
  | 'MissingBackingVotes'
  /**
   * Unconfirmed dispute statement sets provided.
   **/
  | 'UnconfirmedDispute';

export type PolkadotPrimitivesV6SlashingPendingSlashes = {
  keys: Array<[PolkadotPrimitivesV6ValidatorIndex, PolkadotPrimitivesV6ValidatorAppPublic]>;
  kind: PolkadotPrimitivesV6SlashingSlashingOffenceKind;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsDisputesSlashingPalletError =
  /**
   * The key ownership proof is invalid.
   **/
  | 'InvalidKeyOwnershipProof'
  /**
   * The session index is too old or invalid.
   **/
  | 'InvalidSessionIndex'
  /**
   * The candidate hash is invalid.
   **/
  | 'InvalidCandidateHash'
  /**
   * There is no pending slash for the given validator index and time
   * slot.
   **/
  | 'InvalidValidatorIndex'
  /**
   * The validator index does not match the validator id.
   **/
  | 'ValidatorIndexIdMismatch'
  /**
   * The given slashing report is valid but already previously reported.
   **/
  | 'DuplicateSlashingReport';

export type PolkadotRuntimeCommonParasRegistrarParaInfo = {
  manager: AccountId32;
  deposit: bigint;
  locked?: boolean | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeCommonParasRegistrarPalletError =
  /**
   * The ID is not registered.
   **/
  | 'NotRegistered'
  /**
   * The ID is already registered.
   **/
  | 'AlreadyRegistered'
  /**
   * The caller is not the owner of this Id.
   **/
  | 'NotOwner'
  /**
   * Invalid para code size.
   **/
  | 'CodeTooLarge'
  /**
   * Invalid para head data size.
   **/
  | 'HeadDataTooLarge'
  /**
   * Para is not a Parachain.
   **/
  | 'NotParachain'
  /**
   * Para is not a Parathread (on-demand parachain).
   **/
  | 'NotParathread'
  /**
   * Cannot deregister para
   **/
  | 'CannotDeregister'
  /**
   * Cannot schedule downgrade of lease holding parachain to on-demand parachain
   **/
  | 'CannotDowngrade'
  /**
   * Cannot schedule upgrade of on-demand parachain to lease holding parachain
   **/
  | 'CannotUpgrade'
  /**
   * Para is locked from manipulation by the manager. Must use parachain or relay chain
   * governance.
   **/
  | 'ParaLocked'
  /**
   * The ID given for registration has not been reserved.
   **/
  | 'NotReserved'
  /**
   * Registering parachain with empty code is not allowed.
   **/
  | 'EmptyCode'
  /**
   * Cannot perform a parachain slot / lifecycle swap. Check that the state of both paras
   * are correct for the swap to work.
   **/
  | 'CannotSwap';

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeCommonSlotsPalletError =
  /**
   * The parachain ID is not onboarding.
   **/
  | 'ParaNotOnboarding'
  /**
   * There was an error with the lease.
   **/
  | 'LeaseError';

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeCommonAuctionsPalletError =
  /**
   * This auction is already in progress.
   **/
  | 'AuctionInProgress'
  /**
   * The lease period is in the past.
   **/
  | 'LeasePeriodInPast'
  /**
   * Para is not registered
   **/
  | 'ParaNotRegistered'
  /**
   * Not a current auction.
   **/
  | 'NotCurrentAuction'
  /**
   * Not an auction.
   **/
  | 'NotAuction'
  /**
   * Auction has already ended.
   **/
  | 'AuctionEnded'
  /**
   * The para is already leased out for part of this range.
   **/
  | 'AlreadyLeasedOut';

export type PolkadotRuntimeCommonCrowdloanFundInfo = {
  depositor: AccountId32;
  verifier?: SpRuntimeMultiSigner | undefined;
  deposit: bigint;
  raised: bigint;
  end: number;
  cap: bigint;
  lastContribution: PolkadotRuntimeCommonCrowdloanLastContribution;
  firstPeriod: number;
  lastPeriod: number;
  fundIndex: number;
};

export type PolkadotRuntimeCommonCrowdloanLastContribution =
  | { tag: 'Never' }
  | { tag: 'PreEnding'; value: number }
  | { tag: 'Ending'; value: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeCommonCrowdloanPalletError =
  /**
   * The current lease period is more than the first lease period.
   **/
  | 'FirstPeriodInPast'
  /**
   * The first lease period needs to at least be less than 3 `max_value`.
   **/
  | 'FirstPeriodTooFarInFuture'
  /**
   * Last lease period must be greater than first lease period.
   **/
  | 'LastPeriodBeforeFirstPeriod'
  /**
   * The last lease period cannot be more than 3 periods after the first period.
   **/
  | 'LastPeriodTooFarInFuture'
  /**
   * The campaign ends before the current block number. The end must be in the future.
   **/
  | 'CannotEndInPast'
  /**
   * The end date for this crowdloan is not sensible.
   **/
  | 'EndTooFarInFuture'
  /**
   * There was an overflow.
   **/
  | 'Overflow'
  /**
   * The contribution was below the minimum, `MinContribution`.
   **/
  | 'ContributionTooSmall'
  /**
   * Invalid fund index.
   **/
  | 'InvalidParaId'
  /**
   * Contributions exceed maximum amount.
   **/
  | 'CapExceeded'
  /**
   * The contribution period has already ended.
   **/
  | 'ContributionPeriodOver'
  /**
   * The origin of this call is invalid.
   **/
  | 'InvalidOrigin'
  /**
   * This crowdloan does not correspond to a parachain.
   **/
  | 'NotParachain'
  /**
   * This parachain lease is still active and retirement cannot yet begin.
   **/
  | 'LeaseActive'
  /**
   * This parachain's bid or lease is still active and withdraw cannot yet begin.
   **/
  | 'BidOrLeaseActive'
  /**
   * The crowdloan has not yet ended.
   **/
  | 'FundNotEnded'
  /**
   * There are no contributions stored in this crowdloan.
   **/
  | 'NoContributions'
  /**
   * The crowdloan is not ready to dissolve. Potentially still has a slot or in retirement
   * period.
   **/
  | 'NotReadyToDissolve'
  /**
   * Invalid signature.
   **/
  | 'InvalidSignature'
  /**
   * The provided memo is too large.
   **/
  | 'MemoTooLarge'
  /**
   * The fund is already in `NewRaise`
   **/
  | 'AlreadyInNewRaise'
  /**
   * No contributions allowed during the VRF delay
   **/
  | 'VrfDelayInProgress'
  /**
   * A lease period has not started yet, due to an offset in the starting block.
   **/
  | 'NoLeasePeriod';

export type PalletXcmQueryStatus =
  | {
      tag: 'Pending';
      value: {
        responder: XcmVersionedMultiLocation;
        maybeMatchQuerier?: XcmVersionedMultiLocation | undefined;
        maybeNotify?: [number, number] | undefined;
        timeout: number;
      };
    }
  | { tag: 'VersionNotifier'; value: { origin: XcmVersionedMultiLocation; isActive: boolean } }
  | { tag: 'Ready'; value: { response: XcmVersionedResponse; at: number } };

export type XcmVersionedResponse = { tag: 'V2'; value: XcmV2Response } | { tag: 'V3'; value: XcmV3Response };

export type PalletXcmVersionMigrationStage =
  | { tag: 'MigrateSupportedVersion' }
  | { tag: 'MigrateVersionNotifiers' }
  | { tag: 'NotifyCurrentTargets'; value?: Bytes | undefined }
  | { tag: 'MigrateAndNotifyOldTargets' };

export type XcmVersionedAssetId = { tag: 'V3'; value: XcmV3MultiassetAssetId };

export type PalletXcmRemoteLockedFungibleRecord = {
  amount: bigint;
  owner: XcmVersionedMultiLocation;
  locker: XcmVersionedMultiLocation;
  consumers: Array<[[], bigint]>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletXcmError =
  /**
   * The desired destination was unreachable, generally because there is a no way of routing
   * to it.
   **/
  | 'Unreachable'
  /**
   * There was some other issue (i.e. not to do with routing) in sending the message.
   * Perhaps a lack of space for buffering the message.
   **/
  | 'SendFailure'
  /**
   * The message execution fails the filter.
   **/
  | 'Filtered'
  /**
   * The message's weight could not be determined.
   **/
  | 'UnweighableMessage'
  /**
   * The destination `MultiLocation` provided cannot be inverted.
   **/
  | 'DestinationNotInvertible'
  /**
   * The assets to be sent are empty.
   **/
  | 'Empty'
  /**
   * Could not re-anchor the assets to declare the fees for the destination chain.
   **/
  | 'CannotReanchor'
  /**
   * Too many assets have been attempted for transfer.
   **/
  | 'TooManyAssets'
  /**
   * Origin is invalid for sending.
   **/
  | 'InvalidOrigin'
  /**
   * The version of the `Versioned` value used is not able to be interpreted.
   **/
  | 'BadVersion'
  /**
   * The given location could not be used (e.g. because it cannot be expressed in the
   * desired version of XCM).
   **/
  | 'BadLocation'
  /**
   * The referenced subscription could not be found.
   **/
  | 'NoSubscription'
  /**
   * The location is invalid since it already has a subscription from us.
   **/
  | 'AlreadySubscribed'
  /**
   * Invalid asset for the operation.
   **/
  | 'InvalidAsset'
  /**
   * The owner does not own (all) of the asset that they wish to do the operation on.
   **/
  | 'LowBalance'
  /**
   * The asset owner has too many locks on the asset.
   **/
  | 'TooManyLocks'
  /**
   * The given account is not an identifiable sovereign account for any location.
   **/
  | 'AccountNotSovereign'
  /**
   * The operation required fees to be paid which the initiator could not meet.
   **/
  | 'FeesNotMet'
  /**
   * A remote lock with the corresponding data could not be found.
   **/
  | 'LockNotFound'
  /**
   * The unlock operation cannot succeed because there are still consumers of the lock.
   **/
  | 'InUse';

export type PalletMessageQueueBookState = {
  begin: number;
  end: number;
  count: number;
  readyNeighbours?: PalletMessageQueueNeighbours | undefined;
  messageCount: bigint;
  size: bigint;
};

export type PalletMessageQueueNeighbours = {
  prev: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin;
  next: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin;
};

export type PalletMessageQueuePage = {
  remaining: number;
  remainingSize: number;
  firstIndex: number;
  first: number;
  last: number;
  heap: Bytes;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMessageQueueError =
  /**
   * Page is not reapable because it has items remaining to be processed and is not old
   * enough.
   **/
  | 'NotReapable'
  /**
   * Page to be reaped does not exist.
   **/
  | 'NoPage'
  /**
   * The referenced message could not be found.
   **/
  | 'NoMessage'
  /**
   * The message was already processed and cannot be processed again.
   **/
  | 'AlreadyProcessed'
  /**
   * The message is queued for future execution.
   **/
  | 'Queued'
  /**
   * There is temporarily not enough weight to continue servicing messages.
   **/
  | 'InsufficientWeight'
  /**
   * This message is temporarily unprocessable.
   *
   * Such errors are expected, but not guaranteed, to resolve themselves eventually through
   * retrying.
   **/
  | 'TemporarilyUnprocessable'
  /**
   * The queue is paused and no message can be executed from it.
   *
   * This can change at any time and may resolve in the future by re-trying.
   **/
  | 'QueuePaused';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAssetRateError =
  /**
   * The given asset ID is unknown.
   **/
  | 'UnknownAssetKind'
  /**
   * The given asset ID already has an assigned conversion rate and cannot be re-created.
   **/
  | 'AlreadyExists';

export type SpRuntimeUncheckedExtrinsic = Bytes;

export type FrameSystemExtensionsCheckNonZeroSender = {};

export type FrameSystemExtensionsCheckSpecVersion = {};

export type FrameSystemExtensionsCheckTxVersion = {};

export type FrameSystemExtensionsCheckGenesis = {};

export type FrameSystemExtensionsCheckMortality = Era;

export type FrameSystemExtensionsCheckNonce = number;

export type FrameSystemExtensionsCheckWeight = {};

export type PalletTransactionPaymentChargeTransactionPayment = bigint;

export type StagingKusamaRuntimeRuntime = {};
