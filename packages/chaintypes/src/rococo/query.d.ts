// Generated by @dedot/codegen

import type { GenericChainStorage, GenericStorageQuery, Callback } from '@dedot/types';
import type {
  AccountId32Like,
  H256,
  Bytes,
  Digest,
  Phase,
  FixedBytes,
  AccountId32,
  FixedU128,
  BytesLike,
  EthereumAddressLike,
  EthereumAddress,
  Data,
  FixedArray,
} from '@dedot/codecs';
import type {
  FrameSystemAccountInfo,
  FrameSupportDispatchPerDispatchClass,
  FrameSystemEventRecord,
  FrameSystemLastRuntimeUpgradeInfo,
  FrameSystemCodeUpgradeAuthorization,
  SpConsensusBabeAppPublic,
  SpConsensusSlotsSlot,
  SpConsensusBabeDigestsNextConfigDescriptor,
  SpConsensusBabeDigestsPreDigest,
  SpConsensusBabeBabeEpochConfiguration,
  PalletBalancesAccountData,
  PalletBalancesBalanceLock,
  PalletBalancesReserveData,
  PalletBalancesIdAmount,
  PalletBalancesIdAmount002,
  PalletTransactionPaymentReleases,
  SpStakingOffenceOffenceDetails,
  RococoRuntimeSessionKeys,
  SpCoreCryptoKeyTypeId,
  PalletGrandpaStoredState,
  PalletGrandpaStoredPendingChange,
  SpConsensusGrandpaAppPublic,
  SpAuthorityDiscoveryAppPublic,
  PalletTreasuryProposal,
  PalletTreasurySpendStatus,
  PalletConvictionVotingVoteVoting,
  PalletReferendaReferendumInfo,
  PalletRankedCollectiveMemberRecord,
  PalletRankedCollectiveVoteRecord,
  PalletReferendaReferendumInfoTally,
  PolkadotRuntimeCommonClaimsStatementKind,
  PalletIdentityRegistration,
  PalletIdentityRegistrarInfo,
  PalletIdentityAuthorityProperties,
  PalletSocietyGroupParams,
  PalletSocietyMemberRecord,
  PalletSocietyPayoutRecord,
  PalletSocietyBid,
  PalletSocietyCandidacy,
  PalletSocietyVote,
  PalletSocietyIntakeRecord,
  PalletSocietyTally,
  PalletRecoveryRecoveryConfig,
  PalletRecoveryActiveRecovery,
  PalletVestingVestingInfo,
  PalletVestingReleases,
  PalletSchedulerScheduled,
  PalletSchedulerRetryConfig,
  PalletProxyProxyDefinition,
  PalletProxyAnnouncement,
  PalletMultisigMultisig,
  PalletPreimageOldRequestStatus,
  PalletPreimageRequestStatus,
  PolkadotRuntimeCommonImplsVersionedLocatableAsset,
  PalletBountiesBounty,
  PalletChildBountiesChildBounty,
  PalletNisBid,
  PalletNisSummaryRecord,
  PalletNisReceiptRecord,
  PolkadotRuntimeParachainsConfigurationHostConfiguration,
  PolkadotPrimitivesV6ValidatorIndex,
  PolkadotPrimitivesV6ValidatorAppPublic,
  PolkadotRuntimeParachainsSharedAllowedRelayParentsTracker,
  PolkadotRuntimeParachainsInclusionAvailabilityBitfieldRecord,
  PolkadotRuntimeParachainsInclusionCandidatePendingAvailability,
  PolkadotParachainPrimitivesPrimitivesId,
  PolkadotPrimitivesV6CandidateCommitments,
  PolkadotPrimitivesV6ScrapedOnChainVotes,
  PolkadotRuntimeParachainsSchedulerPalletCoreOccupied,
  PolkadotPrimitivesV6CoreIndex,
  PolkadotRuntimeParachainsSchedulerPalletParasEntry,
  PolkadotRuntimeParachainsParasPvfCheckActiveVoteState,
  PolkadotParachainPrimitivesPrimitivesValidationCodeHash,
  PolkadotRuntimeParachainsParasParaLifecycle,
  PolkadotParachainPrimitivesPrimitivesHeadData,
  PolkadotRuntimeParachainsParasParaPastCodeMeta,
  PolkadotPrimitivesV6UpgradeGoAhead,
  PolkadotPrimitivesV6UpgradeRestriction,
  PolkadotRuntimeParachainsParasParaGenesisArgs,
  PolkadotParachainPrimitivesPrimitivesValidationCode,
  PolkadotRuntimeParachainsInitializerBufferedSessionChange,
  PolkadotCorePrimitivesInboundDownwardMessage,
  PolkadotRuntimeParachainsHrmpHrmpOpenChannelRequest,
  PolkadotParachainPrimitivesPrimitivesHrmpChannelId,
  PolkadotRuntimeParachainsHrmpHrmpChannel,
  PolkadotCorePrimitivesInboundHrmpMessage,
  PolkadotPrimitivesV6AssignmentAppPublic,
  PolkadotPrimitivesV6SessionInfo,
  PolkadotPrimitivesV6ExecutorParams,
  PolkadotPrimitivesV6DisputeState,
  PolkadotCorePrimitivesCandidateHash,
  PolkadotPrimitivesV6SlashingPendingSlashes,
  PalletMessageQueueBookState,
  PolkadotRuntimeParachainsInclusionAggregateMessageOrigin,
  PalletMessageQueuePage,
  PolkadotRuntimeParachainsAssignerOnDemandEnqueuedOrder,
  PolkadotRuntimeParachainsAssignerOnDemandCoreAffinityCount,
  PolkadotRuntimeParachainsAssignerCoretimeSchedule,
  PolkadotRuntimeParachainsAssignerCoretimeCoreDescriptor,
  PolkadotRuntimeCommonParasRegistrarParaInfo,
  PolkadotRuntimeCommonCrowdloanFundInfo,
  PalletXcmQueryStatus,
  XcmVersionedLocation,
  SpWeightsWeightV2Weight,
  PalletXcmVersionMigrationStage,
  PalletXcmRemoteLockedFungibleRecord,
  XcmVersionedAssetId,
  SpConsensusBeefyEcdsaCryptoPublic,
  SpConsensusBeefyMmrBeefyAuthoritySet,
  PolkadotRuntimeCommonAssignedSlotsParachainTemporarySlot,
  PalletStateTrieMigrationMigrationTask,
  PalletStateTrieMigrationMigrationLimits,
} from './types';

export interface ChainStorage extends GenericChainStorage {
  /**
   * Pallet `System`'s storage queries
   **/
  system: {
    /**
     * The full account information for a particular account ID.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<FrameSystemAccountInfo> =} callback
     **/
    account: GenericStorageQuery<(arg: AccountId32Like) => FrameSystemAccountInfo>;

    /**
     * Total extrinsics count for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    extrinsicCount: GenericStorageQuery<() => number | undefined>;

    /**
     * The current weight for the block.
     *
     * @param {Callback<FrameSupportDispatchPerDispatchClass> =} callback
     **/
    blockWeight: GenericStorageQuery<() => FrameSupportDispatchPerDispatchClass>;

    /**
     * Total length (in bytes) for all extrinsics put together, for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    allExtrinsicsLen: GenericStorageQuery<() => number | undefined>;

    /**
     * Map of block numbers to block hashes.
     *
     * @param {number} arg
     * @param {Callback<H256> =} callback
     **/
    blockHash: GenericStorageQuery<(arg: number) => H256>;

    /**
     * Extrinsics data for the current block (maps an extrinsic's index to its data).
     *
     * @param {number} arg
     * @param {Callback<Bytes> =} callback
     **/
    extrinsicData: GenericStorageQuery<(arg: number) => Bytes>;

    /**
     * The current block number being processed. Set by `execute_block`.
     *
     * @param {Callback<number> =} callback
     **/
    number: GenericStorageQuery<() => number>;

    /**
     * Hash of the previous block.
     *
     * @param {Callback<H256> =} callback
     **/
    parentHash: GenericStorageQuery<() => H256>;

    /**
     * Digest of the current block, also part of the block header.
     *
     * @param {Callback<Digest> =} callback
     **/
    digest: GenericStorageQuery<() => Digest>;

    /**
     * Events deposited for the current block.
     *
     * NOTE: The item is unbound and should therefore never be read on chain.
     * It could otherwise inflate the PoV size of a block.
     *
     * Events have a large in-memory size. Box the events to not go out-of-memory
     * just in case someone still reads them from within the runtime.
     *
     * @param {Callback<Array<FrameSystemEventRecord>> =} callback
     **/
    events: GenericStorageQuery<() => Array<FrameSystemEventRecord>>;

    /**
     * The number of events in the `Events<T>` list.
     *
     * @param {Callback<number> =} callback
     **/
    eventCount: GenericStorageQuery<() => number>;

    /**
     * Mapping between a topic (represented by T::Hash) and a vector of indexes
     * of events in the `<Events<T>>` list.
     *
     * All topic vectors have deterministic storage locations depending on the topic. This
     * allows light-clients to leverage the changes trie storage tracking mechanism and
     * in case of changes fetch the list of events of interest.
     *
     * The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just
     * the `EventIndex` then in case if the topic has the same contents on the next block
     * no notification will be triggered thus the event might be lost.
     *
     * @param {H256} arg
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    eventTopics: GenericStorageQuery<(arg: H256) => Array<[number, number]>>;

    /**
     * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
     *
     * @param {Callback<FrameSystemLastRuntimeUpgradeInfo | undefined> =} callback
     **/
    lastRuntimeUpgrade: GenericStorageQuery<() => FrameSystemLastRuntimeUpgradeInfo | undefined>;

    /**
     * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToU32RefCount: GenericStorageQuery<() => boolean>;

    /**
     * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
     * (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToTripleRefCount: GenericStorageQuery<() => boolean>;

    /**
     * The execution phase of the block.
     *
     * @param {Callback<Phase | undefined> =} callback
     **/
    executionPhase: GenericStorageQuery<() => Phase | undefined>;

    /**
     * `Some` if a code upgrade has been authorized.
     *
     * @param {Callback<FrameSystemCodeUpgradeAuthorization | undefined> =} callback
     **/
    authorizedUpgrade: GenericStorageQuery<() => FrameSystemCodeUpgradeAuthorization | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Babe`'s storage queries
   **/
  babe: {
    /**
     * Current epoch index.
     *
     * @param {Callback<bigint> =} callback
     **/
    epochIndex: GenericStorageQuery<() => bigint>;

    /**
     * Current epoch authorities.
     *
     * @param {Callback<Array<[SpConsensusBabeAppPublic, bigint]>> =} callback
     **/
    authorities: GenericStorageQuery<() => Array<[SpConsensusBabeAppPublic, bigint]>>;

    /**
     * The slot at which the first epoch actually started. This is 0
     * until the first block of the chain.
     *
     * @param {Callback<SpConsensusSlotsSlot> =} callback
     **/
    genesisSlot: GenericStorageQuery<() => SpConsensusSlotsSlot>;

    /**
     * Current slot number.
     *
     * @param {Callback<SpConsensusSlotsSlot> =} callback
     **/
    currentSlot: GenericStorageQuery<() => SpConsensusSlotsSlot>;

    /**
     * The epoch randomness for the *current* epoch.
     *
     * # Security
     *
     * This MUST NOT be used for gambling, as it can be influenced by a
     * malicious validator in the short term. It MAY be used in many
     * cryptographic protocols, however, so long as one remembers that this
     * (like everything else on-chain) it is public. For example, it can be
     * used where a number is needed that cannot have been chosen by an
     * adversary, for purposes such as public-coin zero-knowledge proofs.
     *
     * @param {Callback<FixedBytes<32>> =} callback
     **/
    randomness: GenericStorageQuery<() => FixedBytes<32>>;

    /**
     * Pending epoch configuration change that will be applied when the next epoch is enacted.
     *
     * @param {Callback<SpConsensusBabeDigestsNextConfigDescriptor | undefined> =} callback
     **/
    pendingEpochConfigChange: GenericStorageQuery<() => SpConsensusBabeDigestsNextConfigDescriptor | undefined>;

    /**
     * Next epoch randomness.
     *
     * @param {Callback<FixedBytes<32>> =} callback
     **/
    nextRandomness: GenericStorageQuery<() => FixedBytes<32>>;

    /**
     * Next epoch authorities.
     *
     * @param {Callback<Array<[SpConsensusBabeAppPublic, bigint]>> =} callback
     **/
    nextAuthorities: GenericStorageQuery<() => Array<[SpConsensusBabeAppPublic, bigint]>>;

    /**
     * Randomness under construction.
     *
     * We make a trade-off between storage accesses and list length.
     * We store the under-construction randomness in segments of up to
     * `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.
     *
     * Once a segment reaches this length, we begin the next one.
     * We reset all segments and return to `0` at the beginning of every
     * epoch.
     *
     * @param {Callback<number> =} callback
     **/
    segmentIndex: GenericStorageQuery<() => number>;

    /**
     * TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay.
     *
     * @param {number} arg
     * @param {Callback<Array<FixedBytes<32>>> =} callback
     **/
    underConstruction: GenericStorageQuery<(arg: number) => Array<FixedBytes<32>>>;

    /**
     * Temporary value (cleared at block finalization) which is `Some`
     * if per-block initialization has already been called for current block.
     *
     * @param {Callback<SpConsensusBabeDigestsPreDigest | undefined | undefined> =} callback
     **/
    initialized: GenericStorageQuery<() => SpConsensusBabeDigestsPreDigest | undefined | undefined>;

    /**
     * This field should always be populated during block processing unless
     * secondary plain slots are enabled (which don't contain a VRF output).
     *
     * It is set in `on_finalize`, before it will contain the value from the last block.
     *
     * @param {Callback<FixedBytes<32> | undefined> =} callback
     **/
    authorVrfRandomness: GenericStorageQuery<() => FixedBytes<32> | undefined>;

    /**
     * The block numbers when the last and current epoch have started, respectively `N-1` and
     * `N`.
     * NOTE: We track this is in order to annotate the block number when a given pool of
     * entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in
     * slots, which may be skipped, the block numbers may not line up with the slot numbers.
     *
     * @param {Callback<[number, number]> =} callback
     **/
    epochStart: GenericStorageQuery<() => [number, number]>;

    /**
     * How late the current block is compared to its parent.
     *
     * This entry is populated as part of block execution and is cleaned up
     * on block finalization. Querying this storage entry outside of block
     * execution context should always yield zero.
     *
     * @param {Callback<number> =} callback
     **/
    lateness: GenericStorageQuery<() => number>;

    /**
     * The configuration for the current epoch. Should never be `None` as it is initialized in
     * genesis.
     *
     * @param {Callback<SpConsensusBabeBabeEpochConfiguration | undefined> =} callback
     **/
    epochConfig: GenericStorageQuery<() => SpConsensusBabeBabeEpochConfiguration | undefined>;

    /**
     * The configuration for the next epoch, `None` if the config will not change
     * (you can fallback to `EpochConfig` instead in that case).
     *
     * @param {Callback<SpConsensusBabeBabeEpochConfiguration | undefined> =} callback
     **/
    nextEpochConfig: GenericStorageQuery<() => SpConsensusBabeBabeEpochConfiguration | undefined>;

    /**
     * A list of the last 100 skipped epochs and the corresponding session index
     * when the epoch was skipped.
     *
     * This is only used for validating equivocation proofs. An equivocation proof
     * must contains a key-ownership proof for a given session, therefore we need a
     * way to tie together sessions and epoch indices, i.e. we need to validate that
     * a validator was the owner of a given key on a given session, and what the
     * active epoch index was during that session.
     *
     * @param {Callback<Array<[bigint, number]>> =} callback
     **/
    skippedEpochs: GenericStorageQuery<() => Array<[bigint, number]>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Timestamp`'s storage queries
   **/
  timestamp: {
    /**
     * The current time for the current block.
     *
     * @param {Callback<bigint> =} callback
     **/
    now: GenericStorageQuery<() => bigint>;

    /**
     * Whether the timestamp has been updated in this block.
     *
     * This value is updated to `true` upon successful submission of a timestamp by a node.
     * It is then checked at the end of each block execution in the `on_finalize` hook.
     *
     * @param {Callback<boolean> =} callback
     **/
    didUpdate: GenericStorageQuery<() => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Indices`'s storage queries
   **/
  indices: {
    /**
     * The lookup from index to account.
     *
     * @param {number} arg
     * @param {Callback<[AccountId32, bigint, boolean] | undefined> =} callback
     **/
    accounts: GenericStorageQuery<(arg: number) => [AccountId32, bigint, boolean] | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Balances`'s storage queries
   **/
  balances: {
    /**
     * The total units issued in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    totalIssuance: GenericStorageQuery<() => bigint>;

    /**
     * The total units of outstanding deactivated balance in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    inactiveIssuance: GenericStorageQuery<() => bigint>;

    /**
     * The Balances pallet example of storing the balance of an account.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
     * }
     * ```
     *
     * You can also store the balance of an account in the `System` pallet.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = System
     * }
     * ```
     *
     * But this comes with tradeoffs, storing account balances in the system pallet stores
     * `frame_system` data alongside the account data contrary to storing account balances in the
     * `Balances` pallet, which uses a `StorageMap` to store balances data only.
     * NOTE: This is only used in the case that this pallet is used to store balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletBalancesAccountData> =} callback
     **/
    account: GenericStorageQuery<(arg: AccountId32Like) => PalletBalancesAccountData>;

    /**
     * Any liquidity locks on some account balances.
     * NOTE: Should only be accessed when setting, changing and freeing a lock.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesBalanceLock>> =} callback
     **/
    locks: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesBalanceLock>>;

    /**
     * Named reserves on some account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesReserveData>> =} callback
     **/
    reserves: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesReserveData>>;

    /**
     * Holds on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesIdAmount>> =} callback
     **/
    holds: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesIdAmount>>;

    /**
     * Freeze locks on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesIdAmount002>> =} callback
     **/
    freezes: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesIdAmount002>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `TransactionPayment`'s storage queries
   **/
  transactionPayment: {
    /**
     *
     * @param {Callback<FixedU128> =} callback
     **/
    nextFeeMultiplier: GenericStorageQuery<() => FixedU128>;

    /**
     *
     * @param {Callback<PalletTransactionPaymentReleases> =} callback
     **/
    storageVersion: GenericStorageQuery<() => PalletTransactionPaymentReleases>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Authorship`'s storage queries
   **/
  authorship: {
    /**
     * Author of current block.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    author: GenericStorageQuery<() => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Offences`'s storage queries
   **/
  offences: {
    /**
     * The primary structure that holds all offence records keyed by report identifiers.
     *
     * @param {H256} arg
     * @param {Callback<SpStakingOffenceOffenceDetails | undefined> =} callback
     **/
    reports: GenericStorageQuery<(arg: H256) => SpStakingOffenceOffenceDetails | undefined>;

    /**
     * A vector of reports of the same kind that happened at the same time slot.
     *
     * @param {[FixedBytes<16>, BytesLike]} arg
     * @param {Callback<Array<H256>> =} callback
     **/
    concurrentReportsIndex: GenericStorageQuery<(arg: [FixedBytes<16>, BytesLike]) => Array<H256>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Historical`'s storage queries
   **/
  historical: {
    /**
     * Mapping from historical session indices to session-data root hash and validator count.
     *
     * @param {number} arg
     * @param {Callback<[H256, number] | undefined> =} callback
     **/
    historicalSessions: GenericStorageQuery<(arg: number) => [H256, number] | undefined>;

    /**
     * The range of historical sessions we store. [first, last)
     *
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    storedRange: GenericStorageQuery<() => [number, number] | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Session`'s storage queries
   **/
  session: {
    /**
     * The current set of validators.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    validators: GenericStorageQuery<() => Array<AccountId32>>;

    /**
     * Current index of the session.
     *
     * @param {Callback<number> =} callback
     **/
    currentIndex: GenericStorageQuery<() => number>;

    /**
     * True if the underlying economic identities or weighting behind the validators
     * has changed in the queued validator set.
     *
     * @param {Callback<boolean> =} callback
     **/
    queuedChanged: GenericStorageQuery<() => boolean>;

    /**
     * The queued keys for the next session. When the next session begins, these keys
     * will be used to determine the validator's session keys.
     *
     * @param {Callback<Array<[AccountId32, RococoRuntimeSessionKeys]>> =} callback
     **/
    queuedKeys: GenericStorageQuery<() => Array<[AccountId32, RococoRuntimeSessionKeys]>>;

    /**
     * Indices of disabled validators.
     *
     * The vec is always kept sorted so that we can find whether a given validator is
     * disabled using binary search. It gets cleared when `on_session_ending` returns
     * a new set of identities.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    disabledValidators: GenericStorageQuery<() => Array<number>>;

    /**
     * The next session keys for a validator.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<RococoRuntimeSessionKeys | undefined> =} callback
     **/
    nextKeys: GenericStorageQuery<(arg: AccountId32Like) => RococoRuntimeSessionKeys | undefined>;

    /**
     * The owner of a key. The key is the `KeyTypeId` + the encoded key.
     *
     * @param {[SpCoreCryptoKeyTypeId, BytesLike]} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    keyOwner: GenericStorageQuery<(arg: [SpCoreCryptoKeyTypeId, BytesLike]) => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Grandpa`'s storage queries
   **/
  grandpa: {
    /**
     * State of the current authority set.
     *
     * @param {Callback<PalletGrandpaStoredState> =} callback
     **/
    state: GenericStorageQuery<() => PalletGrandpaStoredState>;

    /**
     * Pending change: (signaled at, scheduled change).
     *
     * @param {Callback<PalletGrandpaStoredPendingChange | undefined> =} callback
     **/
    pendingChange: GenericStorageQuery<() => PalletGrandpaStoredPendingChange | undefined>;

    /**
     * next block number where we can force a change.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    nextForced: GenericStorageQuery<() => number | undefined>;

    /**
     * `true` if we are currently stalled.
     *
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    stalled: GenericStorageQuery<() => [number, number] | undefined>;

    /**
     * The number of changes (both in terms of keys and underlying economic responsibilities)
     * in the "set" of Grandpa validators from genesis.
     *
     * @param {Callback<bigint> =} callback
     **/
    currentSetId: GenericStorageQuery<() => bigint>;

    /**
     * A mapping from grandpa set ID to the index of the *most recent* session for which its
     * members were responsible.
     *
     * This is only used for validating equivocation proofs. An equivocation proof must
     * contains a key-ownership proof for a given session, therefore we need a way to tie
     * together sessions and GRANDPA set ids, i.e. we need to validate that a validator
     * was the owner of a given key on a given session, and what the active set ID was
     * during that session.
     *
     * TWOX-NOTE: `SetId` is not under user control.
     *
     * @param {bigint} arg
     * @param {Callback<number | undefined> =} callback
     **/
    setIdSession: GenericStorageQuery<(arg: bigint) => number | undefined>;

    /**
     * The current list of authorities.
     *
     * @param {Callback<Array<[SpConsensusGrandpaAppPublic, bigint]>> =} callback
     **/
    authorities: GenericStorageQuery<() => Array<[SpConsensusGrandpaAppPublic, bigint]>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `AuthorityDiscovery`'s storage queries
   **/
  authorityDiscovery: {
    /**
     * Keys of the current authority set.
     *
     * @param {Callback<Array<SpAuthorityDiscoveryAppPublic>> =} callback
     **/
    keys: GenericStorageQuery<() => Array<SpAuthorityDiscoveryAppPublic>>;

    /**
     * Keys of the next authority set.
     *
     * @param {Callback<Array<SpAuthorityDiscoveryAppPublic>> =} callback
     **/
    nextKeys: GenericStorageQuery<() => Array<SpAuthorityDiscoveryAppPublic>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Treasury`'s storage queries
   **/
  treasury: {
    /**
     * Number of proposals that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    proposalCount: GenericStorageQuery<() => number>;

    /**
     * Proposals that have been made.
     *
     * @param {number} arg
     * @param {Callback<PalletTreasuryProposal | undefined> =} callback
     **/
    proposals: GenericStorageQuery<(arg: number) => PalletTreasuryProposal | undefined>;

    /**
     * The amount which has been reported as inactive to Currency.
     *
     * @param {Callback<bigint> =} callback
     **/
    deactivated: GenericStorageQuery<() => bigint>;

    /**
     * Proposal indices that have been approved but not yet awarded.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    approvals: GenericStorageQuery<() => Array<number>>;

    /**
     * The count of spends that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    spendCount: GenericStorageQuery<() => number>;

    /**
     * Spends that have been approved and being processed.
     *
     * @param {number} arg
     * @param {Callback<PalletTreasurySpendStatus | undefined> =} callback
     **/
    spends: GenericStorageQuery<(arg: number) => PalletTreasurySpendStatus | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ConvictionVoting`'s storage queries
   **/
  convictionVoting: {
    /**
     * All voting for a particular voter in a particular voting class. We store the balance for the
     * number of votes that we have recorded.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<PalletConvictionVotingVoteVoting> =} callback
     **/
    votingFor: GenericStorageQuery<(arg: [AccountId32Like, number]) => PalletConvictionVotingVoteVoting>;

    /**
     * The voting classes which have a non-zero lock requirement and the lock amounts which they
     * require. The actual amount locked on behalf of this pallet should always be the maximum of
     * this list.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<[number, bigint]>> =} callback
     **/
    classLocksFor: GenericStorageQuery<(arg: AccountId32Like) => Array<[number, bigint]>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Referenda`'s storage queries
   **/
  referenda: {
    /**
     * The next free referendum index, aka the number of referenda started so far.
     *
     * @param {Callback<number> =} callback
     **/
    referendumCount: GenericStorageQuery<() => number>;

    /**
     * Information concerning any given referendum.
     *
     * @param {number} arg
     * @param {Callback<PalletReferendaReferendumInfo | undefined> =} callback
     **/
    referendumInfoFor: GenericStorageQuery<(arg: number) => PalletReferendaReferendumInfo | undefined>;

    /**
     * The sorted list of referenda ready to be decided but not yet being decided, ordered by
     * conviction-weighted approvals.
     *
     * This should be empty if `DecidingCount` is less than `TrackInfo::max_deciding`.
     *
     * @param {number} arg
     * @param {Callback<Array<[number, bigint]>> =} callback
     **/
    trackQueue: GenericStorageQuery<(arg: number) => Array<[number, bigint]>>;

    /**
     * The number of referenda being decided currently.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    decidingCount: GenericStorageQuery<(arg: number) => number>;

    /**
     * The metadata is a general information concerning the referendum.
     * The `Hash` refers to the preimage of the `Preimages` provider which can be a JSON
     * dump or IPFS hash of a JSON file.
     *
     * Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
     * large preimages.
     *
     * @param {number} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    metadataOf: GenericStorageQuery<(arg: number) => H256 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `FellowshipCollective`'s storage queries
   **/
  fellowshipCollective: {
    /**
     * The number of members in the collective who have at least the rank according to the index
     * of the vec.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    memberCount: GenericStorageQuery<(arg: number) => number>;

    /**
     * The current members of the collective.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletRankedCollectiveMemberRecord | undefined> =} callback
     **/
    members: GenericStorageQuery<(arg: AccountId32Like) => PalletRankedCollectiveMemberRecord | undefined>;

    /**
     * The index of each ranks's member into the group of members who have at least that rank.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    idToIndex: GenericStorageQuery<(arg: [number, AccountId32Like]) => number | undefined>;

    /**
     * The members in the collective by index. All indices in the range `0..MemberCount` will
     * return `Some`, however a member's index is not guaranteed to remain unchanged over time.
     *
     * @param {[number, number]} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    indexToId: GenericStorageQuery<(arg: [number, number]) => AccountId32 | undefined>;

    /**
     * Votes on a given proposal, if it is ongoing.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletRankedCollectiveVoteRecord | undefined> =} callback
     **/
    voting: GenericStorageQuery<(arg: [number, AccountId32Like]) => PalletRankedCollectiveVoteRecord | undefined>;

    /**
     *
     * @param {number} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    votingCleanup: GenericStorageQuery<(arg: number) => Bytes | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `FellowshipReferenda`'s storage queries
   **/
  fellowshipReferenda: {
    /**
     * The next free referendum index, aka the number of referenda started so far.
     *
     * @param {Callback<number> =} callback
     **/
    referendumCount: GenericStorageQuery<() => number>;

    /**
     * Information concerning any given referendum.
     *
     * @param {number} arg
     * @param {Callback<PalletReferendaReferendumInfoTally | undefined> =} callback
     **/
    referendumInfoFor: GenericStorageQuery<(arg: number) => PalletReferendaReferendumInfoTally | undefined>;

    /**
     * The sorted list of referenda ready to be decided but not yet being decided, ordered by
     * conviction-weighted approvals.
     *
     * This should be empty if `DecidingCount` is less than `TrackInfo::max_deciding`.
     *
     * @param {number} arg
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    trackQueue: GenericStorageQuery<(arg: number) => Array<[number, number]>>;

    /**
     * The number of referenda being decided currently.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    decidingCount: GenericStorageQuery<(arg: number) => number>;

    /**
     * The metadata is a general information concerning the referendum.
     * The `Hash` refers to the preimage of the `Preimages` provider which can be a JSON
     * dump or IPFS hash of a JSON file.
     *
     * Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
     * large preimages.
     *
     * @param {number} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    metadataOf: GenericStorageQuery<(arg: number) => H256 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Whitelist`'s storage queries
   **/
  whitelist: {
    /**
     *
     * @param {H256} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    whitelistedCall: GenericStorageQuery<(arg: H256) => [] | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Claims`'s storage queries
   **/
  claims: {
    /**
     *
     * @param {EthereumAddressLike} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    claims: GenericStorageQuery<(arg: EthereumAddressLike) => bigint | undefined>;

    /**
     *
     * @param {Callback<bigint> =} callback
     **/
    total: GenericStorageQuery<() => bigint>;

    /**
     * Vesting schedule for a claim.
     * First balance is the total amount that should be held for vesting.
     * Second balance is how much should be unlocked per block.
     * The block number is when the vesting should start.
     *
     * @param {EthereumAddressLike} arg
     * @param {Callback<[bigint, bigint, number] | undefined> =} callback
     **/
    vesting: GenericStorageQuery<(arg: EthereumAddressLike) => [bigint, bigint, number] | undefined>;

    /**
     * The statement kind that must be signed, if any.
     *
     * @param {EthereumAddressLike} arg
     * @param {Callback<PolkadotRuntimeCommonClaimsStatementKind | undefined> =} callback
     **/
    signing: GenericStorageQuery<(arg: EthereumAddressLike) => PolkadotRuntimeCommonClaimsStatementKind | undefined>;

    /**
     * Pre-claimed Ethereum accounts, by the Account ID that they are claimed to.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<EthereumAddress | undefined> =} callback
     **/
    preclaims: GenericStorageQuery<(arg: AccountId32Like) => EthereumAddress | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Identity`'s storage queries
   **/
  identity: {
    /**
     * Information that is pertinent to identify the entity behind an account. First item is the
     * registration, second is the account's primary username.
     *
     * TWOX-NOTE: OK ― `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[PalletIdentityRegistration, Bytes | undefined] | undefined> =} callback
     **/
    identityOf: GenericStorageQuery<
      (arg: AccountId32Like) => [PalletIdentityRegistration, Bytes | undefined] | undefined
    >;

    /**
     * The super-identity of an alternative "sub" identity together with its name, within that
     * context. If the account is not some other account's sub-identity, then just `None`.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[AccountId32, Data] | undefined> =} callback
     **/
    superOf: GenericStorageQuery<(arg: AccountId32Like) => [AccountId32, Data] | undefined>;

    /**
     * Alternative "sub" identities of this account.
     *
     * The first item is the deposit, the second is a vector of the accounts.
     *
     * TWOX-NOTE: OK ― `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[bigint, Array<AccountId32>]> =} callback
     **/
    subsOf: GenericStorageQuery<(arg: AccountId32Like) => [bigint, Array<AccountId32>]>;

    /**
     * The set of registrars. Not expected to get very big as can only be added through a
     * special origin (likely a council motion).
     *
     * The index into this can be cast to `RegistrarIndex` to get a valid value.
     *
     * @param {Callback<Array<PalletIdentityRegistrarInfo | undefined>> =} callback
     **/
    registrars: GenericStorageQuery<() => Array<PalletIdentityRegistrarInfo | undefined>>;

    /**
     * A map of the accounts who are authorized to grant usernames.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletIdentityAuthorityProperties | undefined> =} callback
     **/
    usernameAuthorities: GenericStorageQuery<(arg: AccountId32Like) => PalletIdentityAuthorityProperties | undefined>;

    /**
     * Reverse lookup from `username` to the `AccountId` that has registered it. The value should
     * be a key in the `IdentityOf` map, but it may not if the user has cleared their identity.
     *
     * Multiple usernames may map to the same `AccountId`, but `IdentityOf` will only map to one
     * primary username.
     *
     * @param {BytesLike} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    accountOfUsername: GenericStorageQuery<(arg: BytesLike) => AccountId32 | undefined>;

    /**
     * Usernames that an authority has granted, but that the account controller has not confirmed
     * that they want it. Used primarily in cases where the `AccountId` cannot provide a signature
     * because they are a pure proxy, multisig, etc. In order to confirm it, they should call
     * [`Call::accept_username`].
     *
     * First tuple item is the account and second is the acceptance deadline.
     *
     * @param {BytesLike} arg
     * @param {Callback<[AccountId32, number] | undefined> =} callback
     **/
    pendingUsernames: GenericStorageQuery<(arg: BytesLike) => [AccountId32, number] | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Society`'s storage queries
   **/
  society: {
    /**
     * The max number of members for the society at one time.
     *
     * @param {Callback<PalletSocietyGroupParams | undefined> =} callback
     **/
    parameters: GenericStorageQuery<() => PalletSocietyGroupParams | undefined>;

    /**
     * Amount of our account balance that is specifically for the next round's bid(s).
     *
     * @param {Callback<bigint> =} callback
     **/
    pot: GenericStorageQuery<() => bigint>;

    /**
     * The first member.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    founder: GenericStorageQuery<() => AccountId32 | undefined>;

    /**
     * The most primary from the most recently approved rank 0 members in the society.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    head: GenericStorageQuery<() => AccountId32 | undefined>;

    /**
     * A hash of the rules of this society concerning membership. Can only be set once and
     * only by the founder.
     *
     * @param {Callback<H256 | undefined> =} callback
     **/
    rules: GenericStorageQuery<() => H256 | undefined>;

    /**
     * The current members and their rank. Doesn't include `SuspendedMembers`.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletSocietyMemberRecord | undefined> =} callback
     **/
    members: GenericStorageQuery<(arg: AccountId32Like) => PalletSocietyMemberRecord | undefined>;

    /**
     * Information regarding rank-0 payouts, past and future.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletSocietyPayoutRecord> =} callback
     **/
    payouts: GenericStorageQuery<(arg: AccountId32Like) => PalletSocietyPayoutRecord>;

    /**
     * The number of items in `Members` currently. (Doesn't include `SuspendedMembers`.)
     *
     * @param {Callback<number> =} callback
     **/
    memberCount: GenericStorageQuery<() => number>;

    /**
     * The current items in `Members` keyed by their unique index. Keys are densely populated
     * `0..MemberCount` (does not include `MemberCount`).
     *
     * @param {number} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    memberByIndex: GenericStorageQuery<(arg: number) => AccountId32 | undefined>;

    /**
     * The set of suspended members, with their old membership record.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletSocietyMemberRecord | undefined> =} callback
     **/
    suspendedMembers: GenericStorageQuery<(arg: AccountId32Like) => PalletSocietyMemberRecord | undefined>;

    /**
     * The number of rounds which have passed.
     *
     * @param {Callback<number> =} callback
     **/
    roundCount: GenericStorageQuery<() => number>;

    /**
     * The current bids, stored ordered by the value of the bid.
     *
     * @param {Callback<Array<PalletSocietyBid>> =} callback
     **/
    bids: GenericStorageQuery<() => Array<PalletSocietyBid>>;

    /**
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletSocietyCandidacy | undefined> =} callback
     **/
    candidates: GenericStorageQuery<(arg: AccountId32Like) => PalletSocietyCandidacy | undefined>;

    /**
     * The current skeptic.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    skeptic: GenericStorageQuery<() => AccountId32 | undefined>;

    /**
     * Double map from Candidate -> Voter -> (Maybe) Vote.
     *
     * @param {[AccountId32Like, AccountId32Like]} arg
     * @param {Callback<PalletSocietyVote | undefined> =} callback
     **/
    votes: GenericStorageQuery<(arg: [AccountId32Like, AccountId32Like]) => PalletSocietyVote | undefined>;

    /**
     * Clear-cursor for Vote, map from Candidate -> (Maybe) Cursor.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    voteClearCursor: GenericStorageQuery<(arg: AccountId32Like) => Bytes | undefined>;

    /**
     * At the end of the claim period, this contains the most recently approved members (along with
     * their bid and round ID) who is from the most recent round with the lowest bid. They will
     * become the new `Head`.
     *
     * @param {Callback<PalletSocietyIntakeRecord | undefined> =} callback
     **/
    nextHead: GenericStorageQuery<() => PalletSocietyIntakeRecord | undefined>;

    /**
     * The number of challenge rounds there have been. Used to identify stale DefenderVotes.
     *
     * @param {Callback<number> =} callback
     **/
    challengeRoundCount: GenericStorageQuery<() => number>;

    /**
     * The defending member currently being challenged, along with a running tally of votes.
     *
     * @param {Callback<[AccountId32, AccountId32, PalletSocietyTally] | undefined> =} callback
     **/
    defending: GenericStorageQuery<() => [AccountId32, AccountId32, PalletSocietyTally] | undefined>;

    /**
     * Votes for the defender, keyed by challenge round.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletSocietyVote | undefined> =} callback
     **/
    defenderVotes: GenericStorageQuery<(arg: [number, AccountId32Like]) => PalletSocietyVote | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Recovery`'s storage queries
   **/
  recovery: {
    /**
     * The set of recoverable accounts and their recovery configuration.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletRecoveryRecoveryConfig | undefined> =} callback
     **/
    recoverable: GenericStorageQuery<(arg: AccountId32Like) => PalletRecoveryRecoveryConfig | undefined>;

    /**
     * Active recovery attempts.
     *
     * First account is the account to be recovered, and the second account
     * is the user trying to recover the account.
     *
     * @param {[AccountId32Like, AccountId32Like]} arg
     * @param {Callback<PalletRecoveryActiveRecovery | undefined> =} callback
     **/
    activeRecoveries: GenericStorageQuery<
      (arg: [AccountId32Like, AccountId32Like]) => PalletRecoveryActiveRecovery | undefined
    >;

    /**
     * The list of allowed proxy accounts.
     *
     * Map from the user who can access it to the recovered account.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    proxy: GenericStorageQuery<(arg: AccountId32Like) => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Vesting`'s storage queries
   **/
  vesting: {
    /**
     * Information regarding the vesting of a given account.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletVestingVestingInfo> | undefined> =} callback
     **/
    vesting: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletVestingVestingInfo> | undefined>;

    /**
     * Storage version of the pallet.
     *
     * New networks start with latest version, as determined by the genesis build.
     *
     * @param {Callback<PalletVestingReleases> =} callback
     **/
    storageVersion: GenericStorageQuery<() => PalletVestingReleases>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Scheduler`'s storage queries
   **/
  scheduler: {
    /**
     *
     * @param {Callback<number | undefined> =} callback
     **/
    incompleteSince: GenericStorageQuery<() => number | undefined>;

    /**
     * Items to be executed, indexed by the block number that they should be executed on.
     *
     * @param {number} arg
     * @param {Callback<Array<PalletSchedulerScheduled | undefined>> =} callback
     **/
    agenda: GenericStorageQuery<(arg: number) => Array<PalletSchedulerScheduled | undefined>>;

    /**
     * Retry configurations for items to be executed, indexed by task address.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletSchedulerRetryConfig | undefined> =} callback
     **/
    retries: GenericStorageQuery<(arg: [number, number]) => PalletSchedulerRetryConfig | undefined>;

    /**
     * Lookup from a name to the block number and index of the task.
     *
     * For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
     * identities.
     *
     * @param {FixedBytes<32>} arg
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    lookup: GenericStorageQuery<(arg: FixedBytes<32>) => [number, number] | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Proxy`'s storage queries
   **/
  proxy: {
    /**
     * The set of account proxies. Maps the account which has delegated to the accounts
     * which are being delegated to, together with the amount held on deposit.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyProxyDefinition>, bigint]> =} callback
     **/
    proxies: GenericStorageQuery<(arg: AccountId32Like) => [Array<PalletProxyProxyDefinition>, bigint]>;

    /**
     * The announcements made by the proxy (key).
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyAnnouncement>, bigint]> =} callback
     **/
    announcements: GenericStorageQuery<(arg: AccountId32Like) => [Array<PalletProxyAnnouncement>, bigint]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Multisig`'s storage queries
   **/
  multisig: {
    /**
     * The set of open multisig operations.
     *
     * @param {[AccountId32Like, FixedBytes<32>]} arg
     * @param {Callback<PalletMultisigMultisig | undefined> =} callback
     **/
    multisigs: GenericStorageQuery<(arg: [AccountId32Like, FixedBytes<32>]) => PalletMultisigMultisig | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Preimage`'s storage queries
   **/
  preimage: {
    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageOldRequestStatus | undefined> =} callback
     **/
    statusFor: GenericStorageQuery<(arg: H256) => PalletPreimageOldRequestStatus | undefined>;

    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageRequestStatus | undefined> =} callback
     **/
    requestStatusFor: GenericStorageQuery<(arg: H256) => PalletPreimageRequestStatus | undefined>;

    /**
     *
     * @param {[H256, number]} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    preimageFor: GenericStorageQuery<(arg: [H256, number]) => Bytes | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `AssetRate`'s storage queries
   **/
  assetRate: {
    /**
     * Maps an asset to its fixed point representation in the native balance.
     *
     * E.g. `native_amount = asset_amount * ConversionRateToNative::<T>::get(asset_kind)`
     *
     * @param {PolkadotRuntimeCommonImplsVersionedLocatableAsset} arg
     * @param {Callback<FixedU128 | undefined> =} callback
     **/
    conversionRateToNative: GenericStorageQuery<
      (arg: PolkadotRuntimeCommonImplsVersionedLocatableAsset) => FixedU128 | undefined
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Bounties`'s storage queries
   **/
  bounties: {
    /**
     * Number of bounty proposals that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    bountyCount: GenericStorageQuery<() => number>;

    /**
     * Bounties that have been made.
     *
     * @param {number} arg
     * @param {Callback<PalletBountiesBounty | undefined> =} callback
     **/
    bounties: GenericStorageQuery<(arg: number) => PalletBountiesBounty | undefined>;

    /**
     * The description of each bounty.
     *
     * @param {number} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    bountyDescriptions: GenericStorageQuery<(arg: number) => Bytes | undefined>;

    /**
     * Bounty indices that have been approved but not yet funded.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    bountyApprovals: GenericStorageQuery<() => Array<number>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ChildBounties`'s storage queries
   **/
  childBounties: {
    /**
     * Number of total child bounties.
     *
     * @param {Callback<number> =} callback
     **/
    childBountyCount: GenericStorageQuery<() => number>;

    /**
     * Number of child bounties per parent bounty.
     * Map of parent bounty index to number of child bounties.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    parentChildBounties: GenericStorageQuery<(arg: number) => number>;

    /**
     * Child bounties that have been added.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletChildBountiesChildBounty | undefined> =} callback
     **/
    childBounties: GenericStorageQuery<(arg: [number, number]) => PalletChildBountiesChildBounty | undefined>;

    /**
     * The description of each child-bounty.
     *
     * @param {number} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    childBountyDescriptions: GenericStorageQuery<(arg: number) => Bytes | undefined>;

    /**
     * The cumulative child-bounty curator fee for each parent bounty.
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    childrenCuratorFees: GenericStorageQuery<(arg: number) => bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Nis`'s storage queries
   **/
  nis: {
    /**
     * The totals of items and balances within each queue. Saves a lot of storage reads in the
     * case of sparsely packed queues.
     *
     * The vector is indexed by duration in `Period`s, offset by one, so information on the queue
     * whose duration is one `Period` would be storage `0`.
     *
     * @param {Callback<Array<[number, bigint]>> =} callback
     **/
    queueTotals: GenericStorageQuery<() => Array<[number, bigint]>>;

    /**
     * The queues of bids. Indexed by duration (in `Period`s).
     *
     * @param {number} arg
     * @param {Callback<Array<PalletNisBid>> =} callback
     **/
    queues: GenericStorageQuery<(arg: number) => Array<PalletNisBid>>;

    /**
     * Summary information over the general state.
     *
     * @param {Callback<PalletNisSummaryRecord> =} callback
     **/
    summary: GenericStorageQuery<() => PalletNisSummaryRecord>;

    /**
     * The currently outstanding receipts, indexed according to the order of creation.
     *
     * @param {number} arg
     * @param {Callback<PalletNisReceiptRecord | undefined> =} callback
     **/
    receipts: GenericStorageQuery<(arg: number) => PalletNisReceiptRecord | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `NisCounterpartBalances`'s storage queries
   **/
  nisCounterpartBalances: {
    /**
     * The total units issued in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    totalIssuance: GenericStorageQuery<() => bigint>;

    /**
     * The total units of outstanding deactivated balance in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    inactiveIssuance: GenericStorageQuery<() => bigint>;

    /**
     * The Balances pallet example of storing the balance of an account.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
     * }
     * ```
     *
     * You can also store the balance of an account in the `System` pallet.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = System
     * }
     * ```
     *
     * But this comes with tradeoffs, storing account balances in the system pallet stores
     * `frame_system` data alongside the account data contrary to storing account balances in the
     * `Balances` pallet, which uses a `StorageMap` to store balances data only.
     * NOTE: This is only used in the case that this pallet is used to store balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletBalancesAccountData> =} callback
     **/
    account: GenericStorageQuery<(arg: AccountId32Like) => PalletBalancesAccountData>;

    /**
     * Any liquidity locks on some account balances.
     * NOTE: Should only be accessed when setting, changing and freeing a lock.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesBalanceLock>> =} callback
     **/
    locks: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesBalanceLock>>;

    /**
     * Named reserves on some account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesReserveData>> =} callback
     **/
    reserves: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesReserveData>>;

    /**
     * Holds on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesIdAmount>> =} callback
     **/
    holds: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesIdAmount>>;

    /**
     * Freeze locks on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesIdAmount002>> =} callback
     **/
    freezes: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesIdAmount002>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Configuration`'s storage queries
   **/
  configuration: {
    /**
     * The active configuration for the current session.
     *
     * @param {Callback<PolkadotRuntimeParachainsConfigurationHostConfiguration> =} callback
     **/
    activeConfig: GenericStorageQuery<() => PolkadotRuntimeParachainsConfigurationHostConfiguration>;

    /**
     * Pending configuration changes.
     *
     * This is a list of configuration changes, each with a session index at which it should
     * be applied.
     *
     * The list is sorted ascending by session index. Also, this list can only contain at most
     * 2 items: for the next session and for the `scheduled_session`.
     *
     * @param {Callback<Array<[number, PolkadotRuntimeParachainsConfigurationHostConfiguration]>> =} callback
     **/
    pendingConfigs: GenericStorageQuery<() => Array<[number, PolkadotRuntimeParachainsConfigurationHostConfiguration]>>;

    /**
     * If this is set, then the configuration setters will bypass the consistency checks. This
     * is meant to be used only as the last resort.
     *
     * @param {Callback<boolean> =} callback
     **/
    bypassConsistencyCheck: GenericStorageQuery<() => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ParasShared`'s storage queries
   **/
  parasShared: {
    /**
     * The current session index.
     *
     * @param {Callback<number> =} callback
     **/
    currentSessionIndex: GenericStorageQuery<() => number>;

    /**
     * All the validators actively participating in parachain consensus.
     * Indices are into the broader validator set.
     *
     * @param {Callback<Array<PolkadotPrimitivesV6ValidatorIndex>> =} callback
     **/
    activeValidatorIndices: GenericStorageQuery<() => Array<PolkadotPrimitivesV6ValidatorIndex>>;

    /**
     * The parachain attestation keys of the validators actively participating in parachain
     * consensus. This should be the same length as `ActiveValidatorIndices`.
     *
     * @param {Callback<Array<PolkadotPrimitivesV6ValidatorAppPublic>> =} callback
     **/
    activeValidatorKeys: GenericStorageQuery<() => Array<PolkadotPrimitivesV6ValidatorAppPublic>>;

    /**
     * All allowed relay-parents.
     *
     * @param {Callback<PolkadotRuntimeParachainsSharedAllowedRelayParentsTracker> =} callback
     **/
    allowedRelayParents: GenericStorageQuery<() => PolkadotRuntimeParachainsSharedAllowedRelayParentsTracker>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ParaInclusion`'s storage queries
   **/
  paraInclusion: {
    /**
     * The latest bitfield for each validator, referred to by their index in the validator set.
     *
     * @param {PolkadotPrimitivesV6ValidatorIndex} arg
     * @param {Callback<PolkadotRuntimeParachainsInclusionAvailabilityBitfieldRecord | undefined> =} callback
     **/
    availabilityBitfields: GenericStorageQuery<
      (
        arg: PolkadotPrimitivesV6ValidatorIndex,
      ) => PolkadotRuntimeParachainsInclusionAvailabilityBitfieldRecord | undefined
    >;

    /**
     * Candidates pending availability by `ParaId`.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<PolkadotRuntimeParachainsInclusionCandidatePendingAvailability | undefined> =} callback
     **/
    pendingAvailability: GenericStorageQuery<
      (
        arg: PolkadotParachainPrimitivesPrimitivesId,
      ) => PolkadotRuntimeParachainsInclusionCandidatePendingAvailability | undefined
    >;

    /**
     * The commitments of candidates pending availability, by `ParaId`.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<PolkadotPrimitivesV6CandidateCommitments | undefined> =} callback
     **/
    pendingAvailabilityCommitments: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => PolkadotPrimitivesV6CandidateCommitments | undefined
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ParaInherent`'s storage queries
   **/
  paraInherent: {
    /**
     * Whether the paras inherent was included within this block.
     *
     * The `Option<()>` is effectively a `bool`, but it never hits storage in the `None` variant
     * due to the guarantees of FRAME's storage APIs.
     *
     * If this is `None` at the end of the block, we panic and render the block invalid.
     *
     * @param {Callback<[] | undefined> =} callback
     **/
    included: GenericStorageQuery<() => [] | undefined>;

    /**
     * Scraped on chain data for extracting resolved disputes as well as backing votes.
     *
     * @param {Callback<PolkadotPrimitivesV6ScrapedOnChainVotes | undefined> =} callback
     **/
    onChainVotes: GenericStorageQuery<() => PolkadotPrimitivesV6ScrapedOnChainVotes | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ParaScheduler`'s storage queries
   **/
  paraScheduler: {
    /**
     * All the validator groups. One for each core. Indices are into `ActiveValidators` - not the
     * broader set of Polkadot validators, but instead just the subset used for parachains during
     * this session.
     *
     * Bound: The number of cores is the sum of the numbers of parachains and parathread
     * multiplexers. Reasonably, 100-1000. The dominant factor is the number of validators: safe
     * upper bound at 10k.
     *
     * @param {Callback<Array<Array<PolkadotPrimitivesV6ValidatorIndex>>> =} callback
     **/
    validatorGroups: GenericStorageQuery<() => Array<Array<PolkadotPrimitivesV6ValidatorIndex>>>;

    /**
     * One entry for each availability core. Entries are `None` if the core is not currently
     * occupied. Can be temporarily `Some` if scheduled but not occupied.
     * The i'th parachain belongs to the i'th core, with the remaining cores all being
     * parathread-multiplexers.
     *
     * Bounded by the maximum of either of these two values:
     * * The number of parachains and parathread multiplexers
     * * The number of validators divided by `configuration.max_validators_per_core`.
     *
     * @param {Callback<Array<PolkadotRuntimeParachainsSchedulerPalletCoreOccupied>> =} callback
     **/
    availabilityCores: GenericStorageQuery<() => Array<PolkadotRuntimeParachainsSchedulerPalletCoreOccupied>>;

    /**
     * The block number where the session start occurred. Used to track how many group rotations
     * have occurred.
     *
     * Note that in the context of parachains modules the session change is signaled during
     * the block and enacted at the end of the block (at the finalization stage, to be exact).
     * Thus for all intents and purposes the effect of the session change is observed at the
     * block following the session change, block number of which we save in this storage value.
     *
     * @param {Callback<number> =} callback
     **/
    sessionStartBlock: GenericStorageQuery<() => number>;

    /**
     * One entry for each availability core. The `VecDeque` represents the assignments to be
     * scheduled on that core. The value contained here will not be valid after the end of
     * a block. Runtime APIs should be used to determine scheduled cores/ for the upcoming block.
     *
     * @param {Callback<Array<[PolkadotPrimitivesV6CoreIndex, Array<PolkadotRuntimeParachainsSchedulerPalletParasEntry>]>> =} callback
     **/
    claimQueue: GenericStorageQuery<
      () => Array<[PolkadotPrimitivesV6CoreIndex, Array<PolkadotRuntimeParachainsSchedulerPalletParasEntry>]>
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Paras`'s storage queries
   **/
  paras: {
    /**
     * All currently active PVF pre-checking votes.
     *
     * Invariant:
     * - There are no PVF pre-checking votes that exists in list but not in the set and vice versa.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesValidationCodeHash} arg
     * @param {Callback<PolkadotRuntimeParachainsParasPvfCheckActiveVoteState | undefined> =} callback
     **/
    pvfActiveVoteMap: GenericStorageQuery<
      (
        arg: PolkadotParachainPrimitivesPrimitivesValidationCodeHash,
      ) => PolkadotRuntimeParachainsParasPvfCheckActiveVoteState | undefined
    >;

    /**
     * The list of all currently active PVF votes. Auxiliary to `PvfActiveVoteMap`.
     *
     * @param {Callback<Array<PolkadotParachainPrimitivesPrimitivesValidationCodeHash>> =} callback
     **/
    pvfActiveVoteList: GenericStorageQuery<() => Array<PolkadotParachainPrimitivesPrimitivesValidationCodeHash>>;

    /**
     * All lease holding parachains. Ordered ascending by `ParaId`. On demand parachains are not
     * included.
     *
     * Consider using the [`ParachainsCache`] type of modifying.
     *
     * @param {Callback<Array<PolkadotParachainPrimitivesPrimitivesId>> =} callback
     **/
    parachains: GenericStorageQuery<() => Array<PolkadotParachainPrimitivesPrimitivesId>>;

    /**
     * The current lifecycle of a all known Para IDs.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<PolkadotRuntimeParachainsParasParaLifecycle | undefined> =} callback
     **/
    paraLifecycles: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => PolkadotRuntimeParachainsParasParaLifecycle | undefined
    >;

    /**
     * The head-data of every registered para.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<PolkadotParachainPrimitivesPrimitivesHeadData | undefined> =} callback
     **/
    heads: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => PolkadotParachainPrimitivesPrimitivesHeadData | undefined
    >;

    /**
     * The context (relay-chain block number) of the most recent parachain head.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<number | undefined> =} callback
     **/
    mostRecentContext: GenericStorageQuery<(arg: PolkadotParachainPrimitivesPrimitivesId) => number | undefined>;

    /**
     * The validation code hash of every live para.
     *
     * Corresponding code can be retrieved with [`CodeByHash`].
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<PolkadotParachainPrimitivesPrimitivesValidationCodeHash | undefined> =} callback
     **/
    currentCodeHash: GenericStorageQuery<
      (
        arg: PolkadotParachainPrimitivesPrimitivesId,
      ) => PolkadotParachainPrimitivesPrimitivesValidationCodeHash | undefined
    >;

    /**
     * Actual past code hash, indicated by the para id as well as the block number at which it
     * became outdated.
     *
     * Corresponding code can be retrieved with [`CodeByHash`].
     *
     * @param {[PolkadotParachainPrimitivesPrimitivesId, number]} arg
     * @param {Callback<PolkadotParachainPrimitivesPrimitivesValidationCodeHash | undefined> =} callback
     **/
    pastCodeHash: GenericStorageQuery<
      (
        arg: [PolkadotParachainPrimitivesPrimitivesId, number],
      ) => PolkadotParachainPrimitivesPrimitivesValidationCodeHash | undefined
    >;

    /**
     * Past code of parachains. The parachains themselves may not be registered anymore,
     * but we also keep their code on-chain for the same amount of time as outdated code
     * to keep it available for approval checkers.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<PolkadotRuntimeParachainsParasParaPastCodeMeta> =} callback
     **/
    pastCodeMeta: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => PolkadotRuntimeParachainsParasParaPastCodeMeta
    >;

    /**
     * Which paras have past code that needs pruning and the relay-chain block at which the code
     * was replaced. Note that this is the actual height of the included block, not the expected
     * height at which the code upgrade would be applied, although they may be equal.
     * This is to ensure the entire acceptance period is covered, not an offset acceptance period
     * starting from the time at which the parachain perceives a code upgrade as having occurred.
     * Multiple entries for a single para are permitted. Ordered ascending by block number.
     *
     * @param {Callback<Array<[PolkadotParachainPrimitivesPrimitivesId, number]>> =} callback
     **/
    pastCodePruning: GenericStorageQuery<() => Array<[PolkadotParachainPrimitivesPrimitivesId, number]>>;

    /**
     * The block number at which the planned code change is expected for a para.
     * The change will be applied after the first parablock for this ID included which executes
     * in the context of a relay chain block with a number >= `expected_at`.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<number | undefined> =} callback
     **/
    futureCodeUpgrades: GenericStorageQuery<(arg: PolkadotParachainPrimitivesPrimitivesId) => number | undefined>;

    /**
     * The actual future code hash of a para.
     *
     * Corresponding code can be retrieved with [`CodeByHash`].
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<PolkadotParachainPrimitivesPrimitivesValidationCodeHash | undefined> =} callback
     **/
    futureCodeHash: GenericStorageQuery<
      (
        arg: PolkadotParachainPrimitivesPrimitivesId,
      ) => PolkadotParachainPrimitivesPrimitivesValidationCodeHash | undefined
    >;

    /**
     * This is used by the relay-chain to communicate to a parachain a go-ahead with in the upgrade
     * procedure.
     *
     * This value is absent when there are no upgrades scheduled or during the time the relay chain
     * performs the checks. It is set at the first relay-chain block when the corresponding
     * parachain can switch its upgrade function. As soon as the parachain's block is included, the
     * value gets reset to `None`.
     *
     * NOTE that this field is used by parachains via merkle storage proofs, therefore changing
     * the format will require migration of parachains.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<PolkadotPrimitivesV6UpgradeGoAhead | undefined> =} callback
     **/
    upgradeGoAheadSignal: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => PolkadotPrimitivesV6UpgradeGoAhead | undefined
    >;

    /**
     * This is used by the relay-chain to communicate that there are restrictions for performing
     * an upgrade for this parachain.
     *
     * This may be a because the parachain waits for the upgrade cooldown to expire. Another
     * potential use case is when we want to perform some maintenance (such as storage migration)
     * we could restrict upgrades to make the process simpler.
     *
     * NOTE that this field is used by parachains via merkle storage proofs, therefore changing
     * the format will require migration of parachains.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<PolkadotPrimitivesV6UpgradeRestriction | undefined> =} callback
     **/
    upgradeRestrictionSignal: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => PolkadotPrimitivesV6UpgradeRestriction | undefined
    >;

    /**
     * The list of parachains that are awaiting for their upgrade restriction to cooldown.
     *
     * Ordered ascending by block number.
     *
     * @param {Callback<Array<[PolkadotParachainPrimitivesPrimitivesId, number]>> =} callback
     **/
    upgradeCooldowns: GenericStorageQuery<() => Array<[PolkadotParachainPrimitivesPrimitivesId, number]>>;

    /**
     * The list of upcoming code upgrades. Each item is a pair of which para performs a code
     * upgrade and at which relay-chain block it is expected at.
     *
     * Ordered ascending by block number.
     *
     * @param {Callback<Array<[PolkadotParachainPrimitivesPrimitivesId, number]>> =} callback
     **/
    upcomingUpgrades: GenericStorageQuery<() => Array<[PolkadotParachainPrimitivesPrimitivesId, number]>>;

    /**
     * The actions to perform during the start of a specific session index.
     *
     * @param {number} arg
     * @param {Callback<Array<PolkadotParachainPrimitivesPrimitivesId>> =} callback
     **/
    actionsQueue: GenericStorageQuery<(arg: number) => Array<PolkadotParachainPrimitivesPrimitivesId>>;

    /**
     * Upcoming paras instantiation arguments.
     *
     * NOTE that after PVF pre-checking is enabled the para genesis arg will have it's code set
     * to empty. Instead, the code will be saved into the storage right away via `CodeByHash`.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<PolkadotRuntimeParachainsParasParaGenesisArgs | undefined> =} callback
     **/
    upcomingParasGenesis: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => PolkadotRuntimeParachainsParasParaGenesisArgs | undefined
    >;

    /**
     * The number of reference on the validation code in [`CodeByHash`] storage.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesValidationCodeHash} arg
     * @param {Callback<number> =} callback
     **/
    codeByHashRefs: GenericStorageQuery<(arg: PolkadotParachainPrimitivesPrimitivesValidationCodeHash) => number>;

    /**
     * Validation code stored by its hash.
     *
     * This storage is consistent with [`FutureCodeHash`], [`CurrentCodeHash`] and
     * [`PastCodeHash`].
     *
     * @param {PolkadotParachainPrimitivesPrimitivesValidationCodeHash} arg
     * @param {Callback<PolkadotParachainPrimitivesPrimitivesValidationCode | undefined> =} callback
     **/
    codeByHash: GenericStorageQuery<
      (
        arg: PolkadotParachainPrimitivesPrimitivesValidationCodeHash,
      ) => PolkadotParachainPrimitivesPrimitivesValidationCode | undefined
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Initializer`'s storage queries
   **/
  initializer: {
    /**
     * Whether the parachains modules have been initialized within this block.
     *
     * Semantically a `bool`, but this guarantees it should never hit the trie,
     * as this is cleared in `on_finalize` and Frame optimizes `None` values to be empty values.
     *
     * As a `bool`, `set(false)` and `remove()` both lead to the next `get()` being false, but one
     * of them writes to the trie and one does not. This confusion makes `Option<()>` more suitable
     * for the semantics of this variable.
     *
     * @param {Callback<[] | undefined> =} callback
     **/
    hasInitialized: GenericStorageQuery<() => [] | undefined>;

    /**
     * Buffered session changes along with the block number at which they should be applied.
     *
     * Typically this will be empty or one element long. Apart from that this item never hits
     * the storage.
     *
     * However this is a `Vec` regardless to handle various edge cases that may occur at runtime
     * upgrade boundaries or if governance intervenes.
     *
     * @param {Callback<Array<PolkadotRuntimeParachainsInitializerBufferedSessionChange>> =} callback
     **/
    bufferedSessionChanges: GenericStorageQuery<() => Array<PolkadotRuntimeParachainsInitializerBufferedSessionChange>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Dmp`'s storage queries
   **/
  dmp: {
    /**
     * The downward messages addressed for a certain para.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<Array<PolkadotCorePrimitivesInboundDownwardMessage>> =} callback
     **/
    downwardMessageQueues: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => Array<PolkadotCorePrimitivesInboundDownwardMessage>
    >;

    /**
     * A mapping that stores the downward message queue MQC head for each para.
     *
     * Each link in this chain has a form:
     * `(prev_head, B, H(M))`, where
     * - `prev_head`: is the previous head hash or zero if none.
     * - `B`: is the relay-chain block number in which a message was appended.
     * - `H(M)`: is the hash of the message being appended.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<H256> =} callback
     **/
    downwardMessageQueueHeads: GenericStorageQuery<(arg: PolkadotParachainPrimitivesPrimitivesId) => H256>;

    /**
     * The factor to multiply the base delivery fee by.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<FixedU128> =} callback
     **/
    deliveryFeeFactor: GenericStorageQuery<(arg: PolkadotParachainPrimitivesPrimitivesId) => FixedU128>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Hrmp`'s storage queries
   **/
  hrmp: {
    /**
     * The set of pending HRMP open channel requests.
     *
     * The set is accompanied by a list for iteration.
     *
     * Invariant:
     * - There are no channels that exists in list but not in the set and vice versa.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesHrmpChannelId} arg
     * @param {Callback<PolkadotRuntimeParachainsHrmpHrmpOpenChannelRequest | undefined> =} callback
     **/
    hrmpOpenChannelRequests: GenericStorageQuery<
      (
        arg: PolkadotParachainPrimitivesPrimitivesHrmpChannelId,
      ) => PolkadotRuntimeParachainsHrmpHrmpOpenChannelRequest | undefined
    >;

    /**
     *
     * @param {Callback<Array<PolkadotParachainPrimitivesPrimitivesHrmpChannelId>> =} callback
     **/
    hrmpOpenChannelRequestsList: GenericStorageQuery<() => Array<PolkadotParachainPrimitivesPrimitivesHrmpChannelId>>;

    /**
     * This mapping tracks how many open channel requests are initiated by a given sender para.
     * Invariant: `HrmpOpenChannelRequests` should contain the same number of items that has
     * `(X, _)` as the number of `HrmpOpenChannelRequestCount` for `X`.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<number> =} callback
     **/
    hrmpOpenChannelRequestCount: GenericStorageQuery<(arg: PolkadotParachainPrimitivesPrimitivesId) => number>;

    /**
     * This mapping tracks how many open channel requests were accepted by a given recipient para.
     * Invariant: `HrmpOpenChannelRequests` should contain the same number of items `(_, X)` with
     * `confirmed` set to true, as the number of `HrmpAcceptedChannelRequestCount` for `X`.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<number> =} callback
     **/
    hrmpAcceptedChannelRequestCount: GenericStorageQuery<(arg: PolkadotParachainPrimitivesPrimitivesId) => number>;

    /**
     * A set of pending HRMP close channel requests that are going to be closed during the session
     * change. Used for checking if a given channel is registered for closure.
     *
     * The set is accompanied by a list for iteration.
     *
     * Invariant:
     * - There are no channels that exists in list but not in the set and vice versa.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesHrmpChannelId} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    hrmpCloseChannelRequests: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesHrmpChannelId) => [] | undefined
    >;

    /**
     *
     * @param {Callback<Array<PolkadotParachainPrimitivesPrimitivesHrmpChannelId>> =} callback
     **/
    hrmpCloseChannelRequestsList: GenericStorageQuery<() => Array<PolkadotParachainPrimitivesPrimitivesHrmpChannelId>>;

    /**
     * The HRMP watermark associated with each para.
     * Invariant:
     * - each para `P` used here as a key should satisfy `Paras::is_valid_para(P)` within a
     * session.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<number | undefined> =} callback
     **/
    hrmpWatermarks: GenericStorageQuery<(arg: PolkadotParachainPrimitivesPrimitivesId) => number | undefined>;

    /**
     * HRMP channel data associated with each para.
     * Invariant:
     * - each participant in the channel should satisfy `Paras::is_valid_para(P)` within a session.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesHrmpChannelId} arg
     * @param {Callback<PolkadotRuntimeParachainsHrmpHrmpChannel | undefined> =} callback
     **/
    hrmpChannels: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesHrmpChannelId) => PolkadotRuntimeParachainsHrmpHrmpChannel | undefined
    >;

    /**
     * Ingress/egress indexes allow to find all the senders and receivers given the opposite side.
     * I.e.
     *
     * (a) ingress index allows to find all the senders for a given recipient.
     * (b) egress index allows to find all the recipients for a given sender.
     *
     * Invariants:
     * - for each ingress index entry for `P` each item `I` in the index should present in
     * `HrmpChannels` as `(I, P)`.
     * - for each egress index entry for `P` each item `E` in the index should present in
     * `HrmpChannels` as `(P, E)`.
     * - there should be no other dangling channels in `HrmpChannels`.
     * - the vectors are sorted.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<Array<PolkadotParachainPrimitivesPrimitivesId>> =} callback
     **/
    hrmpIngressChannelsIndex: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => Array<PolkadotParachainPrimitivesPrimitivesId>
    >;

    /**
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<Array<PolkadotParachainPrimitivesPrimitivesId>> =} callback
     **/
    hrmpEgressChannelsIndex: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => Array<PolkadotParachainPrimitivesPrimitivesId>
    >;

    /**
     * Storage for the messages for each channel.
     * Invariant: cannot be non-empty if the corresponding channel in `HrmpChannels` is `None`.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesHrmpChannelId} arg
     * @param {Callback<Array<PolkadotCorePrimitivesInboundHrmpMessage>> =} callback
     **/
    hrmpChannelContents: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesHrmpChannelId) => Array<PolkadotCorePrimitivesInboundHrmpMessage>
    >;

    /**
     * Maintains a mapping that can be used to answer the question: What paras sent a message at
     * the given block number for a given receiver. Invariants:
     * - The inner `Vec<ParaId>` is never empty.
     * - The inner `Vec<ParaId>` cannot store two same `ParaId`.
     * - The outer vector is sorted ascending by block number and cannot store two items with the
     * same block number.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<Array<[number, Array<PolkadotParachainPrimitivesPrimitivesId>]>> =} callback
     **/
    hrmpChannelDigests: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => Array<[number, Array<PolkadotParachainPrimitivesPrimitivesId>]>
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ParaSessionInfo`'s storage queries
   **/
  paraSessionInfo: {
    /**
     * Assignment keys for the current session.
     * Note that this API is private due to it being prone to 'off-by-one' at session boundaries.
     * When in doubt, use `Sessions` API instead.
     *
     * @param {Callback<Array<PolkadotPrimitivesV6AssignmentAppPublic>> =} callback
     **/
    assignmentKeysUnsafe: GenericStorageQuery<() => Array<PolkadotPrimitivesV6AssignmentAppPublic>>;

    /**
     * The earliest session for which previous session info is stored.
     *
     * @param {Callback<number> =} callback
     **/
    earliestStoredSession: GenericStorageQuery<() => number>;

    /**
     * Session information in a rolling window.
     * Should have an entry in range `EarliestStoredSession..=CurrentSessionIndex`.
     * Does not have any entries before the session index in the first session change notification.
     *
     * @param {number} arg
     * @param {Callback<PolkadotPrimitivesV6SessionInfo | undefined> =} callback
     **/
    sessions: GenericStorageQuery<(arg: number) => PolkadotPrimitivesV6SessionInfo | undefined>;

    /**
     * The validator account keys of the validators actively participating in parachain consensus.
     *
     * @param {number} arg
     * @param {Callback<Array<AccountId32> | undefined> =} callback
     **/
    accountKeys: GenericStorageQuery<(arg: number) => Array<AccountId32> | undefined>;

    /**
     * Executor parameter set for a given session index
     *
     * @param {number} arg
     * @param {Callback<PolkadotPrimitivesV6ExecutorParams | undefined> =} callback
     **/
    sessionExecutorParams: GenericStorageQuery<(arg: number) => PolkadotPrimitivesV6ExecutorParams | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ParasDisputes`'s storage queries
   **/
  parasDisputes: {
    /**
     * The last pruned session, if any. All data stored by this module
     * references sessions.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    lastPrunedSession: GenericStorageQuery<() => number | undefined>;

    /**
     * All ongoing or concluded disputes for the last several sessions.
     *
     * @param {[number, PolkadotCorePrimitivesCandidateHash]} arg
     * @param {Callback<PolkadotPrimitivesV6DisputeState | undefined> =} callback
     **/
    disputes: GenericStorageQuery<
      (arg: [number, PolkadotCorePrimitivesCandidateHash]) => PolkadotPrimitivesV6DisputeState | undefined
    >;

    /**
     * Backing votes stored for each dispute.
     * This storage is used for slashing.
     *
     * @param {[number, PolkadotCorePrimitivesCandidateHash]} arg
     * @param {Callback<Array<PolkadotPrimitivesV6ValidatorIndex> | undefined> =} callback
     **/
    backersOnDisputes: GenericStorageQuery<
      (arg: [number, PolkadotCorePrimitivesCandidateHash]) => Array<PolkadotPrimitivesV6ValidatorIndex> | undefined
    >;

    /**
     * All included blocks on the chain, as well as the block number in this chain that
     * should be reverted back to if the candidate is disputed and determined to be invalid.
     *
     * @param {[number, PolkadotCorePrimitivesCandidateHash]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    included: GenericStorageQuery<(arg: [number, PolkadotCorePrimitivesCandidateHash]) => number | undefined>;

    /**
     * Whether the chain is frozen. Starts as `None`. When this is `Some`,
     * the chain will not accept any new parachain blocks for backing or inclusion,
     * and its value indicates the last valid block number in the chain.
     * It can only be set back to `None` by governance intervention.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    frozen: GenericStorageQuery<() => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ParasSlashing`'s storage queries
   **/
  parasSlashing: {
    /**
     * Validators pending dispute slashes.
     *
     * @param {[number, PolkadotCorePrimitivesCandidateHash]} arg
     * @param {Callback<PolkadotPrimitivesV6SlashingPendingSlashes | undefined> =} callback
     **/
    unappliedSlashes: GenericStorageQuery<
      (arg: [number, PolkadotCorePrimitivesCandidateHash]) => PolkadotPrimitivesV6SlashingPendingSlashes | undefined
    >;

    /**
     * `ValidatorSetCount` per session.
     *
     * @param {number} arg
     * @param {Callback<number | undefined> =} callback
     **/
    validatorSetCounts: GenericStorageQuery<(arg: number) => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `MessageQueue`'s storage queries
   **/
  messageQueue: {
    /**
     * The index of the first and last (non-empty) pages.
     *
     * @param {PolkadotRuntimeParachainsInclusionAggregateMessageOrigin} arg
     * @param {Callback<PalletMessageQueueBookState> =} callback
     **/
    bookStateFor: GenericStorageQuery<
      (arg: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin) => PalletMessageQueueBookState
    >;

    /**
     * The origin at which we should begin servicing.
     *
     * @param {Callback<PolkadotRuntimeParachainsInclusionAggregateMessageOrigin | undefined> =} callback
     **/
    serviceHead: GenericStorageQuery<() => PolkadotRuntimeParachainsInclusionAggregateMessageOrigin | undefined>;

    /**
     * The map of page indices to pages.
     *
     * @param {[PolkadotRuntimeParachainsInclusionAggregateMessageOrigin, number]} arg
     * @param {Callback<PalletMessageQueuePage | undefined> =} callback
     **/
    pages: GenericStorageQuery<
      (arg: [PolkadotRuntimeParachainsInclusionAggregateMessageOrigin, number]) => PalletMessageQueuePage | undefined
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `OnDemandAssignmentProvider`'s storage queries
   **/
  onDemandAssignmentProvider: {
    /**
     * Keeps track of the multiplier used to calculate the current spot price for the on demand
     * assigner.
     *
     * @param {Callback<FixedU128> =} callback
     **/
    spotTraffic: GenericStorageQuery<() => FixedU128>;

    /**
     * The order storage entry. Uses a VecDeque to be able to push to the front of the
     * queue from the scheduler on session boundaries.
     *
     * @param {Callback<Array<PolkadotRuntimeParachainsAssignerOnDemandEnqueuedOrder>> =} callback
     **/
    onDemandQueue: GenericStorageQuery<() => Array<PolkadotRuntimeParachainsAssignerOnDemandEnqueuedOrder>>;

    /**
     * Maps a `ParaId` to `CoreIndex` and keeps track of how many assignments the scheduler has in
     * it's lookahead. Keeping track of this affinity prevents parallel execution of the same
     * `ParaId` on two or more `CoreIndex`es.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<PolkadotRuntimeParachainsAssignerOnDemandCoreAffinityCount | undefined> =} callback
     **/
    paraIdAffinity: GenericStorageQuery<
      (
        arg: PolkadotParachainPrimitivesPrimitivesId,
      ) => PolkadotRuntimeParachainsAssignerOnDemandCoreAffinityCount | undefined
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `CoretimeAssignmentProvider`'s storage queries
   **/
  coretimeAssignmentProvider: {
    /**
     * Scheduled assignment sets.
     *
     * Assignments as of the given block number. They will go into state once the block number is
     * reached (and replace whatever was in there before).
     *
     * @param {[number, PolkadotPrimitivesV6CoreIndex]} arg
     * @param {Callback<PolkadotRuntimeParachainsAssignerCoretimeSchedule | undefined> =} callback
     **/
    coreSchedules: GenericStorageQuery<
      (arg: [number, PolkadotPrimitivesV6CoreIndex]) => PolkadotRuntimeParachainsAssignerCoretimeSchedule | undefined
    >;

    /**
     * Assignments which are currently active.
     *
     * They will be picked from `PendingAssignments` once we reach the scheduled block number in
     * `PendingAssignments`.
     *
     * @param {PolkadotPrimitivesV6CoreIndex} arg
     * @param {Callback<PolkadotRuntimeParachainsAssignerCoretimeCoreDescriptor> =} callback
     **/
    coreDescriptors: GenericStorageQuery<
      (arg: PolkadotPrimitivesV6CoreIndex) => PolkadotRuntimeParachainsAssignerCoretimeCoreDescriptor
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Registrar`'s storage queries
   **/
  registrar: {
    /**
     * Pending swap operations.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<PolkadotParachainPrimitivesPrimitivesId | undefined> =} callback
     **/
    pendingSwap: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => PolkadotParachainPrimitivesPrimitivesId | undefined
    >;

    /**
     * Amount held on deposit for each para and the original depositor.
     *
     * The given account ID is responsible for registering the code and initial head data, but may
     * only do so if it isn't yet registered. (After that, it's up to governance to do so.)
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<PolkadotRuntimeCommonParasRegistrarParaInfo | undefined> =} callback
     **/
    paras: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => PolkadotRuntimeCommonParasRegistrarParaInfo | undefined
    >;

    /**
     * The next free `ParaId`.
     *
     * @param {Callback<PolkadotParachainPrimitivesPrimitivesId> =} callback
     **/
    nextFreeParaId: GenericStorageQuery<() => PolkadotParachainPrimitivesPrimitivesId>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Slots`'s storage queries
   **/
  slots: {
    /**
     * Amounts held on deposit for each (possibly future) leased parachain.
     *
     * The actual amount locked on its behalf by any account at any time is the maximum of the
     * second values of the items in this list whose first value is the account.
     *
     * The first item in the list is the amount locked for the current Lease Period. Following
     * items are for the subsequent lease periods.
     *
     * The default value (an empty list) implies that the parachain no longer exists (or never
     * existed) as far as this pallet is concerned.
     *
     * If a parachain doesn't exist *yet* but is scheduled to exist in the future, then it
     * will be left-padded with one or more `None`s to denote the fact that nothing is held on
     * deposit for the non-existent chain currently, but is held at some point in the future.
     *
     * It is illegal for a `None` value to trail in the list.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<Array<[AccountId32, bigint] | undefined>> =} callback
     **/
    leases: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => Array<[AccountId32, bigint] | undefined>
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Auctions`'s storage queries
   **/
  auctions: {
    /**
     * Number of auctions started so far.
     *
     * @param {Callback<number> =} callback
     **/
    auctionCounter: GenericStorageQuery<() => number>;

    /**
     * Information relating to the current auction, if there is one.
     *
     * The first item in the tuple is the lease period index that the first of the four
     * contiguous lease periods on auction is for. The second is the block number when the
     * auction will "begin to end", i.e. the first block of the Ending Period of the auction.
     *
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    auctionInfo: GenericStorageQuery<() => [number, number] | undefined>;

    /**
     * Amounts currently reserved in the accounts of the bidders currently winning
     * (sub-)ranges.
     *
     * @param {[AccountId32Like, PolkadotParachainPrimitivesPrimitivesId]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    reservedAmounts: GenericStorageQuery<
      (arg: [AccountId32Like, PolkadotParachainPrimitivesPrimitivesId]) => bigint | undefined
    >;

    /**
     * The winning bids for each of the 10 ranges at each sample in the final Ending Period of
     * the current auction. The map's key is the 0-based index into the Sample Size. The
     * first sample of the ending period is 0; the last is `Sample Size - 1`.
     *
     * @param {number} arg
     * @param {Callback<FixedArray<[AccountId32, PolkadotParachainPrimitivesPrimitivesId, bigint] | undefined, 36> | undefined> =} callback
     **/
    winning: GenericStorageQuery<
      (
        arg: number,
      ) => FixedArray<[AccountId32, PolkadotParachainPrimitivesPrimitivesId, bigint] | undefined, 36> | undefined
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Crowdloan`'s storage queries
   **/
  crowdloan: {
    /**
     * Info on all of the funds.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<PolkadotRuntimeCommonCrowdloanFundInfo | undefined> =} callback
     **/
    funds: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => PolkadotRuntimeCommonCrowdloanFundInfo | undefined
    >;

    /**
     * The funds that have had additional contributions during the last block. This is used
     * in order to determine which funds should submit new or updated bids.
     *
     * @param {Callback<Array<PolkadotParachainPrimitivesPrimitivesId>> =} callback
     **/
    newRaise: GenericStorageQuery<() => Array<PolkadotParachainPrimitivesPrimitivesId>>;

    /**
     * The number of auctions that have entered into their ending period so far.
     *
     * @param {Callback<number> =} callback
     **/
    endingsCount: GenericStorageQuery<() => number>;

    /**
     * Tracker for the next available fund index
     *
     * @param {Callback<number> =} callback
     **/
    nextFundIndex: GenericStorageQuery<() => number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `XcmPallet`'s storage queries
   **/
  xcmPallet: {
    /**
     * The latest available query index.
     *
     * @param {Callback<bigint> =} callback
     **/
    queryCounter: GenericStorageQuery<() => bigint>;

    /**
     * The ongoing queries.
     *
     * @param {bigint} arg
     * @param {Callback<PalletXcmQueryStatus | undefined> =} callback
     **/
    queries: GenericStorageQuery<(arg: bigint) => PalletXcmQueryStatus | undefined>;

    /**
     * The existing asset traps.
     *
     * Key is the blake2 256 hash of (origin, versioned `Assets`) pair. Value is the number of
     * times this pair has been trapped (usually just 1 if it exists at all).
     *
     * @param {H256} arg
     * @param {Callback<number> =} callback
     **/
    assetTraps: GenericStorageQuery<(arg: H256) => number>;

    /**
     * Default version to encode XCM when latest version of destination is unknown. If `None`,
     * then the destinations whose XCM version is unknown are considered unreachable.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    safeXcmVersion: GenericStorageQuery<() => number | undefined>;

    /**
     * The Latest versions that we know various locations support.
     *
     * @param {[number, XcmVersionedLocation]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    supportedVersion: GenericStorageQuery<(arg: [number, XcmVersionedLocation]) => number | undefined>;

    /**
     * All locations that we have requested version notifications from.
     *
     * @param {[number, XcmVersionedLocation]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    versionNotifiers: GenericStorageQuery<(arg: [number, XcmVersionedLocation]) => bigint | undefined>;

    /**
     * The target locations that are subscribed to our version changes, as well as the most recent
     * of our versions we informed them of.
     *
     * @param {[number, XcmVersionedLocation]} arg
     * @param {Callback<[bigint, SpWeightsWeightV2Weight, number] | undefined> =} callback
     **/
    versionNotifyTargets: GenericStorageQuery<
      (arg: [number, XcmVersionedLocation]) => [bigint, SpWeightsWeightV2Weight, number] | undefined
    >;

    /**
     * Destinations whose latest XCM version we would like to know. Duplicates not allowed, and
     * the `u32` counter is the number of times that a send to the destination has been attempted,
     * which is used as a prioritization.
     *
     * @param {Callback<Array<[XcmVersionedLocation, number]>> =} callback
     **/
    versionDiscoveryQueue: GenericStorageQuery<() => Array<[XcmVersionedLocation, number]>>;

    /**
     * The current migration's stage, if any.
     *
     * @param {Callback<PalletXcmVersionMigrationStage | undefined> =} callback
     **/
    currentMigration: GenericStorageQuery<() => PalletXcmVersionMigrationStage | undefined>;

    /**
     * Fungible assets which we know are locked on a remote chain.
     *
     * @param {[number, AccountId32Like, XcmVersionedAssetId]} arg
     * @param {Callback<PalletXcmRemoteLockedFungibleRecord | undefined> =} callback
     **/
    remoteLockedFungibles: GenericStorageQuery<
      (arg: [number, AccountId32Like, XcmVersionedAssetId]) => PalletXcmRemoteLockedFungibleRecord | undefined
    >;

    /**
     * Fungible assets which we know are locked on this chain.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<[bigint, XcmVersionedLocation]> | undefined> =} callback
     **/
    lockedFungibles: GenericStorageQuery<(arg: AccountId32Like) => Array<[bigint, XcmVersionedLocation]> | undefined>;

    /**
     * Global suspension state of the XCM executor.
     *
     * @param {Callback<boolean> =} callback
     **/
    xcmExecutionSuspended: GenericStorageQuery<() => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Beefy`'s storage queries
   **/
  beefy: {
    /**
     * The current authorities set
     *
     * @param {Callback<Array<SpConsensusBeefyEcdsaCryptoPublic>> =} callback
     **/
    authorities: GenericStorageQuery<() => Array<SpConsensusBeefyEcdsaCryptoPublic>>;

    /**
     * The current validator set id
     *
     * @param {Callback<bigint> =} callback
     **/
    validatorSetId: GenericStorageQuery<() => bigint>;

    /**
     * Authorities set scheduled to be used with the next session
     *
     * @param {Callback<Array<SpConsensusBeefyEcdsaCryptoPublic>> =} callback
     **/
    nextAuthorities: GenericStorageQuery<() => Array<SpConsensusBeefyEcdsaCryptoPublic>>;

    /**
     * A mapping from BEEFY set ID to the index of the *most recent* session for which its
     * members were responsible.
     *
     * This is only used for validating equivocation proofs. An equivocation proof must
     * contains a key-ownership proof for a given session, therefore we need a way to tie
     * together sessions and BEEFY set ids, i.e. we need to validate that a validator
     * was the owner of a given key on a given session, and what the active set ID was
     * during that session.
     *
     * TWOX-NOTE: `ValidatorSetId` is not under user control.
     *
     * @param {bigint} arg
     * @param {Callback<number | undefined> =} callback
     **/
    setIdSession: GenericStorageQuery<(arg: bigint) => number | undefined>;

    /**
     * Block number where BEEFY consensus is enabled/started.
     * By changing this (through privileged `set_new_genesis()`), BEEFY consensus is effectively
     * restarted from the newly set block number.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    genesisBlock: GenericStorageQuery<() => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Mmr`'s storage queries
   **/
  mmr: {
    /**
     * Latest MMR Root hash.
     *
     * @param {Callback<H256> =} callback
     **/
    rootHash: GenericStorageQuery<() => H256>;

    /**
     * Current size of the MMR (number of leaves).
     *
     * @param {Callback<bigint> =} callback
     **/
    numberOfLeaves: GenericStorageQuery<() => bigint>;

    /**
     * Hashes of the nodes in the MMR.
     *
     * Note this collection only contains MMR peaks, the inner nodes (and leaves)
     * are pruned and only stored in the Offchain DB.
     *
     * @param {bigint} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    nodes: GenericStorageQuery<(arg: bigint) => H256 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `MmrLeaf`'s storage queries
   **/
  mmrLeaf: {
    /**
     * Details of current BEEFY authority set.
     *
     * @param {Callback<SpConsensusBeefyMmrBeefyAuthoritySet> =} callback
     **/
    beefyAuthorities: GenericStorageQuery<() => SpConsensusBeefyMmrBeefyAuthoritySet>;

    /**
     * Details of next BEEFY authority set.
     *
     * This storage entry is used as cache for calls to `update_beefy_next_authority_set`.
     *
     * @param {Callback<SpConsensusBeefyMmrBeefyAuthoritySet> =} callback
     **/
    beefyNextAuthorities: GenericStorageQuery<() => SpConsensusBeefyMmrBeefyAuthoritySet>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `AssignedSlots`'s storage queries
   **/
  assignedSlots: {
    /**
     * Assigned permanent slots, with their start lease period, and duration.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    permanentSlots: GenericStorageQuery<(arg: PolkadotParachainPrimitivesPrimitivesId) => [number, number] | undefined>;

    /**
     * Number of assigned (and active) permanent slots.
     *
     * @param {Callback<number> =} callback
     **/
    permanentSlotCount: GenericStorageQuery<() => number>;

    /**
     * Assigned temporary slots.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<PolkadotRuntimeCommonAssignedSlotsParachainTemporarySlot | undefined> =} callback
     **/
    temporarySlots: GenericStorageQuery<
      (
        arg: PolkadotParachainPrimitivesPrimitivesId,
      ) => PolkadotRuntimeCommonAssignedSlotsParachainTemporarySlot | undefined
    >;

    /**
     * Number of assigned temporary slots.
     *
     * @param {Callback<number> =} callback
     **/
    temporarySlotCount: GenericStorageQuery<() => number>;

    /**
     * Number of active temporary slots in current slot lease period.
     *
     * @param {Callback<number> =} callback
     **/
    activeTemporarySlotCount: GenericStorageQuery<() => number>;

    /**
     * The max number of temporary slots that can be assigned.
     *
     * @param {Callback<number> =} callback
     **/
    maxTemporarySlots: GenericStorageQuery<() => number>;

    /**
     * The max number of permanent slots that can be assigned.
     *
     * @param {Callback<number> =} callback
     **/
    maxPermanentSlots: GenericStorageQuery<() => number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ValidatorManager`'s storage queries
   **/
  validatorManager: {
    /**
     * Validators that should be retired, because their Parachain was deregistered.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    validatorsToRetire: GenericStorageQuery<() => Array<AccountId32>>;

    /**
     * Validators that should be added.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    validatorsToAdd: GenericStorageQuery<() => Array<AccountId32>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `StateTrieMigration`'s storage queries
   **/
  stateTrieMigration: {
    /**
     * Migration progress.
     *
     * This stores the snapshot of the last migrated keys. It can be set into motion and move
     * forward by any of the means provided by this pallet.
     *
     * @param {Callback<PalletStateTrieMigrationMigrationTask> =} callback
     **/
    migrationProcess: GenericStorageQuery<() => PalletStateTrieMigrationMigrationTask>;

    /**
     * The limits that are imposed on automatic migrations.
     *
     * If set to None, then no automatic migration happens.
     *
     * @param {Callback<PalletStateTrieMigrationMigrationLimits | undefined> =} callback
     **/
    autoLimits: GenericStorageQuery<() => PalletStateTrieMigrationMigrationLimits | undefined>;

    /**
     * The maximum limits that the signed migration could use.
     *
     * If not set, no signed submission is allowed.
     *
     * @param {Callback<PalletStateTrieMigrationMigrationLimits | undefined> =} callback
     **/
    signedMigrationMaxLimits: GenericStorageQuery<() => PalletStateTrieMigrationMigrationLimits | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Sudo`'s storage queries
   **/
  sudo: {
    /**
     * The `AccountId` of the sudo key.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    key: GenericStorageQuery<() => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
}
