// Generated by @delightfuldot/codegen

import type { GenericChainStorage, GenericStorageQuery } from '@delightfuldot/types';
import type {
  AccountId32Like,
  H256,
  Bytes,
  Digest,
  Phase,
  FixedBytes,
  FixedU128,
  AccountId32,
  Perbill,
  Percent,
  BytesLike,
  Data,
  Perquintill,
} from '@delightfuldot/codecs';
import type {
  FrameSystemAccountInfo,
  FrameSupportDispatchPerDispatchClass,
  FrameSystemEventRecord,
  FrameSystemLastRuntimeUpgradeInfo,
  PalletSchedulerScheduled,
  SpConsensusAuraSr25519AppSr25519Public,
  SpConsensusSlotsSlot,
  PalletBalancesAccountData,
  PalletBalancesBalanceLock,
  PalletBalancesReserveData,
  PalletBalancesIdAmount,
  PalletBalancesIdAmount002,
  PalletTransactionPaymentReleases,
  PalletStakingStakingLedger,
  PalletStakingRewardDestination,
  PalletStakingValidatorPrefs,
  PalletStakingNominations,
  PalletStakingActiveEraInfo,
  PalletStakingExposure,
  PalletStakingEraRewardPoints,
  PalletStakingForcing,
  PalletStakingUnappliedSlash,
  PalletStakingSlashingSlashingSpans,
  PalletStakingSlashingSpanRecord,
  AlephRuntimeSessionKeys,
  SpCoreCryptoKeyTypeId,
  PrimitivesAppPublic,
  PrimitivesVersionChange,
  PrimitivesCommitteeSeats,
  PrimitivesEraValidators,
  PrimitivesElectionOpenness,
  PalletTreasuryProposal,
  PalletVestingVestingInfo,
  PalletVestingReleases,
  PalletMultisigMultisig,
  PalletContractsWasmCodeInfo,
  PalletContractsStorageContractInfo,
  PalletContractsStorageDeletionQueueManager,
  PalletNominationPoolsPoolMember,
  PalletNominationPoolsBondedPoolInner,
  PalletNominationPoolsRewardPool,
  PalletNominationPoolsSubPools,
  PalletNominationPoolsClaimPermission,
  PalletIdentityRegistration,
  PalletIdentityRegistrarInfo,
  PalletCommitteeManagementValidatorTotalRewards,
  PrimitivesBanConfig,
  PrimitivesBanInfo,
  PalletCommitteeManagementCurrentAndNextSessionValidators,
} from './types';

export interface ChainStorage extends GenericChainStorage {
  system: {
    /**
     * The full account information for a particular account ID.
     **/
    account: GenericStorageQuery<(arg: AccountId32Like) => FrameSystemAccountInfo>;

    /**
     * Total extrinsics count for the current block.
     **/
    extrinsicCount: GenericStorageQuery<() => number | undefined>;

    /**
     * The current weight for the block.
     **/
    blockWeight: GenericStorageQuery<() => FrameSupportDispatchPerDispatchClass>;

    /**
     * Total length (in bytes) for all extrinsics put together, for the current block.
     **/
    allExtrinsicsLen: GenericStorageQuery<() => number | undefined>;

    /**
     * Map of block numbers to block hashes.
     **/
    blockHash: GenericStorageQuery<(arg: number) => H256>;

    /**
     * Extrinsics data for the current block (maps an extrinsic's index to its data).
     **/
    extrinsicData: GenericStorageQuery<(arg: number) => Bytes>;

    /**
     * The current block number being processed. Set by `execute_block`.
     **/
    number: GenericStorageQuery<() => number>;

    /**
     * Hash of the previous block.
     **/
    parentHash: GenericStorageQuery<() => H256>;

    /**
     * Digest of the current block, also part of the block header.
     **/
    digest: GenericStorageQuery<() => Digest>;

    /**
     * Events deposited for the current block.
     *
     * NOTE: The item is unbound and should therefore never be read on chain.
     * It could otherwise inflate the PoV size of a block.
     *
     * Events have a large in-memory size. Box the events to not go out-of-memory
     * just in case someone still reads them from within the runtime.
     **/
    events: GenericStorageQuery<() => Array<FrameSystemEventRecord>>;

    /**
     * The number of events in the `Events<T>` list.
     **/
    eventCount: GenericStorageQuery<() => number>;

    /**
     * Mapping between a topic (represented by T::Hash) and a vector of indexes
     * of events in the `<Events<T>>` list.
     *
     * All topic vectors have deterministic storage locations depending on the topic. This
     * allows light-clients to leverage the changes trie storage tracking mechanism and
     * in case of changes fetch the list of events of interest.
     *
     * The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just
     * the `EventIndex` then in case if the topic has the same contents on the next block
     * no notification will be triggered thus the event might be lost.
     **/
    eventTopics: GenericStorageQuery<(arg: H256) => Array<[number, number]>>;

    /**
     * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
     **/
    lastRuntimeUpgrade: GenericStorageQuery<() => FrameSystemLastRuntimeUpgradeInfo | undefined>;

    /**
     * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.
     **/
    upgradedToU32RefCount: GenericStorageQuery<() => boolean>;

    /**
     * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
     * (default) if not.
     **/
    upgradedToTripleRefCount: GenericStorageQuery<() => boolean>;

    /**
     * The execution phase of the block.
     **/
    executionPhase: GenericStorageQuery<() => Phase | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  randomnessCollectiveFlip: {
    /**
     * Series of block headers from the last 81 blocks that acts as random seed material. This
     * is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of
     * the oldest hash.
     **/
    randomMaterial: GenericStorageQuery<() => Array<H256>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  scheduler: {
    incompleteSince: GenericStorageQuery<() => number | undefined>;

    /**
     * Items to be executed, indexed by the block number that they should be executed on.
     **/
    agenda: GenericStorageQuery<(arg: number) => Array<PalletSchedulerScheduled | undefined>>;

    /**
     * Lookup from a name to the block number and index of the task.
     *
     * For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
     * identities.
     **/
    lookup: GenericStorageQuery<(arg: FixedBytes<32>) => [number, number] | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  aura: {
    /**
     * The current authority set.
     **/
    authorities: GenericStorageQuery<() => Array<SpConsensusAuraSr25519AppSr25519Public>>;

    /**
     * The current slot of this block.
     *
     * This will be set in `on_initialize`.
     **/
    currentSlot: GenericStorageQuery<() => SpConsensusSlotsSlot>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  timestamp: {
    /**
     * Current time for the current block.
     **/
    now: GenericStorageQuery<() => bigint>;

    /**
     * Did the timestamp get updated in this block?
     **/
    didUpdate: GenericStorageQuery<() => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  balances: {
    /**
     * The total units issued in the system.
     **/
    totalIssuance: GenericStorageQuery<() => bigint>;

    /**
     * The total units of outstanding deactivated balance in the system.
     **/
    inactiveIssuance: GenericStorageQuery<() => bigint>;

    /**
     * The Balances pallet example of storing the balance of an account.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
     * }
     * ```
     *
     * You can also store the balance of an account in the `System` pallet.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = System
     * }
     * ```
     *
     * But this comes with tradeoffs, storing account balances in the system pallet stores
     * `frame_system` data alongside the account data contrary to storing account balances in the
     * `Balances` pallet, which uses a `StorageMap` to store balances data only.
     * NOTE: This is only used in the case that this pallet is used to store balances.
     **/
    account: GenericStorageQuery<(arg: AccountId32Like) => PalletBalancesAccountData>;

    /**
     * Any liquidity locks on some account balances.
     * NOTE: Should only be accessed when setting, changing and freeing a lock.
     **/
    locks: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesBalanceLock>>;

    /**
     * Named reserves on some account balances.
     **/
    reserves: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesReserveData>>;

    /**
     * Holds on account balances.
     **/
    holds: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesIdAmount>>;

    /**
     * Freeze locks on account balances.
     **/
    freezes: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesIdAmount002>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  transactionPayment: {
    nextFeeMultiplier: GenericStorageQuery<() => FixedU128>;
    storageVersion: GenericStorageQuery<() => PalletTransactionPaymentReleases>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  authorship: {
    /**
     * Author of current block.
     **/
    author: GenericStorageQuery<() => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  staking: {
    /**
     * The ideal number of active validators.
     **/
    validatorCount: GenericStorageQuery<() => number>;

    /**
     * Minimum number of staking participants before emergency conditions are imposed.
     **/
    minimumValidatorCount: GenericStorageQuery<() => number>;

    /**
     * Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
     * easy to initialize and the performance hit is minimal (we expect no more than four
     * invulnerables) and restricted to testnets.
     **/
    invulnerables: GenericStorageQuery<() => Array<AccountId32>>;

    /**
     * Map from all locked "stash" accounts to the controller account.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     **/
    bonded: GenericStorageQuery<(arg: AccountId32Like) => AccountId32 | undefined>;

    /**
     * The minimum active bond to become and maintain the role of a nominator.
     **/
    minNominatorBond: GenericStorageQuery<() => bigint>;

    /**
     * The minimum active bond to become and maintain the role of a validator.
     **/
    minValidatorBond: GenericStorageQuery<() => bigint>;

    /**
     * The minimum active nominator stake of the last successful election.
     **/
    minimumActiveStake: GenericStorageQuery<() => bigint>;

    /**
     * The minimum amount of commission that validators can set.
     *
     * If set to `0`, no limit exists.
     **/
    minCommission: GenericStorageQuery<() => Perbill>;

    /**
     * Map from all (unlocked) "controller" accounts to the info regarding the staking.
     **/
    ledger: GenericStorageQuery<(arg: AccountId32Like) => PalletStakingStakingLedger | undefined>;

    /**
     * Where the reward payment should be made. Keyed by stash.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     **/
    payee: GenericStorageQuery<(arg: AccountId32Like) => PalletStakingRewardDestination>;

    /**
     * The map from (wannabe) validator stash key to the preferences of that validator.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     **/
    validators: GenericStorageQuery<(arg: AccountId32Like) => PalletStakingValidatorPrefs>;

    /**
     * Counter for the related counted storage map
     **/
    counterForValidators: GenericStorageQuery<() => number>;

    /**
     * The maximum validator count before we stop allowing new validators to join.
     *
     * When this value is not set, no limits are enforced.
     **/
    maxValidatorsCount: GenericStorageQuery<() => number | undefined>;

    /**
     * The map from nominator stash key to their nomination preferences, namely the validators that
     * they wish to support.
     *
     * Note that the keys of this storage map might become non-decodable in case the
     * [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators
     * are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
     * indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
     * nominators will effectively not-exist, until they re-submit their preferences such that it
     * is within the bounds of the newly set `Config::MaxNominations`.
     *
     * This implies that `::iter_keys().count()` and `::iter().count()` might return different
     * values for this map. Moreover, the main `::count()` is aligned with the former, namely the
     * number of keys that exist.
     *
     * Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
     * [`Call::chill_other`] dispatchable by anyone.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     **/
    nominators: GenericStorageQuery<(arg: AccountId32Like) => PalletStakingNominations | undefined>;

    /**
     * Counter for the related counted storage map
     **/
    counterForNominators: GenericStorageQuery<() => number>;

    /**
     * The maximum nominator count before we stop allowing new validators to join.
     *
     * When this value is not set, no limits are enforced.
     **/
    maxNominatorsCount: GenericStorageQuery<() => number | undefined>;

    /**
     * The current era index.
     *
     * This is the latest planned era, depending on how the Session pallet queues the validator
     * set, it might be active or not.
     **/
    currentEra: GenericStorageQuery<() => number | undefined>;

    /**
     * The active era information, it holds index and start.
     *
     * The active era is the era being currently rewarded. Validator set of this era must be
     * equal to [`SessionInterface::validators`].
     **/
    activeEra: GenericStorageQuery<() => PalletStakingActiveEraInfo | undefined>;

    /**
     * The session index at which the era start for the last `HISTORY_DEPTH` eras.
     *
     * Note: This tracks the starting session (i.e. session index when era start being active)
     * for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
     **/
    erasStartSessionIndex: GenericStorageQuery<(arg: number) => number | undefined>;

    /**
     * Exposure of validator at era.
     *
     * This is keyed first by the era index to allow bulk deletion and then the stash account.
     *
     * Is it removed after `HISTORY_DEPTH` eras.
     * If stakers hasn't been set or has been removed then empty exposure is returned.
     **/
    erasStakers: GenericStorageQuery<(arg: [number, AccountId32Like]) => PalletStakingExposure>;

    /**
     * Clipped Exposure of validator at era.
     *
     * This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
     * `T::MaxNominatorRewardedPerValidator` biggest stakers.
     * (Note: the field `total` and `own` of the exposure remains unchanged).
     * This is used to limit the i/o cost for the nominator payout.
     *
     * This is keyed fist by the era index to allow bulk deletion and then the stash account.
     *
     * Is it removed after `HISTORY_DEPTH` eras.
     * If stakers hasn't been set or has been removed then empty exposure is returned.
     **/
    erasStakersClipped: GenericStorageQuery<(arg: [number, AccountId32Like]) => PalletStakingExposure>;

    /**
     * Similar to `ErasStakers`, this holds the preferences of validators.
     *
     * This is keyed first by the era index to allow bulk deletion and then the stash account.
     *
     * Is it removed after `HISTORY_DEPTH` eras.
     **/
    erasValidatorPrefs: GenericStorageQuery<(arg: [number, AccountId32Like]) => PalletStakingValidatorPrefs>;

    /**
     * The total validator era payout for the last `HISTORY_DEPTH` eras.
     *
     * Eras that haven't finished yet or has been removed doesn't have reward.
     **/
    erasValidatorReward: GenericStorageQuery<(arg: number) => bigint | undefined>;

    /**
     * Rewards for the last `HISTORY_DEPTH` eras.
     * If reward hasn't been set or has been removed then 0 reward is returned.
     **/
    erasRewardPoints: GenericStorageQuery<(arg: number) => PalletStakingEraRewardPoints>;

    /**
     * The total amount staked for the last `HISTORY_DEPTH` eras.
     * If total hasn't been set or has been removed then 0 stake is returned.
     **/
    erasTotalStake: GenericStorageQuery<(arg: number) => bigint>;

    /**
     * Mode of era forcing.
     **/
    forceEra: GenericStorageQuery<() => PalletStakingForcing>;

    /**
     * The percentage of the slash that is distributed to reporters.
     *
     * The rest of the slashed value is handled by the `Slash`.
     **/
    slashRewardFraction: GenericStorageQuery<() => Perbill>;

    /**
     * The amount of currency given to reporters of a slash event which was
     * canceled by extraordinary circumstances (e.g. governance).
     **/
    canceledSlashPayout: GenericStorageQuery<() => bigint>;

    /**
     * All unapplied slashes that are queued for later.
     **/
    unappliedSlashes: GenericStorageQuery<(arg: number) => Array<PalletStakingUnappliedSlash>>;

    /**
     * A mapping from still-bonded eras to the first session index of that era.
     *
     * Must contains information for eras for the range:
     * `[active_era - bounding_duration; active_era]`
     **/
    bondedEras: GenericStorageQuery<() => Array<[number, number]>>;

    /**
     * All slashing events on validators, mapped by era to the highest slash proportion
     * and slash value of the era.
     **/
    validatorSlashInEra: GenericStorageQuery<(arg: [number, AccountId32Like]) => [Perbill, bigint] | undefined>;

    /**
     * All slashing events on nominators, mapped by era to the highest slash value of the era.
     **/
    nominatorSlashInEra: GenericStorageQuery<(arg: [number, AccountId32Like]) => bigint | undefined>;

    /**
     * Slashing spans for stash accounts.
     **/
    slashingSpans: GenericStorageQuery<(arg: AccountId32Like) => PalletStakingSlashingSlashingSpans | undefined>;

    /**
     * Records information about the maximum slash of a stash within a slashing span,
     * as well as how much reward has been paid out.
     **/
    spanSlash: GenericStorageQuery<(arg: [AccountId32Like, number]) => PalletStakingSlashingSpanRecord>;

    /**
     * The last planned session scheduled by the session pallet.
     *
     * This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
     **/
    currentPlannedSession: GenericStorageQuery<() => number>;

    /**
     * Indices of validators that have offended in the active era and whether they are currently
     * disabled.
     *
     * This value should be a superset of disabled validators since not all offences lead to the
     * validator being disabled (if there was no slash). This is needed to track the percentage of
     * validators that have offended in the current era, ensuring a new era is forced if
     * `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find
     * whether a given validator has previously offended using binary search. It gets cleared when
     * the era ends.
     **/
    offendingValidators: GenericStorageQuery<() => Array<[number, boolean]>>;

    /**
     * The threshold for when users can start calling `chill_other` for other validators /
     * nominators. The threshold is compared to the actual number of validators / nominators
     * (`CountFor*`) in the system compared to the configured max (`Max*Count`).
     **/
    chillThreshold: GenericStorageQuery<() => Percent | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  history: {
    /**
     * Mapping from historical session indices to session-data root hash and validator count.
     **/
    historicalSessions: GenericStorageQuery<(arg: number) => [H256, number] | undefined>;

    /**
     * The range of historical sessions we store. [first, last)
     **/
    storedRange: GenericStorageQuery<() => [number, number] | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  session: {
    /**
     * The current set of validators.
     **/
    validators: GenericStorageQuery<() => Array<AccountId32>>;

    /**
     * Current index of the session.
     **/
    currentIndex: GenericStorageQuery<() => number>;

    /**
     * True if the underlying economic identities or weighting behind the validators
     * has changed in the queued validator set.
     **/
    queuedChanged: GenericStorageQuery<() => boolean>;

    /**
     * The queued keys for the next session. When the next session begins, these keys
     * will be used to determine the validator's session keys.
     **/
    queuedKeys: GenericStorageQuery<() => Array<[AccountId32, AlephRuntimeSessionKeys]>>;

    /**
     * Indices of disabled validators.
     *
     * The vec is always kept sorted so that we can find whether a given validator is
     * disabled using binary search. It gets cleared when `on_session_ending` returns
     * a new set of identities.
     **/
    disabledValidators: GenericStorageQuery<() => Array<number>>;

    /**
     * The next session keys for a validator.
     **/
    nextKeys: GenericStorageQuery<(arg: AccountId32Like) => AlephRuntimeSessionKeys | undefined>;

    /**
     * The owner of a key. The key is the `KeyTypeId` + the encoded key.
     **/
    keyOwner: GenericStorageQuery<(arg: [SpCoreCryptoKeyTypeId, BytesLike]) => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  aleph: {
    authorities: GenericStorageQuery<() => Array<PrimitivesAppPublic>>;
    nextAuthorities: GenericStorageQuery<() => Array<PrimitivesAppPublic>>;

    /**
     * Set of account ids that will be used as authorities in the next session
     **/
    nextFinalityCommittee: GenericStorageQuery<() => Array<AccountId32>>;
    emergencyFinalizer: GenericStorageQuery<() => PrimitivesAppPublic | undefined>;
    queuedEmergencyFinalizer: GenericStorageQuery<() => PrimitivesAppPublic | undefined>;
    nextEmergencyFinalizer: GenericStorageQuery<() => PrimitivesAppPublic | undefined>;

    /**
     * Current finality version.
     **/
    finalityVersion: GenericStorageQuery<() => number>;

    /**
     * Scheduled finality version change.
     **/
    finalityScheduledVersionChange: GenericStorageQuery<() => PrimitivesVersionChange | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  elections: {
    /**
     * Desirable size of a committee, see [`CommitteeSeats`].
     **/
    committeeSize: GenericStorageQuery<() => PrimitivesCommitteeSeats>;

    /**
     * Desired size of a committee in effect from a new era.
     **/
    nextEraCommitteeSize: GenericStorageQuery<() => PrimitivesCommitteeSeats>;

    /**
     * Next era's list of reserved validators.
     **/
    nextEraReservedValidators: GenericStorageQuery<() => Array<AccountId32>>;

    /**
     * Current era's list of reserved validators.
     **/
    currentEraValidators: GenericStorageQuery<() => PrimitivesEraValidators>;

    /**
     * Next era's list of non reserved validators.
     **/
    nextEraNonReservedValidators: GenericStorageQuery<() => Array<AccountId32>>;

    /**
     * Openness of the elections, whether we allow all candidates that bonded enough tokens or
     * the validators list is managed by sudo
     **/
    openness: GenericStorageQuery<() => PrimitivesElectionOpenness>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  treasury: {
    /**
     * Number of proposals that have been made.
     **/
    proposalCount: GenericStorageQuery<() => number>;

    /**
     * Proposals that have been made.
     **/
    proposals: GenericStorageQuery<(arg: number) => PalletTreasuryProposal | undefined>;

    /**
     * The amount which has been reported as inactive to Currency.
     **/
    deactivated: GenericStorageQuery<() => bigint>;

    /**
     * Proposal indices that have been approved but not yet awarded.
     **/
    approvals: GenericStorageQuery<() => Array<number>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  vesting: {
    /**
     * Information regarding the vesting of a given account.
     **/
    vesting: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletVestingVestingInfo> | undefined>;

    /**
     * Storage version of the pallet.
     *
     * New networks start with latest version, as determined by the genesis build.
     **/
    storageVersion: GenericStorageQuery<() => PalletVestingReleases>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  multisig: {
    /**
     * The set of open multisig operations.
     **/
    multisigs: GenericStorageQuery<(arg: [AccountId32Like, FixedBytes<32>]) => PalletMultisigMultisig | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  sudo: {
    /**
     * The `AccountId` of the sudo key.
     **/
    key: GenericStorageQuery<() => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  contracts: {
    /**
     * A mapping from a contract's code hash to its code.
     **/
    pristineCode: GenericStorageQuery<(arg: H256) => Bytes | undefined>;

    /**
     * A mapping from a contract's code hash to its code info.
     **/
    codeInfoOf: GenericStorageQuery<(arg: H256) => PalletContractsWasmCodeInfo | undefined>;

    /**
     * This is a **monotonic** counter incremented on contract instantiation.
     *
     * This is used in order to generate unique trie ids for contracts.
     * The trie id of a new contract is calculated from hash(account_id, nonce).
     * The nonce is required because otherwise the following sequence would lead to
     * a possible collision of storage:
     *
     * 1. Create a new contract.
     * 2. Terminate the contract.
     * 3. Immediately recreate the contract with the same account_id.
     *
     * This is bad because the contents of a trie are deleted lazily and there might be
     * storage of the old instantiation still in it when the new contract is created. Please
     * note that we can't replace the counter by the block number because the sequence above
     * can happen in the same block. We also can't keep the account counter in memory only
     * because storage is the only way to communicate across different extrinsics in the
     * same block.
     *
     * # Note
     *
     * Do not use it to determine the number of contracts. It won't be decremented if
     * a contract is destroyed.
     **/
    nonce: GenericStorageQuery<() => bigint>;

    /**
     * The code associated with a given account.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     **/
    contractInfoOf: GenericStorageQuery<(arg: AccountId32Like) => PalletContractsStorageContractInfo | undefined>;

    /**
     * Evicted contracts that await child trie deletion.
     *
     * Child trie deletion is a heavy operation depending on the amount of storage items
     * stored in said trie. Therefore this operation is performed lazily in `on_idle`.
     **/
    deletionQueue: GenericStorageQuery<(arg: number) => Bytes | undefined>;

    /**
     * A pair of monotonic counters used to track the latest contract marked for deletion
     * and the latest deleted contract in queue.
     **/
    deletionQueueCounter: GenericStorageQuery<() => PalletContractsStorageDeletionQueueManager>;

    /**
     * A migration can span across multiple blocks. This storage defines a cursor to track the
     * progress of the migration, enabling us to resume from the last completed position.
     **/
    migrationInProgress: GenericStorageQuery<() => Bytes | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  nominationPools: {
    /**
     * Minimum amount to bond to join a pool.
     **/
    minJoinBond: GenericStorageQuery<() => bigint>;

    /**
     * Minimum bond required to create a pool.
     *
     * This is the amount that the depositor must put as their initial stake in the pool, as an
     * indication of "skin in the game".
     *
     * This is the value that will always exist in the staking ledger of the pool bonded account
     * while all other accounts leave.
     **/
    minCreateBond: GenericStorageQuery<() => bigint>;

    /**
     * Maximum number of nomination pools that can exist. If `None`, then an unbounded number of
     * pools can exist.
     **/
    maxPools: GenericStorageQuery<() => number | undefined>;

    /**
     * Maximum number of members that can exist in the system. If `None`, then the count
     * members are not bound on a system wide basis.
     **/
    maxPoolMembers: GenericStorageQuery<() => number | undefined>;

    /**
     * Maximum number of members that may belong to pool. If `None`, then the count of
     * members is not bound on a per pool basis.
     **/
    maxPoolMembersPerPool: GenericStorageQuery<() => number | undefined>;

    /**
     * The maximum commission that can be charged by a pool. Used on commission payouts to bound
     * pool commissions that are > `GlobalMaxCommission`, necessary if a future
     * `GlobalMaxCommission` is lower than some current pool commissions.
     **/
    globalMaxCommission: GenericStorageQuery<() => Perbill | undefined>;

    /**
     * Active members.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     **/
    poolMembers: GenericStorageQuery<(arg: AccountId32Like) => PalletNominationPoolsPoolMember | undefined>;

    /**
     * Counter for the related counted storage map
     **/
    counterForPoolMembers: GenericStorageQuery<() => number>;

    /**
     * Storage for bonded pools.
     **/
    bondedPools: GenericStorageQuery<(arg: number) => PalletNominationPoolsBondedPoolInner | undefined>;

    /**
     * Counter for the related counted storage map
     **/
    counterForBondedPools: GenericStorageQuery<() => number>;

    /**
     * Reward pools. This is where there rewards for each pool accumulate. When a members payout is
     * claimed, the balance comes out fo the reward pool. Keyed by the bonded pools account.
     **/
    rewardPools: GenericStorageQuery<(arg: number) => PalletNominationPoolsRewardPool | undefined>;

    /**
     * Counter for the related counted storage map
     **/
    counterForRewardPools: GenericStorageQuery<() => number>;

    /**
     * Groups of unbonding pools. Each group of unbonding pools belongs to a
     * bonded pool, hence the name sub-pools. Keyed by the bonded pools account.
     **/
    subPoolsStorage: GenericStorageQuery<(arg: number) => PalletNominationPoolsSubPools | undefined>;

    /**
     * Counter for the related counted storage map
     **/
    counterForSubPoolsStorage: GenericStorageQuery<() => number>;

    /**
     * Metadata for the pool.
     **/
    metadata: GenericStorageQuery<(arg: number) => Bytes>;

    /**
     * Counter for the related counted storage map
     **/
    counterForMetadata: GenericStorageQuery<() => number>;

    /**
     * Ever increasing number of all pools created so far.
     **/
    lastPoolId: GenericStorageQuery<() => number>;

    /**
     * A reverse lookup from the pool's account id to its id.
     *
     * This is only used for slashing. In all other instances, the pool id is used, and the
     * accounts are deterministically derived from it.
     **/
    reversePoolIdLookup: GenericStorageQuery<(arg: AccountId32Like) => number | undefined>;

    /**
     * Counter for the related counted storage map
     **/
    counterForReversePoolIdLookup: GenericStorageQuery<() => number>;

    /**
     * Map from a pool member account to their opted claim permission.
     **/
    claimPermissions: GenericStorageQuery<(arg: AccountId32Like) => PalletNominationPoolsClaimPermission>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  identity: {
    /**
     * Information that is pertinent to identify the entity behind an account.
     *
     * TWOX-NOTE: OK ― `AccountId` is a secure hash.
     **/
    identityOf: GenericStorageQuery<(arg: AccountId32Like) => PalletIdentityRegistration | undefined>;

    /**
     * The super-identity of an alternative "sub" identity together with its name, within that
     * context. If the account is not some other account's sub-identity, then just `None`.
     **/
    superOf: GenericStorageQuery<(arg: AccountId32Like) => [AccountId32, Data] | undefined>;

    /**
     * Alternative "sub" identities of this account.
     *
     * The first item is the deposit, the second is a vector of the accounts.
     *
     * TWOX-NOTE: OK ― `AccountId` is a secure hash.
     **/
    subsOf: GenericStorageQuery<(arg: AccountId32Like) => [bigint, Array<AccountId32>]>;

    /**
     * The set of registrars. Not expected to get very big as can only be added through a
     * special origin (likely a council motion).
     *
     * The index into this can be cast to `RegistrarIndex` to get a valid value.
     **/
    registrars: GenericStorageQuery<() => Array<PalletIdentityRegistrarInfo | undefined>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  committeeManagement: {
    lenientThreshold: GenericStorageQuery<() => Perquintill>;

    /**
     * A lookup how many blocks a validator produced.
     **/
    sessionValidatorBlockCount: GenericStorageQuery<(arg: AccountId32Like) => number>;

    /**
     * Total possible reward per validator for the current era.
     **/
    validatorEraTotalReward: GenericStorageQuery<() => PalletCommitteeManagementValidatorTotalRewards | undefined>;

    /**
     * Current era config for ban functionality, see [`BanConfig`]
     **/
    banConfig: GenericStorageQuery<() => PrimitivesBanConfig>;

    /**
     * A lookup for a number of underperformance sessions for a given validator
     **/
    underperformedValidatorSessionCount: GenericStorageQuery<(arg: AccountId32Like) => number>;

    /**
     * Validators to be removed from non reserved list in the next era
     **/
    banned: GenericStorageQuery<(arg: AccountId32Like) => PrimitivesBanInfo | undefined>;

    /**
     * SessionValidators in the current session.
     **/
    currentAndNextSessionValidatorsStorage: GenericStorageQuery<
      () => PalletCommitteeManagementCurrentAndNextSessionValidators
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
}
