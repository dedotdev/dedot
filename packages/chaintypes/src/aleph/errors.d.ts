// Generated by @dedot/codegen

import type { GenericChainErrors, GenericPalletError } from '@dedot/types';

export interface ChainErrors extends GenericChainErrors {
  /**
   * Pallet `System`'s errors
   **/
  system: {
    /**
     * The name of specification does not match between the current runtime
     * and the new runtime.
     **/
    InvalidSpecName: GenericPalletError;

    /**
     * The specification version is not allowed to decrease between the current runtime
     * and the new runtime.
     **/
    SpecVersionNeedsToIncrease: GenericPalletError;

    /**
     * Failed to extract the runtime version from the new runtime.
     *
     * Either calling `Core_version` or decoding `RuntimeVersion` failed.
     **/
    FailedToExtractRuntimeVersion: GenericPalletError;

    /**
     * Suicide called when the account has non-default composite data.
     **/
    NonDefaultComposite: GenericPalletError;

    /**
     * There is a non-zero reference count preventing the account from being purged.
     **/
    NonZeroRefCount: GenericPalletError;

    /**
     * The origin filter prevent the call to be dispatched.
     **/
    CallFiltered: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Scheduler`'s errors
   **/
  scheduler: {
    /**
     * Failed to schedule a call
     **/
    FailedToSchedule: GenericPalletError;

    /**
     * Cannot find the scheduled call.
     **/
    NotFound: GenericPalletError;

    /**
     * Given target block number is in the past.
     **/
    TargetBlockNumberInPast: GenericPalletError;

    /**
     * Reschedule failed because it does not change scheduled time.
     **/
    RescheduleNoChange: GenericPalletError;

    /**
     * Attempt to use a non-named function on a named task.
     **/
    Named: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Balances`'s errors
   **/
  balances: {
    /**
     * Vesting balance too high to send value.
     **/
    VestingBalance: GenericPalletError;

    /**
     * Account liquidity restrictions prevent withdrawal.
     **/
    LiquidityRestrictions: GenericPalletError;

    /**
     * Balance too low to send value.
     **/
    InsufficientBalance: GenericPalletError;

    /**
     * Value too low to create account due to existential deposit.
     **/
    ExistentialDeposit: GenericPalletError;

    /**
     * Transfer/payment would kill account.
     **/
    Expendability: GenericPalletError;

    /**
     * A vesting schedule already exists for this account.
     **/
    ExistingVestingSchedule: GenericPalletError;

    /**
     * Beneficiary account must pre-exist.
     **/
    DeadAccount: GenericPalletError;

    /**
     * Number of named reserves exceed `MaxReserves`.
     **/
    TooManyReserves: GenericPalletError;

    /**
     * Number of holds exceed `MaxHolds`.
     **/
    TooManyHolds: GenericPalletError;

    /**
     * Number of freezes exceed `MaxFreezes`.
     **/
    TooManyFreezes: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Staking`'s errors
   **/
  staking: {
    /**
     * Not a controller account.
     **/
    NotController: GenericPalletError;

    /**
     * Not a stash account.
     **/
    NotStash: GenericPalletError;

    /**
     * Stash is already bonded.
     **/
    AlreadyBonded: GenericPalletError;

    /**
     * Controller is already paired.
     **/
    AlreadyPaired: GenericPalletError;

    /**
     * Targets cannot be empty.
     **/
    EmptyTargets: GenericPalletError;

    /**
     * Duplicate index.
     **/
    DuplicateIndex: GenericPalletError;

    /**
     * Slash record index out of bounds.
     **/
    InvalidSlashIndex: GenericPalletError;

    /**
     * Cannot have a validator or nominator role, with value less than the minimum defined by
     * governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
     * intention, `chill` first to remove one's role as validator/nominator.
     **/
    InsufficientBond: GenericPalletError;

    /**
     * Can not schedule more unlock chunks.
     **/
    NoMoreChunks: GenericPalletError;

    /**
     * Can not rebond without unlocking chunks.
     **/
    NoUnlockChunk: GenericPalletError;

    /**
     * Attempting to target a stash that still has funds.
     **/
    FundedTarget: GenericPalletError;

    /**
     * Invalid era to reward.
     **/
    InvalidEraToReward: GenericPalletError;

    /**
     * Invalid number of nominations.
     **/
    InvalidNumberOfNominations: GenericPalletError;

    /**
     * Items are not sorted and unique.
     **/
    NotSortedAndUnique: GenericPalletError;

    /**
     * Rewards for this era have already been claimed for this validator.
     **/
    AlreadyClaimed: GenericPalletError;

    /**
     * Incorrect previous history depth input provided.
     **/
    IncorrectHistoryDepth: GenericPalletError;

    /**
     * Incorrect number of slashing spans provided.
     **/
    IncorrectSlashingSpans: GenericPalletError;

    /**
     * Internal state has become somehow corrupted and the operation cannot continue.
     **/
    BadState: GenericPalletError;

    /**
     * Too many nomination targets supplied.
     **/
    TooManyTargets: GenericPalletError;

    /**
     * A nomination target was supplied that was blocked or otherwise not a validator.
     **/
    BadTarget: GenericPalletError;

    /**
     * The user has enough bond and thus cannot be chilled forcefully by an external person.
     **/
    CannotChillOther: GenericPalletError;

    /**
     * There are too many nominators in the system. Governance needs to adjust the staking
     * settings to keep things safe for the runtime.
     **/
    TooManyNominators: GenericPalletError;

    /**
     * There are too many validator candidates in the system. Governance needs to adjust the
     * staking settings to keep things safe for the runtime.
     **/
    TooManyValidators: GenericPalletError;

    /**
     * Commission is too low. Must be at least `MinCommission`.
     **/
    CommissionTooLow: GenericPalletError;

    /**
     * Some bound is not met.
     **/
    BoundNotMet: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Session`'s errors
   **/
  session: {
    /**
     * Invalid ownership proof.
     **/
    InvalidProof: GenericPalletError;

    /**
     * No associated validator ID for account.
     **/
    NoAssociatedValidatorId: GenericPalletError;

    /**
     * Registered duplicate key.
     **/
    DuplicatedKey: GenericPalletError;

    /**
     * No keys are associated with this account.
     **/
    NoKeys: GenericPalletError;

    /**
     * Key setting account is not live, so it's impossible to associate keys.
     **/
    NoAccount: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Elections`'s errors
   **/
  elections: {
    NotEnoughValidators: GenericPalletError;
    NotEnoughReservedValidators: GenericPalletError;
    NotEnoughNonReservedValidators: GenericPalletError;
    NonUniqueListOfValidators: GenericPalletError;
    NonReservedFinalitySeatsLargerThanNonReservedSeats: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Treasury`'s errors
   **/
  treasury: {
    /**
     * Proposer's balance is too low.
     **/
    InsufficientProposersBalance: GenericPalletError;

    /**
     * No proposal or bounty at that index.
     **/
    InvalidIndex: GenericPalletError;

    /**
     * Too many approvals in the queue.
     **/
    TooManyApprovals: GenericPalletError;

    /**
     * The spend origin is valid but the amount it is allowed to spend is lower than the
     * amount to be spent.
     **/
    InsufficientPermission: GenericPalletError;

    /**
     * Proposal has not been approved.
     **/
    ProposalNotApproved: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Vesting`'s errors
   **/
  vesting: {
    /**
     * The account given is not vesting.
     **/
    NotVesting: GenericPalletError;

    /**
     * The account already has `MaxVestingSchedules` count of schedules and thus
     * cannot add another one. Consider merging existing schedules in order to add another.
     **/
    AtMaxVestingSchedules: GenericPalletError;

    /**
     * Amount being transferred is too low to create a vesting schedule.
     **/
    AmountLow: GenericPalletError;

    /**
     * An index was out of bounds of the vesting schedules.
     **/
    ScheduleIndexOutOfBounds: GenericPalletError;

    /**
     * Failed to create a new schedule because some parameter was invalid.
     **/
    InvalidScheduleParams: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Utility`'s errors
   **/
  utility: {
    /**
     * Too many calls batched.
     **/
    TooManyCalls: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Multisig`'s errors
   **/
  multisig: {
    /**
     * Threshold must be 2 or greater.
     **/
    MinimumThreshold: GenericPalletError;

    /**
     * Call is already approved by this signatory.
     **/
    AlreadyApproved: GenericPalletError;

    /**
     * Call doesn't need any (more) approvals.
     **/
    NoApprovalsNeeded: GenericPalletError;

    /**
     * There are too few signatories in the list.
     **/
    TooFewSignatories: GenericPalletError;

    /**
     * There are too many signatories in the list.
     **/
    TooManySignatories: GenericPalletError;

    /**
     * The signatories were provided out of order; they should be ordered.
     **/
    SignatoriesOutOfOrder: GenericPalletError;

    /**
     * The sender was contained in the other signatories; it shouldn't be.
     **/
    SenderInSignatories: GenericPalletError;

    /**
     * Multisig operation not found when attempting to cancel.
     **/
    NotFound: GenericPalletError;

    /**
     * Only the account that originally created the multisig is able to cancel it.
     **/
    NotOwner: GenericPalletError;

    /**
     * No timepoint was given, yet the multisig operation is already underway.
     **/
    NoTimepoint: GenericPalletError;

    /**
     * A different timepoint was given to the multisig operation that is underway.
     **/
    WrongTimepoint: GenericPalletError;

    /**
     * A timepoint was given, yet no multisig operation is underway.
     **/
    UnexpectedTimepoint: GenericPalletError;

    /**
     * The maximum weight information provided was too low.
     **/
    MaxWeightTooLow: GenericPalletError;

    /**
     * The data to be stored is already stored.
     **/
    AlreadyStored: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Sudo`'s errors
   **/
  sudo: {
    /**
     * Sender must be the Sudo account
     **/
    RequireSudo: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Contracts`'s errors
   **/
  contracts: {
    /**
     * Invalid schedule supplied, e.g. with zero weight of a basic operation.
     **/
    InvalidSchedule: GenericPalletError;

    /**
     * Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`.
     **/
    InvalidCallFlags: GenericPalletError;

    /**
     * The executed contract exhausted its gas limit.
     **/
    OutOfGas: GenericPalletError;

    /**
     * The output buffer supplied to a contract API call was too small.
     **/
    OutputBufferTooSmall: GenericPalletError;

    /**
     * Performing the requested transfer failed. Probably because there isn't enough
     * free balance in the sender's account.
     **/
    TransferFailed: GenericPalletError;

    /**
     * Performing a call was denied because the calling depth reached the limit
     * of what is specified in the schedule.
     **/
    MaxCallDepthReached: GenericPalletError;

    /**
     * No contract was found at the specified address.
     **/
    ContractNotFound: GenericPalletError;

    /**
     * The code supplied to `instantiate_with_code` exceeds the limit specified in the
     * current schedule.
     **/
    CodeTooLarge: GenericPalletError;

    /**
     * No code could be found at the supplied code hash.
     **/
    CodeNotFound: GenericPalletError;

    /**
     * No code info could be found at the supplied code hash.
     **/
    CodeInfoNotFound: GenericPalletError;

    /**
     * A buffer outside of sandbox memory was passed to a contract API function.
     **/
    OutOfBounds: GenericPalletError;

    /**
     * Input passed to a contract API function failed to decode as expected type.
     **/
    DecodingFailed: GenericPalletError;

    /**
     * Contract trapped during execution.
     **/
    ContractTrapped: GenericPalletError;

    /**
     * The size defined in `T::MaxValueSize` was exceeded.
     **/
    ValueTooLarge: GenericPalletError;

    /**
     * Termination of a contract is not allowed while the contract is already
     * on the call stack. Can be triggered by `seal_terminate`.
     **/
    TerminatedWhileReentrant: GenericPalletError;

    /**
     * `seal_call` forwarded this contracts input. It therefore is no longer available.
     **/
    InputForwarded: GenericPalletError;

    /**
     * The subject passed to `seal_random` exceeds the limit.
     **/
    RandomSubjectTooLong: GenericPalletError;

    /**
     * The amount of topics passed to `seal_deposit_events` exceeds the limit.
     **/
    TooManyTopics: GenericPalletError;

    /**
     * The chain does not provide a chain extension. Calling the chain extension results
     * in this error. Note that this usually shouldn't happen as deploying such contracts
     * is rejected.
     **/
    NoChainExtension: GenericPalletError;

    /**
     * A contract with the same AccountId already exists.
     **/
    DuplicateContract: GenericPalletError;

    /**
     * A contract self destructed in its constructor.
     *
     * This can be triggered by a call to `seal_terminate`.
     **/
    TerminatedInConstructor: GenericPalletError;

    /**
     * A call tried to invoke a contract that is flagged as non-reentrant.
     * The only other cause is that a call from a contract into the runtime tried to call back
     * into `pallet-contracts`. This would make the whole pallet reentrant with regard to
     * contract code execution which is not supported.
     **/
    ReentranceDenied: GenericPalletError;

    /**
     * Origin doesn't have enough balance to pay the required storage deposits.
     **/
    StorageDepositNotEnoughFunds: GenericPalletError;

    /**
     * More storage was created than allowed by the storage deposit limit.
     **/
    StorageDepositLimitExhausted: GenericPalletError;

    /**
     * Code removal was denied because the code is still in use by at least one contract.
     **/
    CodeInUse: GenericPalletError;

    /**
     * The contract ran to completion but decided to revert its storage changes.
     * Please note that this error is only returned from extrinsics. When called directly
     * or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags
     * to determine whether a reversion has taken place.
     **/
    ContractReverted: GenericPalletError;

    /**
     * The contract's code was found to be invalid during validation.
     *
     * The most likely cause of this is that an API was used which is not supported by the
     * node. This happens if an older node is used with a new version of ink!. Try updating
     * your node to the newest available version.
     *
     * A more detailed error can be found on the node console if debug messages are enabled
     * by supplying `-lruntime::contracts=debug`.
     **/
    CodeRejected: GenericPalletError;

    /**
     * An indetermistic code was used in a context where this is not permitted.
     **/
    Indeterministic: GenericPalletError;

    /**
     * A pending migration needs to complete before the extrinsic can be called.
     **/
    MigrationInProgress: GenericPalletError;

    /**
     * Migrate dispatch call was attempted but no migration was performed.
     **/
    NoMigrationPerformed: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `NominationPools`'s errors
   **/
  nominationPools: {
    /**
     * A (bonded) pool id does not exist.
     **/
    PoolNotFound: GenericPalletError;

    /**
     * An account is not a member.
     **/
    PoolMemberNotFound: GenericPalletError;

    /**
     * A reward pool does not exist. In all cases this is a system logic error.
     **/
    RewardPoolNotFound: GenericPalletError;

    /**
     * A sub pool does not exist.
     **/
    SubPoolsNotFound: GenericPalletError;

    /**
     * An account is already delegating in another pool. An account may only belong to one
     * pool at a time.
     **/
    AccountBelongsToOtherPool: GenericPalletError;

    /**
     * The member is fully unbonded (and thus cannot access the bonded and reward pool
     * anymore to, for example, collect rewards).
     **/
    FullyUnbonding: GenericPalletError;

    /**
     * The member cannot unbond further chunks due to reaching the limit.
     **/
    MaxUnbondingLimit: GenericPalletError;

    /**
     * None of the funds can be withdrawn yet because the bonding duration has not passed.
     **/
    CannotWithdrawAny: GenericPalletError;

    /**
     * The amount does not meet the minimum bond to either join or create a pool.
     *
     * The depositor can never unbond to a value less than
     * `Pallet::depositor_min_bond`. The caller does not have nominating
     * permissions for the pool. Members can never unbond to a value below `MinJoinBond`.
     **/
    MinimumBondNotMet: GenericPalletError;

    /**
     * The transaction could not be executed due to overflow risk for the pool.
     **/
    OverflowRisk: GenericPalletError;

    /**
     * A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
     * other members to be permissionlessly unbonded.
     **/
    NotDestroying: GenericPalletError;

    /**
     * The caller does not have nominating permissions for the pool.
     **/
    NotNominator: GenericPalletError;

    /**
     * Either a) the caller cannot make a valid kick or b) the pool is not destroying.
     **/
    NotKickerOrDestroying: GenericPalletError;

    /**
     * The pool is not open to join
     **/
    NotOpen: GenericPalletError;

    /**
     * The system is maxed out on pools.
     **/
    MaxPools: GenericPalletError;

    /**
     * Too many members in the pool or system.
     **/
    MaxPoolMembers: GenericPalletError;

    /**
     * The pools state cannot be changed.
     **/
    CanNotChangeState: GenericPalletError;

    /**
     * The caller does not have adequate permissions.
     **/
    DoesNotHavePermission: GenericPalletError;

    /**
     * Metadata exceeds [`Config::MaxMetadataLen`]
     **/
    MetadataExceedsMaxLen: GenericPalletError;

    /**
     * Some error occurred that should never happen. This should be reported to the
     * maintainers.
     **/
    Defensive: GenericPalletError;

    /**
     * Partial unbonding now allowed permissionlessly.
     **/
    PartialUnbondNotAllowedPermissionlessly: GenericPalletError;

    /**
     * The pool's max commission cannot be set higher than the existing value.
     **/
    MaxCommissionRestricted: GenericPalletError;

    /**
     * The supplied commission exceeds the max allowed commission.
     **/
    CommissionExceedsMaximum: GenericPalletError;

    /**
     * The supplied commission exceeds global maximum commission.
     **/
    CommissionExceedsGlobalMaximum: GenericPalletError;

    /**
     * Not enough blocks have surpassed since the last commission update.
     **/
    CommissionChangeThrottled: GenericPalletError;

    /**
     * The submitted changes to commission change rate are not allowed.
     **/
    CommissionChangeRateNotAllowed: GenericPalletError;

    /**
     * There is no pending commission to claim.
     **/
    NoPendingCommission: GenericPalletError;

    /**
     * No commission current has been set.
     **/
    NoCommissionCurrentSet: GenericPalletError;

    /**
     * Pool id currently in use.
     **/
    PoolIdInUse: GenericPalletError;

    /**
     * Pool id provided is not correct/usable.
     **/
    InvalidPoolId: GenericPalletError;

    /**
     * Bonding extra is restricted to the exact pending reward amount.
     **/
    BondExtraRestricted: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Identity`'s errors
   **/
  identity: {
    /**
     * Too many subs-accounts.
     **/
    TooManySubAccounts: GenericPalletError;

    /**
     * Account isn't found.
     **/
    NotFound: GenericPalletError;

    /**
     * Account isn't named.
     **/
    NotNamed: GenericPalletError;

    /**
     * Empty index.
     **/
    EmptyIndex: GenericPalletError;

    /**
     * Fee is changed.
     **/
    FeeChanged: GenericPalletError;

    /**
     * No identity found.
     **/
    NoIdentity: GenericPalletError;

    /**
     * Sticky judgement.
     **/
    StickyJudgement: GenericPalletError;

    /**
     * Judgement given.
     **/
    JudgementGiven: GenericPalletError;

    /**
     * Invalid judgement.
     **/
    InvalidJudgement: GenericPalletError;

    /**
     * The index is invalid.
     **/
    InvalidIndex: GenericPalletError;

    /**
     * The target is invalid.
     **/
    InvalidTarget: GenericPalletError;

    /**
     * Too many additional fields.
     **/
    TooManyFields: GenericPalletError;

    /**
     * Maximum amount of registrars reached. Cannot add any more.
     **/
    TooManyRegistrars: GenericPalletError;

    /**
     * Account ID is already named.
     **/
    AlreadyClaimed: GenericPalletError;

    /**
     * Sender is not a sub-account.
     **/
    NotSub: GenericPalletError;

    /**
     * Sub-account isn't owned by sender.
     **/
    NotOwned: GenericPalletError;

    /**
     * The provided judgement was for a different identity.
     **/
    JudgementForDifferentIdentity: GenericPalletError;

    /**
     * Error that occurs when there is an issue paying for judgement.
     **/
    JudgementPaymentFailed: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `CommitteeManagement`'s errors
   **/
  committeeManagement: {
    /**
     * Raised in any scenario [`BanConfig`] is invalid
     * * `performance_ratio_threshold` must be a number in range [0; 100]
     * * `underperformed_session_count_threshold` must be a positive number,
     * * `clean_session_counter_delay` must be a positive number.
     **/
    InvalidBanConfig: GenericPalletError;

    /**
     * Ban reason is too big, ie given vector of bytes is greater than
     * [`primitives::DEFAULT_BAN_REASON_LENGTH`]
     **/
    BanReasonTooBig: GenericPalletError;

    /**
     * Lenient threshold not in [0-100] range
     **/
    InvalidLenientThreshold: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
}
