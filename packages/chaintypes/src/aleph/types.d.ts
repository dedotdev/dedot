// Generated by @dedot/codegen

import type {
  Phase,
  H256,
  DispatchInfo,
  DispatchError,
  AccountId32,
  FixedBytes,
  Result,
  Perbill,
  Bytes,
  BytesLike,
  MultiAddress,
  MultiAddressLike,
  AccountId32Like,
  Percent,
  Data,
  FixedU128,
  Era,
  Header,
  UncheckedExtrinsic,
} from '@dedot/codecs';

export type FrameSystemAccountInfo = {
  nonce: number;
  consumers: number;
  providers: number;
  sufficients: number;
  data: PalletBalancesAccountData;
};

export type PalletBalancesAccountData = {
  free: bigint;
  reserved: bigint;
  frozen: bigint;
  flags: PalletBalancesExtraFlags;
};

export type PalletBalancesExtraFlags = bigint;

export type FrameSupportDispatchPerDispatchClass = {
  normal: SpWeightsWeightV2Weight;
  operational: SpWeightsWeightV2Weight;
  mandatory: SpWeightsWeightV2Weight;
};

export type SpWeightsWeightV2Weight = { refTime: bigint; proofSize: bigint };

export type FrameSystemEventRecord = { phase: Phase; event: AlephRuntimeRuntimeEvent; topics: Array<H256> };

export type AlephRuntimeRuntimeEvent =
  | { pallet: 'System'; palletEvent: FrameSystemEvent }
  | { pallet: 'Scheduler'; palletEvent: PalletSchedulerEvent }
  | { pallet: 'Balances'; palletEvent: PalletBalancesEvent }
  | { pallet: 'TransactionPayment'; palletEvent: PalletTransactionPaymentEvent }
  | { pallet: 'Staking'; palletEvent: PalletStakingPalletEvent }
  | { pallet: 'Session'; palletEvent: PalletSessionEvent }
  | { pallet: 'Aleph'; palletEvent: PalletAlephEvent }
  | { pallet: 'Elections'; palletEvent: PalletElectionsEvent }
  | { pallet: 'Treasury'; palletEvent: PalletTreasuryEvent }
  | { pallet: 'Vesting'; palletEvent: PalletVestingEvent }
  | { pallet: 'Utility'; palletEvent: PalletUtilityEvent }
  | { pallet: 'Multisig'; palletEvent: PalletMultisigEvent }
  | { pallet: 'Sudo'; palletEvent: PalletSudoEvent }
  | { pallet: 'Contracts'; palletEvent: PalletContractsEvent }
  | { pallet: 'NominationPools'; palletEvent: PalletNominationPoolsEvent }
  | { pallet: 'Identity'; palletEvent: PalletIdentityEvent }
  | { pallet: 'CommitteeManagement'; palletEvent: PalletCommitteeManagementEvent };

/**
 * Event for the System pallet.
 **/
export type FrameSystemEvent =
  /**
   * An extrinsic completed successfully.
   **/
  | { name: 'ExtrinsicSuccess'; data: { dispatchInfo: DispatchInfo } }
  /**
   * An extrinsic failed.
   **/
  | { name: 'ExtrinsicFailed'; data: { dispatchError: DispatchError; dispatchInfo: DispatchInfo } }
  /**
   * `:code` was updated.
   **/
  | { name: 'CodeUpdated' }
  /**
   * A new account was created.
   **/
  | { name: 'NewAccount'; data: { account: AccountId32 } }
  /**
   * An account was reaped.
   **/
  | { name: 'KilledAccount'; data: { account: AccountId32 } }
  /**
   * On on-chain remark happened.
   **/
  | { name: 'Remarked'; data: { sender: AccountId32; hash: H256 } };

export type FrameSupportDispatchDispatchClass = 'Normal' | 'Operational' | 'Mandatory';

export type FrameSupportDispatchPays = 'Yes' | 'No';

/**
 * Events type.
 **/
export type PalletSchedulerEvent =
  /**
   * Scheduled some task.
   **/
  | { name: 'Scheduled'; data: { when: number; index: number } }
  /**
   * Canceled some task.
   **/
  | { name: 'Canceled'; data: { when: number; index: number } }
  /**
   * Dispatched some task.
   **/
  | {
      name: 'Dispatched';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined; result: Result<[], DispatchError> };
    }
  /**
   * The call for the provided hash was not found so the task has been aborted.
   **/
  | { name: 'CallUnavailable'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task was unable to be renewed since the agenda is full at that block.
   **/
  | { name: 'PeriodicFailed'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task can never be executed since it is overweight.
   **/
  | { name: 'PermanentlyOverweight'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBalancesEvent =
  /**
   * An account was created with some free balance.
   **/
  | { name: 'Endowed'; data: { account: AccountId32; freeBalance: bigint } }
  /**
   * An account was removed whose balance was non-zero but below ExistentialDeposit,
   * resulting in an outright loss.
   **/
  | { name: 'DustLost'; data: { account: AccountId32; amount: bigint } }
  /**
   * Transfer succeeded.
   **/
  | { name: 'Transfer'; data: { from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * A balance was set by root.
   **/
  | { name: 'BalanceSet'; data: { who: AccountId32; free: bigint } }
  /**
   * Some balance was reserved (moved from free to reserved).
   **/
  | { name: 'Reserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unreserved (moved from reserved to free).
   **/
  | { name: 'Unreserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was moved from the reserve of the first account to the second account.
   * Final argument indicates the destination balance type.
   **/
  | {
      name: 'ReserveRepatriated';
      data: {
        from: AccountId32;
        to: AccountId32;
        amount: bigint;
        destinationStatus: FrameSupportTokensMiscBalanceStatus;
      };
    }
  /**
   * Some amount was deposited (e.g. for transaction fees).
   **/
  | { name: 'Deposit'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was withdrawn from the account (e.g. for transaction fees).
   **/
  | { name: 'Withdraw'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was removed from the account (e.g. for misbehavior).
   **/
  | { name: 'Slashed'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was minted into an account.
   **/
  | { name: 'Minted'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was burned from an account.
   **/
  | { name: 'Burned'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was suspended from an account (it can be restored later).
   **/
  | { name: 'Suspended'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was restored into an account.
   **/
  | { name: 'Restored'; data: { who: AccountId32; amount: bigint } }
  /**
   * An account was upgraded.
   **/
  | { name: 'Upgraded'; data: { who: AccountId32 } }
  /**
   * Total issuance was increased by `amount`, creating a credit to be balanced.
   **/
  | { name: 'Issued'; data: { amount: bigint } }
  /**
   * Total issuance was decreased by `amount`, creating a debt to be balanced.
   **/
  | { name: 'Rescinded'; data: { amount: bigint } }
  /**
   * Some balance was locked.
   **/
  | { name: 'Locked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unlocked.
   **/
  | { name: 'Unlocked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was frozen.
   **/
  | { name: 'Frozen'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was thawed.
   **/
  | { name: 'Thawed'; data: { who: AccountId32; amount: bigint } };

export type FrameSupportTokensMiscBalanceStatus = 'Free' | 'Reserved';

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who`.
   **/
  { name: 'TransactionFeePaid'; data: { who: AccountId32; actualFee: bigint; tip: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletStakingPalletEvent =
  /**
   * The era payout has been set; the first balance is the validator-payout; the second is
   * the remainder from the maximum amount of reward.
   **/
  | { name: 'EraPaid'; data: { eraIndex: number; validatorPayout: bigint; remainder: bigint } }
  /**
   * The nominator has been rewarded by this amount.
   **/
  | { name: 'Rewarded'; data: { stash: AccountId32; amount: bigint } }
  /**
   * A staker (validator or nominator) has been slashed by the given amount.
   **/
  | { name: 'Slashed'; data: { staker: AccountId32; amount: bigint } }
  /**
   * A slash for the given validator, for the given percentage of their stake, at the given
   * era as been reported.
   **/
  | { name: 'SlashReported'; data: { validator: AccountId32; fraction: Perbill; slashEra: number } }
  /**
   * An old slashing report from a prior era was discarded because it could
   * not be processed.
   **/
  | { name: 'OldSlashingReportDiscarded'; data: { sessionIndex: number } }
  /**
   * A new set of stakers was elected.
   **/
  | { name: 'StakersElected' }
  /**
   * An account has bonded this amount. \[stash, amount\]
   *
   * NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,
   * it will not be emitted for staking rewards when they are added to stake.
   **/
  | { name: 'Bonded'; data: { stash: AccountId32; amount: bigint } }
  /**
   * An account has unbonded this amount.
   **/
  | { name: 'Unbonded'; data: { stash: AccountId32; amount: bigint } }
  /**
   * An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`
   * from the unlocking queue.
   **/
  | { name: 'Withdrawn'; data: { stash: AccountId32; amount: bigint } }
  /**
   * A nominator has been kicked from a validator.
   **/
  | { name: 'Kicked'; data: { nominator: AccountId32; stash: AccountId32 } }
  /**
   * The election failed. No new era is planned.
   **/
  | { name: 'StakingElectionFailed' }
  /**
   * An account has stopped participating as either a validator or nominator.
   **/
  | { name: 'Chilled'; data: { stash: AccountId32 } }
  /**
   * The stakers' rewards are getting paid.
   **/
  | { name: 'PayoutStarted'; data: { eraIndex: number; validatorStash: AccountId32 } }
  /**
   * A validator has set their preferences.
   **/
  | { name: 'ValidatorPrefsSet'; data: { stash: AccountId32; prefs: PalletStakingValidatorPrefs } }
  /**
   * A new force era mode was set.
   **/
  | { name: 'ForceEra'; data: { mode: PalletStakingForcing } };

export type PalletStakingValidatorPrefs = { commission: Perbill; blocked: boolean };

export type PalletStakingForcing = 'NotForcing' | 'ForceNew' | 'ForceNone' | 'ForceAlways';

/**
 * The `Event` enum of this pallet
 **/
export type PalletSessionEvent =
  /**
   * New session has happened. Note that the argument is the session index, not the
   * block number as the type might suggest.
   **/
  { name: 'NewSession'; data: { sessionIndex: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAlephEvent =
  | { name: 'ChangeEmergencyFinalizer'; data: PrimitivesAppPublic }
  | { name: 'ScheduleFinalityVersionChange'; data: PrimitivesVersionChange }
  | { name: 'FinalityVersionChange'; data: PrimitivesVersionChange };

export type PrimitivesAppPublic = SpCoreEd25519Public;

export type SpCoreEd25519Public = FixedBytes<32>;

export type PrimitivesVersionChange = { versionIncoming: number; session: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletElectionsEvent =
  /**
   * Committee for the next era has changed
   **/
  { name: 'ChangeValidators'; data: [Array<AccountId32>, Array<AccountId32>, PrimitivesCommitteeSeats] };

export type PrimitivesCommitteeSeats = {
  reservedSeats: number;
  nonReservedSeats: number;
  nonReservedFinalitySeats: number;
};

/**
 * The `Event` enum of this pallet
 **/
export type PalletTreasuryEvent =
  /**
   * New proposal.
   **/
  | { name: 'Proposed'; data: { proposalIndex: number } }
  /**
   * We have ended a spend period and will now allocate funds.
   **/
  | { name: 'Spending'; data: { budgetRemaining: bigint } }
  /**
   * Some funds have been allocated.
   **/
  | { name: 'Awarded'; data: { proposalIndex: number; award: bigint; account: AccountId32 } }
  /**
   * A proposal was rejected; funds were slashed.
   **/
  | { name: 'Rejected'; data: { proposalIndex: number; slashed: bigint } }
  /**
   * Some of our funds have been burnt.
   **/
  | { name: 'Burnt'; data: { burntFunds: bigint } }
  /**
   * Spending has finished; this is the amount that rolls over until next spend.
   **/
  | { name: 'Rollover'; data: { rolloverBalance: bigint } }
  /**
   * Some funds have been deposited.
   **/
  | { name: 'Deposit'; data: { value: bigint } }
  /**
   * A new spend proposal has been approved.
   **/
  | { name: 'SpendApproved'; data: { proposalIndex: number; amount: bigint; beneficiary: AccountId32 } }
  /**
   * The inactive funds of the pallet have been updated.
   **/
  | { name: 'UpdatedInactive'; data: { reactivated: bigint; deactivated: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletVestingEvent =
  /**
   * The amount vested has been updated. This could indicate a change in funds available.
   * The balance given is the amount which is left unvested (and thus locked).
   **/
  | { name: 'VestingUpdated'; data: { account: AccountId32; unvested: bigint } }
  /**
   * An \[account\] has become fully vested.
   **/
  | { name: 'VestingCompleted'; data: { account: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletUtilityEvent =
  /**
   * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
   * well as the error.
   **/
  | { name: 'BatchInterrupted'; data: { index: number; error: DispatchError } }
  /**
   * Batch of dispatches completed fully with no error.
   **/
  | { name: 'BatchCompleted' }
  /**
   * Batch of dispatches completed but has errors.
   **/
  | { name: 'BatchCompletedWithErrors' }
  /**
   * A single item within a Batch of dispatches has completed with no error.
   **/
  | { name: 'ItemCompleted' }
  /**
   * A single item within a Batch of dispatches has completed with error.
   **/
  | { name: 'ItemFailed'; data: { error: DispatchError } }
  /**
   * A call was dispatched.
   **/
  | { name: 'DispatchedAs'; data: { result: Result<[], DispatchError> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMultisigEvent =
  /**
   * A new multisig operation has begun.
   **/
  | { name: 'NewMultisig'; data: { approving: AccountId32; multisig: AccountId32; callHash: FixedBytes<32> } }
  /**
   * A multisig operation has been approved by someone.
   **/
  | {
      name: 'MultisigApproval';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been executed.
   **/
  | {
      name: 'MultisigExecuted';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
        result: Result<[], DispatchError>;
      };
    }
  /**
   * A multisig operation has been cancelled.
   **/
  | {
      name: 'MultisigCancelled';
      data: {
        cancelling: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigTimepoint = { height: number; index: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSudoEvent =
  /**
   * A sudo just took place. \[result\]
   **/
  | { name: 'Sudid'; data: { sudoResult: Result<[], DispatchError> } }
  /**
   * The \[sudoer\] just switched identity; the old key is supplied if one existed.
   **/
  | { name: 'KeyChanged'; data: { oldSudoer?: AccountId32 | undefined } }
  /**
   * A sudo just took place. \[result\]
   **/
  | { name: 'SudoAsDone'; data: { sudoResult: Result<[], DispatchError> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletContractsEvent =
  /**
   * Contract deployed by address at the specified address.
   **/
  | { name: 'Instantiated'; data: { deployer: AccountId32; contract: AccountId32 } }
  /**
   * Contract has been removed.
   *
   * # Note
   *
   * The only way for a contract to be removed and emitting this event is by calling
   * `seal_terminate`.
   **/
  | {
      name: 'Terminated';
      data: {
        /**
         * The contract that was terminated.
         **/
        contract: AccountId32;

        /**
         * The account that received the contracts remaining balance
         **/
        beneficiary: AccountId32;
      };
    }
  /**
   * Code with the specified hash has been stored.
   **/
  | { name: 'CodeStored'; data: { codeHash: H256 } }
  /**
   * A custom event emitted by the contract.
   **/
  | {
      name: 'ContractEmitted';
      data: {
        /**
         * The contract that emitted the event.
         **/
        contract: AccountId32;

        /**
         * Data supplied by the contract. Metadata generated during contract compilation
         * is needed to decode it.
         **/
        data: Bytes;
      };
    }
  /**
   * A code with the specified hash was removed.
   **/
  | { name: 'CodeRemoved'; data: { codeHash: H256 } }
  /**
   * A contract's code was updated.
   **/
  | {
      name: 'ContractCodeUpdated';
      data: {
        /**
         * The contract that has been updated.
         **/
        contract: AccountId32;

        /**
         * New code hash that was set for the contract.
         **/
        newCodeHash: H256;

        /**
         * Previous code hash of the contract.
         **/
        oldCodeHash: H256;
      };
    }
  /**
   * A contract was called either by a plain account or another contract.
   *
   * # Note
   *
   * Please keep in mind that like all events this is only emitted for successful
   * calls. This is because on failure all storage changes including events are
   * rolled back.
   **/
  | {
      name: 'Called';
      data: {
        /**
         * The caller of the `contract`.
         **/
        caller: PalletContractsOrigin;

        /**
         * The contract that was called.
         **/
        contract: AccountId32;
      };
    }
  /**
   * A contract delegate called a code hash.
   *
   * # Note
   *
   * Please keep in mind that like all events this is only emitted for successful
   * calls. This is because on failure all storage changes including events are
   * rolled back.
   **/
  | {
      name: 'DelegateCalled';
      data: {
        /**
         * The contract that performed the delegate call and hence in whose context
         * the `code_hash` is executed.
         **/
        contract: AccountId32;

        /**
         * The code hash that was delegate called.
         **/
        codeHash: H256;
      };
    };

export type PalletContractsOrigin = { tag: 'Root' } | { tag: 'Signed'; value: AccountId32 };

export type AlephRuntimeRuntime = {};

/**
 * Events of this pallet.
 **/
export type PalletNominationPoolsEvent =
  /**
   * A pool has been created.
   **/
  | { name: 'Created'; data: { depositor: AccountId32; poolId: number } }
  /**
   * A member has became bonded in a pool.
   **/
  | { name: 'Bonded'; data: { member: AccountId32; poolId: number; bonded: bigint; joined: boolean } }
  /**
   * A payout has been made to a member.
   **/
  | { name: 'PaidOut'; data: { member: AccountId32; poolId: number; payout: bigint } }
  /**
   * A member has unbonded from their pool.
   *
   * - `balance` is the corresponding balance of the number of points that has been
   * requested to be unbonded (the argument of the `unbond` transaction) from the bonded
   * pool.
   * - `points` is the number of points that are issued as a result of `balance` being
   * dissolved into the corresponding unbonding pool.
   * - `era` is the era in which the balance will be unbonded.
   * In the absence of slashing, these values will match. In the presence of slashing, the
   * number of points that are issued in the unbonding pool will be less than the amount
   * requested to be unbonded.
   **/
  | { name: 'Unbonded'; data: { member: AccountId32; poolId: number; balance: bigint; points: bigint; era: number } }
  /**
   * A member has withdrawn from their pool.
   *
   * The given number of `points` have been dissolved in return of `balance`.
   *
   * Similar to `Unbonded` event, in the absence of slashing, the ratio of point to balance
   * will be 1.
   **/
  | { name: 'Withdrawn'; data: { member: AccountId32; poolId: number; balance: bigint; points: bigint } }
  /**
   * A pool has been destroyed.
   **/
  | { name: 'Destroyed'; data: { poolId: number } }
  /**
   * The state of a pool has changed
   **/
  | { name: 'StateChanged'; data: { poolId: number; newState: PalletNominationPoolsPoolState } }
  /**
   * A member has been removed from a pool.
   *
   * The removal can be voluntary (withdrawn all unbonded funds) or involuntary (kicked).
   **/
  | { name: 'MemberRemoved'; data: { poolId: number; member: AccountId32 } }
  /**
   * The roles of a pool have been updated to the given new roles. Note that the depositor
   * can never change.
   **/
  | {
      name: 'RolesUpdated';
      data: { root?: AccountId32 | undefined; bouncer?: AccountId32 | undefined; nominator?: AccountId32 | undefined };
    }
  /**
   * The active balance of pool `pool_id` has been slashed to `balance`.
   **/
  | { name: 'PoolSlashed'; data: { poolId: number; balance: bigint } }
  /**
   * The unbond pool at `era` of pool `pool_id` has been slashed to `balance`.
   **/
  | { name: 'UnbondingPoolSlashed'; data: { poolId: number; era: number; balance: bigint } }
  /**
   * A pool's commission setting has been changed.
   **/
  | { name: 'PoolCommissionUpdated'; data: { poolId: number; current?: [Perbill, AccountId32] | undefined } }
  /**
   * A pool's maximum commission setting has been changed.
   **/
  | { name: 'PoolMaxCommissionUpdated'; data: { poolId: number; maxCommission: Perbill } }
  /**
   * A pool's commission `change_rate` has been changed.
   **/
  | {
      name: 'PoolCommissionChangeRateUpdated';
      data: { poolId: number; changeRate: PalletNominationPoolsCommissionChangeRate };
    }
  /**
   * Pool commission has been claimed.
   **/
  | { name: 'PoolCommissionClaimed'; data: { poolId: number; commission: bigint } };

export type PalletNominationPoolsPoolState = 'Open' | 'Blocked' | 'Destroying';

export type PalletNominationPoolsCommissionChangeRate = { maxIncrease: Perbill; minDelay: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletIdentityEvent =
  /**
   * A name was set or reset (which will remove all judgements).
   **/
  | { name: 'IdentitySet'; data: { who: AccountId32 } }
  /**
   * A name was cleared, and the given balance returned.
   **/
  | { name: 'IdentityCleared'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A name was removed and the given balance slashed.
   **/
  | { name: 'IdentityKilled'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A judgement was asked from a registrar.
   **/
  | { name: 'JudgementRequested'; data: { who: AccountId32; registrarIndex: number } }
  /**
   * A judgement request was retracted.
   **/
  | { name: 'JudgementUnrequested'; data: { who: AccountId32; registrarIndex: number } }
  /**
   * A judgement was given by a registrar.
   **/
  | { name: 'JudgementGiven'; data: { target: AccountId32; registrarIndex: number } }
  /**
   * A registrar was added.
   **/
  | { name: 'RegistrarAdded'; data: { registrarIndex: number } }
  /**
   * A sub-identity was added to an identity and the deposit paid.
   **/
  | { name: 'SubIdentityAdded'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A sub-identity was removed from an identity and the deposit freed.
   **/
  | { name: 'SubIdentityRemoved'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A sub-identity was cleared, and the given deposit repatriated from the
   * main identity account to the sub-identity account.
   **/
  | { name: 'SubIdentityRevoked'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletCommitteeManagementEvent =
  /**
   * Ban thresholds for the next era has changed
   **/
  | { name: 'SetBanConfig'; data: PrimitivesBanConfig }
  /**
   * Validators have been banned from the committee
   **/
  | { name: 'BanValidators'; data: Array<[AccountId32, PrimitivesBanInfo]> };

export type PrimitivesBanConfig = {
  minimalExpectedPerformance: Perbill;
  underperformedSessionCountThreshold: number;
  cleanSessionCounterDelay: number;
  banPeriod: number;
};

export type PrimitivesBanInfo = { reason: PrimitivesBanReason; start: number };

export type PrimitivesBanReason = { tag: 'InsufficientUptime'; value: number } | { tag: 'OtherReason'; value: Bytes };

export type FrameSystemLastRuntimeUpgradeInfo = { specVersion: number; specName: string };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type FrameSystemCall =
  /**
   * See [`Pallet::remark`].
   **/
  | { name: 'Remark'; params: { remark: Bytes } }
  /**
   * See [`Pallet::set_heap_pages`].
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * See [`Pallet::set_code`].
   **/
  | { name: 'SetCode'; params: { code: Bytes } }
  /**
   * See [`Pallet::set_code_without_checks`].
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: Bytes } }
  /**
   * See [`Pallet::set_storage`].
   **/
  | { name: 'SetStorage'; params: { items: Array<[Bytes, Bytes]> } }
  /**
   * See [`Pallet::kill_storage`].
   **/
  | { name: 'KillStorage'; params: { keys: Array<Bytes> } }
  /**
   * See [`Pallet::kill_prefix`].
   **/
  | { name: 'KillPrefix'; params: { prefix: Bytes; subkeys: number } }
  /**
   * See [`Pallet::remark_with_event`].
   **/
  | { name: 'RemarkWithEvent'; params: { remark: Bytes } };

export type FrameSystemCallLike =
  /**
   * See [`Pallet::remark`].
   **/
  | { name: 'Remark'; params: { remark: BytesLike } }
  /**
   * See [`Pallet::set_heap_pages`].
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * See [`Pallet::set_code`].
   **/
  | { name: 'SetCode'; params: { code: BytesLike } }
  /**
   * See [`Pallet::set_code_without_checks`].
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: BytesLike } }
  /**
   * See [`Pallet::set_storage`].
   **/
  | { name: 'SetStorage'; params: { items: Array<[BytesLike, BytesLike]> } }
  /**
   * See [`Pallet::kill_storage`].
   **/
  | { name: 'KillStorage'; params: { keys: Array<BytesLike> } }
  /**
   * See [`Pallet::kill_prefix`].
   **/
  | { name: 'KillPrefix'; params: { prefix: BytesLike; subkeys: number } }
  /**
   * See [`Pallet::remark_with_event`].
   **/
  | { name: 'RemarkWithEvent'; params: { remark: BytesLike } };

export type FrameSystemLimitsBlockWeights = {
  baseBlock: SpWeightsWeightV2Weight;
  maxBlock: SpWeightsWeightV2Weight;
  perClass: FrameSupportDispatchPerDispatchClassWeightsPerClass;
};

export type FrameSupportDispatchPerDispatchClassWeightsPerClass = {
  normal: FrameSystemLimitsWeightsPerClass;
  operational: FrameSystemLimitsWeightsPerClass;
  mandatory: FrameSystemLimitsWeightsPerClass;
};

export type FrameSystemLimitsWeightsPerClass = {
  baseExtrinsic: SpWeightsWeightV2Weight;
  maxExtrinsic?: SpWeightsWeightV2Weight | undefined;
  maxTotal?: SpWeightsWeightV2Weight | undefined;
  reserved?: SpWeightsWeightV2Weight | undefined;
};

export type FrameSystemLimitsBlockLength = { max: FrameSupportDispatchPerDispatchClassU32 };

export type FrameSupportDispatchPerDispatchClassU32 = { normal: number; operational: number; mandatory: number };

export type SpWeightsRuntimeDbWeight = { read: bigint; write: bigint };

/**
 * Error for the System pallet
 **/
export type FrameSystemError =
  /**
   * The name of specification does not match between the current runtime
   * and the new runtime.
   **/
  | 'InvalidSpecName'
  /**
   * The specification version is not allowed to decrease between the current runtime
   * and the new runtime.
   **/
  | 'SpecVersionNeedsToIncrease'
  /**
   * Failed to extract the runtime version from the new runtime.
   *
   * Either calling `Core_version` or decoding `RuntimeVersion` failed.
   **/
  | 'FailedToExtractRuntimeVersion'
  /**
   * Suicide called when the account has non-default composite data.
   **/
  | 'NonDefaultComposite'
  /**
   * There is a non-zero reference count preventing the account from being purged.
   **/
  | 'NonZeroRefCount'
  /**
   * The origin filter prevent the call to be dispatched.
   **/
  | 'CallFiltered';

export type PalletSchedulerScheduled = {
  maybeId?: FixedBytes<32> | undefined;
  priority: number;
  call: FrameSupportPreimagesBounded;
  maybePeriodic?: [number, number] | undefined;
  origin: AlephRuntimeOriginCaller;
};

export type FrameSupportPreimagesBounded =
  | { tag: 'Legacy'; value: { hash: H256 } }
  | { tag: 'Inline'; value: Bytes }
  | { tag: 'Lookup'; value: { hash: H256; len: number } };

export type AlephRuntimeRuntimeCall =
  | { pallet: 'System'; palletCall: FrameSystemCall }
  | { pallet: 'Scheduler'; palletCall: PalletSchedulerCall }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCall }
  | { pallet: 'Balances'; palletCall: PalletBalancesCall }
  | { pallet: 'Staking'; palletCall: PalletStakingPalletCall }
  | { pallet: 'Session'; palletCall: PalletSessionCall }
  | { pallet: 'Aleph'; palletCall: PalletAlephCall }
  | { pallet: 'Elections'; palletCall: PalletElectionsCall }
  | { pallet: 'Treasury'; palletCall: PalletTreasuryCall }
  | { pallet: 'Vesting'; palletCall: PalletVestingCall }
  | { pallet: 'Utility'; palletCall: PalletUtilityCall }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCall }
  | { pallet: 'Sudo'; palletCall: PalletSudoCall }
  | { pallet: 'Contracts'; palletCall: PalletContractsCall }
  | { pallet: 'NominationPools'; palletCall: PalletNominationPoolsCall }
  | { pallet: 'Identity'; palletCall: PalletIdentityCall }
  | { pallet: 'CommitteeManagement'; palletCall: PalletCommitteeManagementCall };

export type AlephRuntimeRuntimeCallLike =
  | { pallet: 'System'; palletCall: FrameSystemCallLike }
  | { pallet: 'Scheduler'; palletCall: PalletSchedulerCallLike }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCallLike }
  | { pallet: 'Balances'; palletCall: PalletBalancesCallLike }
  | { pallet: 'Staking'; palletCall: PalletStakingPalletCallLike }
  | { pallet: 'Session'; palletCall: PalletSessionCallLike }
  | { pallet: 'Aleph'; palletCall: PalletAlephCallLike }
  | { pallet: 'Elections'; palletCall: PalletElectionsCallLike }
  | { pallet: 'Treasury'; palletCall: PalletTreasuryCallLike }
  | { pallet: 'Vesting'; palletCall: PalletVestingCallLike }
  | { pallet: 'Utility'; palletCall: PalletUtilityCallLike }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCallLike }
  | { pallet: 'Sudo'; palletCall: PalletSudoCallLike }
  | { pallet: 'Contracts'; palletCall: PalletContractsCallLike }
  | { pallet: 'NominationPools'; palletCall: PalletNominationPoolsCallLike }
  | { pallet: 'Identity'; palletCall: PalletIdentityCallLike }
  | { pallet: 'CommitteeManagement'; palletCall: PalletCommitteeManagementCallLike };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSchedulerCall =
  /**
   * See [`Pallet::schedule`].
   **/
  | {
      name: 'Schedule';
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: AlephRuntimeRuntimeCall;
      };
    }
  /**
   * See [`Pallet::cancel`].
   **/
  | { name: 'Cancel'; params: { when: number; index: number } }
  /**
   * See [`Pallet::schedule_named`].
   **/
  | {
      name: 'ScheduleNamed';
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: AlephRuntimeRuntimeCall;
      };
    }
  /**
   * See [`Pallet::cancel_named`].
   **/
  | { name: 'CancelNamed'; params: { id: FixedBytes<32> } }
  /**
   * See [`Pallet::schedule_after`].
   **/
  | {
      name: 'ScheduleAfter';
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: AlephRuntimeRuntimeCall;
      };
    }
  /**
   * See [`Pallet::schedule_named_after`].
   **/
  | {
      name: 'ScheduleNamedAfter';
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: AlephRuntimeRuntimeCall;
      };
    };

export type PalletSchedulerCallLike =
  /**
   * See [`Pallet::schedule`].
   **/
  | {
      name: 'Schedule';
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: AlephRuntimeRuntimeCallLike;
      };
    }
  /**
   * See [`Pallet::cancel`].
   **/
  | { name: 'Cancel'; params: { when: number; index: number } }
  /**
   * See [`Pallet::schedule_named`].
   **/
  | {
      name: 'ScheduleNamed';
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: AlephRuntimeRuntimeCallLike;
      };
    }
  /**
   * See [`Pallet::cancel_named`].
   **/
  | { name: 'CancelNamed'; params: { id: FixedBytes<32> } }
  /**
   * See [`Pallet::schedule_after`].
   **/
  | {
      name: 'ScheduleAfter';
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: AlephRuntimeRuntimeCallLike;
      };
    }
  /**
   * See [`Pallet::schedule_named_after`].
   **/
  | {
      name: 'ScheduleNamedAfter';
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: AlephRuntimeRuntimeCallLike;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTimestampCall =
  /**
   * See [`Pallet::set`].
   **/
  { name: 'Set'; params: { now: bigint } };

export type PalletTimestampCallLike =
  /**
   * See [`Pallet::set`].
   **/
  { name: 'Set'; params: { now: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBalancesCall =
  /**
   * See [`Pallet::transfer_allow_death`].
   **/
  | { name: 'TransferAllowDeath'; params: { dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::set_balance_deprecated`].
   **/
  | { name: 'SetBalanceDeprecated'; params: { who: MultiAddress; newFree: bigint; oldReserved: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { name: 'ForceTransfer'; params: { source: MultiAddress; dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: 'TransferKeepAlive'; params: { dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::transfer_all`].
   **/
  | { name: 'TransferAll'; params: { dest: MultiAddress; keepAlive: boolean } }
  /**
   * See [`Pallet::force_unreserve`].
   **/
  | { name: 'ForceUnreserve'; params: { who: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::upgrade_accounts`].
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32> } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::force_set_balance`].
   **/
  | { name: 'ForceSetBalance'; params: { who: MultiAddress; newFree: bigint } };

export type PalletBalancesCallLike =
  /**
   * See [`Pallet::transfer_allow_death`].
   **/
  | { name: 'TransferAllowDeath'; params: { dest: MultiAddressLike; value: bigint } }
  /**
   * See [`Pallet::set_balance_deprecated`].
   **/
  | { name: 'SetBalanceDeprecated'; params: { who: MultiAddressLike; newFree: bigint; oldReserved: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { name: 'ForceTransfer'; params: { source: MultiAddressLike; dest: MultiAddressLike; value: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: 'TransferKeepAlive'; params: { dest: MultiAddressLike; value: bigint } }
  /**
   * See [`Pallet::transfer_all`].
   **/
  | { name: 'TransferAll'; params: { dest: MultiAddressLike; keepAlive: boolean } }
  /**
   * See [`Pallet::force_unreserve`].
   **/
  | { name: 'ForceUnreserve'; params: { who: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::upgrade_accounts`].
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32Like> } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { dest: MultiAddressLike; value: bigint } }
  /**
   * See [`Pallet::force_set_balance`].
   **/
  | { name: 'ForceSetBalance'; params: { who: MultiAddressLike; newFree: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletStakingPalletCall =
  /**
   * See [`Pallet::bond`].
   **/
  | { name: 'Bond'; params: { value: bigint; payee: PalletStakingRewardDestination } }
  /**
   * See [`Pallet::bond_extra`].
   **/
  | { name: 'BondExtra'; params: { maxAdditional: bigint } }
  /**
   * See [`Pallet::unbond`].
   **/
  | { name: 'Unbond'; params: { value: bigint } }
  /**
   * See [`Pallet::withdraw_unbonded`].
   **/
  | { name: 'WithdrawUnbonded'; params: { numSlashingSpans: number } }
  /**
   * See [`Pallet::validate`].
   **/
  | { name: 'Validate'; params: { prefs: PalletStakingValidatorPrefs } }
  /**
   * See [`Pallet::nominate`].
   **/
  | { name: 'Nominate'; params: { targets: Array<MultiAddress> } }
  /**
   * See [`Pallet::chill`].
   **/
  | { name: 'Chill' }
  /**
   * See [`Pallet::set_payee`].
   **/
  | { name: 'SetPayee'; params: { payee: PalletStakingRewardDestination } }
  /**
   * See [`Pallet::set_controller`].
   **/
  | { name: 'SetController' }
  /**
   * See [`Pallet::set_validator_count`].
   **/
  | { name: 'SetValidatorCount'; params: { new: number } }
  /**
   * See [`Pallet::increase_validator_count`].
   **/
  | { name: 'IncreaseValidatorCount'; params: { additional: number } }
  /**
   * See [`Pallet::scale_validator_count`].
   **/
  | { name: 'ScaleValidatorCount'; params: { factor: Percent } }
  /**
   * See [`Pallet::force_no_eras`].
   **/
  | { name: 'ForceNoEras' }
  /**
   * See [`Pallet::force_new_era`].
   **/
  | { name: 'ForceNewEra' }
  /**
   * See [`Pallet::set_invulnerables`].
   **/
  | { name: 'SetInvulnerables'; params: { invulnerables: Array<AccountId32> } }
  /**
   * See [`Pallet::force_unstake`].
   **/
  | { name: 'ForceUnstake'; params: { stash: AccountId32; numSlashingSpans: number } }
  /**
   * See [`Pallet::force_new_era_always`].
   **/
  | { name: 'ForceNewEraAlways' }
  /**
   * See [`Pallet::cancel_deferred_slash`].
   **/
  | { name: 'CancelDeferredSlash'; params: { era: number; slashIndices: Array<number> } }
  /**
   * See [`Pallet::payout_stakers`].
   **/
  | { name: 'PayoutStakers'; params: { validatorStash: AccountId32; era: number } }
  /**
   * See [`Pallet::rebond`].
   **/
  | { name: 'Rebond'; params: { value: bigint } }
  /**
   * See [`Pallet::reap_stash`].
   **/
  | { name: 'ReapStash'; params: { stash: AccountId32; numSlashingSpans: number } }
  /**
   * See [`Pallet::kick`].
   **/
  | { name: 'Kick'; params: { who: Array<MultiAddress> } }
  /**
   * See [`Pallet::set_staking_configs`].
   **/
  | {
      name: 'SetStakingConfigs';
      params: {
        minNominatorBond: PalletStakingPalletConfigOp;
        minValidatorBond: PalletStakingPalletConfigOp;
        maxNominatorCount: PalletStakingPalletConfigOpU32;
        maxValidatorCount: PalletStakingPalletConfigOpU32;
        chillThreshold: PalletStakingPalletConfigOpPercent;
        minCommission: PalletStakingPalletConfigOpPerbill;
      };
    }
  /**
   * See [`Pallet::chill_other`].
   **/
  | { name: 'ChillOther'; params: { controller: AccountId32 } }
  /**
   * See [`Pallet::force_apply_min_commission`].
   **/
  | { name: 'ForceApplyMinCommission'; params: { validatorStash: AccountId32 } }
  /**
   * See [`Pallet::set_min_commission`].
   **/
  | { name: 'SetMinCommission'; params: { new: Perbill } };

export type PalletStakingPalletCallLike =
  /**
   * See [`Pallet::bond`].
   **/
  | { name: 'Bond'; params: { value: bigint; payee: PalletStakingRewardDestination } }
  /**
   * See [`Pallet::bond_extra`].
   **/
  | { name: 'BondExtra'; params: { maxAdditional: bigint } }
  /**
   * See [`Pallet::unbond`].
   **/
  | { name: 'Unbond'; params: { value: bigint } }
  /**
   * See [`Pallet::withdraw_unbonded`].
   **/
  | { name: 'WithdrawUnbonded'; params: { numSlashingSpans: number } }
  /**
   * See [`Pallet::validate`].
   **/
  | { name: 'Validate'; params: { prefs: PalletStakingValidatorPrefs } }
  /**
   * See [`Pallet::nominate`].
   **/
  | { name: 'Nominate'; params: { targets: Array<MultiAddressLike> } }
  /**
   * See [`Pallet::chill`].
   **/
  | { name: 'Chill' }
  /**
   * See [`Pallet::set_payee`].
   **/
  | { name: 'SetPayee'; params: { payee: PalletStakingRewardDestination } }
  /**
   * See [`Pallet::set_controller`].
   **/
  | { name: 'SetController' }
  /**
   * See [`Pallet::set_validator_count`].
   **/
  | { name: 'SetValidatorCount'; params: { new: number } }
  /**
   * See [`Pallet::increase_validator_count`].
   **/
  | { name: 'IncreaseValidatorCount'; params: { additional: number } }
  /**
   * See [`Pallet::scale_validator_count`].
   **/
  | { name: 'ScaleValidatorCount'; params: { factor: Percent } }
  /**
   * See [`Pallet::force_no_eras`].
   **/
  | { name: 'ForceNoEras' }
  /**
   * See [`Pallet::force_new_era`].
   **/
  | { name: 'ForceNewEra' }
  /**
   * See [`Pallet::set_invulnerables`].
   **/
  | { name: 'SetInvulnerables'; params: { invulnerables: Array<AccountId32Like> } }
  /**
   * See [`Pallet::force_unstake`].
   **/
  | { name: 'ForceUnstake'; params: { stash: AccountId32Like; numSlashingSpans: number } }
  /**
   * See [`Pallet::force_new_era_always`].
   **/
  | { name: 'ForceNewEraAlways' }
  /**
   * See [`Pallet::cancel_deferred_slash`].
   **/
  | { name: 'CancelDeferredSlash'; params: { era: number; slashIndices: Array<number> } }
  /**
   * See [`Pallet::payout_stakers`].
   **/
  | { name: 'PayoutStakers'; params: { validatorStash: AccountId32Like; era: number } }
  /**
   * See [`Pallet::rebond`].
   **/
  | { name: 'Rebond'; params: { value: bigint } }
  /**
   * See [`Pallet::reap_stash`].
   **/
  | { name: 'ReapStash'; params: { stash: AccountId32Like; numSlashingSpans: number } }
  /**
   * See [`Pallet::kick`].
   **/
  | { name: 'Kick'; params: { who: Array<MultiAddressLike> } }
  /**
   * See [`Pallet::set_staking_configs`].
   **/
  | {
      name: 'SetStakingConfigs';
      params: {
        minNominatorBond: PalletStakingPalletConfigOp;
        minValidatorBond: PalletStakingPalletConfigOp;
        maxNominatorCount: PalletStakingPalletConfigOpU32;
        maxValidatorCount: PalletStakingPalletConfigOpU32;
        chillThreshold: PalletStakingPalletConfigOpPercent;
        minCommission: PalletStakingPalletConfigOpPerbill;
      };
    }
  /**
   * See [`Pallet::chill_other`].
   **/
  | { name: 'ChillOther'; params: { controller: AccountId32Like } }
  /**
   * See [`Pallet::force_apply_min_commission`].
   **/
  | { name: 'ForceApplyMinCommission'; params: { validatorStash: AccountId32Like } }
  /**
   * See [`Pallet::set_min_commission`].
   **/
  | { name: 'SetMinCommission'; params: { new: Perbill } };

export type PalletStakingRewardDestination =
  | { tag: 'Staked' }
  | { tag: 'Stash' }
  | { tag: 'Controller' }
  | { tag: 'Account'; value: AccountId32 }
  | { tag: 'None' };

export type PalletStakingPalletConfigOp = { tag: 'Noop' } | { tag: 'Set'; value: bigint } | { tag: 'Remove' };

export type PalletStakingPalletConfigOpU32 = { tag: 'Noop' } | { tag: 'Set'; value: number } | { tag: 'Remove' };

export type PalletStakingPalletConfigOpPercent = { tag: 'Noop' } | { tag: 'Set'; value: Percent } | { tag: 'Remove' };

export type PalletStakingPalletConfigOpPerbill = { tag: 'Noop' } | { tag: 'Set'; value: Perbill } | { tag: 'Remove' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSessionCall =
  /**
   * See [`Pallet::set_keys`].
   **/
  | { name: 'SetKeys'; params: { keys: AlephRuntimeSessionKeys; proof: Bytes } }
  /**
   * See [`Pallet::purge_keys`].
   **/
  | { name: 'PurgeKeys' };

export type PalletSessionCallLike =
  /**
   * See [`Pallet::set_keys`].
   **/
  | { name: 'SetKeys'; params: { keys: AlephRuntimeSessionKeys; proof: BytesLike } }
  /**
   * See [`Pallet::purge_keys`].
   **/
  | { name: 'PurgeKeys' };

export type AlephRuntimeSessionKeys = { aura: SpConsensusAuraSr25519AppSr25519Public; aleph: PrimitivesAppPublic };

export type SpConsensusAuraSr25519AppSr25519Public = SpCoreSr25519Public;

export type SpCoreSr25519Public = FixedBytes<32>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAlephCall =
  /**
   * See [`Pallet::set_emergency_finalizer`].
   **/
  | { name: 'SetEmergencyFinalizer'; params: { emergencyFinalizer: PrimitivesAppPublic } }
  /**
   * See [`Pallet::schedule_finality_version_change`].
   **/
  | { name: 'ScheduleFinalityVersionChange'; params: { versionIncoming: number; session: number } };

export type PalletAlephCallLike =
  /**
   * See [`Pallet::set_emergency_finalizer`].
   **/
  | { name: 'SetEmergencyFinalizer'; params: { emergencyFinalizer: PrimitivesAppPublic } }
  /**
   * See [`Pallet::schedule_finality_version_change`].
   **/
  | { name: 'ScheduleFinalityVersionChange'; params: { versionIncoming: number; session: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletElectionsCall =
  /**
   * See [`Pallet::change_validators`].
   **/
  | {
      name: 'ChangeValidators';
      params: {
        reservedValidators?: Array<AccountId32> | undefined;
        nonReservedValidators?: Array<AccountId32> | undefined;
        committeeSize?: PrimitivesCommitteeSeats | undefined;
      };
    }
  /**
   * See [`Pallet::set_elections_openness`].
   **/
  | { name: 'SetElectionsOpenness'; params: { openness: PrimitivesElectionOpenness } };

export type PalletElectionsCallLike =
  /**
   * See [`Pallet::change_validators`].
   **/
  | {
      name: 'ChangeValidators';
      params: {
        reservedValidators?: Array<AccountId32Like> | undefined;
        nonReservedValidators?: Array<AccountId32Like> | undefined;
        committeeSize?: PrimitivesCommitteeSeats | undefined;
      };
    }
  /**
   * See [`Pallet::set_elections_openness`].
   **/
  | { name: 'SetElectionsOpenness'; params: { openness: PrimitivesElectionOpenness } };

export type PrimitivesElectionOpenness = 'Permissioned' | 'Permissionless';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTreasuryCall =
  /**
   * See [`Pallet::propose_spend`].
   **/
  | { name: 'ProposeSpend'; params: { value: bigint; beneficiary: MultiAddress } }
  /**
   * See [`Pallet::reject_proposal`].
   **/
  | { name: 'RejectProposal'; params: { proposalId: number } }
  /**
   * See [`Pallet::approve_proposal`].
   **/
  | { name: 'ApproveProposal'; params: { proposalId: number } }
  /**
   * See [`Pallet::spend`].
   **/
  | { name: 'Spend'; params: { amount: bigint; beneficiary: MultiAddress } }
  /**
   * See [`Pallet::remove_approval`].
   **/
  | { name: 'RemoveApproval'; params: { proposalId: number } };

export type PalletTreasuryCallLike =
  /**
   * See [`Pallet::propose_spend`].
   **/
  | { name: 'ProposeSpend'; params: { value: bigint; beneficiary: MultiAddressLike } }
  /**
   * See [`Pallet::reject_proposal`].
   **/
  | { name: 'RejectProposal'; params: { proposalId: number } }
  /**
   * See [`Pallet::approve_proposal`].
   **/
  | { name: 'ApproveProposal'; params: { proposalId: number } }
  /**
   * See [`Pallet::spend`].
   **/
  | { name: 'Spend'; params: { amount: bigint; beneficiary: MultiAddressLike } }
  /**
   * See [`Pallet::remove_approval`].
   **/
  | { name: 'RemoveApproval'; params: { proposalId: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletVestingCall =
  /**
   * See [`Pallet::vest`].
   **/
  | { name: 'Vest' }
  /**
   * See [`Pallet::vest_other`].
   **/
  | { name: 'VestOther'; params: { target: MultiAddress } }
  /**
   * See [`Pallet::vested_transfer`].
   **/
  | { name: 'VestedTransfer'; params: { target: MultiAddress; schedule: PalletVestingVestingInfo } }
  /**
   * See [`Pallet::force_vested_transfer`].
   **/
  | {
      name: 'ForceVestedTransfer';
      params: { source: MultiAddress; target: MultiAddress; schedule: PalletVestingVestingInfo };
    }
  /**
   * See [`Pallet::merge_schedules`].
   **/
  | { name: 'MergeSchedules'; params: { schedule1Index: number; schedule2Index: number } };

export type PalletVestingCallLike =
  /**
   * See [`Pallet::vest`].
   **/
  | { name: 'Vest' }
  /**
   * See [`Pallet::vest_other`].
   **/
  | { name: 'VestOther'; params: { target: MultiAddressLike } }
  /**
   * See [`Pallet::vested_transfer`].
   **/
  | { name: 'VestedTransfer'; params: { target: MultiAddressLike; schedule: PalletVestingVestingInfo } }
  /**
   * See [`Pallet::force_vested_transfer`].
   **/
  | {
      name: 'ForceVestedTransfer';
      params: { source: MultiAddressLike; target: MultiAddressLike; schedule: PalletVestingVestingInfo };
    }
  /**
   * See [`Pallet::merge_schedules`].
   **/
  | { name: 'MergeSchedules'; params: { schedule1Index: number; schedule2Index: number } };

export type PalletVestingVestingInfo = { locked: bigint; perBlock: bigint; startingBlock: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUtilityCall =
  /**
   * See [`Pallet::batch`].
   **/
  | { name: 'Batch'; params: { calls: Array<AlephRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::as_derivative`].
   **/
  | { name: 'AsDerivative'; params: { index: number; call: AlephRuntimeRuntimeCall } }
  /**
   * See [`Pallet::batch_all`].
   **/
  | { name: 'BatchAll'; params: { calls: Array<AlephRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::dispatch_as`].
   **/
  | { name: 'DispatchAs'; params: { asOrigin: AlephRuntimeOriginCaller; call: AlephRuntimeRuntimeCall } }
  /**
   * See [`Pallet::force_batch`].
   **/
  | { name: 'ForceBatch'; params: { calls: Array<AlephRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::with_weight`].
   **/
  | { name: 'WithWeight'; params: { call: AlephRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight } };

export type PalletUtilityCallLike =
  /**
   * See [`Pallet::batch`].
   **/
  | { name: 'Batch'; params: { calls: Array<AlephRuntimeRuntimeCallLike> } }
  /**
   * See [`Pallet::as_derivative`].
   **/
  | { name: 'AsDerivative'; params: { index: number; call: AlephRuntimeRuntimeCallLike } }
  /**
   * See [`Pallet::batch_all`].
   **/
  | { name: 'BatchAll'; params: { calls: Array<AlephRuntimeRuntimeCallLike> } }
  /**
   * See [`Pallet::dispatch_as`].
   **/
  | { name: 'DispatchAs'; params: { asOrigin: AlephRuntimeOriginCaller; call: AlephRuntimeRuntimeCallLike } }
  /**
   * See [`Pallet::force_batch`].
   **/
  | { name: 'ForceBatch'; params: { calls: Array<AlephRuntimeRuntimeCallLike> } }
  /**
   * See [`Pallet::with_weight`].
   **/
  | { name: 'WithWeight'; params: { call: AlephRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight } };

export type AlephRuntimeOriginCaller =
  | { tag: 'System'; value: FrameSupportDispatchRawOrigin }
  | { tag: 'Void'; value: SpCoreVoid };

export type FrameSupportDispatchRawOrigin = { tag: 'Root' } | { tag: 'Signed'; value: AccountId32 } | { tag: 'None' };

export type SpCoreVoid = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMultisigCall =
  /**
   * See [`Pallet::as_multi_threshold_1`].
   **/
  | { name: 'AsMultiThreshold1'; params: { otherSignatories: Array<AccountId32>; call: AlephRuntimeRuntimeCall } }
  /**
   * See [`Pallet::as_multi`].
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: AlephRuntimeRuntimeCall;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::approve_as_multi`].
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::cancel_as_multi`].
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigCallLike =
  /**
   * See [`Pallet::as_multi_threshold_1`].
   **/
  | {
      name: 'AsMultiThreshold1';
      params: { otherSignatories: Array<AccountId32Like>; call: AlephRuntimeRuntimeCallLike };
    }
  /**
   * See [`Pallet::as_multi`].
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: AlephRuntimeRuntimeCallLike;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::approve_as_multi`].
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::cancel_as_multi`].
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSudoCall =
  /**
   * See [`Pallet::sudo`].
   **/
  | { name: 'Sudo'; params: { call: AlephRuntimeRuntimeCall } }
  /**
   * See [`Pallet::sudo_unchecked_weight`].
   **/
  | { name: 'SudoUncheckedWeight'; params: { call: AlephRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::set_key`].
   **/
  | { name: 'SetKey'; params: { new: MultiAddress } }
  /**
   * See [`Pallet::sudo_as`].
   **/
  | { name: 'SudoAs'; params: { who: MultiAddress; call: AlephRuntimeRuntimeCall } };

export type PalletSudoCallLike =
  /**
   * See [`Pallet::sudo`].
   **/
  | { name: 'Sudo'; params: { call: AlephRuntimeRuntimeCallLike } }
  /**
   * See [`Pallet::sudo_unchecked_weight`].
   **/
  | { name: 'SudoUncheckedWeight'; params: { call: AlephRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::set_key`].
   **/
  | { name: 'SetKey'; params: { new: MultiAddressLike } }
  /**
   * See [`Pallet::sudo_as`].
   **/
  | { name: 'SudoAs'; params: { who: MultiAddressLike; call: AlephRuntimeRuntimeCallLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletContractsCall =
  /**
   * See [`Pallet::call_old_weight`].
   **/
  | {
      name: 'CallOldWeight';
      params: {
        dest: MultiAddress;
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        data: Bytes;
      };
    }
  /**
   * See [`Pallet::instantiate_with_code_old_weight`].
   **/
  | {
      name: 'InstantiateWithCodeOldWeight';
      params: {
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        code: Bytes;
        data: Bytes;
        salt: Bytes;
      };
    }
  /**
   * See [`Pallet::instantiate_old_weight`].
   **/
  | {
      name: 'InstantiateOldWeight';
      params: {
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        codeHash: H256;
        data: Bytes;
        salt: Bytes;
      };
    }
  /**
   * See [`Pallet::upload_code`].
   **/
  | {
      name: 'UploadCode';
      params: { code: Bytes; storageDepositLimit?: bigint | undefined; determinism: PalletContractsWasmDeterminism };
    }
  /**
   * See [`Pallet::remove_code`].
   **/
  | { name: 'RemoveCode'; params: { codeHash: H256 } }
  /**
   * See [`Pallet::set_code`].
   **/
  | { name: 'SetCode'; params: { dest: MultiAddress; codeHash: H256 } }
  /**
   * See [`Pallet::call`].
   **/
  | {
      name: 'Call';
      params: {
        dest: MultiAddress;
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        data: Bytes;
      };
    }
  /**
   * See [`Pallet::instantiate_with_code`].
   **/
  | {
      name: 'InstantiateWithCode';
      params: {
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        code: Bytes;
        data: Bytes;
        salt: Bytes;
      };
    }
  /**
   * See [`Pallet::instantiate`].
   **/
  | {
      name: 'Instantiate';
      params: {
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        codeHash: H256;
        data: Bytes;
        salt: Bytes;
      };
    }
  /**
   * See [`Pallet::migrate`].
   **/
  | { name: 'Migrate'; params: { weightLimit: SpWeightsWeightV2Weight } };

export type PalletContractsCallLike =
  /**
   * See [`Pallet::call_old_weight`].
   **/
  | {
      name: 'CallOldWeight';
      params: {
        dest: MultiAddressLike;
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        data: BytesLike;
      };
    }
  /**
   * See [`Pallet::instantiate_with_code_old_weight`].
   **/
  | {
      name: 'InstantiateWithCodeOldWeight';
      params: {
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        code: BytesLike;
        data: BytesLike;
        salt: BytesLike;
      };
    }
  /**
   * See [`Pallet::instantiate_old_weight`].
   **/
  | {
      name: 'InstantiateOldWeight';
      params: {
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        codeHash: H256;
        data: BytesLike;
        salt: BytesLike;
      };
    }
  /**
   * See [`Pallet::upload_code`].
   **/
  | {
      name: 'UploadCode';
      params: {
        code: BytesLike;
        storageDepositLimit?: bigint | undefined;
        determinism: PalletContractsWasmDeterminism;
      };
    }
  /**
   * See [`Pallet::remove_code`].
   **/
  | { name: 'RemoveCode'; params: { codeHash: H256 } }
  /**
   * See [`Pallet::set_code`].
   **/
  | { name: 'SetCode'; params: { dest: MultiAddressLike; codeHash: H256 } }
  /**
   * See [`Pallet::call`].
   **/
  | {
      name: 'Call';
      params: {
        dest: MultiAddressLike;
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        data: BytesLike;
      };
    }
  /**
   * See [`Pallet::instantiate_with_code`].
   **/
  | {
      name: 'InstantiateWithCode';
      params: {
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        code: BytesLike;
        data: BytesLike;
        salt: BytesLike;
      };
    }
  /**
   * See [`Pallet::instantiate`].
   **/
  | {
      name: 'Instantiate';
      params: {
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        codeHash: H256;
        data: BytesLike;
        salt: BytesLike;
      };
    }
  /**
   * See [`Pallet::migrate`].
   **/
  | { name: 'Migrate'; params: { weightLimit: SpWeightsWeightV2Weight } };

export type PalletContractsWasmDeterminism = 'Enforced' | 'Relaxed';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletNominationPoolsCall =
  /**
   * See [`Pallet::join`].
   **/
  | { name: 'Join'; params: { amount: bigint; poolId: number } }
  /**
   * See [`Pallet::bond_extra`].
   **/
  | { name: 'BondExtra'; params: { extra: PalletNominationPoolsBondExtra } }
  /**
   * See [`Pallet::claim_payout`].
   **/
  | { name: 'ClaimPayout' }
  /**
   * See [`Pallet::unbond`].
   **/
  | { name: 'Unbond'; params: { memberAccount: MultiAddress; unbondingPoints: bigint } }
  /**
   * See [`Pallet::pool_withdraw_unbonded`].
   **/
  | { name: 'PoolWithdrawUnbonded'; params: { poolId: number; numSlashingSpans: number } }
  /**
   * See [`Pallet::withdraw_unbonded`].
   **/
  | { name: 'WithdrawUnbonded'; params: { memberAccount: MultiAddress; numSlashingSpans: number } }
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create'; params: { amount: bigint; root: MultiAddress; nominator: MultiAddress; bouncer: MultiAddress } }
  /**
   * See [`Pallet::create_with_pool_id`].
   **/
  | {
      name: 'CreateWithPoolId';
      params: { amount: bigint; root: MultiAddress; nominator: MultiAddress; bouncer: MultiAddress; poolId: number };
    }
  /**
   * See [`Pallet::nominate`].
   **/
  | { name: 'Nominate'; params: { poolId: number; validators: Array<AccountId32> } }
  /**
   * See [`Pallet::set_state`].
   **/
  | { name: 'SetState'; params: { poolId: number; state: PalletNominationPoolsPoolState } }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { poolId: number; metadata: Bytes } }
  /**
   * See [`Pallet::set_configs`].
   **/
  | {
      name: 'SetConfigs';
      params: {
        minJoinBond: PalletNominationPoolsConfigOp;
        minCreateBond: PalletNominationPoolsConfigOp;
        maxPools: PalletNominationPoolsConfigOpU32;
        maxMembers: PalletNominationPoolsConfigOpU32;
        maxMembersPerPool: PalletNominationPoolsConfigOpU32;
        globalMaxCommission: PalletNominationPoolsConfigOpPerbill;
      };
    }
  /**
   * See [`Pallet::update_roles`].
   **/
  | {
      name: 'UpdateRoles';
      params: {
        poolId: number;
        newRoot: PalletNominationPoolsConfigOp004;
        newNominator: PalletNominationPoolsConfigOp004;
        newBouncer: PalletNominationPoolsConfigOp004;
      };
    }
  /**
   * See [`Pallet::chill`].
   **/
  | { name: 'Chill'; params: { poolId: number } }
  /**
   * See [`Pallet::bond_extra_other`].
   **/
  | { name: 'BondExtraOther'; params: { member: MultiAddress; extra: PalletNominationPoolsBondExtra } }
  /**
   * See [`Pallet::set_claim_permission`].
   **/
  | { name: 'SetClaimPermission'; params: { permission: PalletNominationPoolsClaimPermission } }
  /**
   * See [`Pallet::claim_payout_other`].
   **/
  | { name: 'ClaimPayoutOther'; params: { other: AccountId32 } }
  /**
   * See [`Pallet::set_commission`].
   **/
  | { name: 'SetCommission'; params: { poolId: number; newCommission?: [Perbill, AccountId32] | undefined } }
  /**
   * See [`Pallet::set_commission_max`].
   **/
  | { name: 'SetCommissionMax'; params: { poolId: number; maxCommission: Perbill } }
  /**
   * See [`Pallet::set_commission_change_rate`].
   **/
  | {
      name: 'SetCommissionChangeRate';
      params: { poolId: number; changeRate: PalletNominationPoolsCommissionChangeRate };
    }
  /**
   * See [`Pallet::claim_commission`].
   **/
  | { name: 'ClaimCommission'; params: { poolId: number } };

export type PalletNominationPoolsCallLike =
  /**
   * See [`Pallet::join`].
   **/
  | { name: 'Join'; params: { amount: bigint; poolId: number } }
  /**
   * See [`Pallet::bond_extra`].
   **/
  | { name: 'BondExtra'; params: { extra: PalletNominationPoolsBondExtra } }
  /**
   * See [`Pallet::claim_payout`].
   **/
  | { name: 'ClaimPayout' }
  /**
   * See [`Pallet::unbond`].
   **/
  | { name: 'Unbond'; params: { memberAccount: MultiAddressLike; unbondingPoints: bigint } }
  /**
   * See [`Pallet::pool_withdraw_unbonded`].
   **/
  | { name: 'PoolWithdrawUnbonded'; params: { poolId: number; numSlashingSpans: number } }
  /**
   * See [`Pallet::withdraw_unbonded`].
   **/
  | { name: 'WithdrawUnbonded'; params: { memberAccount: MultiAddressLike; numSlashingSpans: number } }
  /**
   * See [`Pallet::create`].
   **/
  | {
      name: 'Create';
      params: { amount: bigint; root: MultiAddressLike; nominator: MultiAddressLike; bouncer: MultiAddressLike };
    }
  /**
   * See [`Pallet::create_with_pool_id`].
   **/
  | {
      name: 'CreateWithPoolId';
      params: {
        amount: bigint;
        root: MultiAddressLike;
        nominator: MultiAddressLike;
        bouncer: MultiAddressLike;
        poolId: number;
      };
    }
  /**
   * See [`Pallet::nominate`].
   **/
  | { name: 'Nominate'; params: { poolId: number; validators: Array<AccountId32Like> } }
  /**
   * See [`Pallet::set_state`].
   **/
  | { name: 'SetState'; params: { poolId: number; state: PalletNominationPoolsPoolState } }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { poolId: number; metadata: BytesLike } }
  /**
   * See [`Pallet::set_configs`].
   **/
  | {
      name: 'SetConfigs';
      params: {
        minJoinBond: PalletNominationPoolsConfigOp;
        minCreateBond: PalletNominationPoolsConfigOp;
        maxPools: PalletNominationPoolsConfigOpU32;
        maxMembers: PalletNominationPoolsConfigOpU32;
        maxMembersPerPool: PalletNominationPoolsConfigOpU32;
        globalMaxCommission: PalletNominationPoolsConfigOpPerbill;
      };
    }
  /**
   * See [`Pallet::update_roles`].
   **/
  | {
      name: 'UpdateRoles';
      params: {
        poolId: number;
        newRoot: PalletNominationPoolsConfigOp004;
        newNominator: PalletNominationPoolsConfigOp004;
        newBouncer: PalletNominationPoolsConfigOp004;
      };
    }
  /**
   * See [`Pallet::chill`].
   **/
  | { name: 'Chill'; params: { poolId: number } }
  /**
   * See [`Pallet::bond_extra_other`].
   **/
  | { name: 'BondExtraOther'; params: { member: MultiAddressLike; extra: PalletNominationPoolsBondExtra } }
  /**
   * See [`Pallet::set_claim_permission`].
   **/
  | { name: 'SetClaimPermission'; params: { permission: PalletNominationPoolsClaimPermission } }
  /**
   * See [`Pallet::claim_payout_other`].
   **/
  | { name: 'ClaimPayoutOther'; params: { other: AccountId32Like } }
  /**
   * See [`Pallet::set_commission`].
   **/
  | { name: 'SetCommission'; params: { poolId: number; newCommission?: [Perbill, AccountId32Like] | undefined } }
  /**
   * See [`Pallet::set_commission_max`].
   **/
  | { name: 'SetCommissionMax'; params: { poolId: number; maxCommission: Perbill } }
  /**
   * See [`Pallet::set_commission_change_rate`].
   **/
  | {
      name: 'SetCommissionChangeRate';
      params: { poolId: number; changeRate: PalletNominationPoolsCommissionChangeRate };
    }
  /**
   * See [`Pallet::claim_commission`].
   **/
  | { name: 'ClaimCommission'; params: { poolId: number } };

export type PalletNominationPoolsBondExtra = { tag: 'FreeBalance'; value: bigint } | { tag: 'Rewards' };

export type PalletNominationPoolsConfigOp = { tag: 'Noop' } | { tag: 'Set'; value: bigint } | { tag: 'Remove' };

export type PalletNominationPoolsConfigOpU32 = { tag: 'Noop' } | { tag: 'Set'; value: number } | { tag: 'Remove' };

export type PalletNominationPoolsConfigOpPerbill = { tag: 'Noop' } | { tag: 'Set'; value: Perbill } | { tag: 'Remove' };

export type PalletNominationPoolsConfigOp004 = { tag: 'Noop' } | { tag: 'Set'; value: AccountId32 } | { tag: 'Remove' };

export type PalletNominationPoolsClaimPermission =
  | 'Permissioned'
  | 'PermissionlessCompound'
  | 'PermissionlessWithdraw'
  | 'PermissionlessAll';

/**
 * Identity pallet declaration.
 **/
export type PalletIdentityCall =
  /**
   * See [`Pallet::add_registrar`].
   **/
  | { name: 'AddRegistrar'; params: { account: MultiAddress } }
  /**
   * See [`Pallet::set_identity`].
   **/
  | { name: 'SetIdentity'; params: { info: PalletIdentityIdentityInfo } }
  /**
   * See [`Pallet::set_subs`].
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId32, Data]> } }
  /**
   * See [`Pallet::clear_identity`].
   **/
  | { name: 'ClearIdentity' }
  /**
   * See [`Pallet::request_judgement`].
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * See [`Pallet::cancel_request`].
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * See [`Pallet::set_fee`].
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * See [`Pallet::set_account_id`].
   **/
  | { name: 'SetAccountId'; params: { index: number; new: MultiAddress } }
  /**
   * See [`Pallet::set_fields`].
   **/
  | { name: 'SetFields'; params: { index: number; fields: PalletIdentityBitFlags } }
  /**
   * See [`Pallet::provide_judgement`].
   **/
  | {
      name: 'ProvideJudgement';
      params: { regIndex: number; target: MultiAddress; judgement: PalletIdentityJudgement; identity: H256 };
    }
  /**
   * See [`Pallet::kill_identity`].
   **/
  | { name: 'KillIdentity'; params: { target: MultiAddress } }
  /**
   * See [`Pallet::add_sub`].
   **/
  | { name: 'AddSub'; params: { sub: MultiAddress; data: Data } }
  /**
   * See [`Pallet::rename_sub`].
   **/
  | { name: 'RenameSub'; params: { sub: MultiAddress; data: Data } }
  /**
   * See [`Pallet::remove_sub`].
   **/
  | { name: 'RemoveSub'; params: { sub: MultiAddress } }
  /**
   * See [`Pallet::quit_sub`].
   **/
  | { name: 'QuitSub' };

export type PalletIdentityCallLike =
  /**
   * See [`Pallet::add_registrar`].
   **/
  | { name: 'AddRegistrar'; params: { account: MultiAddressLike } }
  /**
   * See [`Pallet::set_identity`].
   **/
  | { name: 'SetIdentity'; params: { info: PalletIdentityIdentityInfo } }
  /**
   * See [`Pallet::set_subs`].
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId32Like, Data]> } }
  /**
   * See [`Pallet::clear_identity`].
   **/
  | { name: 'ClearIdentity' }
  /**
   * See [`Pallet::request_judgement`].
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * See [`Pallet::cancel_request`].
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * See [`Pallet::set_fee`].
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * See [`Pallet::set_account_id`].
   **/
  | { name: 'SetAccountId'; params: { index: number; new: MultiAddressLike } }
  /**
   * See [`Pallet::set_fields`].
   **/
  | { name: 'SetFields'; params: { index: number; fields: PalletIdentityBitFlags } }
  /**
   * See [`Pallet::provide_judgement`].
   **/
  | {
      name: 'ProvideJudgement';
      params: { regIndex: number; target: MultiAddressLike; judgement: PalletIdentityJudgement; identity: H256 };
    }
  /**
   * See [`Pallet::kill_identity`].
   **/
  | { name: 'KillIdentity'; params: { target: MultiAddressLike } }
  /**
   * See [`Pallet::add_sub`].
   **/
  | { name: 'AddSub'; params: { sub: MultiAddressLike; data: Data } }
  /**
   * See [`Pallet::rename_sub`].
   **/
  | { name: 'RenameSub'; params: { sub: MultiAddressLike; data: Data } }
  /**
   * See [`Pallet::remove_sub`].
   **/
  | { name: 'RemoveSub'; params: { sub: MultiAddressLike } }
  /**
   * See [`Pallet::quit_sub`].
   **/
  | { name: 'QuitSub' };

export type PalletIdentityIdentityInfo = {
  additional: Array<[Data, Data]>;
  display: Data;
  legal: Data;
  web: Data;
  riot: Data;
  email: Data;
  pgpFingerprint?: FixedBytes<20> | undefined;
  image: Data;
  twitter: Data;
};

export type PalletIdentityBitFlags = bigint;

export type PalletIdentityIdentityField =
  | 'Display'
  | 'Legal'
  | 'Web'
  | 'Riot'
  | 'Email'
  | 'PgpFingerprint'
  | 'Image'
  | 'Twitter';

export type PalletIdentityJudgement =
  | { tag: 'Unknown' }
  | { tag: 'FeePaid'; value: bigint }
  | { tag: 'Reasonable' }
  | { tag: 'KnownGood' }
  | { tag: 'OutOfDate' }
  | { tag: 'LowQuality' }
  | { tag: 'Erroneous' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCommitteeManagementCall =
  /**
   * See [`Pallet::set_ban_config`].
   **/
  | {
      name: 'SetBanConfig';
      params: {
        minimalExpectedPerformance?: number | undefined;
        underperformedSessionCountThreshold?: number | undefined;
        cleanSessionCounterDelay?: number | undefined;
        banPeriod?: number | undefined;
      };
    }
  /**
   * See [`Pallet::ban_from_committee`].
   **/
  | { name: 'BanFromCommittee'; params: { banned: AccountId32; banReason: Bytes } }
  /**
   * See [`Pallet::cancel_ban`].
   **/
  | { name: 'CancelBan'; params: { banned: AccountId32 } }
  /**
   * See [`Pallet::set_lenient_threshold`].
   **/
  | { name: 'SetLenientThreshold'; params: { thresholdPercent: number } };

export type PalletCommitteeManagementCallLike =
  /**
   * See [`Pallet::set_ban_config`].
   **/
  | {
      name: 'SetBanConfig';
      params: {
        minimalExpectedPerformance?: number | undefined;
        underperformedSessionCountThreshold?: number | undefined;
        cleanSessionCounterDelay?: number | undefined;
        banPeriod?: number | undefined;
      };
    }
  /**
   * See [`Pallet::ban_from_committee`].
   **/
  | { name: 'BanFromCommittee'; params: { banned: AccountId32Like; banReason: BytesLike } }
  /**
   * See [`Pallet::cancel_ban`].
   **/
  | { name: 'CancelBan'; params: { banned: AccountId32Like } }
  /**
   * See [`Pallet::set_lenient_threshold`].
   **/
  | { name: 'SetLenientThreshold'; params: { thresholdPercent: number } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSchedulerError =
  /**
   * Failed to schedule a call
   **/
  | 'FailedToSchedule'
  /**
   * Cannot find the scheduled call.
   **/
  | 'NotFound'
  /**
   * Given target block number is in the past.
   **/
  | 'TargetBlockNumberInPast'
  /**
   * Reschedule failed because it does not change scheduled time.
   **/
  | 'RescheduleNoChange'
  /**
   * Attempt to use a non-named function on a named task.
   **/
  | 'Named';

export type SpConsensusSlotsSlot = bigint;

export type PalletBalancesBalanceLock = { id: FixedBytes<8>; amount: bigint; reasons: PalletBalancesReasons };

export type PalletBalancesReasons = 'Fee' | 'Misc' | 'All';

export type PalletBalancesReserveData = { id: FixedBytes<8>; amount: bigint };

export type PalletBalancesIdAmount = { id: AlephRuntimeRuntimeHoldReason; amount: bigint };

export type AlephRuntimeRuntimeHoldReason = null;

export type PalletBalancesIdAmount002 = { id: []; amount: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBalancesError =
  /**
   * Vesting balance too high to send value.
   **/
  | 'VestingBalance'
  /**
   * Account liquidity restrictions prevent withdrawal.
   **/
  | 'LiquidityRestrictions'
  /**
   * Balance too low to send value.
   **/
  | 'InsufficientBalance'
  /**
   * Value too low to create account due to existential deposit.
   **/
  | 'ExistentialDeposit'
  /**
   * Transfer/payment would kill account.
   **/
  | 'Expendability'
  /**
   * A vesting schedule already exists for this account.
   **/
  | 'ExistingVestingSchedule'
  /**
   * Beneficiary account must pre-exist.
   **/
  | 'DeadAccount'
  /**
   * Number of named reserves exceed `MaxReserves`.
   **/
  | 'TooManyReserves'
  /**
   * Number of holds exceed `MaxHolds`.
   **/
  | 'TooManyHolds'
  /**
   * Number of freezes exceed `MaxFreezes`.
   **/
  | 'TooManyFreezes';

export type PalletTransactionPaymentReleases = 'V1Ancient' | 'V2';

export type PalletStakingStakingLedger = {
  stash: AccountId32;
  total: bigint;
  active: bigint;
  unlocking: Array<PalletStakingUnlockChunk>;
  claimedRewards: Array<number>;
};

export type PalletStakingUnlockChunk = { value: bigint; era: number };

export type PalletStakingNominations = { targets: Array<AccountId32>; submittedIn: number; suppressed: boolean };

export type PalletStakingActiveEraInfo = { index: number; start?: bigint | undefined };

export type PalletStakingExposure = { total: bigint; own: bigint; others: Array<PalletStakingIndividualExposure> };

export type PalletStakingIndividualExposure = { who: AccountId32; value: bigint };

export type PalletStakingEraRewardPoints = { total: number; individual: Array<[AccountId32, number]> };

export type PalletStakingUnappliedSlash = {
  validator: AccountId32;
  own: bigint;
  others: Array<[AccountId32, bigint]>;
  reporters: Array<AccountId32>;
  payout: bigint;
};

export type PalletStakingSlashingSlashingSpans = {
  spanIndex: number;
  lastStart: number;
  lastNonzeroSlash: number;
  prior: Array<number>;
};

export type PalletStakingSlashingSpanRecord = { slashed: bigint; paidOut: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletStakingPalletError =
  /**
   * Not a controller account.
   **/
  | 'NotController'
  /**
   * Not a stash account.
   **/
  | 'NotStash'
  /**
   * Stash is already bonded.
   **/
  | 'AlreadyBonded'
  /**
   * Controller is already paired.
   **/
  | 'AlreadyPaired'
  /**
   * Targets cannot be empty.
   **/
  | 'EmptyTargets'
  /**
   * Duplicate index.
   **/
  | 'DuplicateIndex'
  /**
   * Slash record index out of bounds.
   **/
  | 'InvalidSlashIndex'
  /**
   * Cannot have a validator or nominator role, with value less than the minimum defined by
   * governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
   * intention, `chill` first to remove one's role as validator/nominator.
   **/
  | 'InsufficientBond'
  /**
   * Can not schedule more unlock chunks.
   **/
  | 'NoMoreChunks'
  /**
   * Can not rebond without unlocking chunks.
   **/
  | 'NoUnlockChunk'
  /**
   * Attempting to target a stash that still has funds.
   **/
  | 'FundedTarget'
  /**
   * Invalid era to reward.
   **/
  | 'InvalidEraToReward'
  /**
   * Invalid number of nominations.
   **/
  | 'InvalidNumberOfNominations'
  /**
   * Items are not sorted and unique.
   **/
  | 'NotSortedAndUnique'
  /**
   * Rewards for this era have already been claimed for this validator.
   **/
  | 'AlreadyClaimed'
  /**
   * Incorrect previous history depth input provided.
   **/
  | 'IncorrectHistoryDepth'
  /**
   * Incorrect number of slashing spans provided.
   **/
  | 'IncorrectSlashingSpans'
  /**
   * Internal state has become somehow corrupted and the operation cannot continue.
   **/
  | 'BadState'
  /**
   * Too many nomination targets supplied.
   **/
  | 'TooManyTargets'
  /**
   * A nomination target was supplied that was blocked or otherwise not a validator.
   **/
  | 'BadTarget'
  /**
   * The user has enough bond and thus cannot be chilled forcefully by an external person.
   **/
  | 'CannotChillOther'
  /**
   * There are too many nominators in the system. Governance needs to adjust the staking
   * settings to keep things safe for the runtime.
   **/
  | 'TooManyNominators'
  /**
   * There are too many validator candidates in the system. Governance needs to adjust the
   * staking settings to keep things safe for the runtime.
   **/
  | 'TooManyValidators'
  /**
   * Commission is too low. Must be at least `MinCommission`.
   **/
  | 'CommissionTooLow'
  /**
   * Some bound is not met.
   **/
  | 'BoundNotMet';

export type SpCoreCryptoKeyTypeId = FixedBytes<4>;

/**
 * Error for the session pallet.
 **/
export type PalletSessionError =
  /**
   * Invalid ownership proof.
   **/
  | 'InvalidProof'
  /**
   * No associated validator ID for account.
   **/
  | 'NoAssociatedValidatorId'
  /**
   * Registered duplicate key.
   **/
  | 'DuplicatedKey'
  /**
   * No keys are associated with this account.
   **/
  | 'NoKeys'
  /**
   * Key setting account is not live, so it's impossible to associate keys.
   **/
  | 'NoAccount';

export type PrimitivesEraValidators = { reserved: Array<AccountId32>; nonReserved: Array<AccountId32> };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletElectionsError =
  | 'NotEnoughValidators'
  | 'NotEnoughReservedValidators'
  | 'NotEnoughNonReservedValidators'
  | 'NonUniqueListOfValidators'
  | 'NonReservedFinalitySeatsLargerThanNonReservedSeats';

export type PalletTreasuryProposal = { proposer: AccountId32; value: bigint; beneficiary: AccountId32; bond: bigint };

export type FrameSupportPalletId = FixedBytes<8>;

/**
 * Error for the treasury pallet.
 **/
export type PalletTreasuryError =
  /**
   * Proposer's balance is too low.
   **/
  | 'InsufficientProposersBalance'
  /**
   * No proposal or bounty at that index.
   **/
  | 'InvalidIndex'
  /**
   * Too many approvals in the queue.
   **/
  | 'TooManyApprovals'
  /**
   * The spend origin is valid but the amount it is allowed to spend is lower than the
   * amount to be spent.
   **/
  | 'InsufficientPermission'
  /**
   * Proposal has not been approved.
   **/
  | 'ProposalNotApproved';

export type PalletVestingReleases = 'V0' | 'V1';

/**
 * Error for the vesting pallet.
 **/
export type PalletVestingError =
  /**
   * The account given is not vesting.
   **/
  | 'NotVesting'
  /**
   * The account already has `MaxVestingSchedules` count of schedules and thus
   * cannot add another one. Consider merging existing schedules in order to add another.
   **/
  | 'AtMaxVestingSchedules'
  /**
   * Amount being transferred is too low to create a vesting schedule.
   **/
  | 'AmountLow'
  /**
   * An index was out of bounds of the vesting schedules.
   **/
  | 'ScheduleIndexOutOfBounds'
  /**
   * Failed to create a new schedule because some parameter was invalid.
   **/
  | 'InvalidScheduleParams';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUtilityError =
  /**
   * Too many calls batched.
   **/
  'TooManyCalls';

export type PalletMultisigMultisig = {
  when: PalletMultisigTimepoint;
  deposit: bigint;
  depositor: AccountId32;
  approvals: Array<AccountId32>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMultisigError =
  /**
   * Threshold must be 2 or greater.
   **/
  | 'MinimumThreshold'
  /**
   * Call is already approved by this signatory.
   **/
  | 'AlreadyApproved'
  /**
   * Call doesn't need any (more) approvals.
   **/
  | 'NoApprovalsNeeded'
  /**
   * There are too few signatories in the list.
   **/
  | 'TooFewSignatories'
  /**
   * There are too many signatories in the list.
   **/
  | 'TooManySignatories'
  /**
   * The signatories were provided out of order; they should be ordered.
   **/
  | 'SignatoriesOutOfOrder'
  /**
   * The sender was contained in the other signatories; it shouldn't be.
   **/
  | 'SenderInSignatories'
  /**
   * Multisig operation not found when attempting to cancel.
   **/
  | 'NotFound'
  /**
   * Only the account that originally created the multisig is able to cancel it.
   **/
  | 'NotOwner'
  /**
   * No timepoint was given, yet the multisig operation is already underway.
   **/
  | 'NoTimepoint'
  /**
   * A different timepoint was given to the multisig operation that is underway.
   **/
  | 'WrongTimepoint'
  /**
   * A timepoint was given, yet no multisig operation is underway.
   **/
  | 'UnexpectedTimepoint'
  /**
   * The maximum weight information provided was too low.
   **/
  | 'MaxWeightTooLow'
  /**
   * The data to be stored is already stored.
   **/
  | 'AlreadyStored';

/**
 * Error for the Sudo pallet
 **/
export type PalletSudoError =
  /**
   * Sender must be the Sudo account
   **/
  'RequireSudo';

export type PalletContractsWasmCodeInfo = {
  owner: AccountId32;
  deposit: bigint;
  refcount: bigint;
  determinism: PalletContractsWasmDeterminism;
  codeLen: number;
};

export type PalletContractsStorageContractInfo = {
  trieId: Bytes;
  depositAccount: PalletContractsStorageDepositAccount;
  codeHash: H256;
  storageBytes: number;
  storageItems: number;
  storageByteDeposit: bigint;
  storageItemDeposit: bigint;
  storageBaseDeposit: bigint;
};

export type PalletContractsStorageDepositAccount = AccountId32;

export type PalletContractsStorageDeletionQueueManager = { insertCounter: number; deleteCounter: number };

export type PalletContractsSchedule = {
  limits: PalletContractsScheduleLimits;
  instructionWeights: PalletContractsScheduleInstructionWeights;
  hostFnWeights: PalletContractsScheduleHostFnWeights;
};

export type PalletContractsScheduleLimits = {
  eventTopics: number;
  globals: number;
  locals: number;
  parameters: number;
  memoryPages: number;
  tableSize: number;
  brTableSize: number;
  subjectLen: number;
  payloadLen: number;
  runtimeMemory: number;
};

export type PalletContractsScheduleInstructionWeights = { base: number };

export type PalletContractsScheduleHostFnWeights = {
  caller: SpWeightsWeightV2Weight;
  isContract: SpWeightsWeightV2Weight;
  codeHash: SpWeightsWeightV2Weight;
  ownCodeHash: SpWeightsWeightV2Weight;
  callerIsOrigin: SpWeightsWeightV2Weight;
  callerIsRoot: SpWeightsWeightV2Weight;
  address: SpWeightsWeightV2Weight;
  gasLeft: SpWeightsWeightV2Weight;
  balance: SpWeightsWeightV2Weight;
  valueTransferred: SpWeightsWeightV2Weight;
  minimumBalance: SpWeightsWeightV2Weight;
  blockNumber: SpWeightsWeightV2Weight;
  now: SpWeightsWeightV2Weight;
  weightToFee: SpWeightsWeightV2Weight;
  input: SpWeightsWeightV2Weight;
  inputPerByte: SpWeightsWeightV2Weight;
  rReturn: SpWeightsWeightV2Weight;
  returnPerByte: SpWeightsWeightV2Weight;
  terminate: SpWeightsWeightV2Weight;
  random: SpWeightsWeightV2Weight;
  depositEvent: SpWeightsWeightV2Weight;
  depositEventPerTopic: SpWeightsWeightV2Weight;
  depositEventPerByte: SpWeightsWeightV2Weight;
  debugMessage: SpWeightsWeightV2Weight;
  debugMessagePerByte: SpWeightsWeightV2Weight;
  setStorage: SpWeightsWeightV2Weight;
  setStoragePerNewByte: SpWeightsWeightV2Weight;
  setStoragePerOldByte: SpWeightsWeightV2Weight;
  setCodeHash: SpWeightsWeightV2Weight;
  clearStorage: SpWeightsWeightV2Weight;
  clearStoragePerByte: SpWeightsWeightV2Weight;
  containsStorage: SpWeightsWeightV2Weight;
  containsStoragePerByte: SpWeightsWeightV2Weight;
  getStorage: SpWeightsWeightV2Weight;
  getStoragePerByte: SpWeightsWeightV2Weight;
  takeStorage: SpWeightsWeightV2Weight;
  takeStoragePerByte: SpWeightsWeightV2Weight;
  transfer: SpWeightsWeightV2Weight;
  call: SpWeightsWeightV2Weight;
  delegateCall: SpWeightsWeightV2Weight;
  callTransferSurcharge: SpWeightsWeightV2Weight;
  callPerClonedByte: SpWeightsWeightV2Weight;
  instantiate: SpWeightsWeightV2Weight;
  instantiateTransferSurcharge: SpWeightsWeightV2Weight;
  instantiatePerInputByte: SpWeightsWeightV2Weight;
  instantiatePerSaltByte: SpWeightsWeightV2Weight;
  hashSha2256: SpWeightsWeightV2Weight;
  hashSha2256PerByte: SpWeightsWeightV2Weight;
  hashKeccak256: SpWeightsWeightV2Weight;
  hashKeccak256PerByte: SpWeightsWeightV2Weight;
  hashBlake2256: SpWeightsWeightV2Weight;
  hashBlake2256PerByte: SpWeightsWeightV2Weight;
  hashBlake2128: SpWeightsWeightV2Weight;
  hashBlake2128PerByte: SpWeightsWeightV2Weight;
  ecdsaRecover: SpWeightsWeightV2Weight;
  ecdsaToEthAddress: SpWeightsWeightV2Weight;
  sr25519Verify: SpWeightsWeightV2Weight;
  sr25519VerifyPerByte: SpWeightsWeightV2Weight;
  reentranceCount: SpWeightsWeightV2Weight;
  accountReentranceCount: SpWeightsWeightV2Weight;
  instantiationNonce: SpWeightsWeightV2Weight;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletContractsError =
  /**
   * Invalid schedule supplied, e.g. with zero weight of a basic operation.
   **/
  | 'InvalidSchedule'
  /**
   * Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`.
   **/
  | 'InvalidCallFlags'
  /**
   * The executed contract exhausted its gas limit.
   **/
  | 'OutOfGas'
  /**
   * The output buffer supplied to a contract API call was too small.
   **/
  | 'OutputBufferTooSmall'
  /**
   * Performing the requested transfer failed. Probably because there isn't enough
   * free balance in the sender's account.
   **/
  | 'TransferFailed'
  /**
   * Performing a call was denied because the calling depth reached the limit
   * of what is specified in the schedule.
   **/
  | 'MaxCallDepthReached'
  /**
   * No contract was found at the specified address.
   **/
  | 'ContractNotFound'
  /**
   * The code supplied to `instantiate_with_code` exceeds the limit specified in the
   * current schedule.
   **/
  | 'CodeTooLarge'
  /**
   * No code could be found at the supplied code hash.
   **/
  | 'CodeNotFound'
  /**
   * No code info could be found at the supplied code hash.
   **/
  | 'CodeInfoNotFound'
  /**
   * A buffer outside of sandbox memory was passed to a contract API function.
   **/
  | 'OutOfBounds'
  /**
   * Input passed to a contract API function failed to decode as expected type.
   **/
  | 'DecodingFailed'
  /**
   * Contract trapped during execution.
   **/
  | 'ContractTrapped'
  /**
   * The size defined in `T::MaxValueSize` was exceeded.
   **/
  | 'ValueTooLarge'
  /**
   * Termination of a contract is not allowed while the contract is already
   * on the call stack. Can be triggered by `seal_terminate`.
   **/
  | 'TerminatedWhileReentrant'
  /**
   * `seal_call` forwarded this contracts input. It therefore is no longer available.
   **/
  | 'InputForwarded'
  /**
   * The subject passed to `seal_random` exceeds the limit.
   **/
  | 'RandomSubjectTooLong'
  /**
   * The amount of topics passed to `seal_deposit_events` exceeds the limit.
   **/
  | 'TooManyTopics'
  /**
   * The chain does not provide a chain extension. Calling the chain extension results
   * in this error. Note that this usually shouldn't happen as deploying such contracts
   * is rejected.
   **/
  | 'NoChainExtension'
  /**
   * A contract with the same AccountId already exists.
   **/
  | 'DuplicateContract'
  /**
   * A contract self destructed in its constructor.
   *
   * This can be triggered by a call to `seal_terminate`.
   **/
  | 'TerminatedInConstructor'
  /**
   * A call tried to invoke a contract that is flagged as non-reentrant.
   * The only other cause is that a call from a contract into the runtime tried to call back
   * into `pallet-contracts`. This would make the whole pallet reentrant with regard to
   * contract code execution which is not supported.
   **/
  | 'ReentranceDenied'
  /**
   * Origin doesn't have enough balance to pay the required storage deposits.
   **/
  | 'StorageDepositNotEnoughFunds'
  /**
   * More storage was created than allowed by the storage deposit limit.
   **/
  | 'StorageDepositLimitExhausted'
  /**
   * Code removal was denied because the code is still in use by at least one contract.
   **/
  | 'CodeInUse'
  /**
   * The contract ran to completion but decided to revert its storage changes.
   * Please note that this error is only returned from extrinsics. When called directly
   * or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags
   * to determine whether a reversion has taken place.
   **/
  | 'ContractReverted'
  /**
   * The contract's code was found to be invalid during validation.
   *
   * The most likely cause of this is that an API was used which is not supported by the
   * node. This happens if an older node is used with a new version of ink!. Try updating
   * your node to the newest available version.
   *
   * A more detailed error can be found on the node console if debug messages are enabled
   * by supplying `-lruntime::contracts=debug`.
   **/
  | 'CodeRejected'
  /**
   * An indetermistic code was used in a context where this is not permitted.
   **/
  | 'Indeterministic'
  /**
   * A pending migration needs to complete before the extrinsic can be called.
   **/
  | 'MigrationInProgress'
  /**
   * Migrate dispatch call was attempted but no migration was performed.
   **/
  | 'NoMigrationPerformed';

export type PalletNominationPoolsPoolMember = {
  poolId: number;
  points: bigint;
  lastRecordedRewardCounter: FixedU128;
  unbondingEras: Array<[number, bigint]>;
};

export type PalletNominationPoolsBondedPoolInner = {
  commission: PalletNominationPoolsCommission;
  memberCounter: number;
  points: bigint;
  roles: PalletNominationPoolsPoolRoles;
  state: PalletNominationPoolsPoolState;
};

export type PalletNominationPoolsCommission = {
  current?: [Perbill, AccountId32] | undefined;
  max?: Perbill | undefined;
  changeRate?: PalletNominationPoolsCommissionChangeRate | undefined;
  throttleFrom?: number | undefined;
};

export type PalletNominationPoolsPoolRoles = {
  depositor: AccountId32;
  root?: AccountId32 | undefined;
  nominator?: AccountId32 | undefined;
  bouncer?: AccountId32 | undefined;
};

export type PalletNominationPoolsRewardPool = {
  lastRecordedRewardCounter: FixedU128;
  lastRecordedTotalPayouts: bigint;
  totalRewardsClaimed: bigint;
  totalCommissionPending: bigint;
  totalCommissionClaimed: bigint;
};

export type PalletNominationPoolsSubPools = {
  noEra: PalletNominationPoolsUnbondPool;
  withEra: Array<[number, PalletNominationPoolsUnbondPool]>;
};

export type PalletNominationPoolsUnbondPool = { points: bigint; balance: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletNominationPoolsError =
  /**
   * A (bonded) pool id does not exist.
   **/
  | { tag: 'PoolNotFound' }
  /**
   * An account is not a member.
   **/
  | { tag: 'PoolMemberNotFound' }
  /**
   * A reward pool does not exist. In all cases this is a system logic error.
   **/
  | { tag: 'RewardPoolNotFound' }
  /**
   * A sub pool does not exist.
   **/
  | { tag: 'SubPoolsNotFound' }
  /**
   * An account is already delegating in another pool. An account may only belong to one
   * pool at a time.
   **/
  | { tag: 'AccountBelongsToOtherPool' }
  /**
   * The member is fully unbonded (and thus cannot access the bonded and reward pool
   * anymore to, for example, collect rewards).
   **/
  | { tag: 'FullyUnbonding' }
  /**
   * The member cannot unbond further chunks due to reaching the limit.
   **/
  | { tag: 'MaxUnbondingLimit' }
  /**
   * None of the funds can be withdrawn yet because the bonding duration has not passed.
   **/
  | { tag: 'CannotWithdrawAny' }
  /**
   * The amount does not meet the minimum bond to either join or create a pool.
   *
   * The depositor can never unbond to a value less than
   * `Pallet::depositor_min_bond`. The caller does not have nominating
   * permissions for the pool. Members can never unbond to a value below `MinJoinBond`.
   **/
  | { tag: 'MinimumBondNotMet' }
  /**
   * The transaction could not be executed due to overflow risk for the pool.
   **/
  | { tag: 'OverflowRisk' }
  /**
   * A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
   * other members to be permissionlessly unbonded.
   **/
  | { tag: 'NotDestroying' }
  /**
   * The caller does not have nominating permissions for the pool.
   **/
  | { tag: 'NotNominator' }
  /**
   * Either a) the caller cannot make a valid kick or b) the pool is not destroying.
   **/
  | { tag: 'NotKickerOrDestroying' }
  /**
   * The pool is not open to join
   **/
  | { tag: 'NotOpen' }
  /**
   * The system is maxed out on pools.
   **/
  | { tag: 'MaxPools' }
  /**
   * Too many members in the pool or system.
   **/
  | { tag: 'MaxPoolMembers' }
  /**
   * The pools state cannot be changed.
   **/
  | { tag: 'CanNotChangeState' }
  /**
   * The caller does not have adequate permissions.
   **/
  | { tag: 'DoesNotHavePermission' }
  /**
   * Metadata exceeds [`Config::MaxMetadataLen`]
   **/
  | { tag: 'MetadataExceedsMaxLen' }
  /**
   * Some error occurred that should never happen. This should be reported to the
   * maintainers.
   **/
  | { tag: 'Defensive'; value: PalletNominationPoolsDefensiveError }
  /**
   * Partial unbonding now allowed permissionlessly.
   **/
  | { tag: 'PartialUnbondNotAllowedPermissionlessly' }
  /**
   * The pool's max commission cannot be set higher than the existing value.
   **/
  | { tag: 'MaxCommissionRestricted' }
  /**
   * The supplied commission exceeds the max allowed commission.
   **/
  | { tag: 'CommissionExceedsMaximum' }
  /**
   * The supplied commission exceeds global maximum commission.
   **/
  | { tag: 'CommissionExceedsGlobalMaximum' }
  /**
   * Not enough blocks have surpassed since the last commission update.
   **/
  | { tag: 'CommissionChangeThrottled' }
  /**
   * The submitted changes to commission change rate are not allowed.
   **/
  | { tag: 'CommissionChangeRateNotAllowed' }
  /**
   * There is no pending commission to claim.
   **/
  | { tag: 'NoPendingCommission' }
  /**
   * No commission current has been set.
   **/
  | { tag: 'NoCommissionCurrentSet' }
  /**
   * Pool id currently in use.
   **/
  | { tag: 'PoolIdInUse' }
  /**
   * Pool id provided is not correct/usable.
   **/
  | { tag: 'InvalidPoolId' }
  /**
   * Bonding extra is restricted to the exact pending reward amount.
   **/
  | { tag: 'BondExtraRestricted' };

export type PalletNominationPoolsDefensiveError =
  | 'NotEnoughSpaceInUnbondPool'
  | 'PoolNotFound'
  | 'RewardPoolNotFound'
  | 'SubPoolsNotFound'
  | 'BondedStashKilledPrematurely';

export type PalletIdentityRegistration = {
  judgements: Array<[number, PalletIdentityJudgement]>;
  deposit: bigint;
  info: PalletIdentityIdentityInfo;
};

export type PalletIdentityRegistrarInfo = { account: AccountId32; fee: bigint; fields: PalletIdentityBitFlags };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIdentityError =
  /**
   * Too many subs-accounts.
   **/
  | 'TooManySubAccounts'
  /**
   * Account isn't found.
   **/
  | 'NotFound'
  /**
   * Account isn't named.
   **/
  | 'NotNamed'
  /**
   * Empty index.
   **/
  | 'EmptyIndex'
  /**
   * Fee is changed.
   **/
  | 'FeeChanged'
  /**
   * No identity found.
   **/
  | 'NoIdentity'
  /**
   * Sticky judgement.
   **/
  | 'StickyJudgement'
  /**
   * Judgement given.
   **/
  | 'JudgementGiven'
  /**
   * Invalid judgement.
   **/
  | 'InvalidJudgement'
  /**
   * The index is invalid.
   **/
  | 'InvalidIndex'
  /**
   * The target is invalid.
   **/
  | 'InvalidTarget'
  /**
   * Too many additional fields.
   **/
  | 'TooManyFields'
  /**
   * Maximum amount of registrars reached. Cannot add any more.
   **/
  | 'TooManyRegistrars'
  /**
   * Account ID is already named.
   **/
  | 'AlreadyClaimed'
  /**
   * Sender is not a sub-account.
   **/
  | 'NotSub'
  /**
   * Sub-account isn't owned by sender.
   **/
  | 'NotOwned'
  /**
   * The provided judgement was for a different identity.
   **/
  | 'JudgementForDifferentIdentity'
  /**
   * Error that occurs when there is an issue paying for judgement.
   **/
  | 'JudgementPaymentFailed';

export type PalletCommitteeManagementValidatorTotalRewards = Array<[AccountId32, number]>;

export type PalletCommitteeManagementCurrentAndNextSessionValidators = {
  next: PrimitivesSessionValidators;
  current: PrimitivesSessionValidators;
};

export type PrimitivesSessionValidators = { committee: Array<AccountId32>; nonCommittee: Array<AccountId32> };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCommitteeManagementError =
  /**
   * Raised in any scenario [`BanConfig`] is invalid
   * * `performance_ratio_threshold` must be a number in range [0; 100]
   * * `underperformed_session_count_threshold` must be a positive number,
   * * `clean_session_counter_delay` must be a positive number.
   **/
  | 'InvalidBanConfig'
  /**
   * Ban reason is too big, ie given vector of bytes is greater than
   * [`primitives::DEFAULT_BAN_REASON_LENGTH`]
   **/
  | 'BanReasonTooBig'
  /**
   * Lenient threshold not in [0-100] range
   **/
  | 'InvalidLenientThreshold';

export type SpRuntimeMultiSignature =
  | { tag: 'Ed25519'; value: SpCoreEd25519Signature }
  | { tag: 'Sr25519'; value: SpCoreSr25519Signature }
  | { tag: 'Ecdsa'; value: SpCoreEcdsaSignature };

export type SpCoreEd25519Signature = FixedBytes<64>;

export type SpCoreSr25519Signature = FixedBytes<64>;

export type SpCoreEcdsaSignature = FixedBytes<65>;

export type FrameSystemExtensionsCheckNonZeroSender = {};

export type FrameSystemExtensionsCheckSpecVersion = {};

export type FrameSystemExtensionsCheckTxVersion = {};

export type FrameSystemExtensionsCheckGenesis = {};

export type FrameSystemExtensionsCheckMortality = Era;

export type FrameSystemExtensionsCheckNonce = number;

export type FrameSystemExtensionsCheckWeight = {};

export type PalletTransactionPaymentChargeTransactionPayment = bigint;

export type SpRuntimeBlock = { header: Header; extrinsics: Array<UncheckedExtrinsic> };

export type SpCoreOpaqueMetadata = Bytes;

export type SpRuntimeTransactionValidityTransactionValidityError =
  | { tag: 'Invalid'; value: SpRuntimeTransactionValidityInvalidTransaction }
  | { tag: 'Unknown'; value: SpRuntimeTransactionValidityUnknownTransaction };

export type SpRuntimeTransactionValidityInvalidTransaction =
  | { tag: 'Call' }
  | { tag: 'Payment' }
  | { tag: 'Future' }
  | { tag: 'Stale' }
  | { tag: 'BadProof' }
  | { tag: 'AncientBirthBlock' }
  | { tag: 'ExhaustsResources' }
  | { tag: 'Custom'; value: number }
  | { tag: 'BadMandatory' }
  | { tag: 'MandatoryValidation' }
  | { tag: 'BadSigner' };

export type SpRuntimeTransactionValidityUnknownTransaction =
  | { tag: 'CannotLookup' }
  | { tag: 'NoUnsignedValidator' }
  | { tag: 'Custom'; value: number };

export type SpInherentsInherentData = { data: Array<[FixedBytes<8>, Bytes]> };

export type SpInherentsCheckInherentsResult = { okay: boolean; fatalError: boolean; errors: SpInherentsInherentData };

export type SpRuntimeTransactionValidityTransactionSource = 'InBlock' | 'Local' | 'External';

export type SpRuntimeTransactionValidityValidTransaction = {
  priority: bigint;
  requires: Array<Bytes>;
  provides: Array<Bytes>;
  longevity: bigint;
  propagate: boolean;
};

export type SpConsensusSlotsSlotDuration = bigint;

export type PalletTransactionPaymentRuntimeDispatchInfo = {
  weight: SpWeightsWeightV2Weight;
  class: FrameSupportDispatchDispatchClass;
  partialFee: bigint;
};

export type PalletTransactionPaymentFeeDetails = {
  inclusionFee?: PalletTransactionPaymentInclusionFee | undefined;
  tip: bigint;
};

export type PalletTransactionPaymentInclusionFee = { baseFee: bigint; lenFee: bigint; adjustedWeightFee: bigint };

export type PrimitivesApiError = 'DecodeKey';

export type PrimitivesSessionAuthorityData = {
  authorities: Array<PrimitivesAppPublic>;
  emergencyFinalizer?: PrimitivesAppPublic | undefined;
};

export type PrimitivesSessionCommittee = { finalityCommittee: Array<AccountId32>; blockProducers: Array<AccountId32> };

export type PrimitivesSessionValidatorError =
  | { tag: 'SessionNotWithinRange'; value: { lowerLimit: number; upperLimit: number } }
  | { tag: 'Other'; value: Bytes };

export type PalletContractsPrimitivesContractResult = {
  gasConsumed: SpWeightsWeightV2Weight;
  gasRequired: SpWeightsWeightV2Weight;
  storageDeposit: PalletContractsPrimitivesStorageDeposit;
  debugMessage: Bytes;
  result: Result<PalletContractsPrimitivesExecReturnValue, DispatchError>;
  events?: Array<FrameSystemEventRecord> | undefined;
};

export type PalletContractsPrimitivesExecReturnValue = { flags: PalletContractsPrimitivesReturnFlags; data: Bytes };

export type PalletContractsPrimitivesReturnFlags = { bits: number };

export type PalletContractsPrimitivesStorageDeposit =
  | { tag: 'Refund'; value: bigint }
  | { tag: 'Charge'; value: bigint };

export type PalletContractsPrimitivesCode = { tag: 'Upload'; value: Bytes } | { tag: 'Existing'; value: H256 };

export type PalletContractsPrimitivesContractResultResult = {
  gasConsumed: SpWeightsWeightV2Weight;
  gasRequired: SpWeightsWeightV2Weight;
  storageDeposit: PalletContractsPrimitivesStorageDeposit;
  debugMessage: Bytes;
  result: Result<PalletContractsPrimitivesInstantiateReturnValue, DispatchError>;
  events?: Array<FrameSystemEventRecord> | undefined;
};

export type PalletContractsPrimitivesInstantiateReturnValue = {
  result: PalletContractsPrimitivesExecReturnValue;
  accountId: AccountId32;
};

export type PalletContractsPrimitivesCodeUploadReturnValue = { codeHash: H256; deposit: bigint };

export type PalletContractsPrimitivesContractAccessError = 'DoesntExist' | 'KeyDecodingFailed' | 'MigrationInProgress';

export type AlephRuntimeRuntimeError =
  | { tag: 'System'; value: FrameSystemError }
  | { tag: 'Scheduler'; value: PalletSchedulerError }
  | { tag: 'Balances'; value: PalletBalancesError }
  | { tag: 'Staking'; value: PalletStakingPalletError }
  | { tag: 'Session'; value: PalletSessionError }
  | { tag: 'Elections'; value: PalletElectionsError }
  | { tag: 'Treasury'; value: PalletTreasuryError }
  | { tag: 'Vesting'; value: PalletVestingError }
  | { tag: 'Utility'; value: PalletUtilityError }
  | { tag: 'Multisig'; value: PalletMultisigError }
  | { tag: 'Sudo'; value: PalletSudoError }
  | { tag: 'Contracts'; value: PalletContractsError }
  | { tag: 'NominationPools'; value: PalletNominationPoolsError }
  | { tag: 'Identity'; value: PalletIdentityError }
  | { tag: 'CommitteeManagement'; value: PalletCommitteeManagementError };
