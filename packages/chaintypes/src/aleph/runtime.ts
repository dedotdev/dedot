// Generated by @dedot/codegen

import type { GenericRuntimeApis, GenericRuntimeApiMethod } from '@dedot/types';
import type {
  RuntimeVersion,
  Header,
  DispatchError,
  Result,
  UncheckedExtrinsicLike,
  UncheckedExtrinsic,
  H256,
  Bytes,
  BytesLike,
  AccountId32Like,
} from '@dedot/codecs';
import type {
  SpRuntimeBlock,
  SpCoreOpaqueMetadata,
  SpRuntimeTransactionValidityTransactionValidityError,
  SpInherentsInherentData,
  SpInherentsCheckInherentsResult,
  SpRuntimeTransactionValidityValidTransaction,
  SpRuntimeTransactionValidityTransactionSource,
  SpConsensusSlotsSlotDuration,
  SpConsensusAuraSr25519AppSr25519Public,
  SpCoreCryptoKeyTypeId,
  PalletTransactionPaymentRuntimeDispatchInfo,
  PalletTransactionPaymentFeeDetails,
  SpWeightsWeightV2Weight,
  PrimitivesAppPublic,
  PrimitivesApiError,
  PrimitivesSessionAuthorityData,
  PrimitivesSessionCommittee,
  PrimitivesSessionValidatorError,
  PalletContractsPrimitivesContractResult,
  PalletContractsPrimitivesContractResultResult,
  PalletContractsPrimitivesCode,
  PalletContractsPrimitivesCodeUploadReturnValue,
  PalletContractsWasmDeterminism,
  PalletContractsPrimitivesContractAccessError,
} from './types';

export interface RuntimeApis extends GenericRuntimeApis {
  /**
   * @runtimeapi: Core - 0xdf6acb689907609b
   **/
  core: {
    /**
     * Returns the version of the runtime.
     *
     * @callname: Core_version
     **/
    version: GenericRuntimeApiMethod<() => Promise<RuntimeVersion>>;

    /**
     * Execute the given block.
     *
     * @callname: Core_execute_block
     * @param {SpRuntimeBlock} block
     **/
    executeBlock: GenericRuntimeApiMethod<(block: SpRuntimeBlock) => Promise<[]>>;

    /**
     * Initialize a block with the given header.
     *
     * @callname: Core_initialize_block
     * @param {Header} header
     **/
    initializeBlock: GenericRuntimeApiMethod<(header: Header) => Promise<[]>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: Metadata - 0x37e397fc7c91f5e4
   **/
  metadata: {
    /**
     * Returns the metadata of a runtime.
     *
     * @callname: Metadata_metadata
     **/
    metadata: GenericRuntimeApiMethod<() => Promise<SpCoreOpaqueMetadata>>;

    /**
     * Returns the metadata at a given version.
     *
     * If the given `version` isn't supported, this will return `None`.
     * Use [`Self::metadata_versions`] to find out about supported metadata version of the runtime.
     *
     * @callname: Metadata_metadata_at_version
     * @param {number} version
     **/
    metadataAtVersion: GenericRuntimeApiMethod<(version: number) => Promise<SpCoreOpaqueMetadata | undefined>>;

    /**
     * Returns the supported metadata versions.
     *
     * This can be used to call `metadata_at_version`.
     *
     * @callname: Metadata_metadata_versions
     **/
    metadataVersions: GenericRuntimeApiMethod<() => Promise<Array<number>>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: BlockBuilder - 0x40fe3ad401f8959a
   **/
  blockBuilder: {
    /**
     * Apply the given extrinsic.
     *
     * Returns an inclusion outcome which specifies if this extrinsic is included in
     * this block or not.
     *
     * @callname: BlockBuilder_apply_extrinsic
     * @param {UncheckedExtrinsicLike} extrinsic
     **/
    applyExtrinsic: GenericRuntimeApiMethod<
      (
        extrinsic: UncheckedExtrinsicLike,
      ) => Promise<Result<Result<[], DispatchError>, SpRuntimeTransactionValidityTransactionValidityError>>
    >;

    /**
     * Finish the current block.
     *
     * @callname: BlockBuilder_finalize_block
     **/
    finalizeBlock: GenericRuntimeApiMethod<() => Promise<Header>>;

    /**
     * Generate inherent extrinsics. The inherent data will vary from chain to chain.
     *
     * @callname: BlockBuilder_inherent_extrinsics
     * @param {SpInherentsInherentData} inherent
     **/
    inherentExtrinsics: GenericRuntimeApiMethod<
      (inherent: SpInherentsInherentData) => Promise<Array<UncheckedExtrinsic>>
    >;

    /**
     * Check that the inherents are valid. The inherent data will vary from chain to chain.
     *
     * @callname: BlockBuilder_check_inherents
     * @param {SpRuntimeBlock} block
     * @param {SpInherentsInherentData} data
     **/
    checkInherents: GenericRuntimeApiMethod<
      (block: SpRuntimeBlock, data: SpInherentsInherentData) => Promise<SpInherentsCheckInherentsResult>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: TaggedTransactionQueue - 0xd2bc9897eed08f15
   **/
  taggedTransactionQueue: {
    /**
     * Validate the transaction.
     *
     * This method is invoked by the transaction pool to learn details about given transaction.
     * The implementation should make sure to verify the correctness of the transaction
     * against current state. The given `block_hash` corresponds to the hash of the block
     * that is used as current state.
     *
     * Note that this call may be performed by the pool multiple times and transactions
     * might be verified in any possible order.
     *
     * @callname: TaggedTransactionQueue_validate_transaction
     * @param {SpRuntimeTransactionValidityTransactionSource} source
     * @param {UncheckedExtrinsicLike} tx
     * @param {H256} block_hash
     **/
    validateTransaction: GenericRuntimeApiMethod<
      (
        source: SpRuntimeTransactionValidityTransactionSource,
        tx: UncheckedExtrinsicLike,
        blockHash: H256,
      ) => Promise<
        Result<SpRuntimeTransactionValidityValidTransaction, SpRuntimeTransactionValidityTransactionValidityError>
      >
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: AuraApi - 0xdd718d5cc53262d4
   **/
  auraApi: {
    /**
     * Returns the slot duration for Aura.
     *
     * Currently, only the value provided by this type at genesis will be used.
     *
     * @callname: AuraApi_slot_duration
     **/
    slotDuration: GenericRuntimeApiMethod<() => Promise<SpConsensusSlotsSlotDuration>>;

    /**
     * Return the current set of authorities.
     *
     * @callname: AuraApi_authorities
     **/
    authorities: GenericRuntimeApiMethod<() => Promise<Array<SpConsensusAuraSr25519AppSr25519Public>>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: OffchainWorkerApi - 0xf78b278be53f454c
   **/
  offchainWorkerApi: {
    /**
     * Starts the off-chain task for given block header.
     *
     * @callname: OffchainWorkerApi_offchain_worker
     * @param {Header} header
     **/
    offchainWorker: GenericRuntimeApiMethod<(header: Header) => Promise<[]>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: SessionKeys - 0xab3c0572291feb8b
   **/
  sessionKeys: {
    /**
     * Generate a set of session keys with optionally using the given seed.
     * The keys should be stored within the keystore exposed via runtime
     * externalities.
     *
     * The seed needs to be a valid `utf8` string.
     *
     * Returns the concatenated SCALE encoded public keys.
     *
     * @callname: SessionKeys_generate_session_keys
     * @param {BytesLike | undefined} seed
     **/
    generateSessionKeys: GenericRuntimeApiMethod<(seed?: BytesLike | undefined) => Promise<Bytes>>;

    /**
     * Decode the given public session keys.
     *
     * Returns the list of public raw public keys + key type.
     *
     * @callname: SessionKeys_decode_session_keys
     * @param {BytesLike} encoded
     **/
    decodeSessionKeys: GenericRuntimeApiMethod<
      (encoded: BytesLike) => Promise<Array<[Bytes, SpCoreCryptoKeyTypeId]> | undefined>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: AccountNonceApi - 0xbc9d89904f5b923f
   **/
  accountNonceApi: {
    /**
     * Get current account nonce of given `AccountId`.
     *
     * @callname: AccountNonceApi_account_nonce
     * @param {AccountId32Like} account
     **/
    accountNonce: GenericRuntimeApiMethod<(account: AccountId32Like) => Promise<number>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: TransactionPaymentApi - 0x37c8bb1350a9a2a8
   **/
  transactionPaymentApi: {
    /**
     *
     * @callname: TransactionPaymentApi_query_info
     * @param {UncheckedExtrinsicLike} uxt
     * @param {number} len
     **/
    queryInfo: GenericRuntimeApiMethod<
      (uxt: UncheckedExtrinsicLike, len: number) => Promise<PalletTransactionPaymentRuntimeDispatchInfo>
    >;

    /**
     *
     * @callname: TransactionPaymentApi_query_fee_details
     * @param {UncheckedExtrinsicLike} uxt
     * @param {number} len
     **/
    queryFeeDetails: GenericRuntimeApiMethod<
      (uxt: UncheckedExtrinsicLike, len: number) => Promise<PalletTransactionPaymentFeeDetails>
    >;

    /**
     *
     * @callname: TransactionPaymentApi_query_weight_to_fee
     * @param {SpWeightsWeightV2Weight} weight
     **/
    queryWeightToFee: GenericRuntimeApiMethod<(weight: SpWeightsWeightV2Weight) => Promise<bigint>>;

    /**
     *
     * @callname: TransactionPaymentApi_query_length_to_fee
     * @param {number} length
     **/
    queryLengthToFee: GenericRuntimeApiMethod<(length: number) => Promise<bigint>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: AlephSessionApi - 0x2be3f75b696ad1f6
   **/
  alephSessionApi: {
    /**
     *
     * @callname: AlephSessionApi_next_session_authorities
     **/
    nextSessionAuthorities: GenericRuntimeApiMethod<
      () => Promise<Result<Array<PrimitivesAppPublic>, PrimitivesApiError>>
    >;

    /**
     *
     * @callname: AlephSessionApi_authorities
     **/
    authorities: GenericRuntimeApiMethod<() => Promise<Array<PrimitivesAppPublic>>>;

    /**
     *
     * @callname: AlephSessionApi_next_session_authority_data
     **/
    nextSessionAuthorityData: GenericRuntimeApiMethod<
      () => Promise<Result<PrimitivesSessionAuthorityData, PrimitivesApiError>>
    >;

    /**
     *
     * @callname: AlephSessionApi_authority_data
     **/
    authorityData: GenericRuntimeApiMethod<() => Promise<PrimitivesSessionAuthorityData>>;

    /**
     *
     * @callname: AlephSessionApi_session_period
     **/
    sessionPeriod: GenericRuntimeApiMethod<() => Promise<number>>;

    /**
     *
     * @callname: AlephSessionApi_millisecs_per_block
     **/
    millisecsPerBlock: GenericRuntimeApiMethod<() => Promise<bigint>>;

    /**
     *
     * @callname: AlephSessionApi_finality_version
     **/
    finalityVersion: GenericRuntimeApiMethod<() => Promise<number>>;

    /**
     *
     * @callname: AlephSessionApi_next_session_finality_version
     **/
    nextSessionFinalityVersion: GenericRuntimeApiMethod<() => Promise<number>>;

    /**
     * Predict finality committee and block producers for the given session. `session` must be
     * within the current era (current, in the staking context).
     *
     * If the active era `E` starts in the session `a`, and ends in session `b` then from
     * session `a` to session `b-1` this function can answer question who will be in the
     * committee in the era `E`. In the last session of the era `E` (`b`) this can be used to
     * determine all of the sessions in the era `E+1`.
     *
     * @callname: AlephSessionApi_predict_session_committee
     * @param {number} session
     **/
    predictSessionCommittee: GenericRuntimeApiMethod<
      (session: number) => Promise<Result<PrimitivesSessionCommittee, PrimitivesSessionValidatorError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: NominationPoolsApi - 0x17a6bc0d0062aeb3
   **/
  nominationPoolsApi: {
    /**
     * Returns the pending rewards for the member that the AccountId was given for.
     *
     * @callname: NominationPoolsApi_pending_rewards
     * @param {AccountId32Like} who
     **/
    pendingRewards: GenericRuntimeApiMethod<(who: AccountId32Like) => Promise<bigint>>;

    /**
     * Returns the equivalent balance of `points` for a given pool.
     *
     * @callname: NominationPoolsApi_points_to_balance
     * @param {number} pool_id
     * @param {bigint} points
     **/
    pointsToBalance: GenericRuntimeApiMethod<(poolId: number, points: bigint) => Promise<bigint>>;

    /**
     * Returns the equivalent points of `new_funds` for a given pool.
     *
     * @callname: NominationPoolsApi_balance_to_points
     * @param {number} pool_id
     * @param {bigint} new_funds
     **/
    balanceToPoints: GenericRuntimeApiMethod<(poolId: number, newFunds: bigint) => Promise<bigint>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: ContractsApi - 0x68b66ba122c93fa7
   **/
  contractsApi: {
    /**
     * Perform a call from a specified account to a given contract.
     *
     * See [`crate::Pallet::bare_call`].
     *
     * @callname: ContractsApi_call
     * @param {AccountId32Like} origin
     * @param {AccountId32Like} dest
     * @param {bigint} value
     * @param {SpWeightsWeightV2Weight | undefined} gas_limit
     * @param {bigint | undefined} storage_deposit_limit
     * @param {BytesLike} input_data
     **/
    call: GenericRuntimeApiMethod<
      (
        origin: AccountId32Like,
        dest: AccountId32Like,
        value: bigint,
        gasLimit: SpWeightsWeightV2Weight | undefined,
        storageDepositLimit: bigint | undefined,
        inputData: BytesLike,
      ) => Promise<PalletContractsPrimitivesContractResult>
    >;

    /**
     * Instantiate a new contract.
     *
     * See `[crate::Pallet::bare_instantiate]`.
     *
     * @callname: ContractsApi_instantiate
     * @param {AccountId32Like} origin
     * @param {bigint} value
     * @param {SpWeightsWeightV2Weight | undefined} gas_limit
     * @param {bigint | undefined} storage_deposit_limit
     * @param {PalletContractsPrimitivesCode} code
     * @param {BytesLike} data
     * @param {BytesLike} salt
     **/
    instantiate: GenericRuntimeApiMethod<
      (
        origin: AccountId32Like,
        value: bigint,
        gasLimit: SpWeightsWeightV2Weight | undefined,
        storageDepositLimit: bigint | undefined,
        code: PalletContractsPrimitivesCode,
        data: BytesLike,
        salt: BytesLike,
      ) => Promise<PalletContractsPrimitivesContractResultResult>
    >;

    /**
     * Upload new code without instantiating a contract from it.
     *
     * See [`crate::Pallet::bare_upload_code`].
     *
     * @callname: ContractsApi_upload_code
     * @param {AccountId32Like} origin
     * @param {BytesLike} code
     * @param {bigint | undefined} storage_deposit_limit
     * @param {PalletContractsWasmDeterminism} determinism
     **/
    uploadCode: GenericRuntimeApiMethod<
      (
        origin: AccountId32Like,
        code: BytesLike,
        storageDepositLimit: bigint | undefined,
        determinism: PalletContractsWasmDeterminism,
      ) => Promise<Result<PalletContractsPrimitivesCodeUploadReturnValue, DispatchError>>
    >;

    /**
     * Query a given storage key in a given contract.
     *
     * Returns `Ok(Some(Vec<u8>))` if the storage value exists under the given key in the
     * specified account and `Ok(None)` if it doesn't. If the account specified by the address
     * doesn't exist, or doesn't have a contract then `Err` is returned.
     *
     * @callname: ContractsApi_get_storage
     * @param {AccountId32Like} address
     * @param {BytesLike} key
     **/
    getStorage: GenericRuntimeApiMethod<
      (
        address: AccountId32Like,
        key: BytesLike,
      ) => Promise<Result<Bytes | undefined, PalletContractsPrimitivesContractAccessError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
}
