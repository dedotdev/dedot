// Generated by @dedot/codegen

import type {
  Phase,
  H256,
  DispatchInfo,
  DispatchError,
  AccountId32,
  FixedBytes,
  FixedArray,
  Bytes,
  Result,
  Permill,
  BytesLike,
  MultiAddress,
  MultiAddressLike,
  AccountId32Like,
  FixedU128,
  Era,
  Header,
  UncheckedExtrinsic,
} from '@dedot/codecs';

export type FrameSystemAccountInfo = {
  nonce: number;
  consumers: number;
  providers: number;
  sufficients: number;
  data: PalletBalancesAccountData;
};

export type PalletBalancesAccountData = {
  free: bigint;
  reserved: bigint;
  frozen: bigint;
  flags: PalletBalancesExtraFlags;
};

export type PalletBalancesExtraFlags = bigint;

export type FrameSupportDispatchPerDispatchClass = {
  normal: SpWeightsWeightV2Weight;
  operational: SpWeightsWeightV2Weight;
  mandatory: SpWeightsWeightV2Weight;
};

export type SpWeightsWeightV2Weight = { refTime: bigint; proofSize: bigint };

export type FrameSystemEventRecord = { phase: Phase; event: AssetHubWestendRuntimeRuntimeEvent; topics: Array<H256> };

export type AssetHubWestendRuntimeRuntimeEvent =
  | { pallet: 'System'; palletEvent: FrameSystemEvent }
  | { pallet: 'ParachainSystem'; palletEvent: CumulusPalletParachainSystemEvent }
  | { pallet: 'Balances'; palletEvent: PalletBalancesEvent }
  | { pallet: 'TransactionPayment'; palletEvent: PalletTransactionPaymentEvent }
  | { pallet: 'AssetTxPayment'; palletEvent: PalletAssetConversionTxPaymentEvent }
  | { pallet: 'CollatorSelection'; palletEvent: PalletCollatorSelectionEvent }
  | { pallet: 'Session'; palletEvent: PalletSessionEvent }
  | { pallet: 'XcmpQueue'; palletEvent: CumulusPalletXcmpQueueEvent }
  | { pallet: 'PolkadotXcm'; palletEvent: PalletXcmEvent }
  | { pallet: 'CumulusXcm'; palletEvent: CumulusPalletXcmEvent }
  | { pallet: 'MessageQueue'; palletEvent: PalletMessageQueueEvent }
  | { pallet: 'Utility'; palletEvent: PalletUtilityEvent }
  | { pallet: 'Multisig'; palletEvent: PalletMultisigEvent }
  | { pallet: 'Proxy'; palletEvent: PalletProxyEvent }
  | { pallet: 'Assets'; palletEvent: PalletAssetsEvent }
  | { pallet: 'Uniques'; palletEvent: PalletUniquesEvent }
  | { pallet: 'Nfts'; palletEvent: PalletNftsEvent }
  | { pallet: 'ForeignAssets'; palletEvent: PalletAssetsEvent002 }
  | { pallet: 'NftFractionalization'; palletEvent: PalletNftFractionalizationEvent }
  | { pallet: 'PoolAssets'; palletEvent: PalletAssetsEvent }
  | { pallet: 'AssetConversion'; palletEvent: PalletAssetConversionEvent };

/**
 * Event for the System pallet.
 **/
export type FrameSystemEvent =
  /**
   * An extrinsic completed successfully.
   **/
  | { name: 'ExtrinsicSuccess'; data: { dispatchInfo: DispatchInfo } }
  /**
   * An extrinsic failed.
   **/
  | { name: 'ExtrinsicFailed'; data: { dispatchError: DispatchError; dispatchInfo: DispatchInfo } }
  /**
   * `:code` was updated.
   **/
  | { name: 'CodeUpdated' }
  /**
   * A new account was created.
   **/
  | { name: 'NewAccount'; data: { account: AccountId32 } }
  /**
   * An account was reaped.
   **/
  | { name: 'KilledAccount'; data: { account: AccountId32 } }
  /**
   * On on-chain remark happened.
   **/
  | { name: 'Remarked'; data: { sender: AccountId32; hash: H256 } }
  /**
   * An upgrade was authorized.
   **/
  | { name: 'UpgradeAuthorized'; data: { codeHash: H256; checkVersion: boolean } };

export type FrameSupportDispatchDispatchClass = 'Normal' | 'Operational' | 'Mandatory';

export type FrameSupportDispatchPays = 'Yes' | 'No';

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletParachainSystemEvent =
  /**
   * The validation function has been scheduled to apply.
   **/
  | { name: 'ValidationFunctionStored' }
  /**
   * The validation function was applied as of the contained relay chain block number.
   **/
  | { name: 'ValidationFunctionApplied'; data: { relayChainBlockNum: number } }
  /**
   * The relay-chain aborted the upgrade process.
   **/
  | { name: 'ValidationFunctionDiscarded' }
  /**
   * Some downward messages have been received and will be processed.
   **/
  | { name: 'DownwardMessagesReceived'; data: { count: number } }
  /**
   * Downward messages were processed using the given weight.
   **/
  | { name: 'DownwardMessagesProcessed'; data: { weightUsed: SpWeightsWeightV2Weight; dmqHead: H256 } }
  /**
   * An upward message was sent to the relay chain.
   **/
  | { name: 'UpwardMessageSent'; data: { messageHash?: FixedBytes<32> | undefined } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBalancesEvent =
  /**
   * An account was created with some free balance.
   **/
  | { name: 'Endowed'; data: { account: AccountId32; freeBalance: bigint } }
  /**
   * An account was removed whose balance was non-zero but below ExistentialDeposit,
   * resulting in an outright loss.
   **/
  | { name: 'DustLost'; data: { account: AccountId32; amount: bigint } }
  /**
   * Transfer succeeded.
   **/
  | { name: 'Transfer'; data: { from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * A balance was set by root.
   **/
  | { name: 'BalanceSet'; data: { who: AccountId32; free: bigint } }
  /**
   * Some balance was reserved (moved from free to reserved).
   **/
  | { name: 'Reserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unreserved (moved from reserved to free).
   **/
  | { name: 'Unreserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was moved from the reserve of the first account to the second account.
   * Final argument indicates the destination balance type.
   **/
  | {
      name: 'ReserveRepatriated';
      data: {
        from: AccountId32;
        to: AccountId32;
        amount: bigint;
        destinationStatus: FrameSupportTokensMiscBalanceStatus;
      };
    }
  /**
   * Some amount was deposited (e.g. for transaction fees).
   **/
  | { name: 'Deposit'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was withdrawn from the account (e.g. for transaction fees).
   **/
  | { name: 'Withdraw'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was removed from the account (e.g. for misbehavior).
   **/
  | { name: 'Slashed'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was minted into an account.
   **/
  | { name: 'Minted'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was burned from an account.
   **/
  | { name: 'Burned'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was suspended from an account (it can be restored later).
   **/
  | { name: 'Suspended'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was restored into an account.
   **/
  | { name: 'Restored'; data: { who: AccountId32; amount: bigint } }
  /**
   * An account was upgraded.
   **/
  | { name: 'Upgraded'; data: { who: AccountId32 } }
  /**
   * Total issuance was increased by `amount`, creating a credit to be balanced.
   **/
  | { name: 'Issued'; data: { amount: bigint } }
  /**
   * Total issuance was decreased by `amount`, creating a debt to be balanced.
   **/
  | { name: 'Rescinded'; data: { amount: bigint } }
  /**
   * Some balance was locked.
   **/
  | { name: 'Locked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unlocked.
   **/
  | { name: 'Unlocked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was frozen.
   **/
  | { name: 'Frozen'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was thawed.
   **/
  | { name: 'Thawed'; data: { who: AccountId32; amount: bigint } }
  /**
   * The `TotalIssuance` was forcefully changed.
   **/
  | { name: 'TotalIssuanceForced'; data: { old: bigint; new: bigint } };

export type FrameSupportTokensMiscBalanceStatus = 'Free' | 'Reserved';

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who`.
   **/
  { name: 'TransactionFeePaid'; data: { who: AccountId32; actualFee: bigint; tip: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetConversionTxPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who` in an asset `asset_id`.
   **/
  | {
      name: 'AssetTxFeePaid';
      data: { who: AccountId32; actualFee: bigint; tip: bigint; assetId: StagingXcmV3MultilocationMultiLocation };
    }
  /**
   * A swap of the refund in native currency back to asset failed.
   **/
  | { name: 'AssetRefundFailed'; data: { nativeAmountKept: bigint } };

export type StagingXcmV3MultilocationMultiLocation = { parents: number; interior: XcmV3Junctions };

export type XcmV3Junctions =
  | { tag: 'Here' }
  | { tag: 'X1'; value: XcmV3Junction }
  | { tag: 'X2'; value: [XcmV3Junction, XcmV3Junction] }
  | { tag: 'X3'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { tag: 'X4'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { tag: 'X5'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { tag: 'X6'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | {
      tag: 'X7';
      value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction];
    }
  | {
      tag: 'X8';
      value: [
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
      ];
    };

export type XcmV3Junction =
  | { tag: 'Parachain'; value: number }
  | { tag: 'AccountId32'; value: { network?: XcmV3JunctionNetworkId | undefined; id: FixedBytes<32> } }
  | { tag: 'AccountIndex64'; value: { network?: XcmV3JunctionNetworkId | undefined; index: bigint } }
  | { tag: 'AccountKey20'; value: { network?: XcmV3JunctionNetworkId | undefined; key: FixedBytes<20> } }
  | { tag: 'PalletInstance'; value: number }
  | { tag: 'GeneralIndex'; value: bigint }
  | { tag: 'GeneralKey'; value: { length: number; data: FixedBytes<32> } }
  | { tag: 'OnlyChild' }
  | { tag: 'Plurality'; value: { id: XcmV3JunctionBodyId; part: XcmV3JunctionBodyPart } }
  | { tag: 'GlobalConsensus'; value: XcmV3JunctionNetworkId };

export type XcmV3JunctionNetworkId =
  | { tag: 'ByGenesis'; value: FixedBytes<32> }
  | { tag: 'ByFork'; value: { blockNumber: bigint; blockHash: FixedBytes<32> } }
  | { tag: 'Polkadot' }
  | { tag: 'Kusama' }
  | { tag: 'Westend' }
  | { tag: 'Rococo' }
  | { tag: 'Wococo' }
  | { tag: 'Ethereum'; value: { chainId: bigint } }
  | { tag: 'BitcoinCore' }
  | { tag: 'BitcoinCash' }
  | { tag: 'PolkadotBulletin' };

export type XcmV3JunctionBodyId =
  | { tag: 'Unit' }
  | { tag: 'Moniker'; value: FixedBytes<4> }
  | { tag: 'Index'; value: number }
  | { tag: 'Executive' }
  | { tag: 'Technical' }
  | { tag: 'Legislative' }
  | { tag: 'Judicial' }
  | { tag: 'Defense' }
  | { tag: 'Administration' }
  | { tag: 'Treasury' };

export type XcmV3JunctionBodyPart =
  | { tag: 'Voice' }
  | { tag: 'Members'; value: { count: number } }
  | { tag: 'Fraction'; value: { nom: number; denom: number } }
  | { tag: 'AtLeastProportion'; value: { nom: number; denom: number } }
  | { tag: 'MoreThanProportion'; value: { nom: number; denom: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletCollatorSelectionEvent =
  /**
   * New Invulnerables were set.
   **/
  | { name: 'NewInvulnerables'; data: { invulnerables: Array<AccountId32> } }
  /**
   * A new Invulnerable was added.
   **/
  | { name: 'InvulnerableAdded'; data: { accountId: AccountId32 } }
  /**
   * An Invulnerable was removed.
   **/
  | { name: 'InvulnerableRemoved'; data: { accountId: AccountId32 } }
  /**
   * The number of desired candidates was set.
   **/
  | { name: 'NewDesiredCandidates'; data: { desiredCandidates: number } }
  /**
   * The candidacy bond was set.
   **/
  | { name: 'NewCandidacyBond'; data: { bondAmount: bigint } }
  /**
   * A new candidate joined.
   **/
  | { name: 'CandidateAdded'; data: { accountId: AccountId32; deposit: bigint } }
  /**
   * Bond of a candidate updated.
   **/
  | { name: 'CandidateBondUpdated'; data: { accountId: AccountId32; deposit: bigint } }
  /**
   * A candidate was removed.
   **/
  | { name: 'CandidateRemoved'; data: { accountId: AccountId32 } }
  /**
   * An account was replaced in the candidate list by another one.
   **/
  | { name: 'CandidateReplaced'; data: { old: AccountId32; new: AccountId32; deposit: bigint } }
  /**
   * An account was unable to be added to the Invulnerables because they did not have keys
   * registered. Other Invulnerables may have been set.
   **/
  | { name: 'InvalidInvulnerableSkipped'; data: { accountId: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSessionEvent =
  /**
   * New session has happened. Note that the argument is the session index, not the
   * block number as the type might suggest.
   **/
  { name: 'NewSession'; data: { sessionIndex: number } };

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletXcmpQueueEvent =
  /**
   * An HRMP message was sent to a sibling parachain.
   **/
  { name: 'XcmpMessageSent'; data: { messageHash: FixedBytes<32> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletXcmEvent =
  /**
   * Execution of an XCM message was attempted.
   **/
  | { name: 'Attempted'; data: { outcome: StagingXcmV4TraitsOutcome } }
  /**
   * A XCM message was sent.
   **/
  | {
      name: 'Sent';
      data: {
        origin: StagingXcmV4Location;
        destination: StagingXcmV4Location;
        message: StagingXcmV4Xcm;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * Query response received which does not match a registered query. This may be because a
   * matching query was never registered, it may be because it is a duplicate response, or
   * because the query timed out.
   **/
  | { name: 'UnexpectedResponse'; data: { origin: StagingXcmV4Location; queryId: bigint } }
  /**
   * Query response has been received and is ready for taking with `take_response`. There is
   * no registered notification call.
   **/
  | { name: 'ResponseReady'; data: { queryId: bigint; response: StagingXcmV4Response } }
  /**
   * Query response has been received and query is removed. The registered notification has
   * been dispatched and executed successfully.
   **/
  | { name: 'Notified'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Query response has been received and query is removed. The registered notification
   * could not be dispatched because the dispatch weight is greater than the maximum weight
   * originally budgeted by this runtime for the query result.
   **/
  | {
      name: 'NotifyOverweight';
      data: {
        queryId: bigint;
        palletIndex: number;
        callIndex: number;
        actualWeight: SpWeightsWeightV2Weight;
        maxBudgetedWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Query response has been received and query is removed. There was a general error with
   * dispatching the notification call.
   **/
  | { name: 'NotifyDispatchError'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Query response has been received and query is removed. The dispatch was unable to be
   * decoded into a `Call`; this might be due to dispatch function having a signature which
   * is not `(origin, QueryId, Response)`.
   **/
  | { name: 'NotifyDecodeFailed'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Expected query response has been received but the origin location of the response does
   * not match that expected. The query remains registered for a later, valid, response to
   * be received and acted upon.
   **/
  | {
      name: 'InvalidResponder';
      data: { origin: StagingXcmV4Location; queryId: bigint; expectedLocation?: StagingXcmV4Location | undefined };
    }
  /**
   * Expected query response has been received but the expected origin location placed in
   * storage by this runtime previously cannot be decoded. The query remains registered.
   *
   * This is unexpected (since a location placed in storage in a previously executing
   * runtime should be readable prior to query timeout) and dangerous since the possibly
   * valid response will be dropped. Manual governance intervention is probably going to be
   * needed.
   **/
  | { name: 'InvalidResponderVersion'; data: { origin: StagingXcmV4Location; queryId: bigint } }
  /**
   * Received query response has been read and removed.
   **/
  | { name: 'ResponseTaken'; data: { queryId: bigint } }
  /**
   * Some assets have been placed in an asset trap.
   **/
  | { name: 'AssetsTrapped'; data: { hash: H256; origin: StagingXcmV4Location; assets: XcmVersionedAssets } }
  /**
   * An XCM version change notification message has been attempted to be sent.
   *
   * The cost of sending it (borne by the chain) is included.
   **/
  | {
      name: 'VersionChangeNotified';
      data: {
        destination: StagingXcmV4Location;
        result: number;
        cost: StagingXcmV4AssetAssets;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * The supported version of a location has been changed. This might be through an
   * automatic notification or a manual intervention.
   **/
  | { name: 'SupportedVersionChanged'; data: { location: StagingXcmV4Location; version: number } }
  /**
   * A given location which had a version change subscription was dropped owing to an error
   * sending the notification to it.
   **/
  | { name: 'NotifyTargetSendFail'; data: { location: StagingXcmV4Location; queryId: bigint; error: XcmV3TraitsError } }
  /**
   * A given location which had a version change subscription was dropped owing to an error
   * migrating the location to our new XCM format.
   **/
  | { name: 'NotifyTargetMigrationFail'; data: { location: XcmVersionedLocation; queryId: bigint } }
  /**
   * Expected query response has been received but the expected querier location placed in
   * storage by this runtime previously cannot be decoded. The query remains registered.
   *
   * This is unexpected (since a location placed in storage in a previously executing
   * runtime should be readable prior to query timeout) and dangerous since the possibly
   * valid response will be dropped. Manual governance intervention is probably going to be
   * needed.
   **/
  | { name: 'InvalidQuerierVersion'; data: { origin: StagingXcmV4Location; queryId: bigint } }
  /**
   * Expected query response has been received but the querier location of the response does
   * not match the expected. The query remains registered for a later, valid, response to
   * be received and acted upon.
   **/
  | {
      name: 'InvalidQuerier';
      data: {
        origin: StagingXcmV4Location;
        queryId: bigint;
        expectedQuerier: StagingXcmV4Location;
        maybeActualQuerier?: StagingXcmV4Location | undefined;
      };
    }
  /**
   * A remote has requested XCM version change notification from us and we have honored it.
   * A version information message is sent to them and its cost is included.
   **/
  | {
      name: 'VersionNotifyStarted';
      data: { destination: StagingXcmV4Location; cost: StagingXcmV4AssetAssets; messageId: FixedBytes<32> };
    }
  /**
   * We have requested that a remote chain send us XCM version change notifications.
   **/
  | {
      name: 'VersionNotifyRequested';
      data: { destination: StagingXcmV4Location; cost: StagingXcmV4AssetAssets; messageId: FixedBytes<32> };
    }
  /**
   * We have requested that a remote chain stops sending us XCM version change
   * notifications.
   **/
  | {
      name: 'VersionNotifyUnrequested';
      data: { destination: StagingXcmV4Location; cost: StagingXcmV4AssetAssets; messageId: FixedBytes<32> };
    }
  /**
   * Fees were paid from a location for an operation (often for using `SendXcm`).
   **/
  | { name: 'FeesPaid'; data: { paying: StagingXcmV4Location; fees: StagingXcmV4AssetAssets } }
  /**
   * Some assets have been claimed from an asset trap
   **/
  | { name: 'AssetsClaimed'; data: { hash: H256; origin: StagingXcmV4Location; assets: XcmVersionedAssets } }
  /**
   * A XCM version migration finished.
   **/
  | { name: 'VersionMigrationFinished'; data: { version: number } };

export type StagingXcmV4TraitsOutcome =
  | { tag: 'Complete'; value: { used: SpWeightsWeightV2Weight } }
  | { tag: 'Incomplete'; value: { used: SpWeightsWeightV2Weight; error: XcmV3TraitsError } }
  | { tag: 'Error'; value: { error: XcmV3TraitsError } };

export type XcmV3TraitsError =
  | { tag: 'Overflow' }
  | { tag: 'Unimplemented' }
  | { tag: 'UntrustedReserveLocation' }
  | { tag: 'UntrustedTeleportLocation' }
  | { tag: 'LocationFull' }
  | { tag: 'LocationNotInvertible' }
  | { tag: 'BadOrigin' }
  | { tag: 'InvalidLocation' }
  | { tag: 'AssetNotFound' }
  | { tag: 'FailedToTransactAsset' }
  | { tag: 'NotWithdrawable' }
  | { tag: 'LocationCannotHold' }
  | { tag: 'ExceedsMaxMessageSize' }
  | { tag: 'DestinationUnsupported' }
  | { tag: 'Transport' }
  | { tag: 'Unroutable' }
  | { tag: 'UnknownClaim' }
  | { tag: 'FailedToDecode' }
  | { tag: 'MaxWeightInvalid' }
  | { tag: 'NotHoldingFees' }
  | { tag: 'TooExpensive' }
  | { tag: 'Trap'; value: bigint }
  | { tag: 'ExpectationFalse' }
  | { tag: 'PalletNotFound' }
  | { tag: 'NameMismatch' }
  | { tag: 'VersionIncompatible' }
  | { tag: 'HoldingWouldOverflow' }
  | { tag: 'ExportError' }
  | { tag: 'ReanchorFailed' }
  | { tag: 'NoDeal' }
  | { tag: 'FeesNotMet' }
  | { tag: 'LockError' }
  | { tag: 'NoPermission' }
  | { tag: 'Unanchored' }
  | { tag: 'NotDepositable' }
  | { tag: 'UnhandledXcmVersion' }
  | { tag: 'WeightLimitReached'; value: SpWeightsWeightV2Weight }
  | { tag: 'Barrier' }
  | { tag: 'WeightNotComputable' }
  | { tag: 'ExceedsStackLimit' };

export type StagingXcmV4Location = { parents: number; interior: StagingXcmV4Junctions };

export type StagingXcmV4Junctions =
  | { tag: 'Here' }
  | { tag: 'X1'; value: FixedArray<StagingXcmV4Junction, 1> }
  | { tag: 'X2'; value: FixedArray<StagingXcmV4Junction, 2> }
  | { tag: 'X3'; value: FixedArray<StagingXcmV4Junction, 3> }
  | { tag: 'X4'; value: FixedArray<StagingXcmV4Junction, 4> }
  | { tag: 'X5'; value: FixedArray<StagingXcmV4Junction, 5> }
  | { tag: 'X6'; value: FixedArray<StagingXcmV4Junction, 6> }
  | { tag: 'X7'; value: FixedArray<StagingXcmV4Junction, 7> }
  | { tag: 'X8'; value: FixedArray<StagingXcmV4Junction, 8> };

export type StagingXcmV4Junction =
  | { tag: 'Parachain'; value: number }
  | { tag: 'AccountId32'; value: { network?: StagingXcmV4JunctionNetworkId | undefined; id: FixedBytes<32> } }
  | { tag: 'AccountIndex64'; value: { network?: StagingXcmV4JunctionNetworkId | undefined; index: bigint } }
  | { tag: 'AccountKey20'; value: { network?: StagingXcmV4JunctionNetworkId | undefined; key: FixedBytes<20> } }
  | { tag: 'PalletInstance'; value: number }
  | { tag: 'GeneralIndex'; value: bigint }
  | { tag: 'GeneralKey'; value: { length: number; data: FixedBytes<32> } }
  | { tag: 'OnlyChild' }
  | { tag: 'Plurality'; value: { id: XcmV3JunctionBodyId; part: XcmV3JunctionBodyPart } }
  | { tag: 'GlobalConsensus'; value: StagingXcmV4JunctionNetworkId };

export type StagingXcmV4JunctionNetworkId =
  | { tag: 'ByGenesis'; value: FixedBytes<32> }
  | { tag: 'ByFork'; value: { blockNumber: bigint; blockHash: FixedBytes<32> } }
  | { tag: 'Polkadot' }
  | { tag: 'Kusama' }
  | { tag: 'Westend' }
  | { tag: 'Rococo' }
  | { tag: 'Wococo' }
  | { tag: 'Ethereum'; value: { chainId: bigint } }
  | { tag: 'BitcoinCore' }
  | { tag: 'BitcoinCash' }
  | { tag: 'PolkadotBulletin' };

export type StagingXcmV4Xcm = Array<StagingXcmV4Instruction>;

export type StagingXcmV4Instruction =
  | { tag: 'WithdrawAsset'; value: StagingXcmV4AssetAssets }
  | { tag: 'ReserveAssetDeposited'; value: StagingXcmV4AssetAssets }
  | { tag: 'ReceiveTeleportedAsset'; value: StagingXcmV4AssetAssets }
  | {
      tag: 'QueryResponse';
      value: {
        queryId: bigint;
        response: StagingXcmV4Response;
        maxWeight: SpWeightsWeightV2Weight;
        querier?: StagingXcmV4Location | undefined;
      };
    }
  | { tag: 'TransferAsset'; value: { assets: StagingXcmV4AssetAssets; beneficiary: StagingXcmV4Location } }
  | {
      tag: 'TransferReserveAsset';
      value: { assets: StagingXcmV4AssetAssets; dest: StagingXcmV4Location; xcm: StagingXcmV4Xcm };
    }
  | {
      tag: 'Transact';
      value: { originKind: XcmV2OriginKind; requireWeightAtMost: SpWeightsWeightV2Weight; call: XcmDoubleEncoded };
    }
  | { tag: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { tag: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { tag: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { tag: 'ClearOrigin' }
  | { tag: 'DescendOrigin'; value: StagingXcmV4Junctions }
  | { tag: 'ReportError'; value: StagingXcmV4QueryResponseInfo }
  | { tag: 'DepositAsset'; value: { assets: StagingXcmV4AssetAssetFilter; beneficiary: StagingXcmV4Location } }
  | {
      tag: 'DepositReserveAsset';
      value: { assets: StagingXcmV4AssetAssetFilter; dest: StagingXcmV4Location; xcm: StagingXcmV4Xcm };
    }
  | {
      tag: 'ExchangeAsset';
      value: { give: StagingXcmV4AssetAssetFilter; want: StagingXcmV4AssetAssets; maximal: boolean };
    }
  | {
      tag: 'InitiateReserveWithdraw';
      value: { assets: StagingXcmV4AssetAssetFilter; reserve: StagingXcmV4Location; xcm: StagingXcmV4Xcm };
    }
  | {
      tag: 'InitiateTeleport';
      value: { assets: StagingXcmV4AssetAssetFilter; dest: StagingXcmV4Location; xcm: StagingXcmV4Xcm };
    }
  | {
      tag: 'ReportHolding';
      value: { responseInfo: StagingXcmV4QueryResponseInfo; assets: StagingXcmV4AssetAssetFilter };
    }
  | { tag: 'BuyExecution'; value: { fees: StagingXcmV4Asset; weightLimit: XcmV3WeightLimit } }
  | { tag: 'RefundSurplus' }
  | { tag: 'SetErrorHandler'; value: StagingXcmV4Xcm }
  | { tag: 'SetAppendix'; value: StagingXcmV4Xcm }
  | { tag: 'ClearError' }
  | { tag: 'ClaimAsset'; value: { assets: StagingXcmV4AssetAssets; ticket: StagingXcmV4Location } }
  | { tag: 'Trap'; value: bigint }
  | { tag: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: SpWeightsWeightV2Weight } }
  | { tag: 'UnsubscribeVersion' }
  | { tag: 'BurnAsset'; value: StagingXcmV4AssetAssets }
  | { tag: 'ExpectAsset'; value: StagingXcmV4AssetAssets }
  | { tag: 'ExpectOrigin'; value?: StagingXcmV4Location | undefined }
  | { tag: 'ExpectError'; value?: [number, XcmV3TraitsError] | undefined }
  | { tag: 'ExpectTransactStatus'; value: XcmV3MaybeErrorCode }
  | { tag: 'QueryPallet'; value: { moduleName: Bytes; responseInfo: StagingXcmV4QueryResponseInfo } }
  | {
      tag: 'ExpectPallet';
      value: { index: number; name: Bytes; moduleName: Bytes; crateMajor: number; minCrateMinor: number };
    }
  | { tag: 'ReportTransactStatus'; value: StagingXcmV4QueryResponseInfo }
  | { tag: 'ClearTransactStatus' }
  | { tag: 'UniversalOrigin'; value: StagingXcmV4Junction }
  | {
      tag: 'ExportMessage';
      value: { network: StagingXcmV4JunctionNetworkId; destination: StagingXcmV4Junctions; xcm: StagingXcmV4Xcm };
    }
  | { tag: 'LockAsset'; value: { asset: StagingXcmV4Asset; unlocker: StagingXcmV4Location } }
  | { tag: 'UnlockAsset'; value: { asset: StagingXcmV4Asset; target: StagingXcmV4Location } }
  | { tag: 'NoteUnlockable'; value: { asset: StagingXcmV4Asset; owner: StagingXcmV4Location } }
  | { tag: 'RequestUnlock'; value: { asset: StagingXcmV4Asset; locker: StagingXcmV4Location } }
  | { tag: 'SetFeesMode'; value: { jitWithdraw: boolean } }
  | { tag: 'SetTopic'; value: FixedBytes<32> }
  | { tag: 'ClearTopic' }
  | { tag: 'AliasOrigin'; value: StagingXcmV4Location }
  | {
      tag: 'UnpaidExecution';
      value: { weightLimit: XcmV3WeightLimit; checkOrigin?: StagingXcmV4Location | undefined };
    };

export type StagingXcmV4AssetAssets = Array<StagingXcmV4Asset>;

export type StagingXcmV4Asset = { id: StagingXcmV4AssetAssetId; fun: StagingXcmV4AssetFungibility };

export type StagingXcmV4AssetAssetId = StagingXcmV4Location;

export type StagingXcmV4AssetFungibility =
  | { tag: 'Fungible'; value: bigint }
  | { tag: 'NonFungible'; value: StagingXcmV4AssetAssetInstance };

export type StagingXcmV4AssetAssetInstance =
  | { tag: 'Undefined' }
  | { tag: 'Index'; value: bigint }
  | { tag: 'Array4'; value: FixedBytes<4> }
  | { tag: 'Array8'; value: FixedBytes<8> }
  | { tag: 'Array16'; value: FixedBytes<16> }
  | { tag: 'Array32'; value: FixedBytes<32> };

export type StagingXcmV4Response =
  | { tag: 'Null' }
  | { tag: 'Assets'; value: StagingXcmV4AssetAssets }
  | { tag: 'ExecutionResult'; value?: [number, XcmV3TraitsError] | undefined }
  | { tag: 'Version'; value: number }
  | { tag: 'PalletsInfo'; value: Array<StagingXcmV4PalletInfo> }
  | { tag: 'DispatchResult'; value: XcmV3MaybeErrorCode };

export type StagingXcmV4PalletInfo = {
  index: number;
  name: Bytes;
  moduleName: Bytes;
  major: number;
  minor: number;
  patch: number;
};

export type XcmV3MaybeErrorCode =
  | { tag: 'Success' }
  | { tag: 'Error'; value: Bytes }
  | { tag: 'TruncatedError'; value: Bytes };

export type XcmV2OriginKind = 'Native' | 'SovereignAccount' | 'Superuser' | 'Xcm';

export type XcmDoubleEncoded = { encoded: Bytes };

export type StagingXcmV4QueryResponseInfo = {
  destination: StagingXcmV4Location;
  queryId: bigint;
  maxWeight: SpWeightsWeightV2Weight;
};

export type StagingXcmV4AssetAssetFilter =
  | { tag: 'Definite'; value: StagingXcmV4AssetAssets }
  | { tag: 'Wild'; value: StagingXcmV4AssetWildAsset };

export type StagingXcmV4AssetWildAsset =
  | { tag: 'All' }
  | { tag: 'AllOf'; value: { id: StagingXcmV4AssetAssetId; fun: StagingXcmV4AssetWildFungibility } }
  | { tag: 'AllCounted'; value: number }
  | {
      tag: 'AllOfCounted';
      value: { id: StagingXcmV4AssetAssetId; fun: StagingXcmV4AssetWildFungibility; count: number };
    };

export type StagingXcmV4AssetWildFungibility = 'Fungible' | 'NonFungible';

export type XcmV3WeightLimit = { tag: 'Unlimited' } | { tag: 'Limited'; value: SpWeightsWeightV2Weight };

export type XcmVersionedAssets =
  | { tag: 'V2'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'V3'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'V4'; value: StagingXcmV4AssetAssets };

export type XcmV2MultiassetMultiAssets = Array<XcmV2MultiassetMultiAsset>;

export type XcmV2MultiassetMultiAsset = { id: XcmV2MultiassetAssetId; fun: XcmV2MultiassetFungibility };

export type XcmV2MultiassetAssetId =
  | { tag: 'Concrete'; value: XcmV2MultilocationMultiLocation }
  | { tag: 'Abstract'; value: Bytes };

export type XcmV2MultilocationMultiLocation = { parents: number; interior: XcmV2MultilocationJunctions };

export type XcmV2MultilocationJunctions =
  | { tag: 'Here' }
  | { tag: 'X1'; value: XcmV2Junction }
  | { tag: 'X2'; value: [XcmV2Junction, XcmV2Junction] }
  | { tag: 'X3'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { tag: 'X4'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { tag: 'X5'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { tag: 'X6'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | {
      tag: 'X7';
      value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction];
    }
  | {
      tag: 'X8';
      value: [
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
      ];
    };

export type XcmV2Junction =
  | { tag: 'Parachain'; value: number }
  | { tag: 'AccountId32'; value: { network: XcmV2NetworkId; id: FixedBytes<32> } }
  | { tag: 'AccountIndex64'; value: { network: XcmV2NetworkId; index: bigint } }
  | { tag: 'AccountKey20'; value: { network: XcmV2NetworkId; key: FixedBytes<20> } }
  | { tag: 'PalletInstance'; value: number }
  | { tag: 'GeneralIndex'; value: bigint }
  | { tag: 'GeneralKey'; value: Bytes }
  | { tag: 'OnlyChild' }
  | { tag: 'Plurality'; value: { id: XcmV2BodyId; part: XcmV2BodyPart } };

export type XcmV2NetworkId = { tag: 'Any' } | { tag: 'Named'; value: Bytes } | { tag: 'Polkadot' } | { tag: 'Kusama' };

export type XcmV2BodyId =
  | { tag: 'Unit' }
  | { tag: 'Named'; value: Bytes }
  | { tag: 'Index'; value: number }
  | { tag: 'Executive' }
  | { tag: 'Technical' }
  | { tag: 'Legislative' }
  | { tag: 'Judicial' }
  | { tag: 'Defense' }
  | { tag: 'Administration' }
  | { tag: 'Treasury' };

export type XcmV2BodyPart =
  | { tag: 'Voice' }
  | { tag: 'Members'; value: { count: number } }
  | { tag: 'Fraction'; value: { nom: number; denom: number } }
  | { tag: 'AtLeastProportion'; value: { nom: number; denom: number } }
  | { tag: 'MoreThanProportion'; value: { nom: number; denom: number } };

export type XcmV2MultiassetFungibility =
  | { tag: 'Fungible'; value: bigint }
  | { tag: 'NonFungible'; value: XcmV2MultiassetAssetInstance };

export type XcmV2MultiassetAssetInstance =
  | { tag: 'Undefined' }
  | { tag: 'Index'; value: bigint }
  | { tag: 'Array4'; value: FixedBytes<4> }
  | { tag: 'Array8'; value: FixedBytes<8> }
  | { tag: 'Array16'; value: FixedBytes<16> }
  | { tag: 'Array32'; value: FixedBytes<32> }
  | { tag: 'Blob'; value: Bytes };

export type XcmV3MultiassetMultiAssets = Array<XcmV3MultiassetMultiAsset>;

export type XcmV3MultiassetMultiAsset = { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetFungibility };

export type XcmV3MultiassetAssetId =
  | { tag: 'Concrete'; value: StagingXcmV3MultilocationMultiLocation }
  | { tag: 'Abstract'; value: FixedBytes<32> };

export type XcmV3MultiassetFungibility =
  | { tag: 'Fungible'; value: bigint }
  | { tag: 'NonFungible'; value: XcmV3MultiassetAssetInstance };

export type XcmV3MultiassetAssetInstance =
  | { tag: 'Undefined' }
  | { tag: 'Index'; value: bigint }
  | { tag: 'Array4'; value: FixedBytes<4> }
  | { tag: 'Array8'; value: FixedBytes<8> }
  | { tag: 'Array16'; value: FixedBytes<16> }
  | { tag: 'Array32'; value: FixedBytes<32> };

export type XcmVersionedLocation =
  | { tag: 'V2'; value: XcmV2MultilocationMultiLocation }
  | { tag: 'V3'; value: StagingXcmV3MultilocationMultiLocation }
  | { tag: 'V4'; value: StagingXcmV4Location };

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletXcmEvent =
  /**
   * Downward message is invalid XCM.
   * \[ id \]
   **/
  | { name: 'InvalidFormat'; data: FixedBytes<32> }
  /**
   * Downward message is unsupported version of XCM.
   * \[ id \]
   **/
  | { name: 'UnsupportedVersion'; data: FixedBytes<32> }
  /**
   * Downward message executed with the given outcome.
   * \[ id, outcome \]
   **/
  | { name: 'ExecutedDownward'; data: [FixedBytes<32>, StagingXcmV4TraitsOutcome] };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMessageQueueEvent =
  /**
   * Message discarded due to an error in the `MessageProcessor` (usually a format error).
   **/
  | {
      name: 'ProcessingFailed';
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: H256;

        /**
         * The queue of the message.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * The error that occurred.
         *
         * This error is pretty opaque. More fine-grained errors need to be emitted as events
         * by the `MessageProcessor`.
         **/
        error: FrameSupportMessagesProcessMessageError;
      };
    }
  /**
   * Message is processed.
   **/
  | {
      name: 'Processed';
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: H256;

        /**
         * The queue of the message.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * How much weight was used to process the message.
         **/
        weightUsed: SpWeightsWeightV2Weight;

        /**
         * Whether the message was processed.
         *
         * Note that this does not mean that the underlying `MessageProcessor` was internally
         * successful. It *solely* means that the MQ pallet will treat this as a success
         * condition and discard the message. Any internal error needs to be emitted as events
         * by the `MessageProcessor`.
         **/
        success: boolean;
      };
    }
  /**
   * Message placed in overweight queue.
   **/
  | {
      name: 'OverweightEnqueued';
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: FixedBytes<32>;

        /**
         * The queue of the message.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * The page of the message.
         **/
        pageIndex: number;

        /**
         * The index of the message within the page.
         **/
        messageIndex: number;
      };
    }
  /**
   * This page was reaped.
   **/
  | {
      name: 'PageReaped';
      data: {
        /**
         * The queue of the page.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * The index of the page.
         **/
        index: number;
      };
    };

export type CumulusPrimitivesCoreAggregateMessageOrigin =
  | { tag: 'Here' }
  | { tag: 'Parent' }
  | { tag: 'Sibling'; value: PolkadotParachainPrimitivesPrimitivesId };

export type PolkadotParachainPrimitivesPrimitivesId = number;

export type FrameSupportMessagesProcessMessageError =
  | { tag: 'BadFormat' }
  | { tag: 'Corrupt' }
  | { tag: 'Unsupported' }
  | { tag: 'Overweight'; value: SpWeightsWeightV2Weight }
  | { tag: 'Yield' };

/**
 * The `Event` enum of this pallet
 **/
export type PalletUtilityEvent =
  /**
   * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
   * well as the error.
   **/
  | { name: 'BatchInterrupted'; data: { index: number; error: DispatchError } }
  /**
   * Batch of dispatches completed fully with no error.
   **/
  | { name: 'BatchCompleted' }
  /**
   * Batch of dispatches completed but has errors.
   **/
  | { name: 'BatchCompletedWithErrors' }
  /**
   * A single item within a Batch of dispatches has completed with no error.
   **/
  | { name: 'ItemCompleted' }
  /**
   * A single item within a Batch of dispatches has completed with error.
   **/
  | { name: 'ItemFailed'; data: { error: DispatchError } }
  /**
   * A call was dispatched.
   **/
  | { name: 'DispatchedAs'; data: { result: Result<[], DispatchError> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMultisigEvent =
  /**
   * A new multisig operation has begun.
   **/
  | { name: 'NewMultisig'; data: { approving: AccountId32; multisig: AccountId32; callHash: FixedBytes<32> } }
  /**
   * A multisig operation has been approved by someone.
   **/
  | {
      name: 'MultisigApproval';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been executed.
   **/
  | {
      name: 'MultisigExecuted';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
        result: Result<[], DispatchError>;
      };
    }
  /**
   * A multisig operation has been cancelled.
   **/
  | {
      name: 'MultisigCancelled';
      data: {
        cancelling: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigTimepoint = { height: number; index: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletProxyEvent =
  /**
   * A proxy was executed correctly, with the given.
   **/
  | { name: 'ProxyExecuted'; data: { result: Result<[], DispatchError> } }
  /**
   * A pure account has been created by new proxy with given
   * disambiguation index and proxy type.
   **/
  | {
      name: 'PureCreated';
      data: {
        pure: AccountId32;
        who: AccountId32;
        proxyType: AssetHubWestendRuntimeProxyType;
        disambiguationIndex: number;
      };
    }
  /**
   * An announcement was placed to make a call in the future.
   **/
  | { name: 'Announced'; data: { real: AccountId32; proxy: AccountId32; callHash: H256 } }
  /**
   * A proxy was added.
   **/
  | {
      name: 'ProxyAdded';
      data: {
        delegator: AccountId32;
        delegatee: AccountId32;
        proxyType: AssetHubWestendRuntimeProxyType;
        delay: number;
      };
    }
  /**
   * A proxy was removed.
   **/
  | {
      name: 'ProxyRemoved';
      data: {
        delegator: AccountId32;
        delegatee: AccountId32;
        proxyType: AssetHubWestendRuntimeProxyType;
        delay: number;
      };
    };

export type AssetHubWestendRuntimeProxyType =
  | 'Any'
  | 'NonTransfer'
  | 'CancelProxy'
  | 'Assets'
  | 'AssetOwner'
  | 'AssetManager'
  | 'Collator';

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetsEvent =
  /**
   * Some asset class was created.
   **/
  | { name: 'Created'; data: { assetId: number; creator: AccountId32; owner: AccountId32 } }
  /**
   * Some assets were issued.
   **/
  | { name: 'Issued'; data: { assetId: number; owner: AccountId32; amount: bigint } }
  /**
   * Some assets were transferred.
   **/
  | { name: 'Transferred'; data: { assetId: number; from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * Some assets were destroyed.
   **/
  | { name: 'Burned'; data: { assetId: number; owner: AccountId32; balance: bigint } }
  /**
   * The management team changed.
   **/
  | { name: 'TeamChanged'; data: { assetId: number; issuer: AccountId32; admin: AccountId32; freezer: AccountId32 } }
  /**
   * The owner changed.
   **/
  | { name: 'OwnerChanged'; data: { assetId: number; owner: AccountId32 } }
  /**
   * Some account `who` was frozen.
   **/
  | { name: 'Frozen'; data: { assetId: number; who: AccountId32 } }
  /**
   * Some account `who` was thawed.
   **/
  | { name: 'Thawed'; data: { assetId: number; who: AccountId32 } }
  /**
   * Some asset `asset_id` was frozen.
   **/
  | { name: 'AssetFrozen'; data: { assetId: number } }
  /**
   * Some asset `asset_id` was thawed.
   **/
  | { name: 'AssetThawed'; data: { assetId: number } }
  /**
   * Accounts were destroyed for given asset.
   **/
  | { name: 'AccountsDestroyed'; data: { assetId: number; accountsDestroyed: number; accountsRemaining: number } }
  /**
   * Approvals were destroyed for given asset.
   **/
  | { name: 'ApprovalsDestroyed'; data: { assetId: number; approvalsDestroyed: number; approvalsRemaining: number } }
  /**
   * An asset class is in the process of being destroyed.
   **/
  | { name: 'DestructionStarted'; data: { assetId: number } }
  /**
   * An asset class was destroyed.
   **/
  | { name: 'Destroyed'; data: { assetId: number } }
  /**
   * Some asset class was force-created.
   **/
  | { name: 'ForceCreated'; data: { assetId: number; owner: AccountId32 } }
  /**
   * New metadata has been set for an asset.
   **/
  | { name: 'MetadataSet'; data: { assetId: number; name: Bytes; symbol: Bytes; decimals: number; isFrozen: boolean } }
  /**
   * Metadata has been cleared for an asset.
   **/
  | { name: 'MetadataCleared'; data: { assetId: number } }
  /**
   * (Additional) funds have been approved for transfer to a destination account.
   **/
  | { name: 'ApprovedTransfer'; data: { assetId: number; source: AccountId32; delegate: AccountId32; amount: bigint } }
  /**
   * An approval for account `delegate` was cancelled by `owner`.
   **/
  | { name: 'ApprovalCancelled'; data: { assetId: number; owner: AccountId32; delegate: AccountId32 } }
  /**
   * An `amount` was transferred in its entirety from `owner` to `destination` by
   * the approved `delegate`.
   **/
  | {
      name: 'TransferredApproved';
      data: { assetId: number; owner: AccountId32; delegate: AccountId32; destination: AccountId32; amount: bigint };
    }
  /**
   * An asset has had its attributes changed by the `Force` origin.
   **/
  | { name: 'AssetStatusChanged'; data: { assetId: number } }
  /**
   * The min_balance of an asset has been updated by the asset owner.
   **/
  | { name: 'AssetMinBalanceChanged'; data: { assetId: number; newMinBalance: bigint } }
  /**
   * Some account `who` was created with a deposit from `depositor`.
   **/
  | { name: 'Touched'; data: { assetId: number; who: AccountId32; depositor: AccountId32 } }
  /**
   * Some account `who` was blocked.
   **/
  | { name: 'Blocked'; data: { assetId: number; who: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletUniquesEvent =
  /**
   * A `collection` was created.
   **/
  | { name: 'Created'; data: { collection: number; creator: AccountId32; owner: AccountId32 } }
  /**
   * A `collection` was force-created.
   **/
  | { name: 'ForceCreated'; data: { collection: number; owner: AccountId32 } }
  /**
   * A `collection` was destroyed.
   **/
  | { name: 'Destroyed'; data: { collection: number } }
  /**
   * An `item` was issued.
   **/
  | { name: 'Issued'; data: { collection: number; item: number; owner: AccountId32 } }
  /**
   * An `item` was transferred.
   **/
  | { name: 'Transferred'; data: { collection: number; item: number; from: AccountId32; to: AccountId32 } }
  /**
   * An `item` was destroyed.
   **/
  | { name: 'Burned'; data: { collection: number; item: number; owner: AccountId32 } }
  /**
   * Some `item` was frozen.
   **/
  | { name: 'Frozen'; data: { collection: number; item: number } }
  /**
   * Some `item` was thawed.
   **/
  | { name: 'Thawed'; data: { collection: number; item: number } }
  /**
   * Some `collection` was frozen.
   **/
  | { name: 'CollectionFrozen'; data: { collection: number } }
  /**
   * Some `collection` was thawed.
   **/
  | { name: 'CollectionThawed'; data: { collection: number } }
  /**
   * The owner changed.
   **/
  | { name: 'OwnerChanged'; data: { collection: number; newOwner: AccountId32 } }
  /**
   * The management team changed.
   **/
  | { name: 'TeamChanged'; data: { collection: number; issuer: AccountId32; admin: AccountId32; freezer: AccountId32 } }
  /**
   * An `item` of a `collection` has been approved by the `owner` for transfer by
   * a `delegate`.
   **/
  | { name: 'ApprovedTransfer'; data: { collection: number; item: number; owner: AccountId32; delegate: AccountId32 } }
  /**
   * An approval for a `delegate` account to transfer the `item` of an item
   * `collection` was cancelled by its `owner`.
   **/
  | { name: 'ApprovalCancelled'; data: { collection: number; item: number; owner: AccountId32; delegate: AccountId32 } }
  /**
   * A `collection` has had its attributes changed by the `Force` origin.
   **/
  | { name: 'ItemStatusChanged'; data: { collection: number } }
  /**
   * New metadata has been set for a `collection`.
   **/
  | { name: 'CollectionMetadataSet'; data: { collection: number; data: Bytes; isFrozen: boolean } }
  /**
   * Metadata has been cleared for a `collection`.
   **/
  | { name: 'CollectionMetadataCleared'; data: { collection: number } }
  /**
   * New metadata has been set for an item.
   **/
  | { name: 'MetadataSet'; data: { collection: number; item: number; data: Bytes; isFrozen: boolean } }
  /**
   * Metadata has been cleared for an item.
   **/
  | { name: 'MetadataCleared'; data: { collection: number; item: number } }
  /**
   * Metadata has been cleared for an item.
   **/
  | { name: 'Redeposited'; data: { collection: number; successfulItems: Array<number> } }
  /**
   * New attribute metadata has been set for a `collection` or `item`.
   **/
  | { name: 'AttributeSet'; data: { collection: number; maybeItem?: number | undefined; key: Bytes; value: Bytes } }
  /**
   * Attribute metadata has been cleared for a `collection` or `item`.
   **/
  | { name: 'AttributeCleared'; data: { collection: number; maybeItem?: number | undefined; key: Bytes } }
  /**
   * Ownership acceptance has changed for an account.
   **/
  | { name: 'OwnershipAcceptanceChanged'; data: { who: AccountId32; maybeCollection?: number | undefined } }
  /**
   * Max supply has been set for a collection.
   **/
  | { name: 'CollectionMaxSupplySet'; data: { collection: number; maxSupply: number } }
  /**
   * The price was set for the instance.
   **/
  | {
      name: 'ItemPriceSet';
      data: { collection: number; item: number; price: bigint; whitelistedBuyer?: AccountId32 | undefined };
    }
  /**
   * The price for the instance was removed.
   **/
  | { name: 'ItemPriceRemoved'; data: { collection: number; item: number } }
  /**
   * An item was bought.
   **/
  | {
      name: 'ItemBought';
      data: { collection: number; item: number; price: bigint; seller: AccountId32; buyer: AccountId32 };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletNftsEvent =
  /**
   * A `collection` was created.
   **/
  | { name: 'Created'; data: { collection: number; creator: AccountId32; owner: AccountId32 } }
  /**
   * A `collection` was force-created.
   **/
  | { name: 'ForceCreated'; data: { collection: number; owner: AccountId32 } }
  /**
   * A `collection` was destroyed.
   **/
  | { name: 'Destroyed'; data: { collection: number } }
  /**
   * An `item` was issued.
   **/
  | { name: 'Issued'; data: { collection: number; item: number; owner: AccountId32 } }
  /**
   * An `item` was transferred.
   **/
  | { name: 'Transferred'; data: { collection: number; item: number; from: AccountId32; to: AccountId32 } }
  /**
   * An `item` was destroyed.
   **/
  | { name: 'Burned'; data: { collection: number; item: number; owner: AccountId32 } }
  /**
   * An `item` became non-transferable.
   **/
  | { name: 'ItemTransferLocked'; data: { collection: number; item: number } }
  /**
   * An `item` became transferable.
   **/
  | { name: 'ItemTransferUnlocked'; data: { collection: number; item: number } }
  /**
   * `item` metadata or attributes were locked.
   **/
  | {
      name: 'ItemPropertiesLocked';
      data: { collection: number; item: number; lockMetadata: boolean; lockAttributes: boolean };
    }
  /**
   * Some `collection` was locked.
   **/
  | { name: 'CollectionLocked'; data: { collection: number } }
  /**
   * The owner changed.
   **/
  | { name: 'OwnerChanged'; data: { collection: number; newOwner: AccountId32 } }
  /**
   * The management team changed.
   **/
  | {
      name: 'TeamChanged';
      data: {
        collection: number;
        issuer?: AccountId32 | undefined;
        admin?: AccountId32 | undefined;
        freezer?: AccountId32 | undefined;
      };
    }
  /**
   * An `item` of a `collection` has been approved by the `owner` for transfer by
   * a `delegate`.
   **/
  | {
      name: 'TransferApproved';
      data: {
        collection: number;
        item: number;
        owner: AccountId32;
        delegate: AccountId32;
        deadline?: number | undefined;
      };
    }
  /**
   * An approval for a `delegate` account to transfer the `item` of an item
   * `collection` was cancelled by its `owner`.
   **/
  | { name: 'ApprovalCancelled'; data: { collection: number; item: number; owner: AccountId32; delegate: AccountId32 } }
  /**
   * All approvals of an item got cancelled.
   **/
  | { name: 'AllApprovalsCancelled'; data: { collection: number; item: number; owner: AccountId32 } }
  /**
   * A `collection` has had its config changed by the `Force` origin.
   **/
  | { name: 'CollectionConfigChanged'; data: { collection: number } }
  /**
   * New metadata has been set for a `collection`.
   **/
  | { name: 'CollectionMetadataSet'; data: { collection: number; data: Bytes } }
  /**
   * Metadata has been cleared for a `collection`.
   **/
  | { name: 'CollectionMetadataCleared'; data: { collection: number } }
  /**
   * New metadata has been set for an item.
   **/
  | { name: 'ItemMetadataSet'; data: { collection: number; item: number; data: Bytes } }
  /**
   * Metadata has been cleared for an item.
   **/
  | { name: 'ItemMetadataCleared'; data: { collection: number; item: number } }
  /**
   * The deposit for a set of `item`s within a `collection` has been updated.
   **/
  | { name: 'Redeposited'; data: { collection: number; successfulItems: Array<number> } }
  /**
   * New attribute metadata has been set for a `collection` or `item`.
   **/
  | {
      name: 'AttributeSet';
      data: {
        collection: number;
        maybeItem?: number | undefined;
        key: Bytes;
        value: Bytes;
        namespace: PalletNftsAttributeNamespace;
      };
    }
  /**
   * Attribute metadata has been cleared for a `collection` or `item`.
   **/
  | {
      name: 'AttributeCleared';
      data: { collection: number; maybeItem?: number | undefined; key: Bytes; namespace: PalletNftsAttributeNamespace };
    }
  /**
   * A new approval to modify item attributes was added.
   **/
  | { name: 'ItemAttributesApprovalAdded'; data: { collection: number; item: number; delegate: AccountId32 } }
  /**
   * A new approval to modify item attributes was removed.
   **/
  | { name: 'ItemAttributesApprovalRemoved'; data: { collection: number; item: number; delegate: AccountId32 } }
  /**
   * Ownership acceptance has changed for an account.
   **/
  | { name: 'OwnershipAcceptanceChanged'; data: { who: AccountId32; maybeCollection?: number | undefined } }
  /**
   * Max supply has been set for a collection.
   **/
  | { name: 'CollectionMaxSupplySet'; data: { collection: number; maxSupply: number } }
  /**
   * Mint settings for a collection had changed.
   **/
  | { name: 'CollectionMintSettingsUpdated'; data: { collection: number } }
  /**
   * Event gets emitted when the `NextCollectionId` gets incremented.
   **/
  | { name: 'NextCollectionIdIncremented'; data: { nextId?: number | undefined } }
  /**
   * The price was set for the item.
   **/
  | {
      name: 'ItemPriceSet';
      data: { collection: number; item: number; price: bigint; whitelistedBuyer?: AccountId32 | undefined };
    }
  /**
   * The price for the item was removed.
   **/
  | { name: 'ItemPriceRemoved'; data: { collection: number; item: number } }
  /**
   * An item was bought.
   **/
  | {
      name: 'ItemBought';
      data: { collection: number; item: number; price: bigint; seller: AccountId32; buyer: AccountId32 };
    }
  /**
   * A tip was sent.
   **/
  | {
      name: 'TipSent';
      data: { collection: number; item: number; sender: AccountId32; receiver: AccountId32; amount: bigint };
    }
  /**
   * An `item` swap intent was created.
   **/
  | {
      name: 'SwapCreated';
      data: {
        offeredCollection: number;
        offeredItem: number;
        desiredCollection: number;
        desiredItem?: number | undefined;
        price?: PalletNftsPriceWithDirection | undefined;
        deadline: number;
      };
    }
  /**
   * The swap was cancelled.
   **/
  | {
      name: 'SwapCancelled';
      data: {
        offeredCollection: number;
        offeredItem: number;
        desiredCollection: number;
        desiredItem?: number | undefined;
        price?: PalletNftsPriceWithDirection | undefined;
        deadline: number;
      };
    }
  /**
   * The swap has been claimed.
   **/
  | {
      name: 'SwapClaimed';
      data: {
        sentCollection: number;
        sentItem: number;
        sentItemOwner: AccountId32;
        receivedCollection: number;
        receivedItem: number;
        receivedItemOwner: AccountId32;
        price?: PalletNftsPriceWithDirection | undefined;
        deadline: number;
      };
    }
  /**
   * New attributes have been set for an `item` of the `collection`.
   **/
  | {
      name: 'PreSignedAttributesSet';
      data: { collection: number; item: number; namespace: PalletNftsAttributeNamespace };
    }
  /**
   * A new attribute in the `Pallet` namespace was set for the `collection` or an `item`
   * within that `collection`.
   **/
  | {
      name: 'PalletAttributeSet';
      data: { collection: number; item?: number | undefined; attribute: PalletNftsPalletAttributes; value: Bytes };
    };

export type PalletNftsAttributeNamespace =
  | { tag: 'Pallet' }
  | { tag: 'CollectionOwner' }
  | { tag: 'ItemOwner' }
  | { tag: 'Account'; value: AccountId32 };

export type PalletNftsPriceWithDirection = { amount: bigint; direction: PalletNftsPriceDirection };

export type PalletNftsPriceDirection = 'Send' | 'Receive';

export type PalletNftsPalletAttributes = { tag: 'UsedToClaim'; value: number } | { tag: 'TransferDisabled' };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetsEvent002 =
  /**
   * Some asset class was created.
   **/
  | {
      name: 'Created';
      data: { assetId: StagingXcmV3MultilocationMultiLocation; creator: AccountId32; owner: AccountId32 };
    }
  /**
   * Some assets were issued.
   **/
  | { name: 'Issued'; data: { assetId: StagingXcmV3MultilocationMultiLocation; owner: AccountId32; amount: bigint } }
  /**
   * Some assets were transferred.
   **/
  | {
      name: 'Transferred';
      data: { assetId: StagingXcmV3MultilocationMultiLocation; from: AccountId32; to: AccountId32; amount: bigint };
    }
  /**
   * Some assets were destroyed.
   **/
  | { name: 'Burned'; data: { assetId: StagingXcmV3MultilocationMultiLocation; owner: AccountId32; balance: bigint } }
  /**
   * The management team changed.
   **/
  | {
      name: 'TeamChanged';
      data: {
        assetId: StagingXcmV3MultilocationMultiLocation;
        issuer: AccountId32;
        admin: AccountId32;
        freezer: AccountId32;
      };
    }
  /**
   * The owner changed.
   **/
  | { name: 'OwnerChanged'; data: { assetId: StagingXcmV3MultilocationMultiLocation; owner: AccountId32 } }
  /**
   * Some account `who` was frozen.
   **/
  | { name: 'Frozen'; data: { assetId: StagingXcmV3MultilocationMultiLocation; who: AccountId32 } }
  /**
   * Some account `who` was thawed.
   **/
  | { name: 'Thawed'; data: { assetId: StagingXcmV3MultilocationMultiLocation; who: AccountId32 } }
  /**
   * Some asset `asset_id` was frozen.
   **/
  | { name: 'AssetFrozen'; data: { assetId: StagingXcmV3MultilocationMultiLocation } }
  /**
   * Some asset `asset_id` was thawed.
   **/
  | { name: 'AssetThawed'; data: { assetId: StagingXcmV3MultilocationMultiLocation } }
  /**
   * Accounts were destroyed for given asset.
   **/
  | {
      name: 'AccountsDestroyed';
      data: { assetId: StagingXcmV3MultilocationMultiLocation; accountsDestroyed: number; accountsRemaining: number };
    }
  /**
   * Approvals were destroyed for given asset.
   **/
  | {
      name: 'ApprovalsDestroyed';
      data: { assetId: StagingXcmV3MultilocationMultiLocation; approvalsDestroyed: number; approvalsRemaining: number };
    }
  /**
   * An asset class is in the process of being destroyed.
   **/
  | { name: 'DestructionStarted'; data: { assetId: StagingXcmV3MultilocationMultiLocation } }
  /**
   * An asset class was destroyed.
   **/
  | { name: 'Destroyed'; data: { assetId: StagingXcmV3MultilocationMultiLocation } }
  /**
   * Some asset class was force-created.
   **/
  | { name: 'ForceCreated'; data: { assetId: StagingXcmV3MultilocationMultiLocation; owner: AccountId32 } }
  /**
   * New metadata has been set for an asset.
   **/
  | {
      name: 'MetadataSet';
      data: {
        assetId: StagingXcmV3MultilocationMultiLocation;
        name: Bytes;
        symbol: Bytes;
        decimals: number;
        isFrozen: boolean;
      };
    }
  /**
   * Metadata has been cleared for an asset.
   **/
  | { name: 'MetadataCleared'; data: { assetId: StagingXcmV3MultilocationMultiLocation } }
  /**
   * (Additional) funds have been approved for transfer to a destination account.
   **/
  | {
      name: 'ApprovedTransfer';
      data: {
        assetId: StagingXcmV3MultilocationMultiLocation;
        source: AccountId32;
        delegate: AccountId32;
        amount: bigint;
      };
    }
  /**
   * An approval for account `delegate` was cancelled by `owner`.
   **/
  | {
      name: 'ApprovalCancelled';
      data: { assetId: StagingXcmV3MultilocationMultiLocation; owner: AccountId32; delegate: AccountId32 };
    }
  /**
   * An `amount` was transferred in its entirety from `owner` to `destination` by
   * the approved `delegate`.
   **/
  | {
      name: 'TransferredApproved';
      data: {
        assetId: StagingXcmV3MultilocationMultiLocation;
        owner: AccountId32;
        delegate: AccountId32;
        destination: AccountId32;
        amount: bigint;
      };
    }
  /**
   * An asset has had its attributes changed by the `Force` origin.
   **/
  | { name: 'AssetStatusChanged'; data: { assetId: StagingXcmV3MultilocationMultiLocation } }
  /**
   * The min_balance of an asset has been updated by the asset owner.
   **/
  | { name: 'AssetMinBalanceChanged'; data: { assetId: StagingXcmV3MultilocationMultiLocation; newMinBalance: bigint } }
  /**
   * Some account `who` was created with a deposit from `depositor`.
   **/
  | {
      name: 'Touched';
      data: { assetId: StagingXcmV3MultilocationMultiLocation; who: AccountId32; depositor: AccountId32 };
    }
  /**
   * Some account `who` was blocked.
   **/
  | { name: 'Blocked'; data: { assetId: StagingXcmV3MultilocationMultiLocation; who: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletNftFractionalizationEvent =
  /**
   * An NFT was successfully fractionalized.
   **/
  | {
      name: 'NftFractionalized';
      data: { nftCollection: number; nft: number; fractions: bigint; asset: number; beneficiary: AccountId32 };
    }
  /**
   * An NFT was successfully returned back.
   **/
  | { name: 'NftUnified'; data: { nftCollection: number; nft: number; asset: number; beneficiary: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetConversionEvent =
  /**
   * A successful call of the `CretaPool` extrinsic will create this event.
   **/
  | {
      name: 'PoolCreated';
      data: {
        /**
         * The account that created the pool.
         **/
        creator: AccountId32;

        /**
         * The pool id associated with the pool. Note that the order of the assets may not be
         * the same as the order specified in the create pool extrinsic.
         **/
        poolId: [StagingXcmV3MultilocationMultiLocation, StagingXcmV3MultilocationMultiLocation];

        /**
         * The account ID of the pool.
         **/
        poolAccount: AccountId32;

        /**
         * The id of the liquidity tokens that will be minted when assets are added to this
         * pool.
         **/
        lpToken: number;
      };
    }
  /**
   * A successful call of the `AddLiquidity` extrinsic will create this event.
   **/
  | {
      name: 'LiquidityAdded';
      data: {
        /**
         * The account that the liquidity was taken from.
         **/
        who: AccountId32;

        /**
         * The account that the liquidity tokens were minted to.
         **/
        mintTo: AccountId32;

        /**
         * The pool id of the pool that the liquidity was added to.
         **/
        poolId: [StagingXcmV3MultilocationMultiLocation, StagingXcmV3MultilocationMultiLocation];

        /**
         * The amount of the first asset that was added to the pool.
         **/
        amount1Provided: bigint;

        /**
         * The amount of the second asset that was added to the pool.
         **/
        amount2Provided: bigint;

        /**
         * The id of the lp token that was minted.
         **/
        lpToken: number;

        /**
         * The amount of lp tokens that were minted of that id.
         **/
        lpTokenMinted: bigint;
      };
    }
  /**
   * A successful call of the `RemoveLiquidity` extrinsic will create this event.
   **/
  | {
      name: 'LiquidityRemoved';
      data: {
        /**
         * The account that the liquidity tokens were burned from.
         **/
        who: AccountId32;

        /**
         * The account that the assets were transferred to.
         **/
        withdrawTo: AccountId32;

        /**
         * The pool id that the liquidity was removed from.
         **/
        poolId: [StagingXcmV3MultilocationMultiLocation, StagingXcmV3MultilocationMultiLocation];

        /**
         * The amount of the first asset that was removed from the pool.
         **/
        amount1: bigint;

        /**
         * The amount of the second asset that was removed from the pool.
         **/
        amount2: bigint;

        /**
         * The id of the lp token that was burned.
         **/
        lpToken: number;

        /**
         * The amount of lp tokens that were burned of that id.
         **/
        lpTokenBurned: bigint;

        /**
         * Liquidity withdrawal fee (%).
         **/
        withdrawalFee: Permill;
      };
    }
  /**
   * Assets have been converted from one to another. Both `SwapExactTokenForToken`
   * and `SwapTokenForExactToken` will generate this event.
   **/
  | {
      name: 'SwapExecuted';
      data: {
        /**
         * Which account was the instigator of the swap.
         **/
        who: AccountId32;

        /**
         * The account that the assets were transferred to.
         **/
        sendTo: AccountId32;

        /**
         * The amount of the first asset that was swapped.
         **/
        amountIn: bigint;

        /**
         * The amount of the second asset that was received.
         **/
        amountOut: bigint;

        /**
         * The route of asset IDs with amounts that the swap went through.
         * E.g. (A, amount_in) -> (Dot, amount_out) -> (B, amount_out)
         **/
        path: Array<[StagingXcmV3MultilocationMultiLocation, bigint]>;
      };
    }
  /**
   * Assets have been converted from one to another.
   **/
  | {
      name: 'SwapCreditExecuted';
      data: {
        /**
         * The amount of the first asset that was swapped.
         **/
        amountIn: bigint;

        /**
         * The amount of the second asset that was received.
         **/
        amountOut: bigint;

        /**
         * The route of asset IDs with amounts that the swap went through.
         * E.g. (A, amount_in) -> (Dot, amount_out) -> (B, amount_out)
         **/
        path: Array<[StagingXcmV3MultilocationMultiLocation, bigint]>;
      };
    };

export type FrameSystemLastRuntimeUpgradeInfo = { specVersion: number; specName: string };

export type FrameSystemCodeUpgradeAuthorization = { codeHash: H256; checkVersion: boolean };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type FrameSystemCall =
  /**
   * See [`Pallet::remark`].
   **/
  | { name: 'Remark'; params: { remark: Bytes } }
  /**
   * See [`Pallet::set_heap_pages`].
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * See [`Pallet::set_code`].
   **/
  | { name: 'SetCode'; params: { code: Bytes } }
  /**
   * See [`Pallet::set_code_without_checks`].
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: Bytes } }
  /**
   * See [`Pallet::set_storage`].
   **/
  | { name: 'SetStorage'; params: { items: Array<[Bytes, Bytes]> } }
  /**
   * See [`Pallet::kill_storage`].
   **/
  | { name: 'KillStorage'; params: { keys: Array<Bytes> } }
  /**
   * See [`Pallet::kill_prefix`].
   **/
  | { name: 'KillPrefix'; params: { prefix: Bytes; subkeys: number } }
  /**
   * See [`Pallet::remark_with_event`].
   **/
  | { name: 'RemarkWithEvent'; params: { remark: Bytes } }
  /**
   * See [`Pallet::authorize_upgrade`].
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256 } }
  /**
   * See [`Pallet::authorize_upgrade_without_checks`].
   **/
  | { name: 'AuthorizeUpgradeWithoutChecks'; params: { codeHash: H256 } }
  /**
   * See [`Pallet::apply_authorized_upgrade`].
   **/
  | { name: 'ApplyAuthorizedUpgrade'; params: { code: Bytes } };

export type FrameSystemCallLike =
  /**
   * See [`Pallet::remark`].
   **/
  | { name: 'Remark'; params: { remark: BytesLike } }
  /**
   * See [`Pallet::set_heap_pages`].
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * See [`Pallet::set_code`].
   **/
  | { name: 'SetCode'; params: { code: BytesLike } }
  /**
   * See [`Pallet::set_code_without_checks`].
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: BytesLike } }
  /**
   * See [`Pallet::set_storage`].
   **/
  | { name: 'SetStorage'; params: { items: Array<[BytesLike, BytesLike]> } }
  /**
   * See [`Pallet::kill_storage`].
   **/
  | { name: 'KillStorage'; params: { keys: Array<BytesLike> } }
  /**
   * See [`Pallet::kill_prefix`].
   **/
  | { name: 'KillPrefix'; params: { prefix: BytesLike; subkeys: number } }
  /**
   * See [`Pallet::remark_with_event`].
   **/
  | { name: 'RemarkWithEvent'; params: { remark: BytesLike } }
  /**
   * See [`Pallet::authorize_upgrade`].
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256 } }
  /**
   * See [`Pallet::authorize_upgrade_without_checks`].
   **/
  | { name: 'AuthorizeUpgradeWithoutChecks'; params: { codeHash: H256 } }
  /**
   * See [`Pallet::apply_authorized_upgrade`].
   **/
  | { name: 'ApplyAuthorizedUpgrade'; params: { code: BytesLike } };

export type FrameSystemLimitsBlockWeights = {
  baseBlock: SpWeightsWeightV2Weight;
  maxBlock: SpWeightsWeightV2Weight;
  perClass: FrameSupportDispatchPerDispatchClassWeightsPerClass;
};

export type FrameSupportDispatchPerDispatchClassWeightsPerClass = {
  normal: FrameSystemLimitsWeightsPerClass;
  operational: FrameSystemLimitsWeightsPerClass;
  mandatory: FrameSystemLimitsWeightsPerClass;
};

export type FrameSystemLimitsWeightsPerClass = {
  baseExtrinsic: SpWeightsWeightV2Weight;
  maxExtrinsic?: SpWeightsWeightV2Weight | undefined;
  maxTotal?: SpWeightsWeightV2Weight | undefined;
  reserved?: SpWeightsWeightV2Weight | undefined;
};

export type FrameSystemLimitsBlockLength = { max: FrameSupportDispatchPerDispatchClassU32 };

export type FrameSupportDispatchPerDispatchClassU32 = { normal: number; operational: number; mandatory: number };

export type SpWeightsRuntimeDbWeight = { read: bigint; write: bigint };

/**
 * Error for the System pallet
 **/
export type FrameSystemError =
  /**
   * The name of specification does not match between the current runtime
   * and the new runtime.
   **/
  | 'InvalidSpecName'
  /**
   * The specification version is not allowed to decrease between the current runtime
   * and the new runtime.
   **/
  | 'SpecVersionNeedsToIncrease'
  /**
   * Failed to extract the runtime version from the new runtime.
   *
   * Either calling `Core_version` or decoding `RuntimeVersion` failed.
   **/
  | 'FailedToExtractRuntimeVersion'
  /**
   * Suicide called when the account has non-default composite data.
   **/
  | 'NonDefaultComposite'
  /**
   * There is a non-zero reference count preventing the account from being purged.
   **/
  | 'NonZeroRefCount'
  /**
   * The origin filter prevent the call to be dispatched.
   **/
  | 'CallFiltered'
  /**
   * No upgrade authorized.
   **/
  | 'NothingAuthorized'
  /**
   * The submitted code is not authorized.
   **/
  | 'Unauthorized';

export type CumulusPalletParachainSystemUnincludedSegmentAncestor = {
  usedBandwidth: CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth;
  paraHeadHash?: H256 | undefined;
  consumedGoAheadSignal?: PolkadotPrimitivesV6UpgradeGoAhead | undefined;
};

export type CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth = {
  umpMsgCount: number;
  umpTotalBytes: number;
  hrmpOutgoing: Array<
    [PolkadotParachainPrimitivesPrimitivesId, CumulusPalletParachainSystemUnincludedSegmentHrmpChannelUpdate]
  >;
};

export type CumulusPalletParachainSystemUnincludedSegmentHrmpChannelUpdate = { msgCount: number; totalBytes: number };

export type PolkadotPrimitivesV6UpgradeGoAhead = 'Abort' | 'GoAhead';

export type CumulusPalletParachainSystemUnincludedSegmentSegmentTracker = {
  usedBandwidth: CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth;
  hrmpWatermark?: number | undefined;
  consumedGoAheadSignal?: PolkadotPrimitivesV6UpgradeGoAhead | undefined;
};

export type PolkadotPrimitivesV6PersistedValidationData = {
  parentHead: PolkadotParachainPrimitivesPrimitivesHeadData;
  relayParentNumber: number;
  relayParentStorageRoot: H256;
  maxPovSize: number;
};

export type PolkadotParachainPrimitivesPrimitivesHeadData = Bytes;

export type PolkadotPrimitivesV6UpgradeRestriction = 'Present';

export type SpTrieStorageProof = { trieNodes: Array<Bytes> };

export type CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot = {
  dmqMqcHead: H256;
  relayDispatchQueueRemainingCapacity: CumulusPalletParachainSystemRelayStateSnapshotRelayDispatchQueueRemainingCapacity;
  ingressChannels: Array<[PolkadotParachainPrimitivesPrimitivesId, PolkadotPrimitivesV6AbridgedHrmpChannel]>;
  egressChannels: Array<[PolkadotParachainPrimitivesPrimitivesId, PolkadotPrimitivesV6AbridgedHrmpChannel]>;
};

export type CumulusPalletParachainSystemRelayStateSnapshotRelayDispatchQueueRemainingCapacity = {
  remainingCount: number;
  remainingSize: number;
};

export type PolkadotPrimitivesV6AbridgedHrmpChannel = {
  maxCapacity: number;
  maxTotalSize: number;
  maxMessageSize: number;
  msgCount: number;
  totalSize: number;
  mqcHead?: H256 | undefined;
};

export type PolkadotPrimitivesV6AbridgedHostConfiguration = {
  maxCodeSize: number;
  maxHeadDataSize: number;
  maxUpwardQueueCount: number;
  maxUpwardQueueSize: number;
  maxUpwardMessageSize: number;
  maxUpwardMessageNumPerCandidate: number;
  hrmpMaxMessageNumPerCandidate: number;
  validationUpgradeCooldown: number;
  validationUpgradeDelay: number;
  asyncBackingParams: PolkadotPrimitivesV6AsyncBackingAsyncBackingParams;
};

export type PolkadotPrimitivesV6AsyncBackingAsyncBackingParams = {
  maxCandidateDepth: number;
  allowedAncestryLen: number;
};

export type CumulusPrimitivesParachainInherentMessageQueueChain = H256;

export type PolkadotCorePrimitivesOutboundHrmpMessage = {
  recipient: PolkadotParachainPrimitivesPrimitivesId;
  data: Bytes;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type CumulusPalletParachainSystemCall =
  /**
   * See [`Pallet::set_validation_data`].
   **/
  | { name: 'SetValidationData'; params: { data: CumulusPrimitivesParachainInherentParachainInherentData } }
  /**
   * See [`Pallet::sudo_send_upward_message`].
   **/
  | { name: 'SudoSendUpwardMessage'; params: { message: Bytes } }
  /**
   * See [`Pallet::authorize_upgrade`].
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256; checkVersion: boolean } }
  /**
   * See [`Pallet::enact_authorized_upgrade`].
   **/
  | { name: 'EnactAuthorizedUpgrade'; params: { code: Bytes } };

export type CumulusPalletParachainSystemCallLike =
  /**
   * See [`Pallet::set_validation_data`].
   **/
  | { name: 'SetValidationData'; params: { data: CumulusPrimitivesParachainInherentParachainInherentData } }
  /**
   * See [`Pallet::sudo_send_upward_message`].
   **/
  | { name: 'SudoSendUpwardMessage'; params: { message: BytesLike } }
  /**
   * See [`Pallet::authorize_upgrade`].
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256; checkVersion: boolean } }
  /**
   * See [`Pallet::enact_authorized_upgrade`].
   **/
  | { name: 'EnactAuthorizedUpgrade'; params: { code: BytesLike } };

export type CumulusPrimitivesParachainInherentParachainInherentData = {
  validationData: PolkadotPrimitivesV6PersistedValidationData;
  relayChainState: SpTrieStorageProof;
  downwardMessages: Array<PolkadotCorePrimitivesInboundDownwardMessage>;
  horizontalMessages: Array<[PolkadotParachainPrimitivesPrimitivesId, Array<PolkadotCorePrimitivesInboundHrmpMessage>]>;
};

export type PolkadotCorePrimitivesInboundDownwardMessage = { sentAt: number; msg: Bytes };

export type PolkadotCorePrimitivesInboundHrmpMessage = { sentAt: number; data: Bytes };

/**
 * The `Error` enum of this pallet.
 **/
export type CumulusPalletParachainSystemError =
  /**
   * Attempt to upgrade validation function while existing upgrade pending.
   **/
  | 'OverlappingUpgrades'
  /**
   * Polkadot currently prohibits this parachain from upgrading its validation function.
   **/
  | 'ProhibitedByPolkadot'
  /**
   * The supplied validation function has compiled into a blob larger than Polkadot is
   * willing to run.
   **/
  | 'TooBig'
  /**
   * The inherent which supplies the validation data did not run this block.
   **/
  | 'ValidationDataNotAvailable'
  /**
   * The inherent which supplies the host configuration did not run this block.
   **/
  | 'HostConfigurationNotAvailable'
  /**
   * No validation function upgrade is currently scheduled.
   **/
  | 'NotScheduled'
  /**
   * No code upgrade has been authorized.
   **/
  | 'NothingAuthorized'
  /**
   * The given code upgrade has not been authorized.
   **/
  | 'Unauthorized';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTimestampCall =
  /**
   * See [`Pallet::set`].
   **/
  { name: 'Set'; params: { now: bigint } };

export type PalletTimestampCallLike =
  /**
   * See [`Pallet::set`].
   **/
  { name: 'Set'; params: { now: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type StagingParachainInfoCall = null;

export type StagingParachainInfoCallLike = null;

export type PalletBalancesBalanceLock = { id: FixedBytes<8>; amount: bigint; reasons: PalletBalancesReasons };

export type PalletBalancesReasons = 'Fee' | 'Misc' | 'All';

export type PalletBalancesReserveData = { id: FixedBytes<8>; amount: bigint };

export type PalletBalancesIdAmount = { id: AssetHubWestendRuntimeRuntimeHoldReason; amount: bigint };

export type AssetHubWestendRuntimeRuntimeHoldReason = {
  tag: 'NftFractionalization';
  value: PalletNftFractionalizationHoldReason;
};

export type PalletNftFractionalizationHoldReason = 'Fractionalized';

export type PalletBalancesIdAmount002 = { id: []; amount: bigint };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBalancesCall =
  /**
   * See [`Pallet::transfer_allow_death`].
   **/
  | { name: 'TransferAllowDeath'; params: { dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { name: 'ForceTransfer'; params: { source: MultiAddress; dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: 'TransferKeepAlive'; params: { dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::transfer_all`].
   **/
  | { name: 'TransferAll'; params: { dest: MultiAddress; keepAlive: boolean } }
  /**
   * See [`Pallet::force_unreserve`].
   **/
  | { name: 'ForceUnreserve'; params: { who: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::upgrade_accounts`].
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32> } }
  /**
   * See [`Pallet::force_set_balance`].
   **/
  | { name: 'ForceSetBalance'; params: { who: MultiAddress; newFree: bigint } }
  /**
   * See [`Pallet::force_adjust_total_issuance`].
   **/
  | { name: 'ForceAdjustTotalIssuance'; params: { direction: PalletBalancesAdjustmentDirection; delta: bigint } };

export type PalletBalancesCallLike =
  /**
   * See [`Pallet::transfer_allow_death`].
   **/
  | { name: 'TransferAllowDeath'; params: { dest: MultiAddressLike; value: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { name: 'ForceTransfer'; params: { source: MultiAddressLike; dest: MultiAddressLike; value: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: 'TransferKeepAlive'; params: { dest: MultiAddressLike; value: bigint } }
  /**
   * See [`Pallet::transfer_all`].
   **/
  | { name: 'TransferAll'; params: { dest: MultiAddressLike; keepAlive: boolean } }
  /**
   * See [`Pallet::force_unreserve`].
   **/
  | { name: 'ForceUnreserve'; params: { who: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::upgrade_accounts`].
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32Like> } }
  /**
   * See [`Pallet::force_set_balance`].
   **/
  | { name: 'ForceSetBalance'; params: { who: MultiAddressLike; newFree: bigint } }
  /**
   * See [`Pallet::force_adjust_total_issuance`].
   **/
  | { name: 'ForceAdjustTotalIssuance'; params: { direction: PalletBalancesAdjustmentDirection; delta: bigint } };

export type PalletBalancesAdjustmentDirection = 'Increase' | 'Decrease';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBalancesError =
  /**
   * Vesting balance too high to send value.
   **/
  | 'VestingBalance'
  /**
   * Account liquidity restrictions prevent withdrawal.
   **/
  | 'LiquidityRestrictions'
  /**
   * Balance too low to send value.
   **/
  | 'InsufficientBalance'
  /**
   * Value too low to create account due to existential deposit.
   **/
  | 'ExistentialDeposit'
  /**
   * Transfer/payment would kill account.
   **/
  | 'Expendability'
  /**
   * A vesting schedule already exists for this account.
   **/
  | 'ExistingVestingSchedule'
  /**
   * Beneficiary account must pre-exist.
   **/
  | 'DeadAccount'
  /**
   * Number of named reserves exceed `MaxReserves`.
   **/
  | 'TooManyReserves'
  /**
   * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
   **/
  | 'TooManyHolds'
  /**
   * Number of freezes exceed `MaxFreezes`.
   **/
  | 'TooManyFreezes'
  /**
   * The issuance cannot be modified since it is already deactivated.
   **/
  | 'IssuanceDeactivated'
  /**
   * The delta cannot be zero.
   **/
  | 'DeltaZero';

export type PalletTransactionPaymentReleases = 'V1Ancient' | 'V2';

export type PalletCollatorSelectionCandidateInfo = { who: AccountId32; deposit: bigint };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCollatorSelectionCall =
  /**
   * See [`Pallet::set_invulnerables`].
   **/
  | { name: 'SetInvulnerables'; params: { new: Array<AccountId32> } }
  /**
   * See [`Pallet::set_desired_candidates`].
   **/
  | { name: 'SetDesiredCandidates'; params: { max: number } }
  /**
   * See [`Pallet::set_candidacy_bond`].
   **/
  | { name: 'SetCandidacyBond'; params: { bond: bigint } }
  /**
   * See [`Pallet::register_as_candidate`].
   **/
  | { name: 'RegisterAsCandidate' }
  /**
   * See [`Pallet::leave_intent`].
   **/
  | { name: 'LeaveIntent' }
  /**
   * See [`Pallet::add_invulnerable`].
   **/
  | { name: 'AddInvulnerable'; params: { who: AccountId32 } }
  /**
   * See [`Pallet::remove_invulnerable`].
   **/
  | { name: 'RemoveInvulnerable'; params: { who: AccountId32 } }
  /**
   * See [`Pallet::update_bond`].
   **/
  | { name: 'UpdateBond'; params: { newDeposit: bigint } }
  /**
   * See [`Pallet::take_candidate_slot`].
   **/
  | { name: 'TakeCandidateSlot'; params: { deposit: bigint; target: AccountId32 } };

export type PalletCollatorSelectionCallLike =
  /**
   * See [`Pallet::set_invulnerables`].
   **/
  | { name: 'SetInvulnerables'; params: { new: Array<AccountId32Like> } }
  /**
   * See [`Pallet::set_desired_candidates`].
   **/
  | { name: 'SetDesiredCandidates'; params: { max: number } }
  /**
   * See [`Pallet::set_candidacy_bond`].
   **/
  | { name: 'SetCandidacyBond'; params: { bond: bigint } }
  /**
   * See [`Pallet::register_as_candidate`].
   **/
  | { name: 'RegisterAsCandidate' }
  /**
   * See [`Pallet::leave_intent`].
   **/
  | { name: 'LeaveIntent' }
  /**
   * See [`Pallet::add_invulnerable`].
   **/
  | { name: 'AddInvulnerable'; params: { who: AccountId32Like } }
  /**
   * See [`Pallet::remove_invulnerable`].
   **/
  | { name: 'RemoveInvulnerable'; params: { who: AccountId32Like } }
  /**
   * See [`Pallet::update_bond`].
   **/
  | { name: 'UpdateBond'; params: { newDeposit: bigint } }
  /**
   * See [`Pallet::take_candidate_slot`].
   **/
  | { name: 'TakeCandidateSlot'; params: { deposit: bigint; target: AccountId32Like } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCollatorSelectionError =
  /**
   * The pallet has too many candidates.
   **/
  | 'TooManyCandidates'
  /**
   * Leaving would result in too few candidates.
   **/
  | 'TooFewEligibleCollators'
  /**
   * Account is already a candidate.
   **/
  | 'AlreadyCandidate'
  /**
   * Account is not a candidate.
   **/
  | 'NotCandidate'
  /**
   * There are too many Invulnerables.
   **/
  | 'TooManyInvulnerables'
  /**
   * Account is already an Invulnerable.
   **/
  | 'AlreadyInvulnerable'
  /**
   * Account is not an Invulnerable.
   **/
  | 'NotInvulnerable'
  /**
   * Account has no associated validator ID.
   **/
  | 'NoAssociatedValidatorId'
  /**
   * Validator ID is not yet registered.
   **/
  | 'ValidatorNotRegistered'
  /**
   * Could not insert in the candidate list.
   **/
  | 'InsertToCandidateListFailed'
  /**
   * Could not remove from the candidate list.
   **/
  | 'RemoveFromCandidateListFailed'
  /**
   * New deposit amount would be below the minimum candidacy bond.
   **/
  | 'DepositTooLow'
  /**
   * Could not update the candidate list.
   **/
  | 'UpdateCandidateListFailed'
  /**
   * Deposit amount is too low to take the target's slot in the candidate list.
   **/
  | 'InsufficientBond'
  /**
   * The target account to be replaced in the candidate list is not a candidate.
   **/
  | 'TargetIsNotCandidate'
  /**
   * The updated deposit amount is equal to the amount already reserved.
   **/
  | 'IdenticalDeposit'
  /**
   * Cannot lower candidacy bond while occupying a future collator slot in the list.
   **/
  | 'InvalidUnreserve';

export type AssetHubWestendRuntimeSessionKeys = { aura: SpConsensusAuraSr25519AppSr25519Public };

export type SpConsensusAuraSr25519AppSr25519Public = SpCoreSr25519Public;

export type SpCoreSr25519Public = FixedBytes<32>;

export type SpCoreCryptoKeyTypeId = FixedBytes<4>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSessionCall =
  /**
   * See [`Pallet::set_keys`].
   **/
  | { name: 'SetKeys'; params: { keys: AssetHubWestendRuntimeSessionKeys; proof: Bytes } }
  /**
   * See [`Pallet::purge_keys`].
   **/
  | { name: 'PurgeKeys' };

export type PalletSessionCallLike =
  /**
   * See [`Pallet::set_keys`].
   **/
  | { name: 'SetKeys'; params: { keys: AssetHubWestendRuntimeSessionKeys; proof: BytesLike } }
  /**
   * See [`Pallet::purge_keys`].
   **/
  | { name: 'PurgeKeys' };

/**
 * Error for the session pallet.
 **/
export type PalletSessionError =
  /**
   * Invalid ownership proof.
   **/
  | 'InvalidProof'
  /**
   * No associated validator ID for account.
   **/
  | 'NoAssociatedValidatorId'
  /**
   * Registered duplicate key.
   **/
  | 'DuplicatedKey'
  /**
   * No keys are associated with this account.
   **/
  | 'NoKeys'
  /**
   * Key setting account is not live, so it's impossible to associate keys.
   **/
  | 'NoAccount';

export type SpConsensusSlotsSlot = bigint;

export type CumulusPalletXcmpQueueOutboundChannelDetails = {
  recipient: PolkadotParachainPrimitivesPrimitivesId;
  state: CumulusPalletXcmpQueueOutboundState;
  signalsExist: boolean;
  firstIndex: number;
  lastIndex: number;
};

export type CumulusPalletXcmpQueueOutboundState = 'Ok' | 'Suspended';

export type CumulusPalletXcmpQueueQueueConfigData = {
  suspendThreshold: number;
  dropThreshold: number;
  resumeThreshold: number;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type CumulusPalletXcmpQueueCall =
  /**
   * See [`Pallet::suspend_xcm_execution`].
   **/
  | { name: 'SuspendXcmExecution' }
  /**
   * See [`Pallet::resume_xcm_execution`].
   **/
  | { name: 'ResumeXcmExecution' }
  /**
   * See [`Pallet::update_suspend_threshold`].
   **/
  | { name: 'UpdateSuspendThreshold'; params: { new: number } }
  /**
   * See [`Pallet::update_drop_threshold`].
   **/
  | { name: 'UpdateDropThreshold'; params: { new: number } }
  /**
   * See [`Pallet::update_resume_threshold`].
   **/
  | { name: 'UpdateResumeThreshold'; params: { new: number } };

export type CumulusPalletXcmpQueueCallLike =
  /**
   * See [`Pallet::suspend_xcm_execution`].
   **/
  | { name: 'SuspendXcmExecution' }
  /**
   * See [`Pallet::resume_xcm_execution`].
   **/
  | { name: 'ResumeXcmExecution' }
  /**
   * See [`Pallet::update_suspend_threshold`].
   **/
  | { name: 'UpdateSuspendThreshold'; params: { new: number } }
  /**
   * See [`Pallet::update_drop_threshold`].
   **/
  | { name: 'UpdateDropThreshold'; params: { new: number } }
  /**
   * See [`Pallet::update_resume_threshold`].
   **/
  | { name: 'UpdateResumeThreshold'; params: { new: number } };

/**
 * The `Error` enum of this pallet.
 **/
export type CumulusPalletXcmpQueueError =
  /**
   * Setting the queue config failed since one of its values was invalid.
   **/
  | 'BadQueueConfig'
  /**
   * The execution is already suspended.
   **/
  | 'AlreadySuspended'
  /**
   * The execution is already resumed.
   **/
  | 'AlreadyResumed';

export type PalletXcmQueryStatus =
  | {
      tag: 'Pending';
      value: {
        responder: XcmVersionedLocation;
        maybeMatchQuerier?: XcmVersionedLocation | undefined;
        maybeNotify?: [number, number] | undefined;
        timeout: number;
      };
    }
  | { tag: 'VersionNotifier'; value: { origin: XcmVersionedLocation; isActive: boolean } }
  | { tag: 'Ready'; value: { response: XcmVersionedResponse; at: number } };

export type XcmVersionedResponse =
  | { tag: 'V2'; value: XcmV2Response }
  | { tag: 'V3'; value: XcmV3Response }
  | { tag: 'V4'; value: StagingXcmV4Response };

export type XcmV2Response =
  | { tag: 'Null' }
  | { tag: 'Assets'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'ExecutionResult'; value?: [number, XcmV2TraitsError] | undefined }
  | { tag: 'Version'; value: number };

export type XcmV2TraitsError =
  | { tag: 'Overflow' }
  | { tag: 'Unimplemented' }
  | { tag: 'UntrustedReserveLocation' }
  | { tag: 'UntrustedTeleportLocation' }
  | { tag: 'MultiLocationFull' }
  | { tag: 'MultiLocationNotInvertible' }
  | { tag: 'BadOrigin' }
  | { tag: 'InvalidLocation' }
  | { tag: 'AssetNotFound' }
  | { tag: 'FailedToTransactAsset' }
  | { tag: 'NotWithdrawable' }
  | { tag: 'LocationCannotHold' }
  | { tag: 'ExceedsMaxMessageSize' }
  | { tag: 'DestinationUnsupported' }
  | { tag: 'Transport' }
  | { tag: 'Unroutable' }
  | { tag: 'UnknownClaim' }
  | { tag: 'FailedToDecode' }
  | { tag: 'MaxWeightInvalid' }
  | { tag: 'NotHoldingFees' }
  | { tag: 'TooExpensive' }
  | { tag: 'Trap'; value: bigint }
  | { tag: 'UnhandledXcmVersion' }
  | { tag: 'WeightLimitReached'; value: bigint }
  | { tag: 'Barrier' }
  | { tag: 'WeightNotComputable' };

export type XcmV3Response =
  | { tag: 'Null' }
  | { tag: 'Assets'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'ExecutionResult'; value?: [number, XcmV3TraitsError] | undefined }
  | { tag: 'Version'; value: number }
  | { tag: 'PalletsInfo'; value: Array<XcmV3PalletInfo> }
  | { tag: 'DispatchResult'; value: XcmV3MaybeErrorCode };

export type XcmV3PalletInfo = {
  index: number;
  name: Bytes;
  moduleName: Bytes;
  major: number;
  minor: number;
  patch: number;
};

export type PalletXcmVersionMigrationStage =
  | { tag: 'MigrateSupportedVersion' }
  | { tag: 'MigrateVersionNotifiers' }
  | { tag: 'NotifyCurrentTargets'; value?: Bytes | undefined }
  | { tag: 'MigrateAndNotifyOldTargets' };

export type XcmVersionedAssetId =
  | { tag: 'V3'; value: XcmV3MultiassetAssetId }
  | { tag: 'V4'; value: StagingXcmV4AssetAssetId };

export type PalletXcmRemoteLockedFungibleRecord = {
  amount: bigint;
  owner: XcmVersionedLocation;
  locker: XcmVersionedLocation;
  consumers: Array<[[], bigint]>;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletXcmCall =
  /**
   * See [`Pallet::send`].
   **/
  | { name: 'Send'; params: { dest: XcmVersionedLocation; message: XcmVersionedXcm } }
  /**
   * See [`Pallet::teleport_assets`].
   **/
  | {
      name: 'TeleportAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * See [`Pallet::reserve_transfer_assets`].
   **/
  | {
      name: 'ReserveTransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * See [`Pallet::execute`].
   **/
  | { name: 'Execute'; params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::force_xcm_version`].
   **/
  | { name: 'ForceXcmVersion'; params: { location: StagingXcmV4Location; version: number } }
  /**
   * See [`Pallet::force_default_xcm_version`].
   **/
  | { name: 'ForceDefaultXcmVersion'; params: { maybeXcmVersion?: number | undefined } }
  /**
   * See [`Pallet::force_subscribe_version_notify`].
   **/
  | { name: 'ForceSubscribeVersionNotify'; params: { location: XcmVersionedLocation } }
  /**
   * See [`Pallet::force_unsubscribe_version_notify`].
   **/
  | { name: 'ForceUnsubscribeVersionNotify'; params: { location: XcmVersionedLocation } }
  /**
   * See [`Pallet::limited_reserve_transfer_assets`].
   **/
  | {
      name: 'LimitedReserveTransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::limited_teleport_assets`].
   **/
  | {
      name: 'LimitedTeleportAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::force_suspension`].
   **/
  | { name: 'ForceSuspension'; params: { suspended: boolean } }
  /**
   * See [`Pallet::transfer_assets`].
   **/
  | {
      name: 'TransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    };

export type PalletXcmCallLike =
  /**
   * See [`Pallet::send`].
   **/
  | { name: 'Send'; params: { dest: XcmVersionedLocation; message: XcmVersionedXcm } }
  /**
   * See [`Pallet::teleport_assets`].
   **/
  | {
      name: 'TeleportAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * See [`Pallet::reserve_transfer_assets`].
   **/
  | {
      name: 'ReserveTransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * See [`Pallet::execute`].
   **/
  | { name: 'Execute'; params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::force_xcm_version`].
   **/
  | { name: 'ForceXcmVersion'; params: { location: StagingXcmV4Location; version: number } }
  /**
   * See [`Pallet::force_default_xcm_version`].
   **/
  | { name: 'ForceDefaultXcmVersion'; params: { maybeXcmVersion?: number | undefined } }
  /**
   * See [`Pallet::force_subscribe_version_notify`].
   **/
  | { name: 'ForceSubscribeVersionNotify'; params: { location: XcmVersionedLocation } }
  /**
   * See [`Pallet::force_unsubscribe_version_notify`].
   **/
  | { name: 'ForceUnsubscribeVersionNotify'; params: { location: XcmVersionedLocation } }
  /**
   * See [`Pallet::limited_reserve_transfer_assets`].
   **/
  | {
      name: 'LimitedReserveTransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::limited_teleport_assets`].
   **/
  | {
      name: 'LimitedTeleportAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::force_suspension`].
   **/
  | { name: 'ForceSuspension'; params: { suspended: boolean } }
  /**
   * See [`Pallet::transfer_assets`].
   **/
  | {
      name: 'TransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    };

export type XcmVersionedXcm =
  | { tag: 'V2'; value: XcmV2Xcm }
  | { tag: 'V3'; value: XcmV3Xcm }
  | { tag: 'V4'; value: StagingXcmV4Xcm };

export type XcmV2Xcm = Array<XcmV2Instruction>;

export type XcmV2Instruction =
  | { tag: 'WithdrawAsset'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'ReserveAssetDeposited'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'ReceiveTeleportedAsset'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'QueryResponse'; value: { queryId: bigint; response: XcmV2Response; maxWeight: bigint } }
  | {
      tag: 'TransferAsset';
      value: { assets: XcmV2MultiassetMultiAssets; beneficiary: XcmV2MultilocationMultiLocation };
    }
  | {
      tag: 'TransferReserveAsset';
      value: { assets: XcmV2MultiassetMultiAssets; dest: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | { tag: 'Transact'; value: { originType: XcmV2OriginKind; requireWeightAtMost: bigint; call: XcmDoubleEncoded } }
  | { tag: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { tag: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { tag: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { tag: 'ClearOrigin' }
  | { tag: 'DescendOrigin'; value: XcmV2MultilocationJunctions }
  | { tag: 'ReportError'; value: { queryId: bigint; dest: XcmV2MultilocationMultiLocation; maxResponseWeight: bigint } }
  | {
      tag: 'DepositAsset';
      value: {
        assets: XcmV2MultiassetMultiAssetFilter;
        maxAssets: number;
        beneficiary: XcmV2MultilocationMultiLocation;
      };
    }
  | {
      tag: 'DepositReserveAsset';
      value: {
        assets: XcmV2MultiassetMultiAssetFilter;
        maxAssets: number;
        dest: XcmV2MultilocationMultiLocation;
        xcm: XcmV2Xcm;
      };
    }
  | { tag: 'ExchangeAsset'; value: { give: XcmV2MultiassetMultiAssetFilter; receive: XcmV2MultiassetMultiAssets } }
  | {
      tag: 'InitiateReserveWithdraw';
      value: { assets: XcmV2MultiassetMultiAssetFilter; reserve: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | {
      tag: 'InitiateTeleport';
      value: { assets: XcmV2MultiassetMultiAssetFilter; dest: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | {
      tag: 'QueryHolding';
      value: {
        queryId: bigint;
        dest: XcmV2MultilocationMultiLocation;
        assets: XcmV2MultiassetMultiAssetFilter;
        maxResponseWeight: bigint;
      };
    }
  | { tag: 'BuyExecution'; value: { fees: XcmV2MultiassetMultiAsset; weightLimit: XcmV2WeightLimit } }
  | { tag: 'RefundSurplus' }
  | { tag: 'SetErrorHandler'; value: XcmV2Xcm }
  | { tag: 'SetAppendix'; value: XcmV2Xcm }
  | { tag: 'ClearError' }
  | { tag: 'ClaimAsset'; value: { assets: XcmV2MultiassetMultiAssets; ticket: XcmV2MultilocationMultiLocation } }
  | { tag: 'Trap'; value: bigint }
  | { tag: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: bigint } }
  | { tag: 'UnsubscribeVersion' };

export type XcmV2MultiassetMultiAssetFilter =
  | { tag: 'Definite'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'Wild'; value: XcmV2MultiassetWildMultiAsset };

export type XcmV2MultiassetWildMultiAsset =
  | { tag: 'All' }
  | { tag: 'AllOf'; value: { id: XcmV2MultiassetAssetId; fun: XcmV2MultiassetWildFungibility } };

export type XcmV2MultiassetWildFungibility = 'Fungible' | 'NonFungible';

export type XcmV2WeightLimit = { tag: 'Unlimited' } | { tag: 'Limited'; value: bigint };

export type XcmV3Xcm = Array<XcmV3Instruction>;

export type XcmV3Instruction =
  | { tag: 'WithdrawAsset'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'ReserveAssetDeposited'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'ReceiveTeleportedAsset'; value: XcmV3MultiassetMultiAssets }
  | {
      tag: 'QueryResponse';
      value: {
        queryId: bigint;
        response: XcmV3Response;
        maxWeight: SpWeightsWeightV2Weight;
        querier?: StagingXcmV3MultilocationMultiLocation | undefined;
      };
    }
  | {
      tag: 'TransferAsset';
      value: { assets: XcmV3MultiassetMultiAssets; beneficiary: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      tag: 'TransferReserveAsset';
      value: { assets: XcmV3MultiassetMultiAssets; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | {
      tag: 'Transact';
      value: { originKind: XcmV2OriginKind; requireWeightAtMost: SpWeightsWeightV2Weight; call: XcmDoubleEncoded };
    }
  | { tag: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { tag: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { tag: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { tag: 'ClearOrigin' }
  | { tag: 'DescendOrigin'; value: XcmV3Junctions }
  | { tag: 'ReportError'; value: XcmV3QueryResponseInfo }
  | {
      tag: 'DepositAsset';
      value: { assets: XcmV3MultiassetMultiAssetFilter; beneficiary: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      tag: 'DepositReserveAsset';
      value: { assets: XcmV3MultiassetMultiAssetFilter; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | {
      tag: 'ExchangeAsset';
      value: { give: XcmV3MultiassetMultiAssetFilter; want: XcmV3MultiassetMultiAssets; maximal: boolean };
    }
  | {
      tag: 'InitiateReserveWithdraw';
      value: {
        assets: XcmV3MultiassetMultiAssetFilter;
        reserve: StagingXcmV3MultilocationMultiLocation;
        xcm: XcmV3Xcm;
      };
    }
  | {
      tag: 'InitiateTeleport';
      value: { assets: XcmV3MultiassetMultiAssetFilter; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | { tag: 'ReportHolding'; value: { responseInfo: XcmV3QueryResponseInfo; assets: XcmV3MultiassetMultiAssetFilter } }
  | { tag: 'BuyExecution'; value: { fees: XcmV3MultiassetMultiAsset; weightLimit: XcmV3WeightLimit } }
  | { tag: 'RefundSurplus' }
  | { tag: 'SetErrorHandler'; value: XcmV3Xcm }
  | { tag: 'SetAppendix'; value: XcmV3Xcm }
  | { tag: 'ClearError' }
  | { tag: 'ClaimAsset'; value: { assets: XcmV3MultiassetMultiAssets; ticket: StagingXcmV3MultilocationMultiLocation } }
  | { tag: 'Trap'; value: bigint }
  | { tag: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: SpWeightsWeightV2Weight } }
  | { tag: 'UnsubscribeVersion' }
  | { tag: 'BurnAsset'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'ExpectAsset'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'ExpectOrigin'; value?: StagingXcmV3MultilocationMultiLocation | undefined }
  | { tag: 'ExpectError'; value?: [number, XcmV3TraitsError] | undefined }
  | { tag: 'ExpectTransactStatus'; value: XcmV3MaybeErrorCode }
  | { tag: 'QueryPallet'; value: { moduleName: Bytes; responseInfo: XcmV3QueryResponseInfo } }
  | {
      tag: 'ExpectPallet';
      value: { index: number; name: Bytes; moduleName: Bytes; crateMajor: number; minCrateMinor: number };
    }
  | { tag: 'ReportTransactStatus'; value: XcmV3QueryResponseInfo }
  | { tag: 'ClearTransactStatus' }
  | { tag: 'UniversalOrigin'; value: XcmV3Junction }
  | { tag: 'ExportMessage'; value: { network: XcmV3JunctionNetworkId; destination: XcmV3Junctions; xcm: XcmV3Xcm } }
  | { tag: 'LockAsset'; value: { asset: XcmV3MultiassetMultiAsset; unlocker: StagingXcmV3MultilocationMultiLocation } }
  | { tag: 'UnlockAsset'; value: { asset: XcmV3MultiassetMultiAsset; target: StagingXcmV3MultilocationMultiLocation } }
  | {
      tag: 'NoteUnlockable';
      value: { asset: XcmV3MultiassetMultiAsset; owner: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      tag: 'RequestUnlock';
      value: { asset: XcmV3MultiassetMultiAsset; locker: StagingXcmV3MultilocationMultiLocation };
    }
  | { tag: 'SetFeesMode'; value: { jitWithdraw: boolean } }
  | { tag: 'SetTopic'; value: FixedBytes<32> }
  | { tag: 'ClearTopic' }
  | { tag: 'AliasOrigin'; value: StagingXcmV3MultilocationMultiLocation }
  | {
      tag: 'UnpaidExecution';
      value: { weightLimit: XcmV3WeightLimit; checkOrigin?: StagingXcmV3MultilocationMultiLocation | undefined };
    };

export type XcmV3QueryResponseInfo = {
  destination: StagingXcmV3MultilocationMultiLocation;
  queryId: bigint;
  maxWeight: SpWeightsWeightV2Weight;
};

export type XcmV3MultiassetMultiAssetFilter =
  | { tag: 'Definite'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'Wild'; value: XcmV3MultiassetWildMultiAsset };

export type XcmV3MultiassetWildMultiAsset =
  | { tag: 'All' }
  | { tag: 'AllOf'; value: { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetWildFungibility } }
  | { tag: 'AllCounted'; value: number }
  | { tag: 'AllOfCounted'; value: { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetWildFungibility; count: number } };

export type XcmV3MultiassetWildFungibility = 'Fungible' | 'NonFungible';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletXcmError =
  /**
   * The desired destination was unreachable, generally because there is a no way of routing
   * to it.
   **/
  | 'Unreachable'
  /**
   * There was some other issue (i.e. not to do with routing) in sending the message.
   * Perhaps a lack of space for buffering the message.
   **/
  | 'SendFailure'
  /**
   * The message execution fails the filter.
   **/
  | 'Filtered'
  /**
   * The message's weight could not be determined.
   **/
  | 'UnweighableMessage'
  /**
   * The destination `Location` provided cannot be inverted.
   **/
  | 'DestinationNotInvertible'
  /**
   * The assets to be sent are empty.
   **/
  | 'Empty'
  /**
   * Could not re-anchor the assets to declare the fees for the destination chain.
   **/
  | 'CannotReanchor'
  /**
   * Too many assets have been attempted for transfer.
   **/
  | 'TooManyAssets'
  /**
   * Origin is invalid for sending.
   **/
  | 'InvalidOrigin'
  /**
   * The version of the `Versioned` value used is not able to be interpreted.
   **/
  | 'BadVersion'
  /**
   * The given location could not be used (e.g. because it cannot be expressed in the
   * desired version of XCM).
   **/
  | 'BadLocation'
  /**
   * The referenced subscription could not be found.
   **/
  | 'NoSubscription'
  /**
   * The location is invalid since it already has a subscription from us.
   **/
  | 'AlreadySubscribed'
  /**
   * Could not check-out the assets for teleportation to the destination chain.
   **/
  | 'CannotCheckOutTeleport'
  /**
   * The owner does not own (all) of the asset that they wish to do the operation on.
   **/
  | 'LowBalance'
  /**
   * The asset owner has too many locks on the asset.
   **/
  | 'TooManyLocks'
  /**
   * The given account is not an identifiable sovereign account for any location.
   **/
  | 'AccountNotSovereign'
  /**
   * The operation required fees to be paid which the initiator could not meet.
   **/
  | 'FeesNotMet'
  /**
   * A remote lock with the corresponding data could not be found.
   **/
  | 'LockNotFound'
  /**
   * The unlock operation cannot succeed because there are still consumers of the lock.
   **/
  | 'InUse'
  /**
   * Invalid non-concrete asset.
   **/
  | 'InvalidAssetNotConcrete'
  /**
   * Invalid asset, reserve chain could not be determined for it.
   **/
  | 'InvalidAssetUnknownReserve'
  /**
   * Invalid asset, do not support remote asset reserves with different fees reserves.
   **/
  | 'InvalidAssetUnsupportedReserve'
  /**
   * Too many assets with different reserve locations have been attempted for transfer.
   **/
  | 'TooManyReserves'
  /**
   * Local XCM execution incomplete.
   **/
  | 'LocalExecutionIncomplete';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type CumulusPalletXcmCall = null;

export type CumulusPalletXcmCallLike = null;

export type BpXcmBridgeHubRouterBridgeState = { deliveryFeeFactor: FixedU128; isCongested: boolean };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletXcmBridgeHubRouterCall =
  /**
   * See [`Pallet::report_bridge_status`].
   **/
  { name: 'ReportBridgeStatus'; params: { bridgeId: H256; isCongested: boolean } };

export type PalletXcmBridgeHubRouterCallLike =
  /**
   * See [`Pallet::report_bridge_status`].
   **/
  { name: 'ReportBridgeStatus'; params: { bridgeId: H256; isCongested: boolean } };

export type PalletMessageQueueBookState = {
  begin: number;
  end: number;
  count: number;
  readyNeighbours?: PalletMessageQueueNeighbours | undefined;
  messageCount: bigint;
  size: bigint;
};

export type PalletMessageQueueNeighbours = {
  prev: CumulusPrimitivesCoreAggregateMessageOrigin;
  next: CumulusPrimitivesCoreAggregateMessageOrigin;
};

export type PalletMessageQueuePage = {
  remaining: number;
  remainingSize: number;
  firstIndex: number;
  first: number;
  last: number;
  heap: Bytes;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMessageQueueCall =
  /**
   * See [`Pallet::reap_page`].
   **/
  | { name: 'ReapPage'; params: { messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin; pageIndex: number } }
  /**
   * See [`Pallet::execute_overweight`].
   **/
  | {
      name: 'ExecuteOverweight';
      params: {
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin;
        page: number;
        index: number;
        weightLimit: SpWeightsWeightV2Weight;
      };
    };

export type PalletMessageQueueCallLike =
  /**
   * See [`Pallet::reap_page`].
   **/
  | { name: 'ReapPage'; params: { messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin; pageIndex: number } }
  /**
   * See [`Pallet::execute_overweight`].
   **/
  | {
      name: 'ExecuteOverweight';
      params: {
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin;
        page: number;
        index: number;
        weightLimit: SpWeightsWeightV2Weight;
      };
    };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMessageQueueError =
  /**
   * Page is not reapable because it has items remaining to be processed and is not old
   * enough.
   **/
  | 'NotReapable'
  /**
   * Page to be reaped does not exist.
   **/
  | 'NoPage'
  /**
   * The referenced message could not be found.
   **/
  | 'NoMessage'
  /**
   * The message was already processed and cannot be processed again.
   **/
  | 'AlreadyProcessed'
  /**
   * The message is queued for future execution.
   **/
  | 'Queued'
  /**
   * There is temporarily not enough weight to continue servicing messages.
   **/
  | 'InsufficientWeight'
  /**
   * This message is temporarily unprocessable.
   *
   * Such errors are expected, but not guaranteed, to resolve themselves eventually through
   * retrying.
   **/
  | 'TemporarilyUnprocessable'
  /**
   * The queue is paused and no message can be executed from it.
   *
   * This can change at any time and may resolve in the future by re-trying.
   **/
  | 'QueuePaused'
  /**
   * Another call is in progress and needs to finish before this call can happen.
   **/
  | 'RecursiveDisallowed';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUtilityCall =
  /**
   * See [`Pallet::batch`].
   **/
  | { name: 'Batch'; params: { calls: Array<AssetHubWestendRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::as_derivative`].
   **/
  | { name: 'AsDerivative'; params: { index: number; call: AssetHubWestendRuntimeRuntimeCall } }
  /**
   * See [`Pallet::batch_all`].
   **/
  | { name: 'BatchAll'; params: { calls: Array<AssetHubWestendRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::dispatch_as`].
   **/
  | {
      name: 'DispatchAs';
      params: { asOrigin: AssetHubWestendRuntimeOriginCaller; call: AssetHubWestendRuntimeRuntimeCall };
    }
  /**
   * See [`Pallet::force_batch`].
   **/
  | { name: 'ForceBatch'; params: { calls: Array<AssetHubWestendRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::with_weight`].
   **/
  | { name: 'WithWeight'; params: { call: AssetHubWestendRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight } };

export type PalletUtilityCallLike =
  /**
   * See [`Pallet::batch`].
   **/
  | { name: 'Batch'; params: { calls: Array<AssetHubWestendRuntimeRuntimeCallLike> } }
  /**
   * See [`Pallet::as_derivative`].
   **/
  | { name: 'AsDerivative'; params: { index: number; call: AssetHubWestendRuntimeRuntimeCallLike } }
  /**
   * See [`Pallet::batch_all`].
   **/
  | { name: 'BatchAll'; params: { calls: Array<AssetHubWestendRuntimeRuntimeCallLike> } }
  /**
   * See [`Pallet::dispatch_as`].
   **/
  | {
      name: 'DispatchAs';
      params: { asOrigin: AssetHubWestendRuntimeOriginCaller; call: AssetHubWestendRuntimeRuntimeCallLike };
    }
  /**
   * See [`Pallet::force_batch`].
   **/
  | { name: 'ForceBatch'; params: { calls: Array<AssetHubWestendRuntimeRuntimeCallLike> } }
  /**
   * See [`Pallet::with_weight`].
   **/
  | { name: 'WithWeight'; params: { call: AssetHubWestendRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight } };

export type AssetHubWestendRuntimeRuntimeCall =
  | { pallet: 'System'; palletCall: FrameSystemCall }
  | { pallet: 'ParachainSystem'; palletCall: CumulusPalletParachainSystemCall }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCall }
  | { pallet: 'ParachainInfo'; palletCall: StagingParachainInfoCall }
  | { pallet: 'Balances'; palletCall: PalletBalancesCall }
  | { pallet: 'CollatorSelection'; palletCall: PalletCollatorSelectionCall }
  | { pallet: 'Session'; palletCall: PalletSessionCall }
  | { pallet: 'XcmpQueue'; palletCall: CumulusPalletXcmpQueueCall }
  | { pallet: 'PolkadotXcm'; palletCall: PalletXcmCall }
  | { pallet: 'CumulusXcm'; palletCall: CumulusPalletXcmCall }
  | { pallet: 'ToRococoXcmRouter'; palletCall: PalletXcmBridgeHubRouterCall }
  | { pallet: 'MessageQueue'; palletCall: PalletMessageQueueCall }
  | { pallet: 'Utility'; palletCall: PalletUtilityCall }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCall }
  | { pallet: 'Proxy'; palletCall: PalletProxyCall }
  | { pallet: 'Assets'; palletCall: PalletAssetsCall }
  | { pallet: 'Uniques'; palletCall: PalletUniquesCall }
  | { pallet: 'Nfts'; palletCall: PalletNftsCall }
  | { pallet: 'ForeignAssets'; palletCall: PalletAssetsCall002 }
  | { pallet: 'NftFractionalization'; palletCall: PalletNftFractionalizationCall }
  | { pallet: 'PoolAssets'; palletCall: PalletAssetsCall003 }
  | { pallet: 'AssetConversion'; palletCall: PalletAssetConversionCall };

export type AssetHubWestendRuntimeRuntimeCallLike =
  | { pallet: 'System'; palletCall: FrameSystemCallLike }
  | { pallet: 'ParachainSystem'; palletCall: CumulusPalletParachainSystemCallLike }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCallLike }
  | { pallet: 'ParachainInfo'; palletCall: StagingParachainInfoCallLike }
  | { pallet: 'Balances'; palletCall: PalletBalancesCallLike }
  | { pallet: 'CollatorSelection'; palletCall: PalletCollatorSelectionCallLike }
  | { pallet: 'Session'; palletCall: PalletSessionCallLike }
  | { pallet: 'XcmpQueue'; palletCall: CumulusPalletXcmpQueueCallLike }
  | { pallet: 'PolkadotXcm'; palletCall: PalletXcmCallLike }
  | { pallet: 'CumulusXcm'; palletCall: CumulusPalletXcmCallLike }
  | { pallet: 'ToRococoXcmRouter'; palletCall: PalletXcmBridgeHubRouterCallLike }
  | { pallet: 'MessageQueue'; palletCall: PalletMessageQueueCallLike }
  | { pallet: 'Utility'; palletCall: PalletUtilityCallLike }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCallLike }
  | { pallet: 'Proxy'; palletCall: PalletProxyCallLike }
  | { pallet: 'Assets'; palletCall: PalletAssetsCallLike }
  | { pallet: 'Uniques'; palletCall: PalletUniquesCallLike }
  | { pallet: 'Nfts'; palletCall: PalletNftsCallLike }
  | { pallet: 'ForeignAssets'; palletCall: PalletAssetsCallLike002 }
  | { pallet: 'NftFractionalization'; palletCall: PalletNftFractionalizationCallLike }
  | { pallet: 'PoolAssets'; palletCall: PalletAssetsCallLike003 }
  | { pallet: 'AssetConversion'; palletCall: PalletAssetConversionCallLike };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMultisigCall =
  /**
   * See [`Pallet::as_multi_threshold_1`].
   **/
  | {
      name: 'AsMultiThreshold1';
      params: { otherSignatories: Array<AccountId32>; call: AssetHubWestendRuntimeRuntimeCall };
    }
  /**
   * See [`Pallet::as_multi`].
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: AssetHubWestendRuntimeRuntimeCall;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::approve_as_multi`].
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::cancel_as_multi`].
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigCallLike =
  /**
   * See [`Pallet::as_multi_threshold_1`].
   **/
  | {
      name: 'AsMultiThreshold1';
      params: { otherSignatories: Array<AccountId32Like>; call: AssetHubWestendRuntimeRuntimeCallLike };
    }
  /**
   * See [`Pallet::as_multi`].
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: AssetHubWestendRuntimeRuntimeCallLike;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::approve_as_multi`].
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::cancel_as_multi`].
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletProxyCall =
  /**
   * See [`Pallet::proxy`].
   **/
  | {
      name: 'Proxy';
      params: {
        real: MultiAddress;
        forceProxyType?: AssetHubWestendRuntimeProxyType | undefined;
        call: AssetHubWestendRuntimeRuntimeCall;
      };
    }
  /**
   * See [`Pallet::add_proxy`].
   **/
  | { name: 'AddProxy'; params: { delegate: MultiAddress; proxyType: AssetHubWestendRuntimeProxyType; delay: number } }
  /**
   * See [`Pallet::remove_proxy`].
   **/
  | {
      name: 'RemoveProxy';
      params: { delegate: MultiAddress; proxyType: AssetHubWestendRuntimeProxyType; delay: number };
    }
  /**
   * See [`Pallet::remove_proxies`].
   **/
  | { name: 'RemoveProxies' }
  /**
   * See [`Pallet::create_pure`].
   **/
  | { name: 'CreatePure'; params: { proxyType: AssetHubWestendRuntimeProxyType; delay: number; index: number } }
  /**
   * See [`Pallet::kill_pure`].
   **/
  | {
      name: 'KillPure';
      params: {
        spawner: MultiAddress;
        proxyType: AssetHubWestendRuntimeProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * See [`Pallet::announce`].
   **/
  | { name: 'Announce'; params: { real: MultiAddress; callHash: H256 } }
  /**
   * See [`Pallet::remove_announcement`].
   **/
  | { name: 'RemoveAnnouncement'; params: { real: MultiAddress; callHash: H256 } }
  /**
   * See [`Pallet::reject_announcement`].
   **/
  | { name: 'RejectAnnouncement'; params: { delegate: MultiAddress; callHash: H256 } }
  /**
   * See [`Pallet::proxy_announced`].
   **/
  | {
      name: 'ProxyAnnounced';
      params: {
        delegate: MultiAddress;
        real: MultiAddress;
        forceProxyType?: AssetHubWestendRuntimeProxyType | undefined;
        call: AssetHubWestendRuntimeRuntimeCall;
      };
    };

export type PalletProxyCallLike =
  /**
   * See [`Pallet::proxy`].
   **/
  | {
      name: 'Proxy';
      params: {
        real: MultiAddressLike;
        forceProxyType?: AssetHubWestendRuntimeProxyType | undefined;
        call: AssetHubWestendRuntimeRuntimeCallLike;
      };
    }
  /**
   * See [`Pallet::add_proxy`].
   **/
  | {
      name: 'AddProxy';
      params: { delegate: MultiAddressLike; proxyType: AssetHubWestendRuntimeProxyType; delay: number };
    }
  /**
   * See [`Pallet::remove_proxy`].
   **/
  | {
      name: 'RemoveProxy';
      params: { delegate: MultiAddressLike; proxyType: AssetHubWestendRuntimeProxyType; delay: number };
    }
  /**
   * See [`Pallet::remove_proxies`].
   **/
  | { name: 'RemoveProxies' }
  /**
   * See [`Pallet::create_pure`].
   **/
  | { name: 'CreatePure'; params: { proxyType: AssetHubWestendRuntimeProxyType; delay: number; index: number } }
  /**
   * See [`Pallet::kill_pure`].
   **/
  | {
      name: 'KillPure';
      params: {
        spawner: MultiAddressLike;
        proxyType: AssetHubWestendRuntimeProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * See [`Pallet::announce`].
   **/
  | { name: 'Announce'; params: { real: MultiAddressLike; callHash: H256 } }
  /**
   * See [`Pallet::remove_announcement`].
   **/
  | { name: 'RemoveAnnouncement'; params: { real: MultiAddressLike; callHash: H256 } }
  /**
   * See [`Pallet::reject_announcement`].
   **/
  | { name: 'RejectAnnouncement'; params: { delegate: MultiAddressLike; callHash: H256 } }
  /**
   * See [`Pallet::proxy_announced`].
   **/
  | {
      name: 'ProxyAnnounced';
      params: {
        delegate: MultiAddressLike;
        real: MultiAddressLike;
        forceProxyType?: AssetHubWestendRuntimeProxyType | undefined;
        call: AssetHubWestendRuntimeRuntimeCallLike;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAssetsCall =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create'; params: { id: number; admin: MultiAddress; minBalance: bigint } }
  /**
   * See [`Pallet::force_create`].
   **/
  | { name: 'ForceCreate'; params: { id: number; owner: MultiAddress; isSufficient: boolean; minBalance: bigint } }
  /**
   * See [`Pallet::start_destroy`].
   **/
  | { name: 'StartDestroy'; params: { id: number } }
  /**
   * See [`Pallet::destroy_accounts`].
   **/
  | { name: 'DestroyAccounts'; params: { id: number } }
  /**
   * See [`Pallet::destroy_approvals`].
   **/
  | { name: 'DestroyApprovals'; params: { id: number } }
  /**
   * See [`Pallet::finish_destroy`].
   **/
  | { name: 'FinishDestroy'; params: { id: number } }
  /**
   * See [`Pallet::mint`].
   **/
  | { name: 'Mint'; params: { id: number; beneficiary: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { id: number; who: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { id: number; target: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: 'TransferKeepAlive'; params: { id: number; target: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { name: 'ForceTransfer'; params: { id: number; source: MultiAddress; dest: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::freeze`].
   **/
  | { name: 'Freeze'; params: { id: number; who: MultiAddress } }
  /**
   * See [`Pallet::thaw`].
   **/
  | { name: 'Thaw'; params: { id: number; who: MultiAddress } }
  /**
   * See [`Pallet::freeze_asset`].
   **/
  | { name: 'FreezeAsset'; params: { id: number } }
  /**
   * See [`Pallet::thaw_asset`].
   **/
  | { name: 'ThawAsset'; params: { id: number } }
  /**
   * See [`Pallet::transfer_ownership`].
   **/
  | { name: 'TransferOwnership'; params: { id: number; owner: MultiAddress } }
  /**
   * See [`Pallet::set_team`].
   **/
  | { name: 'SetTeam'; params: { id: number; issuer: MultiAddress; admin: MultiAddress; freezer: MultiAddress } }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { id: number; name: Bytes; symbol: Bytes; decimals: number } }
  /**
   * See [`Pallet::clear_metadata`].
   **/
  | { name: 'ClearMetadata'; params: { id: number } }
  /**
   * See [`Pallet::force_set_metadata`].
   **/
  | {
      name: 'ForceSetMetadata';
      params: { id: number; name: Bytes; symbol: Bytes; decimals: number; isFrozen: boolean };
    }
  /**
   * See [`Pallet::force_clear_metadata`].
   **/
  | { name: 'ForceClearMetadata'; params: { id: number } }
  /**
   * See [`Pallet::force_asset_status`].
   **/
  | {
      name: 'ForceAssetStatus';
      params: {
        id: number;
        owner: MultiAddress;
        issuer: MultiAddress;
        admin: MultiAddress;
        freezer: MultiAddress;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * See [`Pallet::approve_transfer`].
   **/
  | { name: 'ApproveTransfer'; params: { id: number; delegate: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::cancel_approval`].
   **/
  | { name: 'CancelApproval'; params: { id: number; delegate: MultiAddress } }
  /**
   * See [`Pallet::force_cancel_approval`].
   **/
  | { name: 'ForceCancelApproval'; params: { id: number; owner: MultiAddress; delegate: MultiAddress } }
  /**
   * See [`Pallet::transfer_approved`].
   **/
  | { name: 'TransferApproved'; params: { id: number; owner: MultiAddress; destination: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::touch`].
   **/
  | { name: 'Touch'; params: { id: number } }
  /**
   * See [`Pallet::refund`].
   **/
  | { name: 'Refund'; params: { id: number; allowBurn: boolean } }
  /**
   * See [`Pallet::set_min_balance`].
   **/
  | { name: 'SetMinBalance'; params: { id: number; minBalance: bigint } }
  /**
   * See [`Pallet::touch_other`].
   **/
  | { name: 'TouchOther'; params: { id: number; who: MultiAddress } }
  /**
   * See [`Pallet::refund_other`].
   **/
  | { name: 'RefundOther'; params: { id: number; who: MultiAddress } }
  /**
   * See [`Pallet::block`].
   **/
  | { name: 'Block'; params: { id: number; who: MultiAddress } };

export type PalletAssetsCallLike =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create'; params: { id: number; admin: MultiAddressLike; minBalance: bigint } }
  /**
   * See [`Pallet::force_create`].
   **/
  | { name: 'ForceCreate'; params: { id: number; owner: MultiAddressLike; isSufficient: boolean; minBalance: bigint } }
  /**
   * See [`Pallet::start_destroy`].
   **/
  | { name: 'StartDestroy'; params: { id: number } }
  /**
   * See [`Pallet::destroy_accounts`].
   **/
  | { name: 'DestroyAccounts'; params: { id: number } }
  /**
   * See [`Pallet::destroy_approvals`].
   **/
  | { name: 'DestroyApprovals'; params: { id: number } }
  /**
   * See [`Pallet::finish_destroy`].
   **/
  | { name: 'FinishDestroy'; params: { id: number } }
  /**
   * See [`Pallet::mint`].
   **/
  | { name: 'Mint'; params: { id: number; beneficiary: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { id: number; who: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { id: number; target: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: 'TransferKeepAlive'; params: { id: number; target: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { name: 'ForceTransfer'; params: { id: number; source: MultiAddressLike; dest: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::freeze`].
   **/
  | { name: 'Freeze'; params: { id: number; who: MultiAddressLike } }
  /**
   * See [`Pallet::thaw`].
   **/
  | { name: 'Thaw'; params: { id: number; who: MultiAddressLike } }
  /**
   * See [`Pallet::freeze_asset`].
   **/
  | { name: 'FreezeAsset'; params: { id: number } }
  /**
   * See [`Pallet::thaw_asset`].
   **/
  | { name: 'ThawAsset'; params: { id: number } }
  /**
   * See [`Pallet::transfer_ownership`].
   **/
  | { name: 'TransferOwnership'; params: { id: number; owner: MultiAddressLike } }
  /**
   * See [`Pallet::set_team`].
   **/
  | {
      name: 'SetTeam';
      params: { id: number; issuer: MultiAddressLike; admin: MultiAddressLike; freezer: MultiAddressLike };
    }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { id: number; name: BytesLike; symbol: BytesLike; decimals: number } }
  /**
   * See [`Pallet::clear_metadata`].
   **/
  | { name: 'ClearMetadata'; params: { id: number } }
  /**
   * See [`Pallet::force_set_metadata`].
   **/
  | {
      name: 'ForceSetMetadata';
      params: { id: number; name: BytesLike; symbol: BytesLike; decimals: number; isFrozen: boolean };
    }
  /**
   * See [`Pallet::force_clear_metadata`].
   **/
  | { name: 'ForceClearMetadata'; params: { id: number } }
  /**
   * See [`Pallet::force_asset_status`].
   **/
  | {
      name: 'ForceAssetStatus';
      params: {
        id: number;
        owner: MultiAddressLike;
        issuer: MultiAddressLike;
        admin: MultiAddressLike;
        freezer: MultiAddressLike;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * See [`Pallet::approve_transfer`].
   **/
  | { name: 'ApproveTransfer'; params: { id: number; delegate: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::cancel_approval`].
   **/
  | { name: 'CancelApproval'; params: { id: number; delegate: MultiAddressLike } }
  /**
   * See [`Pallet::force_cancel_approval`].
   **/
  | { name: 'ForceCancelApproval'; params: { id: number; owner: MultiAddressLike; delegate: MultiAddressLike } }
  /**
   * See [`Pallet::transfer_approved`].
   **/
  | {
      name: 'TransferApproved';
      params: { id: number; owner: MultiAddressLike; destination: MultiAddressLike; amount: bigint };
    }
  /**
   * See [`Pallet::touch`].
   **/
  | { name: 'Touch'; params: { id: number } }
  /**
   * See [`Pallet::refund`].
   **/
  | { name: 'Refund'; params: { id: number; allowBurn: boolean } }
  /**
   * See [`Pallet::set_min_balance`].
   **/
  | { name: 'SetMinBalance'; params: { id: number; minBalance: bigint } }
  /**
   * See [`Pallet::touch_other`].
   **/
  | { name: 'TouchOther'; params: { id: number; who: MultiAddressLike } }
  /**
   * See [`Pallet::refund_other`].
   **/
  | { name: 'RefundOther'; params: { id: number; who: MultiAddressLike } }
  /**
   * See [`Pallet::block`].
   **/
  | { name: 'Block'; params: { id: number; who: MultiAddressLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUniquesCall =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create'; params: { collection: number; admin: MultiAddress } }
  /**
   * See [`Pallet::force_create`].
   **/
  | { name: 'ForceCreate'; params: { collection: number; owner: MultiAddress; freeHolding: boolean } }
  /**
   * See [`Pallet::destroy`].
   **/
  | { name: 'Destroy'; params: { collection: number; witness: PalletUniquesDestroyWitness } }
  /**
   * See [`Pallet::mint`].
   **/
  | { name: 'Mint'; params: { collection: number; item: number; owner: MultiAddress } }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { collection: number; item: number; checkOwner?: MultiAddress | undefined } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { collection: number; item: number; dest: MultiAddress } }
  /**
   * See [`Pallet::redeposit`].
   **/
  | { name: 'Redeposit'; params: { collection: number; items: Array<number> } }
  /**
   * See [`Pallet::freeze`].
   **/
  | { name: 'Freeze'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::thaw`].
   **/
  | { name: 'Thaw'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::freeze_collection`].
   **/
  | { name: 'FreezeCollection'; params: { collection: number } }
  /**
   * See [`Pallet::thaw_collection`].
   **/
  | { name: 'ThawCollection'; params: { collection: number } }
  /**
   * See [`Pallet::transfer_ownership`].
   **/
  | { name: 'TransferOwnership'; params: { collection: number; newOwner: MultiAddress } }
  /**
   * See [`Pallet::set_team`].
   **/
  | {
      name: 'SetTeam';
      params: { collection: number; issuer: MultiAddress; admin: MultiAddress; freezer: MultiAddress };
    }
  /**
   * See [`Pallet::approve_transfer`].
   **/
  | { name: 'ApproveTransfer'; params: { collection: number; item: number; delegate: MultiAddress } }
  /**
   * See [`Pallet::cancel_approval`].
   **/
  | {
      name: 'CancelApproval';
      params: { collection: number; item: number; maybeCheckDelegate?: MultiAddress | undefined };
    }
  /**
   * See [`Pallet::force_item_status`].
   **/
  | {
      name: 'ForceItemStatus';
      params: {
        collection: number;
        owner: MultiAddress;
        issuer: MultiAddress;
        admin: MultiAddress;
        freezer: MultiAddress;
        freeHolding: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * See [`Pallet::set_attribute`].
   **/
  | { name: 'SetAttribute'; params: { collection: number; maybeItem?: number | undefined; key: Bytes; value: Bytes } }
  /**
   * See [`Pallet::clear_attribute`].
   **/
  | { name: 'ClearAttribute'; params: { collection: number; maybeItem?: number | undefined; key: Bytes } }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { collection: number; item: number; data: Bytes; isFrozen: boolean } }
  /**
   * See [`Pallet::clear_metadata`].
   **/
  | { name: 'ClearMetadata'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::set_collection_metadata`].
   **/
  | { name: 'SetCollectionMetadata'; params: { collection: number; data: Bytes; isFrozen: boolean } }
  /**
   * See [`Pallet::clear_collection_metadata`].
   **/
  | { name: 'ClearCollectionMetadata'; params: { collection: number } }
  /**
   * See [`Pallet::set_accept_ownership`].
   **/
  | { name: 'SetAcceptOwnership'; params: { maybeCollection?: number | undefined } }
  /**
   * See [`Pallet::set_collection_max_supply`].
   **/
  | { name: 'SetCollectionMaxSupply'; params: { collection: number; maxSupply: number } }
  /**
   * See [`Pallet::set_price`].
   **/
  | {
      name: 'SetPrice';
      params: {
        collection: number;
        item: number;
        price?: bigint | undefined;
        whitelistedBuyer?: MultiAddress | undefined;
      };
    }
  /**
   * See [`Pallet::buy_item`].
   **/
  | { name: 'BuyItem'; params: { collection: number; item: number; bidPrice: bigint } };

export type PalletUniquesCallLike =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create'; params: { collection: number; admin: MultiAddressLike } }
  /**
   * See [`Pallet::force_create`].
   **/
  | { name: 'ForceCreate'; params: { collection: number; owner: MultiAddressLike; freeHolding: boolean } }
  /**
   * See [`Pallet::destroy`].
   **/
  | { name: 'Destroy'; params: { collection: number; witness: PalletUniquesDestroyWitness } }
  /**
   * See [`Pallet::mint`].
   **/
  | { name: 'Mint'; params: { collection: number; item: number; owner: MultiAddressLike } }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { collection: number; item: number; checkOwner?: MultiAddressLike | undefined } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { collection: number; item: number; dest: MultiAddressLike } }
  /**
   * See [`Pallet::redeposit`].
   **/
  | { name: 'Redeposit'; params: { collection: number; items: Array<number> } }
  /**
   * See [`Pallet::freeze`].
   **/
  | { name: 'Freeze'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::thaw`].
   **/
  | { name: 'Thaw'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::freeze_collection`].
   **/
  | { name: 'FreezeCollection'; params: { collection: number } }
  /**
   * See [`Pallet::thaw_collection`].
   **/
  | { name: 'ThawCollection'; params: { collection: number } }
  /**
   * See [`Pallet::transfer_ownership`].
   **/
  | { name: 'TransferOwnership'; params: { collection: number; newOwner: MultiAddressLike } }
  /**
   * See [`Pallet::set_team`].
   **/
  | {
      name: 'SetTeam';
      params: { collection: number; issuer: MultiAddressLike; admin: MultiAddressLike; freezer: MultiAddressLike };
    }
  /**
   * See [`Pallet::approve_transfer`].
   **/
  | { name: 'ApproveTransfer'; params: { collection: number; item: number; delegate: MultiAddressLike } }
  /**
   * See [`Pallet::cancel_approval`].
   **/
  | {
      name: 'CancelApproval';
      params: { collection: number; item: number; maybeCheckDelegate?: MultiAddressLike | undefined };
    }
  /**
   * See [`Pallet::force_item_status`].
   **/
  | {
      name: 'ForceItemStatus';
      params: {
        collection: number;
        owner: MultiAddressLike;
        issuer: MultiAddressLike;
        admin: MultiAddressLike;
        freezer: MultiAddressLike;
        freeHolding: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * See [`Pallet::set_attribute`].
   **/
  | {
      name: 'SetAttribute';
      params: { collection: number; maybeItem?: number | undefined; key: BytesLike; value: BytesLike };
    }
  /**
   * See [`Pallet::clear_attribute`].
   **/
  | { name: 'ClearAttribute'; params: { collection: number; maybeItem?: number | undefined; key: BytesLike } }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { collection: number; item: number; data: BytesLike; isFrozen: boolean } }
  /**
   * See [`Pallet::clear_metadata`].
   **/
  | { name: 'ClearMetadata'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::set_collection_metadata`].
   **/
  | { name: 'SetCollectionMetadata'; params: { collection: number; data: BytesLike; isFrozen: boolean } }
  /**
   * See [`Pallet::clear_collection_metadata`].
   **/
  | { name: 'ClearCollectionMetadata'; params: { collection: number } }
  /**
   * See [`Pallet::set_accept_ownership`].
   **/
  | { name: 'SetAcceptOwnership'; params: { maybeCollection?: number | undefined } }
  /**
   * See [`Pallet::set_collection_max_supply`].
   **/
  | { name: 'SetCollectionMaxSupply'; params: { collection: number; maxSupply: number } }
  /**
   * See [`Pallet::set_price`].
   **/
  | {
      name: 'SetPrice';
      params: {
        collection: number;
        item: number;
        price?: bigint | undefined;
        whitelistedBuyer?: MultiAddressLike | undefined;
      };
    }
  /**
   * See [`Pallet::buy_item`].
   **/
  | { name: 'BuyItem'; params: { collection: number; item: number; bidPrice: bigint } };

export type PalletUniquesDestroyWitness = { items: number; itemMetadatas: number; attributes: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletNftsCall =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create'; params: { admin: MultiAddress; config: PalletNftsCollectionConfig } }
  /**
   * See [`Pallet::force_create`].
   **/
  | { name: 'ForceCreate'; params: { owner: MultiAddress; config: PalletNftsCollectionConfig } }
  /**
   * See [`Pallet::destroy`].
   **/
  | { name: 'Destroy'; params: { collection: number; witness: PalletNftsDestroyWitness } }
  /**
   * See [`Pallet::mint`].
   **/
  | {
      name: 'Mint';
      params: {
        collection: number;
        item: number;
        mintTo: MultiAddress;
        witnessData?: PalletNftsMintWitness | undefined;
      };
    }
  /**
   * See [`Pallet::force_mint`].
   **/
  | {
      name: 'ForceMint';
      params: { collection: number; item: number; mintTo: MultiAddress; itemConfig: PalletNftsItemConfig };
    }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { collection: number; item: number; dest: MultiAddress } }
  /**
   * See [`Pallet::redeposit`].
   **/
  | { name: 'Redeposit'; params: { collection: number; items: Array<number> } }
  /**
   * See [`Pallet::lock_item_transfer`].
   **/
  | { name: 'LockItemTransfer'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::unlock_item_transfer`].
   **/
  | { name: 'UnlockItemTransfer'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::lock_collection`].
   **/
  | { name: 'LockCollection'; params: { collection: number; lockSettings: PalletNftsBitFlags } }
  /**
   * See [`Pallet::transfer_ownership`].
   **/
  | { name: 'TransferOwnership'; params: { collection: number; newOwner: MultiAddress } }
  /**
   * See [`Pallet::set_team`].
   **/
  | {
      name: 'SetTeam';
      params: {
        collection: number;
        issuer?: MultiAddress | undefined;
        admin?: MultiAddress | undefined;
        freezer?: MultiAddress | undefined;
      };
    }
  /**
   * See [`Pallet::force_collection_owner`].
   **/
  | { name: 'ForceCollectionOwner'; params: { collection: number; owner: MultiAddress } }
  /**
   * See [`Pallet::force_collection_config`].
   **/
  | { name: 'ForceCollectionConfig'; params: { collection: number; config: PalletNftsCollectionConfig } }
  /**
   * See [`Pallet::approve_transfer`].
   **/
  | {
      name: 'ApproveTransfer';
      params: { collection: number; item: number; delegate: MultiAddress; maybeDeadline?: number | undefined };
    }
  /**
   * See [`Pallet::cancel_approval`].
   **/
  | { name: 'CancelApproval'; params: { collection: number; item: number; delegate: MultiAddress } }
  /**
   * See [`Pallet::clear_all_transfer_approvals`].
   **/
  | { name: 'ClearAllTransferApprovals'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::lock_item_properties`].
   **/
  | {
      name: 'LockItemProperties';
      params: { collection: number; item: number; lockMetadata: boolean; lockAttributes: boolean };
    }
  /**
   * See [`Pallet::set_attribute`].
   **/
  | {
      name: 'SetAttribute';
      params: {
        collection: number;
        maybeItem?: number | undefined;
        namespace: PalletNftsAttributeNamespace;
        key: Bytes;
        value: Bytes;
      };
    }
  /**
   * See [`Pallet::force_set_attribute`].
   **/
  | {
      name: 'ForceSetAttribute';
      params: {
        setAs?: AccountId32 | undefined;
        collection: number;
        maybeItem?: number | undefined;
        namespace: PalletNftsAttributeNamespace;
        key: Bytes;
        value: Bytes;
      };
    }
  /**
   * See [`Pallet::clear_attribute`].
   **/
  | {
      name: 'ClearAttribute';
      params: {
        collection: number;
        maybeItem?: number | undefined;
        namespace: PalletNftsAttributeNamespace;
        key: Bytes;
      };
    }
  /**
   * See [`Pallet::approve_item_attributes`].
   **/
  | { name: 'ApproveItemAttributes'; params: { collection: number; item: number; delegate: MultiAddress } }
  /**
   * See [`Pallet::cancel_item_attributes_approval`].
   **/
  | {
      name: 'CancelItemAttributesApproval';
      params: {
        collection: number;
        item: number;
        delegate: MultiAddress;
        witness: PalletNftsCancelAttributesApprovalWitness;
      };
    }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { collection: number; item: number; data: Bytes } }
  /**
   * See [`Pallet::clear_metadata`].
   **/
  | { name: 'ClearMetadata'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::set_collection_metadata`].
   **/
  | { name: 'SetCollectionMetadata'; params: { collection: number; data: Bytes } }
  /**
   * See [`Pallet::clear_collection_metadata`].
   **/
  | { name: 'ClearCollectionMetadata'; params: { collection: number } }
  /**
   * See [`Pallet::set_accept_ownership`].
   **/
  | { name: 'SetAcceptOwnership'; params: { maybeCollection?: number | undefined } }
  /**
   * See [`Pallet::set_collection_max_supply`].
   **/
  | { name: 'SetCollectionMaxSupply'; params: { collection: number; maxSupply: number } }
  /**
   * See [`Pallet::update_mint_settings`].
   **/
  | { name: 'UpdateMintSettings'; params: { collection: number; mintSettings: PalletNftsMintSettings } }
  /**
   * See [`Pallet::set_price`].
   **/
  | {
      name: 'SetPrice';
      params: {
        collection: number;
        item: number;
        price?: bigint | undefined;
        whitelistedBuyer?: MultiAddress | undefined;
      };
    }
  /**
   * See [`Pallet::buy_item`].
   **/
  | { name: 'BuyItem'; params: { collection: number; item: number; bidPrice: bigint } }
  /**
   * See [`Pallet::pay_tips`].
   **/
  | { name: 'PayTips'; params: { tips: Array<PalletNftsItemTip> } }
  /**
   * See [`Pallet::create_swap`].
   **/
  | {
      name: 'CreateSwap';
      params: {
        offeredCollection: number;
        offeredItem: number;
        desiredCollection: number;
        maybeDesiredItem?: number | undefined;
        maybePrice?: PalletNftsPriceWithDirection | undefined;
        duration: number;
      };
    }
  /**
   * See [`Pallet::cancel_swap`].
   **/
  | { name: 'CancelSwap'; params: { offeredCollection: number; offeredItem: number } }
  /**
   * See [`Pallet::claim_swap`].
   **/
  | {
      name: 'ClaimSwap';
      params: {
        sendCollection: number;
        sendItem: number;
        receiveCollection: number;
        receiveItem: number;
        witnessPrice?: PalletNftsPriceWithDirection | undefined;
      };
    }
  /**
   * See [`Pallet::mint_pre_signed`].
   **/
  | {
      name: 'MintPreSigned';
      params: { mintData: PalletNftsPreSignedMint; signature: SpRuntimeMultiSignature; signer: AccountId32 };
    }
  /**
   * See [`Pallet::set_attributes_pre_signed`].
   **/
  | {
      name: 'SetAttributesPreSigned';
      params: { data: PalletNftsPreSignedAttributes; signature: SpRuntimeMultiSignature; signer: AccountId32 };
    };

export type PalletNftsCallLike =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create'; params: { admin: MultiAddressLike; config: PalletNftsCollectionConfig } }
  /**
   * See [`Pallet::force_create`].
   **/
  | { name: 'ForceCreate'; params: { owner: MultiAddressLike; config: PalletNftsCollectionConfig } }
  /**
   * See [`Pallet::destroy`].
   **/
  | { name: 'Destroy'; params: { collection: number; witness: PalletNftsDestroyWitness } }
  /**
   * See [`Pallet::mint`].
   **/
  | {
      name: 'Mint';
      params: {
        collection: number;
        item: number;
        mintTo: MultiAddressLike;
        witnessData?: PalletNftsMintWitness | undefined;
      };
    }
  /**
   * See [`Pallet::force_mint`].
   **/
  | {
      name: 'ForceMint';
      params: { collection: number; item: number; mintTo: MultiAddressLike; itemConfig: PalletNftsItemConfig };
    }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { collection: number; item: number; dest: MultiAddressLike } }
  /**
   * See [`Pallet::redeposit`].
   **/
  | { name: 'Redeposit'; params: { collection: number; items: Array<number> } }
  /**
   * See [`Pallet::lock_item_transfer`].
   **/
  | { name: 'LockItemTransfer'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::unlock_item_transfer`].
   **/
  | { name: 'UnlockItemTransfer'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::lock_collection`].
   **/
  | { name: 'LockCollection'; params: { collection: number; lockSettings: PalletNftsBitFlags } }
  /**
   * See [`Pallet::transfer_ownership`].
   **/
  | { name: 'TransferOwnership'; params: { collection: number; newOwner: MultiAddressLike } }
  /**
   * See [`Pallet::set_team`].
   **/
  | {
      name: 'SetTeam';
      params: {
        collection: number;
        issuer?: MultiAddressLike | undefined;
        admin?: MultiAddressLike | undefined;
        freezer?: MultiAddressLike | undefined;
      };
    }
  /**
   * See [`Pallet::force_collection_owner`].
   **/
  | { name: 'ForceCollectionOwner'; params: { collection: number; owner: MultiAddressLike } }
  /**
   * See [`Pallet::force_collection_config`].
   **/
  | { name: 'ForceCollectionConfig'; params: { collection: number; config: PalletNftsCollectionConfig } }
  /**
   * See [`Pallet::approve_transfer`].
   **/
  | {
      name: 'ApproveTransfer';
      params: { collection: number; item: number; delegate: MultiAddressLike; maybeDeadline?: number | undefined };
    }
  /**
   * See [`Pallet::cancel_approval`].
   **/
  | { name: 'CancelApproval'; params: { collection: number; item: number; delegate: MultiAddressLike } }
  /**
   * See [`Pallet::clear_all_transfer_approvals`].
   **/
  | { name: 'ClearAllTransferApprovals'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::lock_item_properties`].
   **/
  | {
      name: 'LockItemProperties';
      params: { collection: number; item: number; lockMetadata: boolean; lockAttributes: boolean };
    }
  /**
   * See [`Pallet::set_attribute`].
   **/
  | {
      name: 'SetAttribute';
      params: {
        collection: number;
        maybeItem?: number | undefined;
        namespace: PalletNftsAttributeNamespace;
        key: BytesLike;
        value: BytesLike;
      };
    }
  /**
   * See [`Pallet::force_set_attribute`].
   **/
  | {
      name: 'ForceSetAttribute';
      params: {
        setAs?: AccountId32Like | undefined;
        collection: number;
        maybeItem?: number | undefined;
        namespace: PalletNftsAttributeNamespace;
        key: BytesLike;
        value: BytesLike;
      };
    }
  /**
   * See [`Pallet::clear_attribute`].
   **/
  | {
      name: 'ClearAttribute';
      params: {
        collection: number;
        maybeItem?: number | undefined;
        namespace: PalletNftsAttributeNamespace;
        key: BytesLike;
      };
    }
  /**
   * See [`Pallet::approve_item_attributes`].
   **/
  | { name: 'ApproveItemAttributes'; params: { collection: number; item: number; delegate: MultiAddressLike } }
  /**
   * See [`Pallet::cancel_item_attributes_approval`].
   **/
  | {
      name: 'CancelItemAttributesApproval';
      params: {
        collection: number;
        item: number;
        delegate: MultiAddressLike;
        witness: PalletNftsCancelAttributesApprovalWitness;
      };
    }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { collection: number; item: number; data: BytesLike } }
  /**
   * See [`Pallet::clear_metadata`].
   **/
  | { name: 'ClearMetadata'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::set_collection_metadata`].
   **/
  | { name: 'SetCollectionMetadata'; params: { collection: number; data: BytesLike } }
  /**
   * See [`Pallet::clear_collection_metadata`].
   **/
  | { name: 'ClearCollectionMetadata'; params: { collection: number } }
  /**
   * See [`Pallet::set_accept_ownership`].
   **/
  | { name: 'SetAcceptOwnership'; params: { maybeCollection?: number | undefined } }
  /**
   * See [`Pallet::set_collection_max_supply`].
   **/
  | { name: 'SetCollectionMaxSupply'; params: { collection: number; maxSupply: number } }
  /**
   * See [`Pallet::update_mint_settings`].
   **/
  | { name: 'UpdateMintSettings'; params: { collection: number; mintSettings: PalletNftsMintSettings } }
  /**
   * See [`Pallet::set_price`].
   **/
  | {
      name: 'SetPrice';
      params: {
        collection: number;
        item: number;
        price?: bigint | undefined;
        whitelistedBuyer?: MultiAddressLike | undefined;
      };
    }
  /**
   * See [`Pallet::buy_item`].
   **/
  | { name: 'BuyItem'; params: { collection: number; item: number; bidPrice: bigint } }
  /**
   * See [`Pallet::pay_tips`].
   **/
  | { name: 'PayTips'; params: { tips: Array<PalletNftsItemTip> } }
  /**
   * See [`Pallet::create_swap`].
   **/
  | {
      name: 'CreateSwap';
      params: {
        offeredCollection: number;
        offeredItem: number;
        desiredCollection: number;
        maybeDesiredItem?: number | undefined;
        maybePrice?: PalletNftsPriceWithDirection | undefined;
        duration: number;
      };
    }
  /**
   * See [`Pallet::cancel_swap`].
   **/
  | { name: 'CancelSwap'; params: { offeredCollection: number; offeredItem: number } }
  /**
   * See [`Pallet::claim_swap`].
   **/
  | {
      name: 'ClaimSwap';
      params: {
        sendCollection: number;
        sendItem: number;
        receiveCollection: number;
        receiveItem: number;
        witnessPrice?: PalletNftsPriceWithDirection | undefined;
      };
    }
  /**
   * See [`Pallet::mint_pre_signed`].
   **/
  | {
      name: 'MintPreSigned';
      params: { mintData: PalletNftsPreSignedMint; signature: SpRuntimeMultiSignature; signer: AccountId32Like };
    }
  /**
   * See [`Pallet::set_attributes_pre_signed`].
   **/
  | {
      name: 'SetAttributesPreSigned';
      params: { data: PalletNftsPreSignedAttributes; signature: SpRuntimeMultiSignature; signer: AccountId32Like };
    };

export type PalletNftsCollectionConfig = {
  settings: PalletNftsBitFlags;
  maxSupply?: number | undefined;
  mintSettings: PalletNftsMintSettings;
};

export type PalletNftsBitFlags = bigint;

export type PalletNftsCollectionSetting =
  | 'TransferableItems'
  | 'UnlockedMetadata'
  | 'UnlockedAttributes'
  | 'UnlockedMaxSupply'
  | 'DepositRequired';

export type PalletNftsMintSettings = {
  mintType: PalletNftsMintType;
  price?: bigint | undefined;
  startBlock?: number | undefined;
  endBlock?: number | undefined;
  defaultItemSettings: PalletNftsBitFlagsItemSetting;
};

export type PalletNftsMintType = { tag: 'Issuer' } | { tag: 'Public' } | { tag: 'HolderOf'; value: number };

export type PalletNftsBitFlagsItemSetting = bigint;

export type PalletNftsItemSetting = 'Transferable' | 'UnlockedMetadata' | 'UnlockedAttributes';

export type PalletNftsDestroyWitness = { itemMetadatas: number; itemConfigs: number; attributes: number };

export type PalletNftsMintWitness = { ownedItem?: number | undefined; mintPrice?: bigint | undefined };

export type PalletNftsItemConfig = { settings: PalletNftsBitFlagsItemSetting };

export type PalletNftsCancelAttributesApprovalWitness = { accountAttributes: number };

export type PalletNftsItemTip = { collection: number; item: number; receiver: AccountId32; amount: bigint };

export type PalletNftsPreSignedMint = {
  collection: number;
  item: number;
  attributes: Array<[Bytes, Bytes]>;
  metadata: Bytes;
  onlyAccount?: AccountId32 | undefined;
  deadline: number;
  mintPrice?: bigint | undefined;
};

export type SpRuntimeMultiSignature =
  | { tag: 'Ed25519'; value: SpCoreEd25519Signature }
  | { tag: 'Sr25519'; value: SpCoreSr25519Signature }
  | { tag: 'Ecdsa'; value: SpCoreEcdsaSignature };

export type SpCoreEd25519Signature = FixedBytes<64>;

export type SpCoreSr25519Signature = FixedBytes<64>;

export type SpCoreEcdsaSignature = FixedBytes<65>;

export type PalletNftsPreSignedAttributes = {
  collection: number;
  item: number;
  attributes: Array<[Bytes, Bytes]>;
  namespace: PalletNftsAttributeNamespace;
  deadline: number;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAssetsCall002 =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create'; params: { id: StagingXcmV3MultilocationMultiLocation; admin: MultiAddress; minBalance: bigint } }
  /**
   * See [`Pallet::force_create`].
   **/
  | {
      name: 'ForceCreate';
      params: {
        id: StagingXcmV3MultilocationMultiLocation;
        owner: MultiAddress;
        isSufficient: boolean;
        minBalance: bigint;
      };
    }
  /**
   * See [`Pallet::start_destroy`].
   **/
  | { name: 'StartDestroy'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::destroy_accounts`].
   **/
  | { name: 'DestroyAccounts'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::destroy_approvals`].
   **/
  | { name: 'DestroyApprovals'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::finish_destroy`].
   **/
  | { name: 'FinishDestroy'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::mint`].
   **/
  | { name: 'Mint'; params: { id: StagingXcmV3MultilocationMultiLocation; beneficiary: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { id: StagingXcmV3MultilocationMultiLocation; who: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { id: StagingXcmV3MultilocationMultiLocation; target: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | {
      name: 'TransferKeepAlive';
      params: { id: StagingXcmV3MultilocationMultiLocation; target: MultiAddress; amount: bigint };
    }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | {
      name: 'ForceTransfer';
      params: { id: StagingXcmV3MultilocationMultiLocation; source: MultiAddress; dest: MultiAddress; amount: bigint };
    }
  /**
   * See [`Pallet::freeze`].
   **/
  | { name: 'Freeze'; params: { id: StagingXcmV3MultilocationMultiLocation; who: MultiAddress } }
  /**
   * See [`Pallet::thaw`].
   **/
  | { name: 'Thaw'; params: { id: StagingXcmV3MultilocationMultiLocation; who: MultiAddress } }
  /**
   * See [`Pallet::freeze_asset`].
   **/
  | { name: 'FreezeAsset'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::thaw_asset`].
   **/
  | { name: 'ThawAsset'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::transfer_ownership`].
   **/
  | { name: 'TransferOwnership'; params: { id: StagingXcmV3MultilocationMultiLocation; owner: MultiAddress } }
  /**
   * See [`Pallet::set_team`].
   **/
  | {
      name: 'SetTeam';
      params: {
        id: StagingXcmV3MultilocationMultiLocation;
        issuer: MultiAddress;
        admin: MultiAddress;
        freezer: MultiAddress;
      };
    }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | {
      name: 'SetMetadata';
      params: { id: StagingXcmV3MultilocationMultiLocation; name: Bytes; symbol: Bytes; decimals: number };
    }
  /**
   * See [`Pallet::clear_metadata`].
   **/
  | { name: 'ClearMetadata'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::force_set_metadata`].
   **/
  | {
      name: 'ForceSetMetadata';
      params: {
        id: StagingXcmV3MultilocationMultiLocation;
        name: Bytes;
        symbol: Bytes;
        decimals: number;
        isFrozen: boolean;
      };
    }
  /**
   * See [`Pallet::force_clear_metadata`].
   **/
  | { name: 'ForceClearMetadata'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::force_asset_status`].
   **/
  | {
      name: 'ForceAssetStatus';
      params: {
        id: StagingXcmV3MultilocationMultiLocation;
        owner: MultiAddress;
        issuer: MultiAddress;
        admin: MultiAddress;
        freezer: MultiAddress;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * See [`Pallet::approve_transfer`].
   **/
  | {
      name: 'ApproveTransfer';
      params: { id: StagingXcmV3MultilocationMultiLocation; delegate: MultiAddress; amount: bigint };
    }
  /**
   * See [`Pallet::cancel_approval`].
   **/
  | { name: 'CancelApproval'; params: { id: StagingXcmV3MultilocationMultiLocation; delegate: MultiAddress } }
  /**
   * See [`Pallet::force_cancel_approval`].
   **/
  | {
      name: 'ForceCancelApproval';
      params: { id: StagingXcmV3MultilocationMultiLocation; owner: MultiAddress; delegate: MultiAddress };
    }
  /**
   * See [`Pallet::transfer_approved`].
   **/
  | {
      name: 'TransferApproved';
      params: {
        id: StagingXcmV3MultilocationMultiLocation;
        owner: MultiAddress;
        destination: MultiAddress;
        amount: bigint;
      };
    }
  /**
   * See [`Pallet::touch`].
   **/
  | { name: 'Touch'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::refund`].
   **/
  | { name: 'Refund'; params: { id: StagingXcmV3MultilocationMultiLocation; allowBurn: boolean } }
  /**
   * See [`Pallet::set_min_balance`].
   **/
  | { name: 'SetMinBalance'; params: { id: StagingXcmV3MultilocationMultiLocation; minBalance: bigint } }
  /**
   * See [`Pallet::touch_other`].
   **/
  | { name: 'TouchOther'; params: { id: StagingXcmV3MultilocationMultiLocation; who: MultiAddress } }
  /**
   * See [`Pallet::refund_other`].
   **/
  | { name: 'RefundOther'; params: { id: StagingXcmV3MultilocationMultiLocation; who: MultiAddress } }
  /**
   * See [`Pallet::block`].
   **/
  | { name: 'Block'; params: { id: StagingXcmV3MultilocationMultiLocation; who: MultiAddress } };

export type PalletAssetsCallLike002 =
  /**
   * See [`Pallet::create`].
   **/
  | {
      name: 'Create';
      params: { id: StagingXcmV3MultilocationMultiLocation; admin: MultiAddressLike; minBalance: bigint };
    }
  /**
   * See [`Pallet::force_create`].
   **/
  | {
      name: 'ForceCreate';
      params: {
        id: StagingXcmV3MultilocationMultiLocation;
        owner: MultiAddressLike;
        isSufficient: boolean;
        minBalance: bigint;
      };
    }
  /**
   * See [`Pallet::start_destroy`].
   **/
  | { name: 'StartDestroy'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::destroy_accounts`].
   **/
  | { name: 'DestroyAccounts'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::destroy_approvals`].
   **/
  | { name: 'DestroyApprovals'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::finish_destroy`].
   **/
  | { name: 'FinishDestroy'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::mint`].
   **/
  | {
      name: 'Mint';
      params: { id: StagingXcmV3MultilocationMultiLocation; beneficiary: MultiAddressLike; amount: bigint };
    }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { id: StagingXcmV3MultilocationMultiLocation; who: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::transfer`].
   **/
  | {
      name: 'Transfer';
      params: { id: StagingXcmV3MultilocationMultiLocation; target: MultiAddressLike; amount: bigint };
    }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | {
      name: 'TransferKeepAlive';
      params: { id: StagingXcmV3MultilocationMultiLocation; target: MultiAddressLike; amount: bigint };
    }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | {
      name: 'ForceTransfer';
      params: {
        id: StagingXcmV3MultilocationMultiLocation;
        source: MultiAddressLike;
        dest: MultiAddressLike;
        amount: bigint;
      };
    }
  /**
   * See [`Pallet::freeze`].
   **/
  | { name: 'Freeze'; params: { id: StagingXcmV3MultilocationMultiLocation; who: MultiAddressLike } }
  /**
   * See [`Pallet::thaw`].
   **/
  | { name: 'Thaw'; params: { id: StagingXcmV3MultilocationMultiLocation; who: MultiAddressLike } }
  /**
   * See [`Pallet::freeze_asset`].
   **/
  | { name: 'FreezeAsset'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::thaw_asset`].
   **/
  | { name: 'ThawAsset'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::transfer_ownership`].
   **/
  | { name: 'TransferOwnership'; params: { id: StagingXcmV3MultilocationMultiLocation; owner: MultiAddressLike } }
  /**
   * See [`Pallet::set_team`].
   **/
  | {
      name: 'SetTeam';
      params: {
        id: StagingXcmV3MultilocationMultiLocation;
        issuer: MultiAddressLike;
        admin: MultiAddressLike;
        freezer: MultiAddressLike;
      };
    }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | {
      name: 'SetMetadata';
      params: { id: StagingXcmV3MultilocationMultiLocation; name: BytesLike; symbol: BytesLike; decimals: number };
    }
  /**
   * See [`Pallet::clear_metadata`].
   **/
  | { name: 'ClearMetadata'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::force_set_metadata`].
   **/
  | {
      name: 'ForceSetMetadata';
      params: {
        id: StagingXcmV3MultilocationMultiLocation;
        name: BytesLike;
        symbol: BytesLike;
        decimals: number;
        isFrozen: boolean;
      };
    }
  /**
   * See [`Pallet::force_clear_metadata`].
   **/
  | { name: 'ForceClearMetadata'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::force_asset_status`].
   **/
  | {
      name: 'ForceAssetStatus';
      params: {
        id: StagingXcmV3MultilocationMultiLocation;
        owner: MultiAddressLike;
        issuer: MultiAddressLike;
        admin: MultiAddressLike;
        freezer: MultiAddressLike;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * See [`Pallet::approve_transfer`].
   **/
  | {
      name: 'ApproveTransfer';
      params: { id: StagingXcmV3MultilocationMultiLocation; delegate: MultiAddressLike; amount: bigint };
    }
  /**
   * See [`Pallet::cancel_approval`].
   **/
  | { name: 'CancelApproval'; params: { id: StagingXcmV3MultilocationMultiLocation; delegate: MultiAddressLike } }
  /**
   * See [`Pallet::force_cancel_approval`].
   **/
  | {
      name: 'ForceCancelApproval';
      params: { id: StagingXcmV3MultilocationMultiLocation; owner: MultiAddressLike; delegate: MultiAddressLike };
    }
  /**
   * See [`Pallet::transfer_approved`].
   **/
  | {
      name: 'TransferApproved';
      params: {
        id: StagingXcmV3MultilocationMultiLocation;
        owner: MultiAddressLike;
        destination: MultiAddressLike;
        amount: bigint;
      };
    }
  /**
   * See [`Pallet::touch`].
   **/
  | { name: 'Touch'; params: { id: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::refund`].
   **/
  | { name: 'Refund'; params: { id: StagingXcmV3MultilocationMultiLocation; allowBurn: boolean } }
  /**
   * See [`Pallet::set_min_balance`].
   **/
  | { name: 'SetMinBalance'; params: { id: StagingXcmV3MultilocationMultiLocation; minBalance: bigint } }
  /**
   * See [`Pallet::touch_other`].
   **/
  | { name: 'TouchOther'; params: { id: StagingXcmV3MultilocationMultiLocation; who: MultiAddressLike } }
  /**
   * See [`Pallet::refund_other`].
   **/
  | { name: 'RefundOther'; params: { id: StagingXcmV3MultilocationMultiLocation; who: MultiAddressLike } }
  /**
   * See [`Pallet::block`].
   **/
  | { name: 'Block'; params: { id: StagingXcmV3MultilocationMultiLocation; who: MultiAddressLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletNftFractionalizationCall =
  /**
   * See [`Pallet::fractionalize`].
   **/
  | {
      name: 'Fractionalize';
      params: { nftCollectionId: number; nftId: number; assetId: number; beneficiary: MultiAddress; fractions: bigint };
    }
  /**
   * See [`Pallet::unify`].
   **/
  | { name: 'Unify'; params: { nftCollectionId: number; nftId: number; assetId: number; beneficiary: MultiAddress } };

export type PalletNftFractionalizationCallLike =
  /**
   * See [`Pallet::fractionalize`].
   **/
  | {
      name: 'Fractionalize';
      params: {
        nftCollectionId: number;
        nftId: number;
        assetId: number;
        beneficiary: MultiAddressLike;
        fractions: bigint;
      };
    }
  /**
   * See [`Pallet::unify`].
   **/
  | {
      name: 'Unify';
      params: { nftCollectionId: number; nftId: number; assetId: number; beneficiary: MultiAddressLike };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAssetsCall003 =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create'; params: { id: number; admin: MultiAddress; minBalance: bigint } }
  /**
   * See [`Pallet::force_create`].
   **/
  | { name: 'ForceCreate'; params: { id: number; owner: MultiAddress; isSufficient: boolean; minBalance: bigint } }
  /**
   * See [`Pallet::start_destroy`].
   **/
  | { name: 'StartDestroy'; params: { id: number } }
  /**
   * See [`Pallet::destroy_accounts`].
   **/
  | { name: 'DestroyAccounts'; params: { id: number } }
  /**
   * See [`Pallet::destroy_approvals`].
   **/
  | { name: 'DestroyApprovals'; params: { id: number } }
  /**
   * See [`Pallet::finish_destroy`].
   **/
  | { name: 'FinishDestroy'; params: { id: number } }
  /**
   * See [`Pallet::mint`].
   **/
  | { name: 'Mint'; params: { id: number; beneficiary: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { id: number; who: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { id: number; target: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: 'TransferKeepAlive'; params: { id: number; target: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { name: 'ForceTransfer'; params: { id: number; source: MultiAddress; dest: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::freeze`].
   **/
  | { name: 'Freeze'; params: { id: number; who: MultiAddress } }
  /**
   * See [`Pallet::thaw`].
   **/
  | { name: 'Thaw'; params: { id: number; who: MultiAddress } }
  /**
   * See [`Pallet::freeze_asset`].
   **/
  | { name: 'FreezeAsset'; params: { id: number } }
  /**
   * See [`Pallet::thaw_asset`].
   **/
  | { name: 'ThawAsset'; params: { id: number } }
  /**
   * See [`Pallet::transfer_ownership`].
   **/
  | { name: 'TransferOwnership'; params: { id: number; owner: MultiAddress } }
  /**
   * See [`Pallet::set_team`].
   **/
  | { name: 'SetTeam'; params: { id: number; issuer: MultiAddress; admin: MultiAddress; freezer: MultiAddress } }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { id: number; name: Bytes; symbol: Bytes; decimals: number } }
  /**
   * See [`Pallet::clear_metadata`].
   **/
  | { name: 'ClearMetadata'; params: { id: number } }
  /**
   * See [`Pallet::force_set_metadata`].
   **/
  | {
      name: 'ForceSetMetadata';
      params: { id: number; name: Bytes; symbol: Bytes; decimals: number; isFrozen: boolean };
    }
  /**
   * See [`Pallet::force_clear_metadata`].
   **/
  | { name: 'ForceClearMetadata'; params: { id: number } }
  /**
   * See [`Pallet::force_asset_status`].
   **/
  | {
      name: 'ForceAssetStatus';
      params: {
        id: number;
        owner: MultiAddress;
        issuer: MultiAddress;
        admin: MultiAddress;
        freezer: MultiAddress;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * See [`Pallet::approve_transfer`].
   **/
  | { name: 'ApproveTransfer'; params: { id: number; delegate: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::cancel_approval`].
   **/
  | { name: 'CancelApproval'; params: { id: number; delegate: MultiAddress } }
  /**
   * See [`Pallet::force_cancel_approval`].
   **/
  | { name: 'ForceCancelApproval'; params: { id: number; owner: MultiAddress; delegate: MultiAddress } }
  /**
   * See [`Pallet::transfer_approved`].
   **/
  | { name: 'TransferApproved'; params: { id: number; owner: MultiAddress; destination: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::touch`].
   **/
  | { name: 'Touch'; params: { id: number } }
  /**
   * See [`Pallet::refund`].
   **/
  | { name: 'Refund'; params: { id: number; allowBurn: boolean } }
  /**
   * See [`Pallet::set_min_balance`].
   **/
  | { name: 'SetMinBalance'; params: { id: number; minBalance: bigint } }
  /**
   * See [`Pallet::touch_other`].
   **/
  | { name: 'TouchOther'; params: { id: number; who: MultiAddress } }
  /**
   * See [`Pallet::refund_other`].
   **/
  | { name: 'RefundOther'; params: { id: number; who: MultiAddress } }
  /**
   * See [`Pallet::block`].
   **/
  | { name: 'Block'; params: { id: number; who: MultiAddress } };

export type PalletAssetsCallLike003 =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create'; params: { id: number; admin: MultiAddressLike; minBalance: bigint } }
  /**
   * See [`Pallet::force_create`].
   **/
  | { name: 'ForceCreate'; params: { id: number; owner: MultiAddressLike; isSufficient: boolean; minBalance: bigint } }
  /**
   * See [`Pallet::start_destroy`].
   **/
  | { name: 'StartDestroy'; params: { id: number } }
  /**
   * See [`Pallet::destroy_accounts`].
   **/
  | { name: 'DestroyAccounts'; params: { id: number } }
  /**
   * See [`Pallet::destroy_approvals`].
   **/
  | { name: 'DestroyApprovals'; params: { id: number } }
  /**
   * See [`Pallet::finish_destroy`].
   **/
  | { name: 'FinishDestroy'; params: { id: number } }
  /**
   * See [`Pallet::mint`].
   **/
  | { name: 'Mint'; params: { id: number; beneficiary: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { id: number; who: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { id: number; target: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: 'TransferKeepAlive'; params: { id: number; target: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { name: 'ForceTransfer'; params: { id: number; source: MultiAddressLike; dest: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::freeze`].
   **/
  | { name: 'Freeze'; params: { id: number; who: MultiAddressLike } }
  /**
   * See [`Pallet::thaw`].
   **/
  | { name: 'Thaw'; params: { id: number; who: MultiAddressLike } }
  /**
   * See [`Pallet::freeze_asset`].
   **/
  | { name: 'FreezeAsset'; params: { id: number } }
  /**
   * See [`Pallet::thaw_asset`].
   **/
  | { name: 'ThawAsset'; params: { id: number } }
  /**
   * See [`Pallet::transfer_ownership`].
   **/
  | { name: 'TransferOwnership'; params: { id: number; owner: MultiAddressLike } }
  /**
   * See [`Pallet::set_team`].
   **/
  | {
      name: 'SetTeam';
      params: { id: number; issuer: MultiAddressLike; admin: MultiAddressLike; freezer: MultiAddressLike };
    }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { id: number; name: BytesLike; symbol: BytesLike; decimals: number } }
  /**
   * See [`Pallet::clear_metadata`].
   **/
  | { name: 'ClearMetadata'; params: { id: number } }
  /**
   * See [`Pallet::force_set_metadata`].
   **/
  | {
      name: 'ForceSetMetadata';
      params: { id: number; name: BytesLike; symbol: BytesLike; decimals: number; isFrozen: boolean };
    }
  /**
   * See [`Pallet::force_clear_metadata`].
   **/
  | { name: 'ForceClearMetadata'; params: { id: number } }
  /**
   * See [`Pallet::force_asset_status`].
   **/
  | {
      name: 'ForceAssetStatus';
      params: {
        id: number;
        owner: MultiAddressLike;
        issuer: MultiAddressLike;
        admin: MultiAddressLike;
        freezer: MultiAddressLike;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * See [`Pallet::approve_transfer`].
   **/
  | { name: 'ApproveTransfer'; params: { id: number; delegate: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::cancel_approval`].
   **/
  | { name: 'CancelApproval'; params: { id: number; delegate: MultiAddressLike } }
  /**
   * See [`Pallet::force_cancel_approval`].
   **/
  | { name: 'ForceCancelApproval'; params: { id: number; owner: MultiAddressLike; delegate: MultiAddressLike } }
  /**
   * See [`Pallet::transfer_approved`].
   **/
  | {
      name: 'TransferApproved';
      params: { id: number; owner: MultiAddressLike; destination: MultiAddressLike; amount: bigint };
    }
  /**
   * See [`Pallet::touch`].
   **/
  | { name: 'Touch'; params: { id: number } }
  /**
   * See [`Pallet::refund`].
   **/
  | { name: 'Refund'; params: { id: number; allowBurn: boolean } }
  /**
   * See [`Pallet::set_min_balance`].
   **/
  | { name: 'SetMinBalance'; params: { id: number; minBalance: bigint } }
  /**
   * See [`Pallet::touch_other`].
   **/
  | { name: 'TouchOther'; params: { id: number; who: MultiAddressLike } }
  /**
   * See [`Pallet::refund_other`].
   **/
  | { name: 'RefundOther'; params: { id: number; who: MultiAddressLike } }
  /**
   * See [`Pallet::block`].
   **/
  | { name: 'Block'; params: { id: number; who: MultiAddressLike } };

/**
 * Pallet's callable functions.
 **/
export type PalletAssetConversionCall =
  /**
   * See [`Pallet::create_pool`].
   **/
  | {
      name: 'CreatePool';
      params: { asset1: StagingXcmV3MultilocationMultiLocation; asset2: StagingXcmV3MultilocationMultiLocation };
    }
  /**
   * See [`Pallet::add_liquidity`].
   **/
  | {
      name: 'AddLiquidity';
      params: {
        asset1: StagingXcmV3MultilocationMultiLocation;
        asset2: StagingXcmV3MultilocationMultiLocation;
        amount1Desired: bigint;
        amount2Desired: bigint;
        amount1Min: bigint;
        amount2Min: bigint;
        mintTo: AccountId32;
      };
    }
  /**
   * See [`Pallet::remove_liquidity`].
   **/
  | {
      name: 'RemoveLiquidity';
      params: {
        asset1: StagingXcmV3MultilocationMultiLocation;
        asset2: StagingXcmV3MultilocationMultiLocation;
        lpTokenBurn: bigint;
        amount1MinReceive: bigint;
        amount2MinReceive: bigint;
        withdrawTo: AccountId32;
      };
    }
  /**
   * See [`Pallet::swap_exact_tokens_for_tokens`].
   **/
  | {
      name: 'SwapExactTokensForTokens';
      params: {
        path: Array<StagingXcmV3MultilocationMultiLocation>;
        amountIn: bigint;
        amountOutMin: bigint;
        sendTo: AccountId32;
        keepAlive: boolean;
      };
    }
  /**
   * See [`Pallet::swap_tokens_for_exact_tokens`].
   **/
  | {
      name: 'SwapTokensForExactTokens';
      params: {
        path: Array<StagingXcmV3MultilocationMultiLocation>;
        amountOut: bigint;
        amountInMax: bigint;
        sendTo: AccountId32;
        keepAlive: boolean;
      };
    };

export type PalletAssetConversionCallLike =
  /**
   * See [`Pallet::create_pool`].
   **/
  | {
      name: 'CreatePool';
      params: { asset1: StagingXcmV3MultilocationMultiLocation; asset2: StagingXcmV3MultilocationMultiLocation };
    }
  /**
   * See [`Pallet::add_liquidity`].
   **/
  | {
      name: 'AddLiquidity';
      params: {
        asset1: StagingXcmV3MultilocationMultiLocation;
        asset2: StagingXcmV3MultilocationMultiLocation;
        amount1Desired: bigint;
        amount2Desired: bigint;
        amount1Min: bigint;
        amount2Min: bigint;
        mintTo: AccountId32Like;
      };
    }
  /**
   * See [`Pallet::remove_liquidity`].
   **/
  | {
      name: 'RemoveLiquidity';
      params: {
        asset1: StagingXcmV3MultilocationMultiLocation;
        asset2: StagingXcmV3MultilocationMultiLocation;
        lpTokenBurn: bigint;
        amount1MinReceive: bigint;
        amount2MinReceive: bigint;
        withdrawTo: AccountId32Like;
      };
    }
  /**
   * See [`Pallet::swap_exact_tokens_for_tokens`].
   **/
  | {
      name: 'SwapExactTokensForTokens';
      params: {
        path: Array<StagingXcmV3MultilocationMultiLocation>;
        amountIn: bigint;
        amountOutMin: bigint;
        sendTo: AccountId32Like;
        keepAlive: boolean;
      };
    }
  /**
   * See [`Pallet::swap_tokens_for_exact_tokens`].
   **/
  | {
      name: 'SwapTokensForExactTokens';
      params: {
        path: Array<StagingXcmV3MultilocationMultiLocation>;
        amountOut: bigint;
        amountInMax: bigint;
        sendTo: AccountId32Like;
        keepAlive: boolean;
      };
    };

export type AssetHubWestendRuntimeOriginCaller =
  | { tag: 'System'; value: FrameSupportDispatchRawOrigin }
  | { tag: 'PolkadotXcm'; value: PalletXcmOrigin }
  | { tag: 'CumulusXcm'; value: CumulusPalletXcmOrigin }
  | { tag: 'Void'; value: SpCoreVoid };

export type FrameSupportDispatchRawOrigin = { tag: 'Root' } | { tag: 'Signed'; value: AccountId32 } | { tag: 'None' };

export type PalletXcmOrigin =
  | { tag: 'Xcm'; value: StagingXcmV4Location }
  | { tag: 'Response'; value: StagingXcmV4Location };

export type CumulusPalletXcmOrigin =
  | { tag: 'Relay' }
  | { tag: 'SiblingParachain'; value: PolkadotParachainPrimitivesPrimitivesId };

export type SpCoreVoid = null;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUtilityError =
  /**
   * Too many calls batched.
   **/
  'TooManyCalls';

export type PalletMultisigMultisig = {
  when: PalletMultisigTimepoint;
  deposit: bigint;
  depositor: AccountId32;
  approvals: Array<AccountId32>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMultisigError =
  /**
   * Threshold must be 2 or greater.
   **/
  | 'MinimumThreshold'
  /**
   * Call is already approved by this signatory.
   **/
  | 'AlreadyApproved'
  /**
   * Call doesn't need any (more) approvals.
   **/
  | 'NoApprovalsNeeded'
  /**
   * There are too few signatories in the list.
   **/
  | 'TooFewSignatories'
  /**
   * There are too many signatories in the list.
   **/
  | 'TooManySignatories'
  /**
   * The signatories were provided out of order; they should be ordered.
   **/
  | 'SignatoriesOutOfOrder'
  /**
   * The sender was contained in the other signatories; it shouldn't be.
   **/
  | 'SenderInSignatories'
  /**
   * Multisig operation not found when attempting to cancel.
   **/
  | 'NotFound'
  /**
   * Only the account that originally created the multisig is able to cancel it.
   **/
  | 'NotOwner'
  /**
   * No timepoint was given, yet the multisig operation is already underway.
   **/
  | 'NoTimepoint'
  /**
   * A different timepoint was given to the multisig operation that is underway.
   **/
  | 'WrongTimepoint'
  /**
   * A timepoint was given, yet no multisig operation is underway.
   **/
  | 'UnexpectedTimepoint'
  /**
   * The maximum weight information provided was too low.
   **/
  | 'MaxWeightTooLow'
  /**
   * The data to be stored is already stored.
   **/
  | 'AlreadyStored';

export type PalletProxyProxyDefinition = {
  delegate: AccountId32;
  proxyType: AssetHubWestendRuntimeProxyType;
  delay: number;
};

export type PalletProxyAnnouncement = { real: AccountId32; callHash: H256; height: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletProxyError =
  /**
   * There are too many proxies registered or too many announcements pending.
   **/
  | 'TooMany'
  /**
   * Proxy registration not found.
   **/
  | 'NotFound'
  /**
   * Sender is not a proxy of the account to be proxied.
   **/
  | 'NotProxy'
  /**
   * A call which is incompatible with the proxy type's filter was attempted.
   **/
  | 'Unproxyable'
  /**
   * Account is already a proxy.
   **/
  | 'Duplicate'
  /**
   * Call may not be made by proxy because it may escalate its privileges.
   **/
  | 'NoPermission'
  /**
   * Announcement, if made at all, was made too recently.
   **/
  | 'Unannounced'
  /**
   * Cannot add self as proxy.
   **/
  | 'NoSelfProxy';

export type PalletAssetsAssetDetails = {
  owner: AccountId32;
  issuer: AccountId32;
  admin: AccountId32;
  freezer: AccountId32;
  supply: bigint;
  deposit: bigint;
  minBalance: bigint;
  isSufficient: boolean;
  accounts: number;
  sufficients: number;
  approvals: number;
  status: PalletAssetsAssetStatus;
};

export type PalletAssetsAssetStatus = 'Live' | 'Frozen' | 'Destroying';

export type PalletAssetsAssetAccount = {
  balance: bigint;
  status: PalletAssetsAccountStatus;
  reason: PalletAssetsExistenceReason;
  extra: [];
};

export type PalletAssetsAccountStatus = 'Liquid' | 'Frozen' | 'Blocked';

export type PalletAssetsExistenceReason =
  | { tag: 'Consumer' }
  | { tag: 'Sufficient' }
  | { tag: 'DepositHeld'; value: bigint }
  | { tag: 'DepositRefunded' }
  | { tag: 'DepositFrom'; value: [AccountId32, bigint] };

export type PalletAssetsApproval = { amount: bigint; deposit: bigint };

export type PalletAssetsAssetMetadata = {
  deposit: bigint;
  name: Bytes;
  symbol: Bytes;
  decimals: number;
  isFrozen: boolean;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAssetsError =
  /**
   * Account balance must be greater than or equal to the transfer amount.
   **/
  | 'BalanceLow'
  /**
   * The account to alter does not exist.
   **/
  | 'NoAccount'
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * The given asset ID is unknown.
   **/
  | 'Unknown'
  /**
   * The origin account is frozen.
   **/
  | 'Frozen'
  /**
   * The asset ID is already taken.
   **/
  | 'InUse'
  /**
   * Invalid witness data given.
   **/
  | 'BadWitness'
  /**
   * Minimum balance should be non-zero.
   **/
  | 'MinBalanceZero'
  /**
   * Unable to increment the consumer reference counters on the account. Either no provider
   * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
   * fewer then the maximum number of consumers has been reached.
   **/
  | 'UnavailableConsumer'
  /**
   * Invalid metadata given.
   **/
  | 'BadMetadata'
  /**
   * No approval exists that would allow the transfer.
   **/
  | 'Unapproved'
  /**
   * The source account would not survive the transfer and it needs to stay alive.
   **/
  | 'WouldDie'
  /**
   * The asset-account already exists.
   **/
  | 'AlreadyExists'
  /**
   * The asset-account doesn't have an associated deposit.
   **/
  | 'NoDeposit'
  /**
   * The operation would result in funds being burned.
   **/
  | 'WouldBurn'
  /**
   * The asset is a live asset and is actively being used. Usually emit for operations such
   * as `start_destroy` which require the asset to be in a destroying state.
   **/
  | 'LiveAsset'
  /**
   * The asset is not live, and likely being destroyed.
   **/
  | 'AssetNotLive'
  /**
   * The asset status is not the expected status.
   **/
  | 'IncorrectStatus'
  /**
   * The asset should be frozen before the given operation.
   **/
  | 'NotFrozen'
  /**
   * Callback action resulted in error
   **/
  | 'CallbackFailed';

export type PalletUniquesCollectionDetails = {
  owner: AccountId32;
  issuer: AccountId32;
  admin: AccountId32;
  freezer: AccountId32;
  totalDeposit: bigint;
  freeHolding: boolean;
  items: number;
  itemMetadatas: number;
  attributes: number;
  isFrozen: boolean;
};

export type PalletUniquesItemDetails = {
  owner: AccountId32;
  approved?: AccountId32 | undefined;
  isFrozen: boolean;
  deposit: bigint;
};

export type PalletUniquesCollectionMetadata = { deposit: bigint; data: Bytes; isFrozen: boolean };

export type PalletUniquesItemMetadata = { deposit: bigint; data: Bytes; isFrozen: boolean };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUniquesError =
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * The given item ID is unknown.
   **/
  | 'UnknownCollection'
  /**
   * The item ID has already been used for an item.
   **/
  | 'AlreadyExists'
  /**
   * The owner turned out to be different to what was expected.
   **/
  | 'WrongOwner'
  /**
   * Invalid witness data given.
   **/
  | 'BadWitness'
  /**
   * The item ID is already taken.
   **/
  | 'InUse'
  /**
   * The item or collection is frozen.
   **/
  | 'Frozen'
  /**
   * The delegate turned out to be different to what was expected.
   **/
  | 'WrongDelegate'
  /**
   * There is no delegate approved.
   **/
  | 'NoDelegate'
  /**
   * No approval exists that would allow the transfer.
   **/
  | 'Unapproved'
  /**
   * The named owner has not signed ownership of the collection is acceptable.
   **/
  | 'Unaccepted'
  /**
   * The item is locked.
   **/
  | 'Locked'
  /**
   * All items have been minted.
   **/
  | 'MaxSupplyReached'
  /**
   * The max supply has already been set.
   **/
  | 'MaxSupplyAlreadySet'
  /**
   * The provided max supply is less to the amount of items a collection already has.
   **/
  | 'MaxSupplyTooSmall'
  /**
   * The given item ID is unknown.
   **/
  | 'UnknownItem'
  /**
   * Item is not for sale.
   **/
  | 'NotForSale'
  /**
   * The provided bid is too low.
   **/
  | 'BidTooLow';

export type PalletNftsCollectionDetails = {
  owner: AccountId32;
  ownerDeposit: bigint;
  items: number;
  itemMetadatas: number;
  itemConfigs: number;
  attributes: number;
};

export type PalletNftsBitFlagsCollectionRole = number;

export type PalletNftsCollectionRole = 'Issuer' | 'Freezer' | 'Admin';

export type PalletNftsItemDetails = {
  owner: AccountId32;
  approvals: Array<[AccountId32, number | undefined]>;
  deposit: PalletNftsItemDeposit;
};

export type PalletNftsItemDeposit = { account: AccountId32; amount: bigint };

export type PalletNftsCollectionMetadata = { deposit: bigint; data: Bytes };

export type PalletNftsItemMetadata = { deposit: PalletNftsItemMetadataDeposit; data: Bytes };

export type PalletNftsItemMetadataDeposit = { account?: AccountId32 | undefined; amount: bigint };

export type PalletNftsAttributeDeposit = { account?: AccountId32 | undefined; amount: bigint };

export type PalletNftsPendingSwap = {
  desiredCollection: number;
  desiredItem?: number | undefined;
  price?: PalletNftsPriceWithDirection | undefined;
  deadline: number;
};

export type PalletNftsBitFlagsPalletFeature = bigint;

export type PalletNftsPalletFeature = 'Trading' | 'Attributes' | 'Approvals' | 'Swaps';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletNftsError =
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * The given item ID is unknown.
   **/
  | 'UnknownCollection'
  /**
   * The item ID has already been used for an item.
   **/
  | 'AlreadyExists'
  /**
   * The approval had a deadline that expired, so the approval isn't valid anymore.
   **/
  | 'ApprovalExpired'
  /**
   * The owner turned out to be different to what was expected.
   **/
  | 'WrongOwner'
  /**
   * The witness data given does not match the current state of the chain.
   **/
  | 'BadWitness'
  /**
   * Collection ID is already taken.
   **/
  | 'CollectionIdInUse'
  /**
   * Items within that collection are non-transferable.
   **/
  | 'ItemsNonTransferable'
  /**
   * The provided account is not a delegate.
   **/
  | 'NotDelegate'
  /**
   * The delegate turned out to be different to what was expected.
   **/
  | 'WrongDelegate'
  /**
   * No approval exists that would allow the transfer.
   **/
  | 'Unapproved'
  /**
   * The named owner has not signed ownership acceptance of the collection.
   **/
  | 'Unaccepted'
  /**
   * The item is locked (non-transferable).
   **/
  | 'ItemLocked'
  /**
   * Item's attributes are locked.
   **/
  | 'LockedItemAttributes'
  /**
   * Collection's attributes are locked.
   **/
  | 'LockedCollectionAttributes'
  /**
   * Item's metadata is locked.
   **/
  | 'LockedItemMetadata'
  /**
   * Collection's metadata is locked.
   **/
  | 'LockedCollectionMetadata'
  /**
   * All items have been minted.
   **/
  | 'MaxSupplyReached'
  /**
   * The max supply is locked and can't be changed.
   **/
  | 'MaxSupplyLocked'
  /**
   * The provided max supply is less than the number of items a collection already has.
   **/
  | 'MaxSupplyTooSmall'
  /**
   * The given item ID is unknown.
   **/
  | 'UnknownItem'
  /**
   * Swap doesn't exist.
   **/
  | 'UnknownSwap'
  /**
   * The given item has no metadata set.
   **/
  | 'MetadataNotFound'
  /**
   * The provided attribute can't be found.
   **/
  | 'AttributeNotFound'
  /**
   * Item is not for sale.
   **/
  | 'NotForSale'
  /**
   * The provided bid is too low.
   **/
  | 'BidTooLow'
  /**
   * The item has reached its approval limit.
   **/
  | 'ReachedApprovalLimit'
  /**
   * The deadline has already expired.
   **/
  | 'DeadlineExpired'
  /**
   * The duration provided should be less than or equal to `MaxDeadlineDuration`.
   **/
  | 'WrongDuration'
  /**
   * The method is disabled by system settings.
   **/
  | 'MethodDisabled'
  /**
   * The provided setting can't be set.
   **/
  | 'WrongSetting'
  /**
   * Item's config already exists and should be equal to the provided one.
   **/
  | 'InconsistentItemConfig'
  /**
   * Config for a collection or an item can't be found.
   **/
  | 'NoConfig'
  /**
   * Some roles were not cleared.
   **/
  | 'RolesNotCleared'
  /**
   * Mint has not started yet.
   **/
  | 'MintNotStarted'
  /**
   * Mint has already ended.
   **/
  | 'MintEnded'
  /**
   * The provided Item was already used for claiming.
   **/
  | 'AlreadyClaimed'
  /**
   * The provided data is incorrect.
   **/
  | 'IncorrectData'
  /**
   * The extrinsic was sent by the wrong origin.
   **/
  | 'WrongOrigin'
  /**
   * The provided signature is incorrect.
   **/
  | 'WrongSignature'
  /**
   * The provided metadata might be too long.
   **/
  | 'IncorrectMetadata'
  /**
   * Can't set more attributes per one call.
   **/
  | 'MaxAttributesLimitReached'
  /**
   * The provided namespace isn't supported in this call.
   **/
  | 'WrongNamespace'
  /**
   * Can't delete non-empty collections.
   **/
  | 'CollectionNotEmpty'
  /**
   * The witness data should be provided.
   **/
  | 'WitnessRequired';

export type PalletNftFractionalizationDetails = {
  asset: number;
  fractions: bigint;
  deposit: bigint;
  assetCreator: AccountId32;
};

export type FrameSupportPalletId = FixedBytes<8>;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletNftFractionalizationError =
  /**
   * Asset ID does not correspond to locked NFT.
   **/
  | 'IncorrectAssetId'
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * NFT doesn't exist.
   **/
  | 'NftNotFound'
  /**
   * NFT has not yet been fractionalised.
   **/
  | 'NftNotFractionalized';

export type PalletAssetConversionPoolInfo = { lpToken: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAssetConversionError =
  /**
   * Provided asset pair is not supported for pool.
   **/
  | 'InvalidAssetPair'
  /**
   * Pool already exists.
   **/
  | 'PoolExists'
  /**
   * Desired amount can't be zero.
   **/
  | 'WrongDesiredAmount'
  /**
   * Provided amount should be greater than or equal to the existential deposit/asset's
   * minimal amount.
   **/
  | 'AmountOneLessThanMinimal'
  /**
   * Provided amount should be greater than or equal to the existential deposit/asset's
   * minimal amount.
   **/
  | 'AmountTwoLessThanMinimal'
  /**
   * Reserve needs to always be greater than or equal to the existential deposit/asset's
   * minimal amount.
   **/
  | 'ReserveLeftLessThanMinimal'
  /**
   * Desired amount can't be equal to the pool reserve.
   **/
  | 'AmountOutTooHigh'
  /**
   * The pool doesn't exist.
   **/
  | 'PoolNotFound'
  /**
   * An overflow happened.
   **/
  | 'Overflow'
  /**
   * The minimal amount requirement for the first token in the pair wasn't met.
   **/
  | 'AssetOneDepositDidNotMeetMinimum'
  /**
   * The minimal amount requirement for the second token in the pair wasn't met.
   **/
  | 'AssetTwoDepositDidNotMeetMinimum'
  /**
   * The minimal amount requirement for the first token in the pair wasn't met.
   **/
  | 'AssetOneWithdrawalDidNotMeetMinimum'
  /**
   * The minimal amount requirement for the second token in the pair wasn't met.
   **/
  | 'AssetTwoWithdrawalDidNotMeetMinimum'
  /**
   * Optimal calculated amount is less than desired.
   **/
  | 'OptimalAmountLessThanDesired'
  /**
   * Insufficient liquidity minted.
   **/
  | 'InsufficientLiquidityMinted'
  /**
   * Requested liquidity can't be zero.
   **/
  | 'ZeroLiquidity'
  /**
   * Amount can't be zero.
   **/
  | 'ZeroAmount'
  /**
   * Calculated amount out is less than provided minimum amount.
   **/
  | 'ProvidedMinimumNotSufficientForSwap'
  /**
   * Provided maximum amount is not sufficient for swap.
   **/
  | 'ProvidedMaximumNotSufficientForSwap'
  /**
   * The provided path must consists of 2 assets at least.
   **/
  | 'InvalidPath'
  /**
   * The provided path must consists of unique assets.
   **/
  | 'NonUniquePath'
  /**
   * It was not possible to get or increment the Id of the pool.
   **/
  | 'IncorrectPoolAssetId'
  /**
   * The destination account cannot exist with the swapped funds.
   **/
  | 'BelowMinimum';

export type FrameSystemExtensionsCheckNonZeroSender = {};

export type FrameSystemExtensionsCheckSpecVersion = {};

export type FrameSystemExtensionsCheckTxVersion = {};

export type FrameSystemExtensionsCheckGenesis = {};

export type FrameSystemExtensionsCheckMortality = Era;

export type FrameSystemExtensionsCheckNonce = number;

export type FrameSystemExtensionsCheckWeight = {};

export type PalletAssetConversionTxPaymentChargeAssetTxPayment = {
  tip: bigint;
  assetId?: StagingXcmV3MultilocationMultiLocation | undefined;
};

export type AssetHubWestendRuntimeRuntime = {};

export type SpConsensusSlotsSlotDuration = bigint;

export type SpRuntimeBlock = { header: Header; extrinsics: Array<UncheckedExtrinsic> };

export type SpCoreOpaqueMetadata = Bytes;

export type SpRuntimeTransactionValidityTransactionValidityError =
  | { tag: 'Invalid'; value: SpRuntimeTransactionValidityInvalidTransaction }
  | { tag: 'Unknown'; value: SpRuntimeTransactionValidityUnknownTransaction };

export type SpRuntimeTransactionValidityInvalidTransaction =
  | { tag: 'Call' }
  | { tag: 'Payment' }
  | { tag: 'Future' }
  | { tag: 'Stale' }
  | { tag: 'BadProof' }
  | { tag: 'AncientBirthBlock' }
  | { tag: 'ExhaustsResources' }
  | { tag: 'Custom'; value: number }
  | { tag: 'BadMandatory' }
  | { tag: 'MandatoryValidation' }
  | { tag: 'BadSigner' };

export type SpRuntimeTransactionValidityUnknownTransaction =
  | { tag: 'CannotLookup' }
  | { tag: 'NoUnsignedValidator' }
  | { tag: 'Custom'; value: number };

export type SpInherentsInherentData = { data: Array<[FixedBytes<8>, Bytes]> };

export type SpInherentsCheckInherentsResult = { okay: boolean; fatalError: boolean; errors: SpInherentsInherentData };

export type SpRuntimeTransactionValidityTransactionSource = 'InBlock' | 'Local' | 'External';

export type SpRuntimeTransactionValidityValidTransaction = {
  priority: bigint;
  requires: Array<Bytes>;
  provides: Array<Bytes>;
  longevity: bigint;
  propagate: boolean;
};

export type PalletTransactionPaymentRuntimeDispatchInfo = {
  weight: SpWeightsWeightV2Weight;
  class: FrameSupportDispatchDispatchClass;
  partialFee: bigint;
};

export type PalletTransactionPaymentFeeDetails = {
  inclusionFee?: PalletTransactionPaymentInclusionFee | undefined;
  tip: bigint;
};

export type PalletTransactionPaymentInclusionFee = { baseFee: bigint; lenFee: bigint; adjustedWeightFee: bigint };

export type AssetsCommonRuntimeApiFungiblesAccessError = 'AssetIdConversionFailed' | 'AmountToBalanceConversionFailed';

export type CumulusPrimitivesCoreCollationInfo = {
  upwardMessages: Array<Bytes>;
  horizontalMessages: Array<PolkadotCorePrimitivesOutboundHrmpMessage>;
  newValidationCode?: PolkadotParachainPrimitivesPrimitivesValidationCode | undefined;
  processedDownwardMessages: number;
  hrmpWatermark: number;
  headData: PolkadotParachainPrimitivesPrimitivesHeadData;
};

export type PolkadotParachainPrimitivesPrimitivesValidationCode = Bytes;

export type AssetHubWestendRuntimeRuntimeError =
  | { tag: 'System'; value: FrameSystemError }
  | { tag: 'ParachainSystem'; value: CumulusPalletParachainSystemError }
  | { tag: 'Balances'; value: PalletBalancesError }
  | { tag: 'CollatorSelection'; value: PalletCollatorSelectionError }
  | { tag: 'Session'; value: PalletSessionError }
  | { tag: 'XcmpQueue'; value: CumulusPalletXcmpQueueError }
  | { tag: 'PolkadotXcm'; value: PalletXcmError }
  | { tag: 'MessageQueue'; value: PalletMessageQueueError }
  | { tag: 'Utility'; value: PalletUtilityError }
  | { tag: 'Multisig'; value: PalletMultisigError }
  | { tag: 'Proxy'; value: PalletProxyError }
  | { tag: 'Assets'; value: PalletAssetsError }
  | { tag: 'Uniques'; value: PalletUniquesError }
  | { tag: 'Nfts'; value: PalletNftsError }
  | { tag: 'ForeignAssets'; value: PalletAssetsError }
  | { tag: 'NftFractionalization'; value: PalletNftFractionalizationError }
  | { tag: 'PoolAssets'; value: PalletAssetsError }
  | { tag: 'AssetConversion'; value: PalletAssetConversionError };
