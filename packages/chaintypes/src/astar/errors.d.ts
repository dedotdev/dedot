// Generated by @dedot/codegen

import type { GenericChainErrors, GenericPalletError } from '@dedot/types';

export interface ChainErrors extends GenericChainErrors {
  /**
   * Pallet `System`'s errors
   **/
  system: {
    /**
     * The name of specification does not match between the current runtime
     * and the new runtime.
     **/
    InvalidSpecName: GenericPalletError;

    /**
     * The specification version is not allowed to decrease between the current runtime
     * and the new runtime.
     **/
    SpecVersionNeedsToIncrease: GenericPalletError;

    /**
     * Failed to extract the runtime version from the new runtime.
     *
     * Either calling `Core_version` or decoding `RuntimeVersion` failed.
     **/
    FailedToExtractRuntimeVersion: GenericPalletError;

    /**
     * Suicide called when the account has non-default composite data.
     **/
    NonDefaultComposite: GenericPalletError;

    /**
     * There is a non-zero reference count preventing the account from being purged.
     **/
    NonZeroRefCount: GenericPalletError;

    /**
     * The origin filter prevent the call to be dispatched.
     **/
    CallFiltered: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Utility`'s errors
   **/
  utility: {
    /**
     * Too many calls batched.
     **/
    TooManyCalls: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Identity`'s errors
   **/
  identity: {
    /**
     * Too many subs-accounts.
     **/
    TooManySubAccounts: GenericPalletError;

    /**
     * Account isn't found.
     **/
    NotFound: GenericPalletError;

    /**
     * Account isn't named.
     **/
    NotNamed: GenericPalletError;

    /**
     * Empty index.
     **/
    EmptyIndex: GenericPalletError;

    /**
     * Fee is changed.
     **/
    FeeChanged: GenericPalletError;

    /**
     * No identity found.
     **/
    NoIdentity: GenericPalletError;

    /**
     * Sticky judgement.
     **/
    StickyJudgement: GenericPalletError;

    /**
     * Judgement given.
     **/
    JudgementGiven: GenericPalletError;

    /**
     * Invalid judgement.
     **/
    InvalidJudgement: GenericPalletError;

    /**
     * The index is invalid.
     **/
    InvalidIndex: GenericPalletError;

    /**
     * The target is invalid.
     **/
    InvalidTarget: GenericPalletError;

    /**
     * Too many additional fields.
     **/
    TooManyFields: GenericPalletError;

    /**
     * Maximum amount of registrars reached. Cannot add any more.
     **/
    TooManyRegistrars: GenericPalletError;

    /**
     * Account ID is already named.
     **/
    AlreadyClaimed: GenericPalletError;

    /**
     * Sender is not a sub-account.
     **/
    NotSub: GenericPalletError;

    /**
     * Sub-account isn't owned by sender.
     **/
    NotOwned: GenericPalletError;

    /**
     * The provided judgement was for a different identity.
     **/
    JudgementForDifferentIdentity: GenericPalletError;

    /**
     * Error that occurs when there is an issue paying for judgement.
     **/
    JudgementPaymentFailed: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Multisig`'s errors
   **/
  multisig: {
    /**
     * Threshold must be 2 or greater.
     **/
    MinimumThreshold: GenericPalletError;

    /**
     * Call is already approved by this signatory.
     **/
    AlreadyApproved: GenericPalletError;

    /**
     * Call doesn't need any (more) approvals.
     **/
    NoApprovalsNeeded: GenericPalletError;

    /**
     * There are too few signatories in the list.
     **/
    TooFewSignatories: GenericPalletError;

    /**
     * There are too many signatories in the list.
     **/
    TooManySignatories: GenericPalletError;

    /**
     * The signatories were provided out of order; they should be ordered.
     **/
    SignatoriesOutOfOrder: GenericPalletError;

    /**
     * The sender was contained in the other signatories; it shouldn't be.
     **/
    SenderInSignatories: GenericPalletError;

    /**
     * Multisig operation not found when attempting to cancel.
     **/
    NotFound: GenericPalletError;

    /**
     * Only the account that originally created the multisig is able to cancel it.
     **/
    NotOwner: GenericPalletError;

    /**
     * No timepoint was given, yet the multisig operation is already underway.
     **/
    NoTimepoint: GenericPalletError;

    /**
     * A different timepoint was given to the multisig operation that is underway.
     **/
    WrongTimepoint: GenericPalletError;

    /**
     * A timepoint was given, yet no multisig operation is underway.
     **/
    UnexpectedTimepoint: GenericPalletError;

    /**
     * The maximum weight information provided was too low.
     **/
    MaxWeightTooLow: GenericPalletError;

    /**
     * The data to be stored is already stored.
     **/
    AlreadyStored: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Proxy`'s errors
   **/
  proxy: {
    /**
     * There are too many proxies registered or too many announcements pending.
     **/
    TooMany: GenericPalletError;

    /**
     * Proxy registration not found.
     **/
    NotFound: GenericPalletError;

    /**
     * Sender is not a proxy of the account to be proxied.
     **/
    NotProxy: GenericPalletError;

    /**
     * A call which is incompatible with the proxy type's filter was attempted.
     **/
    Unproxyable: GenericPalletError;

    /**
     * Account is already a proxy.
     **/
    Duplicate: GenericPalletError;

    /**
     * Call may not be made by proxy because it may escalate its privileges.
     **/
    NoPermission: GenericPalletError;

    /**
     * Announcement, if made at all, was made too recently.
     **/
    Unannounced: GenericPalletError;

    /**
     * Cannot add self as proxy.
     **/
    NoSelfProxy: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `ParachainSystem`'s errors
   **/
  parachainSystem: {
    /**
     * Attempt to upgrade validation function while existing upgrade pending.
     **/
    OverlappingUpgrades: GenericPalletError;

    /**
     * Polkadot currently prohibits this parachain from upgrading its validation function.
     **/
    ProhibitedByPolkadot: GenericPalletError;

    /**
     * The supplied validation function has compiled into a blob larger than Polkadot is
     * willing to run.
     **/
    TooBig: GenericPalletError;

    /**
     * The inherent which supplies the validation data did not run this block.
     **/
    ValidationDataNotAvailable: GenericPalletError;

    /**
     * The inherent which supplies the host configuration did not run this block.
     **/
    HostConfigurationNotAvailable: GenericPalletError;

    /**
     * No validation function upgrade is currently scheduled.
     **/
    NotScheduled: GenericPalletError;

    /**
     * No code upgrade has been authorized.
     **/
    NothingAuthorized: GenericPalletError;

    /**
     * The given code upgrade has not been authorized.
     **/
    Unauthorized: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Balances`'s errors
   **/
  balances: {
    /**
     * Vesting balance too high to send value.
     **/
    VestingBalance: GenericPalletError;

    /**
     * Account liquidity restrictions prevent withdrawal.
     **/
    LiquidityRestrictions: GenericPalletError;

    /**
     * Balance too low to send value.
     **/
    InsufficientBalance: GenericPalletError;

    /**
     * Value too low to create account due to existential deposit.
     **/
    ExistentialDeposit: GenericPalletError;

    /**
     * Transfer/payment would kill account.
     **/
    Expendability: GenericPalletError;

    /**
     * A vesting schedule already exists for this account.
     **/
    ExistingVestingSchedule: GenericPalletError;

    /**
     * Beneficiary account must pre-exist.
     **/
    DeadAccount: GenericPalletError;

    /**
     * Number of named reserves exceed `MaxReserves`.
     **/
    TooManyReserves: GenericPalletError;

    /**
     * Number of holds exceed `MaxHolds`.
     **/
    TooManyHolds: GenericPalletError;

    /**
     * Number of freezes exceed `MaxFreezes`.
     **/
    TooManyFreezes: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Vesting`'s errors
   **/
  vesting: {
    /**
     * The account given is not vesting.
     **/
    NotVesting: GenericPalletError;

    /**
     * The account already has `MaxVestingSchedules` count of schedules and thus
     * cannot add another one. Consider merging existing schedules in order to add another.
     **/
    AtMaxVestingSchedules: GenericPalletError;

    /**
     * Amount being transferred is too low to create a vesting schedule.
     **/
    AmountLow: GenericPalletError;

    /**
     * An index was out of bounds of the vesting schedules.
     **/
    ScheduleIndexOutOfBounds: GenericPalletError;

    /**
     * Failed to create a new schedule because some parameter was invalid.
     **/
    InvalidScheduleParams: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Inflation`'s errors
   **/
  inflation: {
    /**
     * Sum of all parts must be one whole (100%).
     **/
    InvalidInflationParameters: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `DappStaking`'s errors
   **/
  dappStaking: {
    /**
     * Pallet is disabled/in maintenance mode.
     **/
    Disabled: GenericPalletError;

    /**
     * Smart contract already exists within dApp staking protocol.
     **/
    ContractAlreadyExists: GenericPalletError;

    /**
     * Maximum number of smart contracts has been reached.
     **/
    ExceededMaxNumberOfContracts: GenericPalletError;

    /**
     * Not possible to assign a new dApp Id.
     * This should never happen since current type can support up to 65536 - 1 unique dApps.
     **/
    NewDAppIdUnavailable: GenericPalletError;

    /**
     * Specified smart contract does not exist in dApp staking.
     **/
    ContractNotFound: GenericPalletError;

    /**
     * Call origin is not dApp owner.
     **/
    OriginNotOwner: GenericPalletError;

    /**
     * Performing locking or staking with 0 amount.
     **/
    ZeroAmount: GenericPalletError;

    /**
     * Total locked amount for staker is below minimum threshold.
     **/
    LockedAmountBelowThreshold: GenericPalletError;

    /**
     * Account is not allowed to participate in dApp staking due to some external reason (e.g. account is already a collator).
     **/
    AccountNotAvailableForDappStaking: GenericPalletError;

    /**
     * Cannot add additional unlocking chunks due to capacity limit.
     **/
    TooManyUnlockingChunks: GenericPalletError;

    /**
     * Remaining stake prevents entire balance of starting the unlocking process.
     **/
    RemainingStakePreventsFullUnlock: GenericPalletError;

    /**
     * There are no eligible unlocked chunks to claim. This can happen either if no eligible chunks exist, or if user has no chunks at all.
     **/
    NoUnlockedChunksToClaim: GenericPalletError;

    /**
     * There are no unlocking chunks available to relock.
     **/
    NoUnlockingChunks: GenericPalletError;

    /**
     * The amount being staked is too large compared to what's available for staking.
     **/
    UnavailableStakeFunds: GenericPalletError;

    /**
     * There are unclaimed rewards remaining from past eras or periods. They should be claimed before attempting any stake modification again.
     **/
    UnclaimedRewards: GenericPalletError;

    /**
     * An unexpected error occurred while trying to stake.
     **/
    InternalStakeError: GenericPalletError;

    /**
     * Total staked amount on contract is below the minimum required value.
     **/
    InsufficientStakeAmount: GenericPalletError;

    /**
     * Stake operation is rejected since period ends in the next era.
     **/
    PeriodEndsInNextEra: GenericPalletError;

    /**
     * Unstaking is rejected since the period in which past stake was active has passed.
     **/
    UnstakeFromPastPeriod: GenericPalletError;

    /**
     * Unstake amount is greater than the staked amount.
     **/
    UnstakeAmountTooLarge: GenericPalletError;

    /**
     * Account has no staking information for the contract.
     **/
    NoStakingInfo: GenericPalletError;

    /**
     * An unexpected error occurred while trying to unstake.
     **/
    InternalUnstakeError: GenericPalletError;

    /**
     * Rewards are no longer claimable since they are too old.
     **/
    RewardExpired: GenericPalletError;

    /**
     * Reward payout has failed due to an unexpected reason.
     **/
    RewardPayoutFailed: GenericPalletError;

    /**
     * There are no claimable rewards.
     **/
    NoClaimableRewards: GenericPalletError;

    /**
     * An unexpected error occurred while trying to claim staker rewards.
     **/
    InternalClaimStakerError: GenericPalletError;

    /**
     * Account is has no eligible stake amount for bonus reward.
     **/
    NotEligibleForBonusReward: GenericPalletError;

    /**
     * An unexpected error occurred while trying to claim bonus reward.
     **/
    InternalClaimBonusError: GenericPalletError;

    /**
     * Claim era is invalid - it must be in history, and rewards must exist for it.
     **/
    InvalidClaimEra: GenericPalletError;

    /**
     * No dApp tier info exists for the specified era. This can be because era has expired
     * or because during the specified era there were no eligible rewards or protocol wasn't active.
     **/
    NoDAppTierInfo: GenericPalletError;

    /**
     * An unexpected error occurred while trying to claim dApp reward.
     **/
    InternalClaimDAppError: GenericPalletError;

    /**
     * Contract is still active, not unregistered.
     **/
    ContractStillActive: GenericPalletError;

    /**
     * There are too many contract stake entries for the account. This can be cleaned up by either unstaking or cleaning expired entries.
     **/
    TooManyStakedContracts: GenericPalletError;

    /**
     * There are no expired entries to cleanup for the account.
     **/
    NoExpiredEntries: GenericPalletError;

    /**
     * Force call is not allowed in production.
     **/
    ForceNotAllowed: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Assets`'s errors
   **/
  assets: {
    /**
     * Account balance must be greater than or equal to the transfer amount.
     **/
    BalanceLow: GenericPalletError;

    /**
     * The account to alter does not exist.
     **/
    NoAccount: GenericPalletError;

    /**
     * The signing account has no permission to do the operation.
     **/
    NoPermission: GenericPalletError;

    /**
     * The given asset ID is unknown.
     **/
    Unknown: GenericPalletError;

    /**
     * The origin account is frozen.
     **/
    Frozen: GenericPalletError;

    /**
     * The asset ID is already taken.
     **/
    InUse: GenericPalletError;

    /**
     * Invalid witness data given.
     **/
    BadWitness: GenericPalletError;

    /**
     * Minimum balance should be non-zero.
     **/
    MinBalanceZero: GenericPalletError;

    /**
     * Unable to increment the consumer reference counters on the account. Either no provider
     * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
     * fewer then the maximum number of consumers has been reached.
     **/
    UnavailableConsumer: GenericPalletError;

    /**
     * Invalid metadata given.
     **/
    BadMetadata: GenericPalletError;

    /**
     * No approval exists that would allow the transfer.
     **/
    Unapproved: GenericPalletError;

    /**
     * The source account would not survive the transfer and it needs to stay alive.
     **/
    WouldDie: GenericPalletError;

    /**
     * The asset-account already exists.
     **/
    AlreadyExists: GenericPalletError;

    /**
     * The asset-account doesn't have an associated deposit.
     **/
    NoDeposit: GenericPalletError;

    /**
     * The operation would result in funds being burned.
     **/
    WouldBurn: GenericPalletError;

    /**
     * The asset is a live asset and is actively being used. Usually emit for operations such
     * as `start_destroy` which require the asset to be in a destroying state.
     **/
    LiveAsset: GenericPalletError;

    /**
     * The asset is not live, and likely being destroyed.
     **/
    AssetNotLive: GenericPalletError;

    /**
     * The asset status is not the expected status.
     **/
    IncorrectStatus: GenericPalletError;

    /**
     * The asset should be frozen before the given operation.
     **/
    NotFrozen: GenericPalletError;

    /**
     * Callback action resulted in error
     **/
    CallbackFailed: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `CollatorSelection`'s errors
   **/
  collatorSelection: {
    /**
     * Too many candidates
     **/
    TooManyCandidates: GenericPalletError;

    /**
     * Too few candidates
     **/
    TooFewCandidates: GenericPalletError;

    /**
     * Unknown error
     **/
    Unknown: GenericPalletError;

    /**
     * Permission issue
     **/
    Permission: GenericPalletError;

    /**
     * User is already a candidate
     **/
    AlreadyCandidate: GenericPalletError;

    /**
     * User is not a candidate
     **/
    NotCandidate: GenericPalletError;

    /**
     * User is already an Invulnerable
     **/
    AlreadyInvulnerable: GenericPalletError;

    /**
     * Account has no associated validator ID
     **/
    NoAssociatedValidatorId: GenericPalletError;

    /**
     * Validator ID is not yet registered
     **/
    ValidatorNotRegistered: GenericPalletError;

    /**
     * Account is now allowed to be a candidate due to an external reason (e.g. it might be participating in dApp staking)
     **/
    NotAllowedCandidate: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Session`'s errors
   **/
  session: {
    /**
     * Invalid ownership proof.
     **/
    InvalidProof: GenericPalletError;

    /**
     * No associated validator ID for account.
     **/
    NoAssociatedValidatorId: GenericPalletError;

    /**
     * Registered duplicate key.
     **/
    DuplicatedKey: GenericPalletError;

    /**
     * No keys are associated with this account.
     **/
    NoKeys: GenericPalletError;

    /**
     * Key setting account is not live, so it's impossible to associate keys.
     **/
    NoAccount: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `XcmpQueue`'s errors
   **/
  xcmpQueue: {
    /**
     * Failed to send XCM message.
     **/
    FailedToSend: GenericPalletError;

    /**
     * Bad XCM origin.
     **/
    BadXcmOrigin: GenericPalletError;

    /**
     * Bad XCM data.
     **/
    BadXcm: GenericPalletError;

    /**
     * Bad overweight index.
     **/
    BadOverweightIndex: GenericPalletError;

    /**
     * Provided weight is possibly not enough to execute the message.
     **/
    WeightOverLimit: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `PolkadotXcm`'s errors
   **/
  polkadotXcm: {
    /**
     * The desired destination was unreachable, generally because there is a no way of routing
     * to it.
     **/
    Unreachable: GenericPalletError;

    /**
     * There was some other issue (i.e. not to do with routing) in sending the message. Perhaps
     * a lack of space for buffering the message.
     **/
    SendFailure: GenericPalletError;

    /**
     * The message execution fails the filter.
     **/
    Filtered: GenericPalletError;

    /**
     * The message's weight could not be determined.
     **/
    UnweighableMessage: GenericPalletError;

    /**
     * The destination `MultiLocation` provided cannot be inverted.
     **/
    DestinationNotInvertible: GenericPalletError;

    /**
     * The assets to be sent are empty.
     **/
    Empty: GenericPalletError;

    /**
     * Could not re-anchor the assets to declare the fees for the destination chain.
     **/
    CannotReanchor: GenericPalletError;

    /**
     * Too many assets have been attempted for transfer.
     **/
    TooManyAssets: GenericPalletError;

    /**
     * Origin is invalid for sending.
     **/
    InvalidOrigin: GenericPalletError;

    /**
     * The version of the `Versioned` value used is not able to be interpreted.
     **/
    BadVersion: GenericPalletError;

    /**
     * The given location could not be used (e.g. because it cannot be expressed in the
     * desired version of XCM).
     **/
    BadLocation: GenericPalletError;

    /**
     * The referenced subscription could not be found.
     **/
    NoSubscription: GenericPalletError;

    /**
     * The location is invalid since it already has a subscription from us.
     **/
    AlreadySubscribed: GenericPalletError;

    /**
     * Invalid asset for the operation.
     **/
    InvalidAsset: GenericPalletError;

    /**
     * The owner does not own (all) of the asset that they wish to do the operation on.
     **/
    LowBalance: GenericPalletError;

    /**
     * The asset owner has too many locks on the asset.
     **/
    TooManyLocks: GenericPalletError;

    /**
     * The given account is not an identifiable sovereign account for any location.
     **/
    AccountNotSovereign: GenericPalletError;

    /**
     * The operation required fees to be paid which the initiator could not meet.
     **/
    FeesNotMet: GenericPalletError;

    /**
     * A remote lock with the corresponding data could not be found.
     **/
    LockNotFound: GenericPalletError;

    /**
     * The unlock operation cannot succeed because there are still consumers of the lock.
     **/
    InUse: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `CumulusXcm`'s errors
   **/
  cumulusXcm: {
    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `DmpQueue`'s errors
   **/
  dmpQueue: {
    /**
     * The message index given is unknown.
     **/
    Unknown: GenericPalletError;

    /**
     * The amount of weight given is possibly not enough for executing the message.
     **/
    OverLimit: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `XcAssetConfig`'s errors
   **/
  xcAssetConfig: {
    /**
     * Asset is already registered.
     **/
    AssetAlreadyRegistered: GenericPalletError;

    /**
     * Asset does not exist (hasn't been registered).
     **/
    AssetDoesNotExist: GenericPalletError;

    /**
     * Failed to convert to latest versioned MultiLocation
     **/
    MultiLocationNotSupported: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `XTokens`'s errors
   **/
  xTokens: {
    /**
     * Asset has no reserve location.
     **/
    AssetHasNoReserve: GenericPalletError;

    /**
     * Not cross-chain transfer.
     **/
    NotCrossChainTransfer: GenericPalletError;

    /**
     * Invalid transfer destination.
     **/
    InvalidDest: GenericPalletError;

    /**
     * Currency is not cross-chain transferable.
     **/
    NotCrossChainTransferableCurrency: GenericPalletError;

    /**
     * The message's weight could not be determined.
     **/
    UnweighableMessage: GenericPalletError;

    /**
     * XCM execution failed.
     **/
    XcmExecutionFailed: GenericPalletError;

    /**
     * Could not re-anchor the assets to declare the fees for the
     * destination chain.
     **/
    CannotReanchor: GenericPalletError;

    /**
     * Could not get ancestry of asset reserve location.
     **/
    InvalidAncestry: GenericPalletError;

    /**
     * The MultiAsset is invalid.
     **/
    InvalidAsset: GenericPalletError;

    /**
     * The destination `MultiLocation` provided cannot be inverted.
     **/
    DestinationNotInvertible: GenericPalletError;

    /**
     * The version of the `Versioned` value used is not able to be
     * interpreted.
     **/
    BadVersion: GenericPalletError;

    /**
     * We tried sending distinct asset and fee but they have different
     * reserve chains.
     **/
    DistinctReserveForAssetAndFee: GenericPalletError;

    /**
     * The fee is zero.
     **/
    ZeroFee: GenericPalletError;

    /**
     * The transfering asset amount is zero.
     **/
    ZeroAmount: GenericPalletError;

    /**
     * The number of assets to be sent is over the maximum.
     **/
    TooManyAssetsBeingSent: GenericPalletError;

    /**
     * The specified index does not exist in a MultiAssets struct.
     **/
    AssetIndexNonExistent: GenericPalletError;

    /**
     * Fee is not enough.
     **/
    FeeNotEnough: GenericPalletError;

    /**
     * Not supported MultiLocation
     **/
    NotSupportedMultiLocation: GenericPalletError;

    /**
     * MinXcmFee not registered for certain reserve location
     **/
    MinXcmFeeNotDefined: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `EVM`'s errors
   **/
  evm: {
    /**
     * Not enough balance to perform action
     **/
    BalanceLow: GenericPalletError;

    /**
     * Calculating total fee overflowed
     **/
    FeeOverflow: GenericPalletError;

    /**
     * Calculating total payment overflowed
     **/
    PaymentOverflow: GenericPalletError;

    /**
     * Withdraw fee failed
     **/
    WithdrawFailed: GenericPalletError;

    /**
     * Gas price is too low.
     **/
    GasPriceTooLow: GenericPalletError;

    /**
     * Nonce is invalid
     **/
    InvalidNonce: GenericPalletError;

    /**
     * Gas limit is too low.
     **/
    GasLimitTooLow: GenericPalletError;

    /**
     * Gas limit is too high.
     **/
    GasLimitTooHigh: GenericPalletError;

    /**
     * Undefined error.
     **/
    Undefined: GenericPalletError;

    /**
     * EVM reentrancy
     **/
    Reentrancy: GenericPalletError;

    /**
     * EIP-3607,
     **/
    TransactionMustComeFromEOA: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Ethereum`'s errors
   **/
  ethereum: {
    /**
     * Signature is invalid.
     **/
    InvalidSignature: GenericPalletError;

    /**
     * Pre-log is present, therefore transact is not allowed.
     **/
    PreLogExists: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `DynamicEvmBaseFee`'s errors
   **/
  dynamicEvmBaseFee: {
    /**
     * Specified value is outside of the allowed range.
     **/
    ValueOutOfBounds: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Contracts`'s errors
   **/
  contracts: {
    /**
     * A new schedule must have a greater version than the current one.
     **/
    InvalidScheduleVersion: GenericPalletError;

    /**
     * Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`.
     **/
    InvalidCallFlags: GenericPalletError;

    /**
     * The executed contract exhausted its gas limit.
     **/
    OutOfGas: GenericPalletError;

    /**
     * The output buffer supplied to a contract API call was too small.
     **/
    OutputBufferTooSmall: GenericPalletError;

    /**
     * Performing the requested transfer failed. Probably because there isn't enough
     * free balance in the sender's account.
     **/
    TransferFailed: GenericPalletError;

    /**
     * Performing a call was denied because the calling depth reached the limit
     * of what is specified in the schedule.
     **/
    MaxCallDepthReached: GenericPalletError;

    /**
     * No contract was found at the specified address.
     **/
    ContractNotFound: GenericPalletError;

    /**
     * The code supplied to `instantiate_with_code` exceeds the limit specified in the
     * current schedule.
     **/
    CodeTooLarge: GenericPalletError;

    /**
     * No code could be found at the supplied code hash.
     **/
    CodeNotFound: GenericPalletError;

    /**
     * A buffer outside of sandbox memory was passed to a contract API function.
     **/
    OutOfBounds: GenericPalletError;

    /**
     * Input passed to a contract API function failed to decode as expected type.
     **/
    DecodingFailed: GenericPalletError;

    /**
     * Contract trapped during execution.
     **/
    ContractTrapped: GenericPalletError;

    /**
     * The size defined in `T::MaxValueSize` was exceeded.
     **/
    ValueTooLarge: GenericPalletError;

    /**
     * Termination of a contract is not allowed while the contract is already
     * on the call stack. Can be triggered by `seal_terminate`.
     **/
    TerminatedWhileReentrant: GenericPalletError;

    /**
     * `seal_call` forwarded this contracts input. It therefore is no longer available.
     **/
    InputForwarded: GenericPalletError;

    /**
     * The subject passed to `seal_random` exceeds the limit.
     **/
    RandomSubjectTooLong: GenericPalletError;

    /**
     * The amount of topics passed to `seal_deposit_events` exceeds the limit.
     **/
    TooManyTopics: GenericPalletError;

    /**
     * The chain does not provide a chain extension. Calling the chain extension results
     * in this error. Note that this usually shouldn't happen as deploying such contracts
     * is rejected.
     **/
    NoChainExtension: GenericPalletError;

    /**
     * A contract with the same AccountId already exists.
     **/
    DuplicateContract: GenericPalletError;

    /**
     * A contract self destructed in its constructor.
     *
     * This can be triggered by a call to `seal_terminate`.
     **/
    TerminatedInConstructor: GenericPalletError;

    /**
     * A call tried to invoke a contract that is flagged as non-reentrant.
     * The only other cause is that a call from a contract into the runtime tried to call back
     * into `pallet-contracts`. This would make the whole pallet reentrant with regard to
     * contract code execution which is not supported.
     **/
    ReentranceDenied: GenericPalletError;

    /**
     * Origin doesn't have enough balance to pay the required storage deposits.
     **/
    StorageDepositNotEnoughFunds: GenericPalletError;

    /**
     * More storage was created than allowed by the storage deposit limit.
     **/
    StorageDepositLimitExhausted: GenericPalletError;

    /**
     * Code removal was denied because the code is still in use by at least one contract.
     **/
    CodeInUse: GenericPalletError;

    /**
     * The contract ran to completion but decided to revert its storage changes.
     * Please note that this error is only returned from extrinsics. When called directly
     * or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags
     * to determine whether a reversion has taken place.
     **/
    ContractReverted: GenericPalletError;

    /**
     * The contract's code was found to be invalid during validation or instrumentation.
     *
     * The most likely cause of this is that an API was used which is not supported by the
     * node. This happens if an older node is used with a new version of ink!. Try updating
     * your node to the newest available version.
     *
     * A more detailed error can be found on the node console if debug messages are enabled
     * by supplying `-lruntime::contracts=debug`.
     **/
    CodeRejected: GenericPalletError;

    /**
     * An indetermistic code was used in a context where this is not permitted.
     **/
    Indeterministic: GenericPalletError;

    /**
     * A pending migration needs to complete before the extrinsic can be called.
     **/
    MigrationInProgress: GenericPalletError;

    /**
     * Migrate dispatch call was attempted but no migration was performed.
     **/
    NoMigrationPerformed: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Sudo`'s errors
   **/
  sudo: {
    /**
     * Sender must be the Sudo account
     **/
    RequireSudo: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `StaticPriceProvider`'s errors
   **/
  staticPriceProvider: {
    /**
     * Zero is invalid value for the price (hopefully).
     **/
    ZeroPrice: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `DappsStaking`'s errors
   **/
  dappsStaking: {
    /**
     * Disabled
     **/
    Disabled: GenericPalletError;

    /**
     * No change in maintenance mode
     **/
    NoMaintenanceModeChange: GenericPalletError;

    /**
     * Upgrade is too heavy, reduce the weight parameter.
     **/
    UpgradeTooHeavy: GenericPalletError;

    /**
     * Can not stake with zero value.
     **/
    StakingWithNoValue: GenericPalletError;

    /**
     * Can not stake with value less than minimum staking value
     **/
    InsufficientValue: GenericPalletError;

    /**
     * Number of stakers per contract exceeded.
     **/
    MaxNumberOfStakersExceeded: GenericPalletError;

    /**
     * Targets must be operated contracts
     **/
    NotOperatedContract: GenericPalletError;

    /**
     * Contract isn't staked.
     **/
    NotStakedContract: GenericPalletError;

    /**
     * Contract isn't unregistered.
     **/
    NotUnregisteredContract: GenericPalletError;

    /**
     * Unclaimed rewards should be claimed before withdrawing stake.
     **/
    UnclaimedRewardsRemaining: GenericPalletError;

    /**
     * Unstaking a contract with zero value
     **/
    UnstakingWithNoValue: GenericPalletError;

    /**
     * There are no previously unbonded funds that can be unstaked and withdrawn.
     **/
    NothingToWithdraw: GenericPalletError;

    /**
     * The contract is already registered by other account
     **/
    AlreadyRegisteredContract: GenericPalletError;

    /**
     * This account was already used to register contract
     **/
    AlreadyUsedDeveloperAccount: GenericPalletError;

    /**
     * Smart contract not owned by the account id.
     **/
    NotOwnedContract: GenericPalletError;

    /**
     * Report issue on github if this is ever emitted
     **/
    UnknownEraReward: GenericPalletError;

    /**
     * Report issue on github if this is ever emitted
     **/
    UnexpectedStakeInfoEra: GenericPalletError;

    /**
     * Contract has too many unlocking chunks. Withdraw the existing chunks if possible
     * or wait for current chunks to complete unlocking process to withdraw them.
     **/
    TooManyUnlockingChunks: GenericPalletError;

    /**
     * Contract already claimed in this era and reward is distributed
     **/
    AlreadyClaimedInThisEra: GenericPalletError;

    /**
     * Era parameter is out of bounds
     **/
    EraOutOfBounds: GenericPalletError;

    /**
     * Too many active `EraStake` values for (staker, contract) pairing.
     * Claim existing rewards to fix this problem.
     **/
    TooManyEraStakeValues: GenericPalletError;

    /**
     * Account is not actively staking
     **/
    NotActiveStaker: GenericPalletError;

    /**
     * Transfering nomination to the same contract
     **/
    NominationTransferToSameContract: GenericPalletError;

    /**
     * Decommission is in progress so this call is not allowed.
     **/
    DecommissionInProgress: GenericPalletError;

    /**
     * Delegated claim call is not allowed if both the staker & caller are the same accounts.
     **/
    ClaimForCallerAccount: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
}
