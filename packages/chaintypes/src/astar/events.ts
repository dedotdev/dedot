// Generated by @delightfuldot/codegen

import type { GenericChainEvents, GenericPalletEvent } from '@delightfuldot/types';
import type {
  DispatchError,
  AccountId32,
  H256,
  ResultPayload,
  FixedBytes,
  Bytes,
  H160,
  U256,
} from '@delightfuldot/codecs';
import type {
  FrameSupportDispatchDispatchInfo,
  PalletMultisigTimepoint,
  AstarRuntimeProxyType,
  SpWeightsWeightV2Weight,
  FrameSupportTokensMiscBalanceStatus,
  AstarRuntimeSmartContract,
  PalletDappsStakingRewardDestination,
  PalletBlockRewardRewardDistributionConfig,
  XcmV3TraitsError,
  PolkadotParachainPrimitivesId,
  XcmV3TraitsOutcome,
  XcmV3MultilocationMultiLocation,
  XcmV3Xcm,
  XcmV3Response,
  XcmVersionedMultiAssets,
  XcmV3MultiassetMultiAssets,
  XcmVersionedMultiLocation,
  XcmV3MultiassetMultiAsset,
  EthereumLog,
  EvmCoreErrorExitReason,
  PalletContractsOrigin,
} from './types';

export interface ChainEvents extends GenericChainEvents {
  system: {
    /**
     * An extrinsic completed successfully.
     **/
    ExtrinsicSuccess: GenericPalletEvent<
      'System',
      'ExtrinsicSuccess',
      { dispatchInfo: FrameSupportDispatchDispatchInfo }
    >;

    /**
     * An extrinsic failed.
     **/
    ExtrinsicFailed: GenericPalletEvent<
      'System',
      'ExtrinsicFailed',
      { dispatchError: DispatchError; dispatchInfo: FrameSupportDispatchDispatchInfo }
    >;

    /**
     * `:code` was updated.
     **/
    CodeUpdated: GenericPalletEvent<'System', 'CodeUpdated', null>;

    /**
     * A new account was created.
     **/
    NewAccount: GenericPalletEvent<'System', 'NewAccount', { account: AccountId32 }>;

    /**
     * An account was reaped.
     **/
    KilledAccount: GenericPalletEvent<'System', 'KilledAccount', { account: AccountId32 }>;

    /**
     * On on-chain remark happened.
     **/
    Remarked: GenericPalletEvent<'System', 'Remarked', { sender: AccountId32; hash: H256 }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  utility: {
    /**
     * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
     * well as the error.
     **/
    BatchInterrupted: GenericPalletEvent<'Utility', 'BatchInterrupted', { index: number; error: DispatchError }>;

    /**
     * Batch of dispatches completed fully with no error.
     **/
    BatchCompleted: GenericPalletEvent<'Utility', 'BatchCompleted', null>;

    /**
     * Batch of dispatches completed but has errors.
     **/
    BatchCompletedWithErrors: GenericPalletEvent<'Utility', 'BatchCompletedWithErrors', null>;

    /**
     * A single item within a Batch of dispatches has completed with no error.
     **/
    ItemCompleted: GenericPalletEvent<'Utility', 'ItemCompleted', null>;

    /**
     * A single item within a Batch of dispatches has completed with error.
     **/
    ItemFailed: GenericPalletEvent<'Utility', 'ItemFailed', { error: DispatchError }>;

    /**
     * A call was dispatched.
     **/
    DispatchedAs: GenericPalletEvent<'Utility', 'DispatchedAs', { result: ResultPayload<[], DispatchError> }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  identity: {
    /**
     * A name was set or reset (which will remove all judgements).
     **/
    IdentitySet: GenericPalletEvent<'Identity', 'IdentitySet', { who: AccountId32 }>;

    /**
     * A name was cleared, and the given balance returned.
     **/
    IdentityCleared: GenericPalletEvent<'Identity', 'IdentityCleared', { who: AccountId32; deposit: bigint }>;

    /**
     * A name was removed and the given balance slashed.
     **/
    IdentityKilled: GenericPalletEvent<'Identity', 'IdentityKilled', { who: AccountId32; deposit: bigint }>;

    /**
     * A judgement was asked from a registrar.
     **/
    JudgementRequested: GenericPalletEvent<
      'Identity',
      'JudgementRequested',
      { who: AccountId32; registrarIndex: number }
    >;

    /**
     * A judgement request was retracted.
     **/
    JudgementUnrequested: GenericPalletEvent<
      'Identity',
      'JudgementUnrequested',
      { who: AccountId32; registrarIndex: number }
    >;

    /**
     * A judgement was given by a registrar.
     **/
    JudgementGiven: GenericPalletEvent<'Identity', 'JudgementGiven', { target: AccountId32; registrarIndex: number }>;

    /**
     * A registrar was added.
     **/
    RegistrarAdded: GenericPalletEvent<'Identity', 'RegistrarAdded', { registrarIndex: number }>;

    /**
     * A sub-identity was added to an identity and the deposit paid.
     **/
    SubIdentityAdded: GenericPalletEvent<
      'Identity',
      'SubIdentityAdded',
      { sub: AccountId32; main: AccountId32; deposit: bigint }
    >;

    /**
     * A sub-identity was removed from an identity and the deposit freed.
     **/
    SubIdentityRemoved: GenericPalletEvent<
      'Identity',
      'SubIdentityRemoved',
      { sub: AccountId32; main: AccountId32; deposit: bigint }
    >;

    /**
     * A sub-identity was cleared, and the given deposit repatriated from the
     * main identity account to the sub-identity account.
     **/
    SubIdentityRevoked: GenericPalletEvent<
      'Identity',
      'SubIdentityRevoked',
      { sub: AccountId32; main: AccountId32; deposit: bigint }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  multisig: {
    /**
     * A new multisig operation has begun.
     **/
    NewMultisig: GenericPalletEvent<
      'Multisig',
      'NewMultisig',
      { approving: AccountId32; multisig: AccountId32; callHash: FixedBytes<32> }
    >;

    /**
     * A multisig operation has been approved by someone.
     **/
    MultisigApproval: GenericPalletEvent<
      'Multisig',
      'MultisigApproval',
      { approving: AccountId32; timepoint: PalletMultisigTimepoint; multisig: AccountId32; callHash: FixedBytes<32> }
    >;

    /**
     * A multisig operation has been executed.
     **/
    MultisigExecuted: GenericPalletEvent<
      'Multisig',
      'MultisigExecuted',
      {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
        result: ResultPayload<[], DispatchError>;
      }
    >;

    /**
     * A multisig operation has been cancelled.
     **/
    MultisigCancelled: GenericPalletEvent<
      'Multisig',
      'MultisigCancelled',
      { cancelling: AccountId32; timepoint: PalletMultisigTimepoint; multisig: AccountId32; callHash: FixedBytes<32> }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  proxy: {
    /**
     * A proxy was executed correctly, with the given.
     **/
    ProxyExecuted: GenericPalletEvent<'Proxy', 'ProxyExecuted', { result: ResultPayload<[], DispatchError> }>;

    /**
     * A pure account has been created by new proxy with given
     * disambiguation index and proxy type.
     **/
    PureCreated: GenericPalletEvent<
      'Proxy',
      'PureCreated',
      { pure: AccountId32; who: AccountId32; proxyType: AstarRuntimeProxyType; disambiguationIndex: number }
    >;

    /**
     * An announcement was placed to make a call in the future.
     **/
    Announced: GenericPalletEvent<'Proxy', 'Announced', { real: AccountId32; proxy: AccountId32; callHash: H256 }>;

    /**
     * A proxy was added.
     **/
    ProxyAdded: GenericPalletEvent<
      'Proxy',
      'ProxyAdded',
      { delegator: AccountId32; delegatee: AccountId32; proxyType: AstarRuntimeProxyType; delay: number }
    >;

    /**
     * A proxy was removed.
     **/
    ProxyRemoved: GenericPalletEvent<
      'Proxy',
      'ProxyRemoved',
      { delegator: AccountId32; delegatee: AccountId32; proxyType: AstarRuntimeProxyType; delay: number }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  parachainSystem: {
    /**
     * The validation function has been scheduled to apply.
     **/
    ValidationFunctionStored: GenericPalletEvent<'ParachainSystem', 'ValidationFunctionStored', null>;

    /**
     * The validation function was applied as of the contained relay chain block number.
     **/
    ValidationFunctionApplied: GenericPalletEvent<
      'ParachainSystem',
      'ValidationFunctionApplied',
      { relayChainBlockNum: number }
    >;

    /**
     * The relay-chain aborted the upgrade process.
     **/
    ValidationFunctionDiscarded: GenericPalletEvent<'ParachainSystem', 'ValidationFunctionDiscarded', null>;

    /**
     * An upgrade has been authorized.
     **/
    UpgradeAuthorized: GenericPalletEvent<'ParachainSystem', 'UpgradeAuthorized', { codeHash: H256 }>;

    /**
     * Some downward messages have been received and will be processed.
     **/
    DownwardMessagesReceived: GenericPalletEvent<'ParachainSystem', 'DownwardMessagesReceived', { count: number }>;

    /**
     * Downward messages were processed using the given weight.
     **/
    DownwardMessagesProcessed: GenericPalletEvent<
      'ParachainSystem',
      'DownwardMessagesProcessed',
      { weightUsed: SpWeightsWeightV2Weight; dmqHead: H256 }
    >;

    /**
     * An upward message was sent to the relay chain.
     **/
    UpwardMessageSent: GenericPalletEvent<
      'ParachainSystem',
      'UpwardMessageSent',
      { messageHash?: FixedBytes<32> | undefined }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  transactionPayment: {
    /**
     * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
     * has been paid by `who`.
     **/
    TransactionFeePaid: GenericPalletEvent<
      'TransactionPayment',
      'TransactionFeePaid',
      { who: AccountId32; actualFee: bigint; tip: bigint }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  balances: {
    /**
     * An account was created with some free balance.
     **/
    Endowed: GenericPalletEvent<'Balances', 'Endowed', { account: AccountId32; freeBalance: bigint }>;

    /**
     * An account was removed whose balance was non-zero but below ExistentialDeposit,
     * resulting in an outright loss.
     **/
    DustLost: GenericPalletEvent<'Balances', 'DustLost', { account: AccountId32; amount: bigint }>;

    /**
     * Transfer succeeded.
     **/
    Transfer: GenericPalletEvent<'Balances', 'Transfer', { from: AccountId32; to: AccountId32; amount: bigint }>;

    /**
     * A balance was set by root.
     **/
    BalanceSet: GenericPalletEvent<'Balances', 'BalanceSet', { who: AccountId32; free: bigint }>;

    /**
     * Some balance was reserved (moved from free to reserved).
     **/
    Reserved: GenericPalletEvent<'Balances', 'Reserved', { who: AccountId32; amount: bigint }>;

    /**
     * Some balance was unreserved (moved from reserved to free).
     **/
    Unreserved: GenericPalletEvent<'Balances', 'Unreserved', { who: AccountId32; amount: bigint }>;

    /**
     * Some balance was moved from the reserve of the first account to the second account.
     * Final argument indicates the destination balance type.
     **/
    ReserveRepatriated: GenericPalletEvent<
      'Balances',
      'ReserveRepatriated',
      { from: AccountId32; to: AccountId32; amount: bigint; destinationStatus: FrameSupportTokensMiscBalanceStatus }
    >;

    /**
     * Some amount was deposited (e.g. for transaction fees).
     **/
    Deposit: GenericPalletEvent<'Balances', 'Deposit', { who: AccountId32; amount: bigint }>;

    /**
     * Some amount was withdrawn from the account (e.g. for transaction fees).
     **/
    Withdraw: GenericPalletEvent<'Balances', 'Withdraw', { who: AccountId32; amount: bigint }>;

    /**
     * Some amount was removed from the account (e.g. for misbehavior).
     **/
    Slashed: GenericPalletEvent<'Balances', 'Slashed', { who: AccountId32; amount: bigint }>;

    /**
     * Some amount was minted into an account.
     **/
    Minted: GenericPalletEvent<'Balances', 'Minted', { who: AccountId32; amount: bigint }>;

    /**
     * Some amount was burned from an account.
     **/
    Burned: GenericPalletEvent<'Balances', 'Burned', { who: AccountId32; amount: bigint }>;

    /**
     * Some amount was suspended from an account (it can be restored later).
     **/
    Suspended: GenericPalletEvent<'Balances', 'Suspended', { who: AccountId32; amount: bigint }>;

    /**
     * Some amount was restored into an account.
     **/
    Restored: GenericPalletEvent<'Balances', 'Restored', { who: AccountId32; amount: bigint }>;

    /**
     * An account was upgraded.
     **/
    Upgraded: GenericPalletEvent<'Balances', 'Upgraded', { who: AccountId32 }>;

    /**
     * Total issuance was increased by `amount`, creating a credit to be balanced.
     **/
    Issued: GenericPalletEvent<'Balances', 'Issued', { amount: bigint }>;

    /**
     * Total issuance was decreased by `amount`, creating a debt to be balanced.
     **/
    Rescinded: GenericPalletEvent<'Balances', 'Rescinded', { amount: bigint }>;

    /**
     * Some balance was locked.
     **/
    Locked: GenericPalletEvent<'Balances', 'Locked', { who: AccountId32; amount: bigint }>;

    /**
     * Some balance was unlocked.
     **/
    Unlocked: GenericPalletEvent<'Balances', 'Unlocked', { who: AccountId32; amount: bigint }>;

    /**
     * Some balance was frozen.
     **/
    Frozen: GenericPalletEvent<'Balances', 'Frozen', { who: AccountId32; amount: bigint }>;

    /**
     * Some balance was thawed.
     **/
    Thawed: GenericPalletEvent<'Balances', 'Thawed', { who: AccountId32; amount: bigint }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  vesting: {
    /**
     * The amount vested has been updated. This could indicate a change in funds available.
     * The balance given is the amount which is left unvested (and thus locked).
     **/
    VestingUpdated: GenericPalletEvent<'Vesting', 'VestingUpdated', { account: AccountId32; unvested: bigint }>;

    /**
     * An \[account\] has become fully vested.
     **/
    VestingCompleted: GenericPalletEvent<'Vesting', 'VestingCompleted', { account: AccountId32 }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  dappsStaking: {
    /**
     * Account has bonded and staked funds on a smart contract.
     **/
    BondAndStake: GenericPalletEvent<'DappsStaking', 'BondAndStake', [AccountId32, AstarRuntimeSmartContract, bigint]>;

    /**
     * Account has unbonded & unstaked some funds. Unbonding process begins.
     **/
    UnbondAndUnstake: GenericPalletEvent<
      'DappsStaking',
      'UnbondAndUnstake',
      [AccountId32, AstarRuntimeSmartContract, bigint]
    >;

    /**
     * Account has fully withdrawn all staked amount from an unregistered contract.
     **/
    WithdrawFromUnregistered: GenericPalletEvent<
      'DappsStaking',
      'WithdrawFromUnregistered',
      [AccountId32, AstarRuntimeSmartContract, bigint]
    >;

    /**
     * Account has withdrawn unbonded funds.
     **/
    Withdrawn: GenericPalletEvent<'DappsStaking', 'Withdrawn', [AccountId32, bigint]>;

    /**
     * New contract added for staking.
     **/
    NewContract: GenericPalletEvent<'DappsStaking', 'NewContract', [AccountId32, AstarRuntimeSmartContract]>;

    /**
     * Contract removed from dapps staking.
     **/
    ContractRemoved: GenericPalletEvent<'DappsStaking', 'ContractRemoved', [AccountId32, AstarRuntimeSmartContract]>;

    /**
     * New dapps staking era. Distribute era rewards to contracts.
     **/
    NewDappStakingEra: GenericPalletEvent<'DappsStaking', 'NewDappStakingEra', number>;

    /**
     * Reward paid to staker or developer.
     **/
    Reward: GenericPalletEvent<'DappsStaking', 'Reward', [AccountId32, AstarRuntimeSmartContract, number, bigint]>;

    /**
     * Maintenance mode has been enabled or disabled
     **/
    MaintenanceMode: GenericPalletEvent<'DappsStaking', 'MaintenanceMode', boolean>;

    /**
     * Reward handling modified
     **/
    RewardDestination: GenericPalletEvent<
      'DappsStaking',
      'RewardDestination',
      [AccountId32, PalletDappsStakingRewardDestination]
    >;

    /**
     * Nomination part has been transfered from one contract to another.
     *
     * \(staker account, origin smart contract, amount, target smart contract\)
     **/
    NominationTransfer: GenericPalletEvent<
      'DappsStaking',
      'NominationTransfer',
      [AccountId32, AstarRuntimeSmartContract, bigint, AstarRuntimeSmartContract]
    >;

    /**
     * Stale, unclaimed reward from an unregistered contract has been burned.
     *
     * \(developer account, smart contract, era, amount burned\)
     **/
    StaleRewardBurned: GenericPalletEvent<
      'DappsStaking',
      'StaleRewardBurned',
      [AccountId32, AstarRuntimeSmartContract, number, bigint]
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  blockReward: {
    /**
     * Distribution configuration has been updated.
     **/
    DistributionConfigurationChanged: GenericPalletEvent<
      'BlockReward',
      'DistributionConfigurationChanged',
      PalletBlockRewardRewardDistributionConfig
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  assets: {
    /**
     * Some asset class was created.
     **/
    Created: GenericPalletEvent<'Assets', 'Created', { assetId: bigint; creator: AccountId32; owner: AccountId32 }>;

    /**
     * Some assets were issued.
     **/
    Issued: GenericPalletEvent<'Assets', 'Issued', { assetId: bigint; owner: AccountId32; amount: bigint }>;

    /**
     * Some assets were transferred.
     **/
    Transferred: GenericPalletEvent<
      'Assets',
      'Transferred',
      { assetId: bigint; from: AccountId32; to: AccountId32; amount: bigint }
    >;

    /**
     * Some assets were destroyed.
     **/
    Burned: GenericPalletEvent<'Assets', 'Burned', { assetId: bigint; owner: AccountId32; balance: bigint }>;

    /**
     * The management team changed.
     **/
    TeamChanged: GenericPalletEvent<
      'Assets',
      'TeamChanged',
      { assetId: bigint; issuer: AccountId32; admin: AccountId32; freezer: AccountId32 }
    >;

    /**
     * The owner changed.
     **/
    OwnerChanged: GenericPalletEvent<'Assets', 'OwnerChanged', { assetId: bigint; owner: AccountId32 }>;

    /**
     * Some account `who` was frozen.
     **/
    Frozen: GenericPalletEvent<'Assets', 'Frozen', { assetId: bigint; who: AccountId32 }>;

    /**
     * Some account `who` was thawed.
     **/
    Thawed: GenericPalletEvent<'Assets', 'Thawed', { assetId: bigint; who: AccountId32 }>;

    /**
     * Some asset `asset_id` was frozen.
     **/
    AssetFrozen: GenericPalletEvent<'Assets', 'AssetFrozen', { assetId: bigint }>;

    /**
     * Some asset `asset_id` was thawed.
     **/
    AssetThawed: GenericPalletEvent<'Assets', 'AssetThawed', { assetId: bigint }>;

    /**
     * Accounts were destroyed for given asset.
     **/
    AccountsDestroyed: GenericPalletEvent<
      'Assets',
      'AccountsDestroyed',
      { assetId: bigint; accountsDestroyed: number; accountsRemaining: number }
    >;

    /**
     * Approvals were destroyed for given asset.
     **/
    ApprovalsDestroyed: GenericPalletEvent<
      'Assets',
      'ApprovalsDestroyed',
      { assetId: bigint; approvalsDestroyed: number; approvalsRemaining: number }
    >;

    /**
     * An asset class is in the process of being destroyed.
     **/
    DestructionStarted: GenericPalletEvent<'Assets', 'DestructionStarted', { assetId: bigint }>;

    /**
     * An asset class was destroyed.
     **/
    Destroyed: GenericPalletEvent<'Assets', 'Destroyed', { assetId: bigint }>;

    /**
     * Some asset class was force-created.
     **/
    ForceCreated: GenericPalletEvent<'Assets', 'ForceCreated', { assetId: bigint; owner: AccountId32 }>;

    /**
     * New metadata has been set for an asset.
     **/
    MetadataSet: GenericPalletEvent<
      'Assets',
      'MetadataSet',
      { assetId: bigint; name: Bytes; symbol: Bytes; decimals: number; isFrozen: boolean }
    >;

    /**
     * Metadata has been cleared for an asset.
     **/
    MetadataCleared: GenericPalletEvent<'Assets', 'MetadataCleared', { assetId: bigint }>;

    /**
     * (Additional) funds have been approved for transfer to a destination account.
     **/
    ApprovedTransfer: GenericPalletEvent<
      'Assets',
      'ApprovedTransfer',
      { assetId: bigint; source: AccountId32; delegate: AccountId32; amount: bigint }
    >;

    /**
     * An approval for account `delegate` was cancelled by `owner`.
     **/
    ApprovalCancelled: GenericPalletEvent<
      'Assets',
      'ApprovalCancelled',
      { assetId: bigint; owner: AccountId32; delegate: AccountId32 }
    >;

    /**
     * An `amount` was transferred in its entirety from `owner` to `destination` by
     * the approved `delegate`.
     **/
    TransferredApproved: GenericPalletEvent<
      'Assets',
      'TransferredApproved',
      { assetId: bigint; owner: AccountId32; delegate: AccountId32; destination: AccountId32; amount: bigint }
    >;

    /**
     * An asset has had its attributes changed by the `Force` origin.
     **/
    AssetStatusChanged: GenericPalletEvent<'Assets', 'AssetStatusChanged', { assetId: bigint }>;

    /**
     * The min_balance of an asset has been updated by the asset owner.
     **/
    AssetMinBalanceChanged: GenericPalletEvent<
      'Assets',
      'AssetMinBalanceChanged',
      { assetId: bigint; newMinBalance: bigint }
    >;

    /**
     * Some account `who` was created with a deposit from `depositor`.
     **/
    Touched: GenericPalletEvent<'Assets', 'Touched', { assetId: bigint; who: AccountId32; depositor: AccountId32 }>;

    /**
     * Some account `who` was blocked.
     **/
    Blocked: GenericPalletEvent<'Assets', 'Blocked', { assetId: bigint; who: AccountId32 }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  collatorSelection: {
    NewInvulnerables: GenericPalletEvent<'CollatorSelection', 'NewInvulnerables', Array<AccountId32>>;
    NewDesiredCandidates: GenericPalletEvent<'CollatorSelection', 'NewDesiredCandidates', number>;
    NewCandidacyBond: GenericPalletEvent<'CollatorSelection', 'NewCandidacyBond', bigint>;
    CandidateAdded: GenericPalletEvent<'CollatorSelection', 'CandidateAdded', [AccountId32, bigint]>;
    CandidateRemoved: GenericPalletEvent<'CollatorSelection', 'CandidateRemoved', AccountId32>;
    CandidateSlashed: GenericPalletEvent<'CollatorSelection', 'CandidateSlashed', AccountId32>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  session: {
    /**
     * New session has happened. Note that the argument is the session index, not the
     * block number as the type might suggest.
     **/
    NewSession: GenericPalletEvent<'Session', 'NewSession', { sessionIndex: number }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  xcmpQueue: {
    /**
     * Some XCM was executed ok.
     **/
    Success: GenericPalletEvent<
      'XcmpQueue',
      'Success',
      { messageHash?: FixedBytes<32> | undefined; weight: SpWeightsWeightV2Weight }
    >;

    /**
     * Some XCM failed.
     **/
    Fail: GenericPalletEvent<
      'XcmpQueue',
      'Fail',
      { messageHash?: FixedBytes<32> | undefined; error: XcmV3TraitsError; weight: SpWeightsWeightV2Weight }
    >;

    /**
     * Bad XCM version used.
     **/
    BadVersion: GenericPalletEvent<'XcmpQueue', 'BadVersion', { messageHash?: FixedBytes<32> | undefined }>;

    /**
     * Bad XCM format used.
     **/
    BadFormat: GenericPalletEvent<'XcmpQueue', 'BadFormat', { messageHash?: FixedBytes<32> | undefined }>;

    /**
     * An HRMP message was sent to a sibling parachain.
     **/
    XcmpMessageSent: GenericPalletEvent<'XcmpQueue', 'XcmpMessageSent', { messageHash?: FixedBytes<32> | undefined }>;

    /**
     * An XCM exceeded the individual message weight budget.
     **/
    OverweightEnqueued: GenericPalletEvent<
      'XcmpQueue',
      'OverweightEnqueued',
      { sender: PolkadotParachainPrimitivesId; sentAt: number; index: bigint; required: SpWeightsWeightV2Weight }
    >;

    /**
     * An XCM from the overweight queue was executed with the given actual weight used.
     **/
    OverweightServiced: GenericPalletEvent<
      'XcmpQueue',
      'OverweightServiced',
      { index: bigint; used: SpWeightsWeightV2Weight }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  polkadotXcm: {
    /**
     * Execution of an XCM message was attempted.
     *
     * \[ outcome \]
     **/
    Attempted: GenericPalletEvent<'PolkadotXcm', 'Attempted', XcmV3TraitsOutcome>;

    /**
     * A XCM message was sent.
     *
     * \[ origin, destination, message \]
     **/
    Sent: GenericPalletEvent<
      'PolkadotXcm',
      'Sent',
      [XcmV3MultilocationMultiLocation, XcmV3MultilocationMultiLocation, XcmV3Xcm]
    >;

    /**
     * Query response received which does not match a registered query. This may be because a
     * matching query was never registered, it may be because it is a duplicate response, or
     * because the query timed out.
     *
     * \[ origin location, id \]
     **/
    UnexpectedResponse: GenericPalletEvent<
      'PolkadotXcm',
      'UnexpectedResponse',
      [XcmV3MultilocationMultiLocation, bigint]
    >;

    /**
     * Query response has been received and is ready for taking with `take_response`. There is
     * no registered notification call.
     *
     * \[ id, response \]
     **/
    ResponseReady: GenericPalletEvent<'PolkadotXcm', 'ResponseReady', [bigint, XcmV3Response]>;

    /**
     * Query response has been received and query is removed. The registered notification has
     * been dispatched and executed successfully.
     *
     * \[ id, pallet index, call index \]
     **/
    Notified: GenericPalletEvent<'PolkadotXcm', 'Notified', [bigint, number, number]>;

    /**
     * Query response has been received and query is removed. The registered notification could
     * not be dispatched because the dispatch weight is greater than the maximum weight
     * originally budgeted by this runtime for the query result.
     *
     * \[ id, pallet index, call index, actual weight, max budgeted weight \]
     **/
    NotifyOverweight: GenericPalletEvent<
      'PolkadotXcm',
      'NotifyOverweight',
      [bigint, number, number, SpWeightsWeightV2Weight, SpWeightsWeightV2Weight]
    >;

    /**
     * Query response has been received and query is removed. There was a general error with
     * dispatching the notification call.
     *
     * \[ id, pallet index, call index \]
     **/
    NotifyDispatchError: GenericPalletEvent<'PolkadotXcm', 'NotifyDispatchError', [bigint, number, number]>;

    /**
     * Query response has been received and query is removed. The dispatch was unable to be
     * decoded into a `Call`; this might be due to dispatch function having a signature which
     * is not `(origin, QueryId, Response)`.
     *
     * \[ id, pallet index, call index \]
     **/
    NotifyDecodeFailed: GenericPalletEvent<'PolkadotXcm', 'NotifyDecodeFailed', [bigint, number, number]>;

    /**
     * Expected query response has been received but the origin location of the response does
     * not match that expected. The query remains registered for a later, valid, response to
     * be received and acted upon.
     *
     * \[ origin location, id, expected location \]
     **/
    InvalidResponder: GenericPalletEvent<
      'PolkadotXcm',
      'InvalidResponder',
      [XcmV3MultilocationMultiLocation, bigint, XcmV3MultilocationMultiLocation | undefined]
    >;

    /**
     * Expected query response has been received but the expected origin location placed in
     * storage by this runtime previously cannot be decoded. The query remains registered.
     *
     * This is unexpected (since a location placed in storage in a previously executing
     * runtime should be readable prior to query timeout) and dangerous since the possibly
     * valid response will be dropped. Manual governance intervention is probably going to be
     * needed.
     *
     * \[ origin location, id \]
     **/
    InvalidResponderVersion: GenericPalletEvent<
      'PolkadotXcm',
      'InvalidResponderVersion',
      [XcmV3MultilocationMultiLocation, bigint]
    >;

    /**
     * Received query response has been read and removed.
     *
     * \[ id \]
     **/
    ResponseTaken: GenericPalletEvent<'PolkadotXcm', 'ResponseTaken', bigint>;

    /**
     * Some assets have been placed in an asset trap.
     *
     * \[ hash, origin, assets \]
     **/
    AssetsTrapped: GenericPalletEvent<
      'PolkadotXcm',
      'AssetsTrapped',
      [H256, XcmV3MultilocationMultiLocation, XcmVersionedMultiAssets]
    >;

    /**
     * An XCM version change notification message has been attempted to be sent.
     *
     * The cost of sending it (borne by the chain) is included.
     *
     * \[ destination, result, cost \]
     **/
    VersionChangeNotified: GenericPalletEvent<
      'PolkadotXcm',
      'VersionChangeNotified',
      [XcmV3MultilocationMultiLocation, number, XcmV3MultiassetMultiAssets]
    >;

    /**
     * The supported version of a location has been changed. This might be through an
     * automatic notification or a manual intervention.
     *
     * \[ location, XCM version \]
     **/
    SupportedVersionChanged: GenericPalletEvent<
      'PolkadotXcm',
      'SupportedVersionChanged',
      [XcmV3MultilocationMultiLocation, number]
    >;

    /**
     * A given location which had a version change subscription was dropped owing to an error
     * sending the notification to it.
     *
     * \[ location, query ID, error \]
     **/
    NotifyTargetSendFail: GenericPalletEvent<
      'PolkadotXcm',
      'NotifyTargetSendFail',
      [XcmV3MultilocationMultiLocation, bigint, XcmV3TraitsError]
    >;

    /**
     * A given location which had a version change subscription was dropped owing to an error
     * migrating the location to our new XCM format.
     *
     * \[ location, query ID \]
     **/
    NotifyTargetMigrationFail: GenericPalletEvent<
      'PolkadotXcm',
      'NotifyTargetMigrationFail',
      [XcmVersionedMultiLocation, bigint]
    >;

    /**
     * Expected query response has been received but the expected querier location placed in
     * storage by this runtime previously cannot be decoded. The query remains registered.
     *
     * This is unexpected (since a location placed in storage in a previously executing
     * runtime should be readable prior to query timeout) and dangerous since the possibly
     * valid response will be dropped. Manual governance intervention is probably going to be
     * needed.
     *
     * \[ origin location, id \]
     **/
    InvalidQuerierVersion: GenericPalletEvent<
      'PolkadotXcm',
      'InvalidQuerierVersion',
      [XcmV3MultilocationMultiLocation, bigint]
    >;

    /**
     * Expected query response has been received but the querier location of the response does
     * not match the expected. The query remains registered for a later, valid, response to
     * be received and acted upon.
     *
     * \[ origin location, id, expected querier, maybe actual querier \]
     **/
    InvalidQuerier: GenericPalletEvent<
      'PolkadotXcm',
      'InvalidQuerier',
      [
        XcmV3MultilocationMultiLocation,
        bigint,
        XcmV3MultilocationMultiLocation,
        XcmV3MultilocationMultiLocation | undefined,
      ]
    >;

    /**
     * A remote has requested XCM version change notification from us and we have honored it.
     * A version information message is sent to them and its cost is included.
     *
     * \[ destination location, cost \]
     **/
    VersionNotifyStarted: GenericPalletEvent<
      'PolkadotXcm',
      'VersionNotifyStarted',
      [XcmV3MultilocationMultiLocation, XcmV3MultiassetMultiAssets]
    >;

    /**
     * We have requested that a remote chain sends us XCM version change notifications.
     *
     * \[ destination location, cost \]
     **/
    VersionNotifyRequested: GenericPalletEvent<
      'PolkadotXcm',
      'VersionNotifyRequested',
      [XcmV3MultilocationMultiLocation, XcmV3MultiassetMultiAssets]
    >;

    /**
     * We have requested that a remote chain stops sending us XCM version change notifications.
     *
     * \[ destination location, cost \]
     **/
    VersionNotifyUnrequested: GenericPalletEvent<
      'PolkadotXcm',
      'VersionNotifyUnrequested',
      [XcmV3MultilocationMultiLocation, XcmV3MultiassetMultiAssets]
    >;

    /**
     * Fees were paid from a location for an operation (often for using `SendXcm`).
     *
     * \[ paying location, fees \]
     **/
    FeesPaid: GenericPalletEvent<
      'PolkadotXcm',
      'FeesPaid',
      [XcmV3MultilocationMultiLocation, XcmV3MultiassetMultiAssets]
    >;

    /**
     * Some assets have been claimed from an asset trap
     *
     * \[ hash, origin, assets \]
     **/
    AssetsClaimed: GenericPalletEvent<
      'PolkadotXcm',
      'AssetsClaimed',
      [H256, XcmV3MultilocationMultiLocation, XcmVersionedMultiAssets]
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  cumulusXcm: {
    /**
     * Downward message is invalid XCM.
     * \[ id \]
     **/
    InvalidFormat: GenericPalletEvent<'CumulusXcm', 'InvalidFormat', FixedBytes<32>>;

    /**
     * Downward message is unsupported version of XCM.
     * \[ id \]
     **/
    UnsupportedVersion: GenericPalletEvent<'CumulusXcm', 'UnsupportedVersion', FixedBytes<32>>;

    /**
     * Downward message executed with the given outcome.
     * \[ id, outcome \]
     **/
    ExecutedDownward: GenericPalletEvent<'CumulusXcm', 'ExecutedDownward', [FixedBytes<32>, XcmV3TraitsOutcome]>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  dmpQueue: {
    /**
     * Downward message is invalid XCM.
     **/
    InvalidFormat: GenericPalletEvent<'DmpQueue', 'InvalidFormat', { messageId: FixedBytes<32> }>;

    /**
     * Downward message is unsupported version of XCM.
     **/
    UnsupportedVersion: GenericPalletEvent<'DmpQueue', 'UnsupportedVersion', { messageId: FixedBytes<32> }>;

    /**
     * Downward message executed with the given outcome.
     **/
    ExecutedDownward: GenericPalletEvent<
      'DmpQueue',
      'ExecutedDownward',
      { messageId: FixedBytes<32>; outcome: XcmV3TraitsOutcome }
    >;

    /**
     * The weight limit for handling downward messages was reached.
     **/
    WeightExhausted: GenericPalletEvent<
      'DmpQueue',
      'WeightExhausted',
      { messageId: FixedBytes<32>; remainingWeight: SpWeightsWeightV2Weight; requiredWeight: SpWeightsWeightV2Weight }
    >;

    /**
     * Downward message is overweight and was placed in the overweight queue.
     **/
    OverweightEnqueued: GenericPalletEvent<
      'DmpQueue',
      'OverweightEnqueued',
      { messageId: FixedBytes<32>; overweightIndex: bigint; requiredWeight: SpWeightsWeightV2Weight }
    >;

    /**
     * Downward message from the overweight queue was executed.
     **/
    OverweightServiced: GenericPalletEvent<
      'DmpQueue',
      'OverweightServiced',
      { overweightIndex: bigint; weightUsed: SpWeightsWeightV2Weight }
    >;

    /**
     * The maximum number of downward messages was.
     **/
    MaxMessagesExhausted: GenericPalletEvent<'DmpQueue', 'MaxMessagesExhausted', { messageId: FixedBytes<32> }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  xcAssetConfig: {
    /**
     * Registed mapping between asset type and asset Id.
     **/
    AssetRegistered: GenericPalletEvent<
      'XcAssetConfig',
      'AssetRegistered',
      { assetLocation: XcmVersionedMultiLocation; assetId: bigint }
    >;

    /**
     * Changed the amount of units we are charging per execution second for an asset
     **/
    UnitsPerSecondChanged: GenericPalletEvent<
      'XcAssetConfig',
      'UnitsPerSecondChanged',
      { assetLocation: XcmVersionedMultiLocation; unitsPerSecond: bigint }
    >;

    /**
     * Changed the asset type mapping for a given asset id
     **/
    AssetLocationChanged: GenericPalletEvent<
      'XcAssetConfig',
      'AssetLocationChanged',
      { previousAssetLocation: XcmVersionedMultiLocation; assetId: bigint; newAssetLocation: XcmVersionedMultiLocation }
    >;

    /**
     * Supported asset type for fee payment removed.
     **/
    SupportedAssetRemoved: GenericPalletEvent<
      'XcAssetConfig',
      'SupportedAssetRemoved',
      { assetLocation: XcmVersionedMultiLocation }
    >;

    /**
     * Removed all information related to an asset Id
     **/
    AssetRemoved: GenericPalletEvent<
      'XcAssetConfig',
      'AssetRemoved',
      { assetLocation: XcmVersionedMultiLocation; assetId: bigint }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  xTokens: {
    /**
     * Transferred `MultiAsset` with fee.
     **/
    TransferredMultiAssets: GenericPalletEvent<
      'XTokens',
      'TransferredMultiAssets',
      {
        sender: AccountId32;
        assets: XcmV3MultiassetMultiAssets;
        fee: XcmV3MultiassetMultiAsset;
        dest: XcmV3MultilocationMultiLocation;
      }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  evm: {
    /**
     * Ethereum events from contracts.
     **/
    Log: GenericPalletEvent<'EVM', 'Log', { log: EthereumLog }>;

    /**
     * A contract has been created at given address.
     **/
    Created: GenericPalletEvent<'EVM', 'Created', { address: H160 }>;

    /**
     * A contract was attempted to be created, but the execution failed.
     **/
    CreatedFailed: GenericPalletEvent<'EVM', 'CreatedFailed', { address: H160 }>;

    /**
     * A contract has been executed successfully with states applied.
     **/
    Executed: GenericPalletEvent<'EVM', 'Executed', { address: H160 }>;

    /**
     * A contract has been executed with errors. States are reverted with only gas fees applied.
     **/
    ExecutedFailed: GenericPalletEvent<'EVM', 'ExecutedFailed', { address: H160 }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  ethereum: {
    /**
     * An ethereum transaction was successfully executed.
     **/
    Executed: GenericPalletEvent<
      'Ethereum',
      'Executed',
      { from: H160; to: H160; transactionHash: H256; exitReason: EvmCoreErrorExitReason; extraData: Bytes }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  dynamicEvmBaseFee: {
    /**
     * New `base fee per gas` value has been force-set.
     **/
    NewBaseFeePerGas: GenericPalletEvent<'DynamicEvmBaseFee', 'NewBaseFeePerGas', { fee: U256 }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  contracts: {
    /**
     * Contract deployed by address at the specified address.
     **/
    Instantiated: GenericPalletEvent<'Contracts', 'Instantiated', { deployer: AccountId32; contract: AccountId32 }>;

    /**
     * Contract has been removed.
     *
     * # Note
     *
     * The only way for a contract to be removed and emitting this event is by calling
     * `seal_terminate`.
     **/
    Terminated: GenericPalletEvent<
      'Contracts',
      'Terminated',
      {
        /**
         * The contract that was terminated.
         **/
        contract: AccountId32;

        /**
         * The account that received the contracts remaining balance
         **/
        beneficiary: AccountId32;
      }
    >;

    /**
     * Code with the specified hash has been stored.
     **/
    CodeStored: GenericPalletEvent<'Contracts', 'CodeStored', { codeHash: H256 }>;

    /**
     * A custom event emitted by the contract.
     **/
    ContractEmitted: GenericPalletEvent<
      'Contracts',
      'ContractEmitted',
      {
        /**
         * The contract that emitted the event.
         **/
        contract: AccountId32;

        /**
         * Data supplied by the contract. Metadata generated during contract compilation
         * is needed to decode it.
         **/
        data: Bytes;
      }
    >;

    /**
     * A code with the specified hash was removed.
     **/
    CodeRemoved: GenericPalletEvent<'Contracts', 'CodeRemoved', { codeHash: H256 }>;

    /**
     * A contract's code was updated.
     **/
    ContractCodeUpdated: GenericPalletEvent<
      'Contracts',
      'ContractCodeUpdated',
      {
        /**
         * The contract that has been updated.
         **/
        contract: AccountId32;

        /**
         * New code hash that was set for the contract.
         **/
        newCodeHash: H256;

        /**
         * Previous code hash of the contract.
         **/
        oldCodeHash: H256;
      }
    >;

    /**
     * A contract was called either by a plain account or another contract.
     *
     * # Note
     *
     * Please keep in mind that like all events this is only emitted for successful
     * calls. This is because on failure all storage changes including events are
     * rolled back.
     **/
    Called: GenericPalletEvent<
      'Contracts',
      'Called',
      {
        /**
         * The caller of the `contract`.
         **/
        caller: PalletContractsOrigin;

        /**
         * The contract that was called.
         **/
        contract: AccountId32;
      }
    >;

    /**
     * A contract delegate called a code hash.
     *
     * # Note
     *
     * Please keep in mind that like all events this is only emitted for successful
     * calls. This is because on failure all storage changes including events are
     * rolled back.
     **/
    DelegateCalled: GenericPalletEvent<
      'Contracts',
      'DelegateCalled',
      {
        /**
         * The contract that performed the delegate call and hence in whose context
         * the `code_hash` is executed.
         **/
        contract: AccountId32;

        /**
         * The code hash that was delegate called.
         **/
        codeHash: H256;
      }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  sudo: {
    /**
     * A sudo just took place. \[result\]
     **/
    Sudid: GenericPalletEvent<'Sudo', 'Sudid', { sudoResult: ResultPayload<[], DispatchError> }>;

    /**
     * The \[sudoer\] just switched identity; the old key is supplied if one existed.
     **/
    KeyChanged: GenericPalletEvent<'Sudo', 'KeyChanged', { oldSudoer?: AccountId32 | undefined }>;

    /**
     * A sudo just took place. \[result\]
     **/
    SudoAsDone: GenericPalletEvent<'Sudo', 'SudoAsDone', { sudoResult: ResultPayload<[], DispatchError> }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
}
