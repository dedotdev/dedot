// Generated by @dedot/codegen

import type {
  GenericChainTx,
  GenericTxCall,
  ISubmittableExtrinsic,
  ISubmittableResult,
  IRuntimeTxCall,
} from '@dedot/types';
import type {
  MultiAddressLike,
  Extrinsic,
  BytesLike,
  AccountId32Like,
  Data,
  H256,
  FixedBytes,
  H160,
  U256,
  FixedU64,
} from '@dedot/codecs';
import type {
  AstarRuntimeRuntimeCallLike,
  SpRuntimeMultiSignature,
  FrameSystemEventRecord,
  AstarRuntimeOriginCaller,
  SpWeightsWeightV2Weight,
  PalletIdentityIdentityInfo,
  PalletIdentityBitFlags,
  PalletIdentityJudgement,
  PalletMultisigTimepoint,
  AstarRuntimeProxyType,
  CumulusPrimitivesParachainInherentParachainInherentData,
  PalletVestingVestingInfo,
  PalletInflationInflationParameters,
  AstarPrimitivesDappStakingSmartContract,
  PalletDappStakingV3ForcingType,
  AstarRuntimeSessionKeys,
  XcmVersionedMultiLocation,
  XcmVersionedXcm,
  XcmVersionedMultiAssets,
  XcmV3MultilocationMultiLocation,
  XcmV3WeightLimit,
  XcmVersionedMultiAsset,
  EthereumTransactionTransactionV2,
  PalletContractsWasmDeterminism,
  PalletDappsStakingRewardDestination,
  PalletDappsStakingContractStakeInfo,
} from './types';

export type ChainSubmittableExtrinsic<T extends IRuntimeTxCall = AstarRuntimeRuntimeCallLike> = Extrinsic<
  MultiAddressLike,
  T,
  SpRuntimeMultiSignature,
  any[]
> &
  ISubmittableExtrinsic<ISubmittableResult<FrameSystemEventRecord>>;

export type TxCall = (...args: any[]) => ChainSubmittableExtrinsic;

export interface ChainTx extends GenericChainTx<TxCall> {
  /**
   * Pallet `System`'s transaction calls
   **/
  system: {
    /**
     * Make some on-chain remark.
     *
     * - `O(1)`
     *
     * @param {BytesLike} remark
     **/
    remark: GenericTxCall<
      (remark: BytesLike) => ChainSubmittableExtrinsic<{
        pallet: 'System';
        palletCall: {
          name: 'Remark';
          params: { remark: BytesLike };
        };
      }>
    >;

    /**
     * Set the number of pages in the WebAssembly environment's heap.
     *
     * @param {bigint} pages
     **/
    setHeapPages: GenericTxCall<
      (pages: bigint) => ChainSubmittableExtrinsic<{
        pallet: 'System';
        palletCall: {
          name: 'SetHeapPages';
          params: { pages: bigint };
        };
      }>
    >;

    /**
     * Set the new runtime code.
     *
     * @param {BytesLike} code
     **/
    setCode: GenericTxCall<
      (code: BytesLike) => ChainSubmittableExtrinsic<{
        pallet: 'System';
        palletCall: {
          name: 'SetCode';
          params: { code: BytesLike };
        };
      }>
    >;

    /**
     * Set the new runtime code without doing any checks of the given `code`.
     *
     * @param {BytesLike} code
     **/
    setCodeWithoutChecks: GenericTxCall<
      (code: BytesLike) => ChainSubmittableExtrinsic<{
        pallet: 'System';
        palletCall: {
          name: 'SetCodeWithoutChecks';
          params: { code: BytesLike };
        };
      }>
    >;

    /**
     * Set some items of storage.
     *
     * @param {Array<[BytesLike, BytesLike]>} items
     **/
    setStorage: GenericTxCall<
      (items: Array<[BytesLike, BytesLike]>) => ChainSubmittableExtrinsic<{
        pallet: 'System';
        palletCall: {
          name: 'SetStorage';
          params: { items: Array<[BytesLike, BytesLike]> };
        };
      }>
    >;

    /**
     * Kill some items from storage.
     *
     * @param {Array<BytesLike>} keys
     **/
    killStorage: GenericTxCall<
      (keys: Array<BytesLike>) => ChainSubmittableExtrinsic<{
        pallet: 'System';
        palletCall: {
          name: 'KillStorage';
          params: { keys: Array<BytesLike> };
        };
      }>
    >;

    /**
     * Kill all storage items with a key that starts with the given prefix.
     *
     * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     * the prefix we are removing to accurately calculate the weight of this function.
     *
     * @param {BytesLike} prefix
     * @param {number} subkeys
     **/
    killPrefix: GenericTxCall<
      (
        prefix: BytesLike,
        subkeys: number,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'System';
        palletCall: {
          name: 'KillPrefix';
          params: { prefix: BytesLike; subkeys: number };
        };
      }>
    >;

    /**
     * Make some on-chain remark and emit event.
     *
     * @param {BytesLike} remark
     **/
    remarkWithEvent: GenericTxCall<
      (remark: BytesLike) => ChainSubmittableExtrinsic<{
        pallet: 'System';
        palletCall: {
          name: 'RemarkWithEvent';
          params: { remark: BytesLike };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `Utility`'s transaction calls
   **/
  utility: {
    /**
     * Send a batch of dispatch calls.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     *
     * @param {Array<AstarRuntimeRuntimeCallLike>} calls
     **/
    batch: GenericTxCall<
      (calls: Array<AstarRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<{
        pallet: 'Utility';
        palletCall: {
          name: 'Batch';
          params: { calls: Array<AstarRuntimeRuntimeCallLike> };
        };
      }>
    >;

    /**
     * Send a call through an indexed pseudonym of the sender.
     *
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     *
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     *
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {number} index
     * @param {AstarRuntimeRuntimeCallLike} call
     **/
    asDerivative: GenericTxCall<
      (
        index: number,
        call: AstarRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Utility';
        palletCall: {
          name: 'AsDerivative';
          params: { index: number; call: AstarRuntimeRuntimeCallLike };
        };
      }>
    >;

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<AstarRuntimeRuntimeCallLike>} calls
     **/
    batchAll: GenericTxCall<
      (calls: Array<AstarRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<{
        pallet: 'Utility';
        palletCall: {
          name: 'BatchAll';
          params: { calls: Array<AstarRuntimeRuntimeCallLike> };
        };
      }>
    >;

    /**
     * Dispatches a function call with a provided origin.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {AstarRuntimeOriginCaller} asOrigin
     * @param {AstarRuntimeRuntimeCallLike} call
     **/
    dispatchAs: GenericTxCall<
      (
        asOrigin: AstarRuntimeOriginCaller,
        call: AstarRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Utility';
        palletCall: {
          name: 'DispatchAs';
          params: { asOrigin: AstarRuntimeOriginCaller; call: AstarRuntimeRuntimeCallLike };
        };
      }>
    >;

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<AstarRuntimeRuntimeCallLike>} calls
     **/
    forceBatch: GenericTxCall<
      (calls: Array<AstarRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<{
        pallet: 'Utility';
        palletCall: {
          name: 'ForceBatch';
          params: { calls: Array<AstarRuntimeRuntimeCallLike> };
        };
      }>
    >;

    /**
     * Dispatch a function call with a specified weight.
     *
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * @param {AstarRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    withWeight: GenericTxCall<
      (
        call: AstarRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Utility';
        palletCall: {
          name: 'WithWeight';
          params: { call: AstarRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `Identity`'s transaction calls
   **/
  identity: {
    /**
     * Add a registrar to the system.
     *
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     *
     * - `account`: the account of the registrar.
     *
     * Emits `RegistrarAdded` if successful.
     *
     * ## Complexity
     * - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).
     *
     * @param {MultiAddressLike} account
     **/
    addRegistrar: GenericTxCall<
      (account: MultiAddressLike) => ChainSubmittableExtrinsic<{
        pallet: 'Identity';
        palletCall: {
          name: 'AddRegistrar';
          params: { account: MultiAddressLike };
        };
      }>
    >;

    /**
     * Set an account's identity information and reserve the appropriate deposit.
     *
     * If the account already has identity information, the deposit is taken as part payment
     * for the new deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `info`: The identity information.
     *
     * Emits `IdentitySet` if successful.
     *
     * ## Complexity
     * - `O(X + X' + R)`
     * - where `X` additional-field-count (deposit-bounded and code-bounded)
     * - where `R` judgements-count (registrar-count-bounded)
     *
     * @param {PalletIdentityIdentityInfo} info
     **/
    setIdentity: GenericTxCall<
      (info: PalletIdentityIdentityInfo) => ChainSubmittableExtrinsic<{
        pallet: 'Identity';
        palletCall: {
          name: 'SetIdentity';
          params: { info: PalletIdentityIdentityInfo };
        };
      }>
    >;

    /**
     * Set the sub-accounts of the sender.
     *
     * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * - `subs`: The identity's (new) sub-accounts.
     *
     * ## Complexity
     * - `O(P + S)`
     * - where `P` old-subs-count (hard- and deposit-bounded).
     * - where `S` subs-count (hard- and deposit-bounded).
     *
     * @param {Array<[AccountId32Like, Data]>} subs
     **/
    setSubs: GenericTxCall<
      (subs: Array<[AccountId32Like, Data]>) => ChainSubmittableExtrinsic<{
        pallet: 'Identity';
        palletCall: {
          name: 'SetSubs';
          params: { subs: Array<[AccountId32Like, Data]> };
        };
      }>
    >;

    /**
     * Clear an account's identity info and all sub-accounts and return all deposits.
     *
     * Payment: All reserved balances on the account are returned.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * Emits `IdentityCleared` if successful.
     *
     * ## Complexity
     * - `O(R + S + X)`
     * - where `R` registrar-count (governance-bounded).
     * - where `S` subs-count (hard- and deposit-bounded).
     * - where `X` additional-field-count (deposit-bounded and code-bounded).
     *
     **/
    clearIdentity: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'Identity';
        palletCall: {
          name: 'ClearIdentity';
        };
      }>
    >;

    /**
     * Request a judgement from a registrar.
     *
     * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     * given.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is requested.
     * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     *
     * ```nocompile
     * Self::registrars().get(reg_index).unwrap().fee
     * ```
     *
     * Emits `JudgementRequested` if successful.
     *
     * ## Complexity
     * - `O(R + X)`.
     * - where `R` registrar-count (governance-bounded).
     * - where `X` additional-field-count (deposit-bounded and code-bounded).
     *
     * @param {number} regIndex
     * @param {bigint} maxFee
     **/
    requestJudgement: GenericTxCall<
      (
        regIndex: number,
        maxFee: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Identity';
        palletCall: {
          name: 'RequestJudgement';
          params: { regIndex: number; maxFee: bigint };
        };
      }>
    >;

    /**
     * Cancel a previous request.
     *
     * Payment: A previously reserved deposit is returned on success.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is no longer requested.
     *
     * Emits `JudgementUnrequested` if successful.
     *
     * ## Complexity
     * - `O(R + X)`.
     * - where `R` registrar-count (governance-bounded).
     * - where `X` additional-field-count (deposit-bounded and code-bounded).
     *
     * @param {number} regIndex
     **/
    cancelRequest: GenericTxCall<
      (regIndex: number) => ChainSubmittableExtrinsic<{
        pallet: 'Identity';
        palletCall: {
          name: 'CancelRequest';
          params: { regIndex: number };
        };
      }>
    >;

    /**
     * Set the fee required for a judgement to be requested from a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fee`: the new fee.
     *
     * ## Complexity
     * - `O(R)`.
     * - where `R` registrar-count (governance-bounded).
     *
     * @param {number} index
     * @param {bigint} fee
     **/
    setFee: GenericTxCall<
      (
        index: number,
        fee: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Identity';
        palletCall: {
          name: 'SetFee';
          params: { index: number; fee: bigint };
        };
      }>
    >;

    /**
     * Change the account associated with a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     *
     * ## Complexity
     * - `O(R)`.
     * - where `R` registrar-count (governance-bounded).
     *
     * @param {number} index
     * @param {MultiAddressLike} new_
     **/
    setAccountId: GenericTxCall<
      (
        index: number,
        new_: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Identity';
        palletCall: {
          name: 'SetAccountId';
          params: { index: number; new: MultiAddressLike };
        };
      }>
    >;

    /**
     * Set the field information for a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fields`: the fields that the registrar concerns themselves with.
     *
     * ## Complexity
     * - `O(R)`.
     * - where `R` registrar-count (governance-bounded).
     *
     * @param {number} index
     * @param {PalletIdentityBitFlags} fields
     **/
    setFields: GenericTxCall<
      (
        index: number,
        fields: PalletIdentityBitFlags,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Identity';
        palletCall: {
          name: 'SetFields';
          params: { index: number; fields: PalletIdentityBitFlags };
        };
      }>
    >;

    /**
     * Provide a judgement for an account's identity.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     *
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInfo`] for that the judgement is provided.
     *
     * Emits `JudgementGiven` if successful.
     *
     * ## Complexity
     * - `O(R + X)`.
     * - where `R` registrar-count (governance-bounded).
     * - where `X` additional-field-count (deposit-bounded and code-bounded).
     *
     * @param {number} regIndex
     * @param {MultiAddressLike} target
     * @param {PalletIdentityJudgement} judgement
     * @param {H256} identity
     **/
    provideJudgement: GenericTxCall<
      (
        regIndex: number,
        target: MultiAddressLike,
        judgement: PalletIdentityJudgement,
        identity: H256,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Identity';
        palletCall: {
          name: 'ProvideJudgement';
          params: { regIndex: number; target: MultiAddressLike; judgement: PalletIdentityJudgement; identity: H256 };
        };
      }>
    >;

    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     *
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     *
     * The dispatch origin for this call must match `T::ForceOrigin`.
     *
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     *
     * Emits `IdentityKilled` if successful.
     *
     * ## Complexity
     * - `O(R + S + X)`
     * - where `R` registrar-count (governance-bounded).
     * - where `S` subs-count (hard- and deposit-bounded).
     * - where `X` additional-field-count (deposit-bounded and code-bounded).
     *
     * @param {MultiAddressLike} target
     **/
    killIdentity: GenericTxCall<
      (target: MultiAddressLike) => ChainSubmittableExtrinsic<{
        pallet: 'Identity';
        palletCall: {
          name: 'KillIdentity';
          params: { target: MultiAddressLike };
        };
      }>
    >;

    /**
     * Add the given account to the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     * @param {Data} data
     **/
    addSub: GenericTxCall<
      (
        sub: MultiAddressLike,
        data: Data,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Identity';
        palletCall: {
          name: 'AddSub';
          params: { sub: MultiAddressLike; data: Data };
        };
      }>
    >;

    /**
     * Alter the associated name of the given sub-account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     * @param {Data} data
     **/
    renameSub: GenericTxCall<
      (
        sub: MultiAddressLike,
        data: Data,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Identity';
        palletCall: {
          name: 'RenameSub';
          params: { sub: MultiAddressLike; data: Data };
        };
      }>
    >;

    /**
     * Remove the given account from the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     **/
    removeSub: GenericTxCall<
      (sub: MultiAddressLike) => ChainSubmittableExtrinsic<{
        pallet: 'Identity';
        palletCall: {
          name: 'RemoveSub';
          params: { sub: MultiAddressLike };
        };
      }>
    >;

    /**
     * Remove the sender as a sub-account.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender (*not* the original depositor).
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * super-identity.
     *
     * NOTE: This should not normally be used, but is provided in the case that the non-
     * controller of an account is maliciously registered as a sub-account.
     *
     **/
    quitSub: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'Identity';
        palletCall: {
          name: 'QuitSub';
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `Timestamp`'s transaction calls
   **/
  timestamp: {
    /**
     * Set the current time.
     *
     * This call should be invoked exactly once per block. It will panic at the finalization
     * phase, if this call hasn't been invoked by that time.
     *
     * The timestamp should be greater than the previous one by the amount specified by
     * `MinimumPeriod`.
     *
     * The dispatch origin for this call must be `Inherent`.
     *
     * ## Complexity
     * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
     * - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in
     * `on_finalize`)
     * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
     *
     * @param {bigint} now
     **/
    set: GenericTxCall<
      (now: bigint) => ChainSubmittableExtrinsic<{
        pallet: 'Timestamp';
        palletCall: {
          name: 'Set';
          params: { now: bigint };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `Multisig`'s transaction calls
   **/
  multisig: {
    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     *
     * Result is equivalent to the dispatched result.
     *
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     *
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {AstarRuntimeRuntimeCallLike} call
     **/
    asMultiThreshold1: GenericTxCall<
      (
        otherSignatories: Array<AccountId32Like>,
        call: AstarRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Multisig';
        palletCall: {
          name: 'AsMultiThreshold1';
          params: { otherSignatories: Array<AccountId32Like>; call: AstarRuntimeRuntimeCallLike };
        };
      }>
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * If there are enough, then dispatch the call.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     *
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     *
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     *
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {AstarRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    asMulti: GenericTxCall<
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        call: AstarRuntimeRuntimeCallLike,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Multisig';
        palletCall: {
          name: 'AsMulti';
          params: {
            threshold: number;
            otherSignatories: Array<AccountId32Like>;
            maybeTimepoint: PalletMultisigTimepoint | undefined;
            call: AstarRuntimeRuntimeCallLike;
            maxWeight: SpWeightsWeightV2Weight;
          };
        };
      }>
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     *
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {FixedBytes<32>} callHash
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    approveAsMulti: GenericTxCall<
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        callHash: FixedBytes<32>,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Multisig';
        palletCall: {
          name: 'ApproveAsMulti';
          params: {
            threshold: number;
            otherSignatories: Array<AccountId32Like>;
            maybeTimepoint: PalletMultisigTimepoint | undefined;
            callHash: FixedBytes<32>;
            maxWeight: SpWeightsWeightV2Weight;
          };
        };
      }>
    >;

    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint} timepoint
     * @param {FixedBytes<32>} callHash
     **/
    cancelAsMulti: GenericTxCall<
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        timepoint: PalletMultisigTimepoint,
        callHash: FixedBytes<32>,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Multisig';
        palletCall: {
          name: 'CancelAsMulti';
          params: {
            threshold: number;
            otherSignatories: Array<AccountId32Like>;
            timepoint: PalletMultisigTimepoint;
            callHash: FixedBytes<32>;
          };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `Proxy`'s transaction calls
   **/
  proxy: {
    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {AstarRuntimeProxyType | undefined} forceProxyType
     * @param {AstarRuntimeRuntimeCallLike} call
     **/
    proxy: GenericTxCall<
      (
        real: MultiAddressLike,
        forceProxyType: AstarRuntimeProxyType | undefined,
        call: AstarRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Proxy';
        palletCall: {
          name: 'Proxy';
          params: {
            real: MultiAddressLike;
            forceProxyType: AstarRuntimeProxyType | undefined;
            call: AstarRuntimeRuntimeCallLike;
          };
        };
      }>
    >;

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * @param {MultiAddressLike} delegate
     * @param {AstarRuntimeProxyType} proxyType
     * @param {number} delay
     **/
    addProxy: GenericTxCall<
      (
        delegate: MultiAddressLike,
        proxyType: AstarRuntimeProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Proxy';
        palletCall: {
          name: 'AddProxy';
          params: { delegate: MultiAddressLike; proxyType: AstarRuntimeProxyType; delay: number };
        };
      }>
    >;

    /**
     * Unregister a proxy account for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     *
     * @param {MultiAddressLike} delegate
     * @param {AstarRuntimeProxyType} proxyType
     * @param {number} delay
     **/
    removeProxy: GenericTxCall<
      (
        delegate: MultiAddressLike,
        proxyType: AstarRuntimeProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Proxy';
        palletCall: {
          name: 'RemoveProxy';
          params: { delegate: MultiAddressLike; proxyType: AstarRuntimeProxyType; delay: number };
        };
      }>
    >;

    /**
     * Unregister all proxy accounts for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * WARNING: This may be called on accounts created by `pure`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     *
     **/
    removeProxies: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'Proxy';
        palletCall: {
          name: 'RemoveProxies';
        };
      }>
    >;

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     *
     * Requires a `Signed` origin.
     *
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     *
     * Fails if there are insufficient funds to pay for deposit.
     *
     * @param {AstarRuntimeProxyType} proxyType
     * @param {number} delay
     * @param {number} index
     **/
    createPure: GenericTxCall<
      (
        proxyType: AstarRuntimeProxyType,
        delay: number,
        index: number,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Proxy';
        palletCall: {
          name: 'CreatePure';
          params: { proxyType: AstarRuntimeProxyType; delay: number; index: number };
        };
      }>
    >;

    /**
     * Removes a previously spawned pure proxy.
     *
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     *
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     *
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     *
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     *
     * @param {MultiAddressLike} spawner
     * @param {AstarRuntimeProxyType} proxyType
     * @param {number} index
     * @param {number} height
     * @param {number} extIndex
     **/
    killPure: GenericTxCall<
      (
        spawner: MultiAddressLike,
        proxyType: AstarRuntimeProxyType,
        index: number,
        height: number,
        extIndex: number,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Proxy';
        palletCall: {
          name: 'KillPure';
          params: {
            spawner: MultiAddressLike;
            proxyType: AstarRuntimeProxyType;
            index: number;
            height: number;
            extIndex: number;
          };
        };
      }>
    >;

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     *
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     *
     * No more than `MaxPending` announcements may be made at any one time.
     *
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     *
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    announce: GenericTxCall<
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Proxy';
        palletCall: {
          name: 'Announce';
          params: { real: MultiAddressLike; callHash: H256 };
        };
      }>
    >;

    /**
     * Remove a given announcement.
     *
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    removeAnnouncement: GenericTxCall<
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Proxy';
        palletCall: {
          name: 'RemoveAnnouncement';
          params: { real: MultiAddressLike; callHash: H256 };
        };
      }>
    >;

    /**
     * Remove the given announcement of a delegate.
     *
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     *
     * @param {MultiAddressLike} delegate
     * @param {H256} callHash
     **/
    rejectAnnouncement: GenericTxCall<
      (
        delegate: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Proxy';
        palletCall: {
          name: 'RejectAnnouncement';
          params: { delegate: MultiAddressLike; callHash: H256 };
        };
      }>
    >;

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     *
     * Removes any corresponding announcement(s).
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} delegate
     * @param {MultiAddressLike} real
     * @param {AstarRuntimeProxyType | undefined} forceProxyType
     * @param {AstarRuntimeRuntimeCallLike} call
     **/
    proxyAnnounced: GenericTxCall<
      (
        delegate: MultiAddressLike,
        real: MultiAddressLike,
        forceProxyType: AstarRuntimeProxyType | undefined,
        call: AstarRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Proxy';
        palletCall: {
          name: 'ProxyAnnounced';
          params: {
            delegate: MultiAddressLike;
            real: MultiAddressLike;
            forceProxyType: AstarRuntimeProxyType | undefined;
            call: AstarRuntimeRuntimeCallLike;
          };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `ParachainSystem`'s transaction calls
   **/
  parachainSystem: {
    /**
     * Set the current validation data.
     *
     * This should be invoked exactly once per block. It will panic at the finalization
     * phase if the call was not invoked.
     *
     * The dispatch origin for this call must be `Inherent`
     *
     * As a side effect, this function upgrades the current validation function
     * if the appropriate time has come.
     *
     * @param {CumulusPrimitivesParachainInherentParachainInherentData} data
     **/
    setValidationData: GenericTxCall<
      (data: CumulusPrimitivesParachainInherentParachainInherentData) => ChainSubmittableExtrinsic<{
        pallet: 'ParachainSystem';
        palletCall: {
          name: 'SetValidationData';
          params: { data: CumulusPrimitivesParachainInherentParachainInherentData };
        };
      }>
    >;

    /**
     *
     * @param {BytesLike} message
     **/
    sudoSendUpwardMessage: GenericTxCall<
      (message: BytesLike) => ChainSubmittableExtrinsic<{
        pallet: 'ParachainSystem';
        palletCall: {
          name: 'SudoSendUpwardMessage';
          params: { message: BytesLike };
        };
      }>
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * The `check_version` parameter sets a boolean flag for whether or not the runtime's spec
     * version and name should be verified on upgrade. Since the authorization only has a hash,
     * it cannot actually perform the verification.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     * @param {boolean} checkVersion
     **/
    authorizeUpgrade: GenericTxCall<
      (
        codeHash: H256,
        checkVersion: boolean,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'ParachainSystem';
        palletCall: {
          name: 'AuthorizeUpgrade';
          params: { codeHash: H256; checkVersion: boolean };
        };
      }>
    >;

    /**
     * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
     *
     * If the authorization required a version check, this call will ensure the spec name
     * remains unchanged and that the spec version has increased.
     *
     * Note that this function will not apply the new `code`, but only attempt to schedule the
     * upgrade with the Relay Chain.
     *
     * All origins are allowed.
     *
     * @param {BytesLike} code
     **/
    enactAuthorizedUpgrade: GenericTxCall<
      (code: BytesLike) => ChainSubmittableExtrinsic<{
        pallet: 'ParachainSystem';
        palletCall: {
          name: 'EnactAuthorizedUpgrade';
          params: { code: BytesLike };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `ParachainInfo`'s transaction calls
   **/
  parachainInfo: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `Balances`'s transaction calls
   **/
  balances: {
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the transactor.
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferAllowDeath: GenericTxCall<
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Balances';
        palletCall: {
          name: 'TransferAllowDeath';
          params: { dest: MultiAddressLike; value: bigint };
        };
      }>
    >;

    /**
     * Set the regular balance of a given account; it also takes a reserved balance but this
     * must be the same as the account's current reserved balance.
     *
     * The dispatch origin for this call is `root`.
     *
     * WARNING: This call is DEPRECATED! Use `force_set_balance` instead.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} newFree
     * @param {bigint} oldReserved
     **/
    setBalanceDeprecated: GenericTxCall<
      (
        who: MultiAddressLike,
        newFree: bigint,
        oldReserved: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Balances';
        palletCall: {
          name: 'SetBalanceDeprecated';
          params: { who: MultiAddressLike; newFree: bigint; oldReserved: bigint };
        };
      }>
    >;

    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     *
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    forceTransfer: GenericTxCall<
      (
        source: MultiAddressLike,
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Balances';
        palletCall: {
          name: 'ForceTransfer';
          params: { source: MultiAddressLike; dest: MultiAddressLike; value: bigint };
        };
      }>
    >;

    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     *
     * 99% of the time you want [`transfer_allow_death`] instead.
     *
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferKeepAlive: GenericTxCall<
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Balances';
        palletCall: {
          name: 'TransferKeepAlive';
          params: { dest: MultiAddressLike; value: bigint };
        };
      }>
    >;

    /**
     * Transfer the entire transferable balance from the caller account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the account has, causing the sender account to be killed (false), or
     * transfer everything except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     *
     * @param {MultiAddressLike} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      (
        dest: MultiAddressLike,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Balances';
        palletCall: {
          name: 'TransferAll';
          params: { dest: MultiAddressLike; keepAlive: boolean };
        };
      }>
    >;

    /**
     * Unreserve some balance from a user by force.
     *
     * Can only be called by ROOT.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} amount
     **/
    forceUnreserve: GenericTxCall<
      (
        who: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Balances';
        palletCall: {
          name: 'ForceUnreserve';
          params: { who: MultiAddressLike; amount: bigint };
        };
      }>
    >;

    /**
     * Upgrade a specified account.
     *
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     *
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibililty of churn).
     *
     * @param {Array<AccountId32Like>} who
     **/
    upgradeAccounts: GenericTxCall<
      (who: Array<AccountId32Like>) => ChainSubmittableExtrinsic<{
        pallet: 'Balances';
        palletCall: {
          name: 'UpgradeAccounts';
          params: { who: Array<AccountId32Like> };
        };
      }>
    >;

    /**
     * Alias for `transfer_allow_death`, provided only for name-wise compatibility.
     *
     * WARNING: DEPRECATED! Will be released in approximately 3 months.
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transfer: GenericTxCall<
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Balances';
        palletCall: {
          name: 'Transfer';
          params: { dest: MultiAddressLike; value: bigint };
        };
      }>
    >;

    /**
     * Set the regular balance of a given account.
     *
     * The dispatch origin for this call is `root`.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} newFree
     **/
    forceSetBalance: GenericTxCall<
      (
        who: MultiAddressLike,
        newFree: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Balances';
        palletCall: {
          name: 'ForceSetBalance';
          params: { who: MultiAddressLike; newFree: bigint };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `Vesting`'s transaction calls
   **/
  vesting: {
    /**
     * Unlock any vested funds of the sender account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     *
     **/
    vest: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'Vesting';
        palletCall: {
          name: 'Vest';
        };
      }>
    >;

    /**
     * Unlock any vested funds of a `target` account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account whose vested funds should be unlocked. Must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} target
     **/
    vestOther: GenericTxCall<
      (target: MultiAddressLike) => ChainSubmittableExtrinsic<{
        pallet: 'Vesting';
        palletCall: {
          name: 'VestOther';
          params: { target: MultiAddressLike };
        };
      }>
    >;

    /**
     * Create a vested transfer.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account receiving the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     *
     * Emits `VestingCreated`.
     *
     * NOTE: This will unlock all schedules through the current block.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} target
     * @param {PalletVestingVestingInfo} schedule
     **/
    vestedTransfer: GenericTxCall<
      (
        target: MultiAddressLike,
        schedule: PalletVestingVestingInfo,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Vesting';
        palletCall: {
          name: 'VestedTransfer';
          params: { target: MultiAddressLike; schedule: PalletVestingVestingInfo };
        };
      }>
    >;

    /**
     * Force a vested transfer.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `source`: The account whose funds should be transferred.
     * - `target`: The account that should be transferred the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     *
     * Emits `VestingCreated`.
     *
     * NOTE: This will unlock all schedules through the current block.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} target
     * @param {PalletVestingVestingInfo} schedule
     **/
    forceVestedTransfer: GenericTxCall<
      (
        source: MultiAddressLike,
        target: MultiAddressLike,
        schedule: PalletVestingVestingInfo,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Vesting';
        palletCall: {
          name: 'ForceVestedTransfer';
          params: { source: MultiAddressLike; target: MultiAddressLike; schedule: PalletVestingVestingInfo };
        };
      }>
    >;

    /**
     * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
     * the highest possible start and end blocks. If both schedules have already started the
     * current block will be used as the schedule start; with the caveat that if one schedule
     * is finished by the current block, the other will be treated as the new merged schedule,
     * unmodified.
     *
     * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
     * NOTE: This will unlock all schedules through the current block prior to merging.
     * NOTE: If both schedules have ended by the current block, no new schedule will be created
     * and both will be removed.
     *
     * Merged schedule attributes:
     * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
     * current_block)`.
     * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
     * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `schedule1_index`: index of the first schedule to merge.
     * - `schedule2_index`: index of the second schedule to merge.
     *
     * @param {number} schedule1Index
     * @param {number} schedule2Index
     **/
    mergeSchedules: GenericTxCall<
      (
        schedule1Index: number,
        schedule2Index: number,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Vesting';
        palletCall: {
          name: 'MergeSchedules';
          params: { schedule1Index: number; schedule2Index: number };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `Inflation`'s transaction calls
   **/
  inflation: {
    /**
     * Used to force-set the inflation parameters.
     * The parameters must be valid, all parts summing up to one whole (100%), otherwise the call will fail.
     *
     * Must be called by `root` origin.
     *
     * Purpose of the call is testing & handling unforeseen circumstances.
     *
     * @param {PalletInflationInflationParameters} params
     **/
    forceSetInflationParams: GenericTxCall<
      (params: PalletInflationInflationParameters) => ChainSubmittableExtrinsic<{
        pallet: 'Inflation';
        palletCall: {
          name: 'ForceSetInflationParams';
          params: { params: PalletInflationInflationParameters };
        };
      }>
    >;

    /**
     * Used to force inflation recalculation.
     * This is done in the same way as it would be done in an appropriate block, but this call forces it.
     *
     * Must be called by `root` origin.
     *
     * Purpose of the call is testing & handling unforeseen circumstances.
     *
     * @param {number} nextEra
     **/
    forceInflationRecalculation: GenericTxCall<
      (nextEra: number) => ChainSubmittableExtrinsic<{
        pallet: 'Inflation';
        palletCall: {
          name: 'ForceInflationRecalculation';
          params: { nextEra: number };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `DappStaking`'s transaction calls
   **/
  dappStaking: {
    /**
     * Wrapper around _legacy-like_ `unbond_and_unstake`.
     *
     * Used to support legacy Ledger users so they can start the unlocking process for their funds.
     *
     * @param {AstarPrimitivesDappStakingSmartContract} contractId
     * @param {bigint} value
     **/
    unbondAndUnstake: GenericTxCall<
      (
        contractId: AstarPrimitivesDappStakingSmartContract,
        value: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'UnbondAndUnstake';
          params: { contractId: AstarPrimitivesDappStakingSmartContract; value: bigint };
        };
      }>
    >;

    /**
     * Wrapper around _legacy-like_ `withdraw_unbonded`.
     *
     * Used to support legacy Ledger users so they can reclaim unlocked chunks back into
     * their _transferable_ free balance.
     *
     **/
    withdrawUnbonded: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'WithdrawUnbonded';
        };
      }>
    >;

    /**
     * Used to enable or disable maintenance mode.
     * Can only be called by manager origin.
     *
     * @param {boolean} enabled
     **/
    maintenanceMode: GenericTxCall<
      (enabled: boolean) => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'MaintenanceMode';
          params: { enabled: boolean };
        };
      }>
    >;

    /**
     * Used to register a new contract for dApp staking.
     *
     * If successful, smart contract will be assigned a simple, unique numerical identifier.
     * Owner is set to be initial beneficiary & manager of the dApp.
     *
     * @param {AccountId32Like} owner
     * @param {AstarPrimitivesDappStakingSmartContract} smartContract
     **/
    register: GenericTxCall<
      (
        owner: AccountId32Like,
        smartContract: AstarPrimitivesDappStakingSmartContract,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'Register';
          params: { owner: AccountId32Like; smartContract: AstarPrimitivesDappStakingSmartContract };
        };
      }>
    >;

    /**
     * Used to modify the reward beneficiary account for a dApp.
     *
     * Caller has to be dApp owner.
     * If set to `None`, rewards will be deposited to the dApp owner.
     * After this call, all existing & future rewards will be paid out to the beneficiary.
     *
     * @param {AstarPrimitivesDappStakingSmartContract} smartContract
     * @param {AccountId32Like | undefined} beneficiary
     **/
    setDappRewardBeneficiary: GenericTxCall<
      (
        smartContract: AstarPrimitivesDappStakingSmartContract,
        beneficiary: AccountId32Like | undefined,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'SetDappRewardBeneficiary';
          params: { smartContract: AstarPrimitivesDappStakingSmartContract; beneficiary: AccountId32Like | undefined };
        };
      }>
    >;

    /**
     * Used to change dApp owner.
     *
     * Can be called by dApp owner or dApp staking manager origin.
     * This is useful in two cases:
     * 1. when the dApp owner account is compromised, manager can change the owner to a new account
     * 2. if project wants to transfer ownership to a new account (DAO, multisig, etc.).
     *
     * @param {AstarPrimitivesDappStakingSmartContract} smartContract
     * @param {AccountId32Like} newOwner
     **/
    setDappOwner: GenericTxCall<
      (
        smartContract: AstarPrimitivesDappStakingSmartContract,
        newOwner: AccountId32Like,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'SetDappOwner';
          params: { smartContract: AstarPrimitivesDappStakingSmartContract; newOwner: AccountId32Like };
        };
      }>
    >;

    /**
     * Unregister dApp from dApp staking protocol, making it ineligible for future rewards.
     * This doesn't remove the dApp completely from the system just yet, but it can no longer be used for staking.
     *
     * Can be called by dApp staking manager origin.
     *
     * @param {AstarPrimitivesDappStakingSmartContract} smartContract
     **/
    unregister: GenericTxCall<
      (smartContract: AstarPrimitivesDappStakingSmartContract) => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'Unregister';
          params: { smartContract: AstarPrimitivesDappStakingSmartContract };
        };
      }>
    >;

    /**
     * Locks additional funds into dApp staking.
     *
     * In case caller account doesn't have sufficient balance to cover the specified amount, everything is locked.
     * After adjustment, lock amount must be greater than zero and in total must be equal or greater than the minimum locked amount.
     *
     * Locked amount can immediately be used for staking.
     *
     * @param {bigint} amount
     **/
    lock: GenericTxCall<
      (amount: bigint) => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'Lock';
          params: { amount: bigint };
        };
      }>
    >;

    /**
     * Attempts to start the unlocking process for the specified amount.
     *
     * Only the amount that isn't actively used for staking can be unlocked.
     * If the amount is greater than the available amount for unlocking, everything is unlocked.
     * If the remaining locked amount would take the account below the minimum locked amount, everything is unlocked.
     *
     * @param {bigint} amount
     **/
    unlock: GenericTxCall<
      (amount: bigint) => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'Unlock';
          params: { amount: bigint };
        };
      }>
    >;

    /**
     * Claims all of fully unlocked chunks, removing the lock from them.
     *
     **/
    claimUnlocked: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'ClaimUnlocked';
        };
      }>
    >;

    /**
     *
     **/
    relockUnlocking: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'RelockUnlocking';
        };
      }>
    >;

    /**
     * Stake the specified amount on a smart contract.
     * The precise `amount` specified **must** be available for staking.
     * The total amount staked on a dApp must be greater than the minimum required value.
     *
     * Depending on the period type, appropriate stake amount will be updated. During `Voting` subperiod, `voting` stake amount is updated,
     * and same for `Build&Earn` subperiod.
     *
     * Staked amount is only eligible for rewards from the next era onwards.
     *
     * @param {AstarPrimitivesDappStakingSmartContract} smartContract
     * @param {bigint} amount
     **/
    stake: GenericTxCall<
      (
        smartContract: AstarPrimitivesDappStakingSmartContract,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'Stake';
          params: { smartContract: AstarPrimitivesDappStakingSmartContract; amount: bigint };
        };
      }>
    >;

    /**
     * Unstake the specified amount from a smart contract.
     * The `amount` specified **must** not exceed what's staked, otherwise the call will fail.
     *
     * If unstaking the specified `amount` would take staker below the minimum stake threshold, everything is unstaked.
     *
     * Depending on the period type, appropriate stake amount will be updated.
     * In case amount is unstaked during `Voting` subperiod, the `voting` amount is reduced.
     * In case amount is unstaked during `Build&Earn` subperiod, first the `build_and_earn` is reduced,
     * and any spillover is subtracted from the `voting` amount.
     *
     * @param {AstarPrimitivesDappStakingSmartContract} smartContract
     * @param {bigint} amount
     **/
    unstake: GenericTxCall<
      (
        smartContract: AstarPrimitivesDappStakingSmartContract,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'Unstake';
          params: { smartContract: AstarPrimitivesDappStakingSmartContract; amount: bigint };
        };
      }>
    >;

    /**
     * Claims some staker rewards, if user has any.
     * In the case of a successful call, at least one era will be claimed, with the possibility of multiple claims happening.
     *
     **/
    claimStakerRewards: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'ClaimStakerRewards';
        };
      }>
    >;

    /**
     * Used to claim bonus reward for a smart contract, if eligible.
     *
     * @param {AstarPrimitivesDappStakingSmartContract} smartContract
     **/
    claimBonusReward: GenericTxCall<
      (smartContract: AstarPrimitivesDappStakingSmartContract) => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'ClaimBonusReward';
          params: { smartContract: AstarPrimitivesDappStakingSmartContract };
        };
      }>
    >;

    /**
     * Used to claim dApp reward for the specified era.
     *
     * @param {AstarPrimitivesDappStakingSmartContract} smartContract
     * @param {number} era
     **/
    claimDappReward: GenericTxCall<
      (
        smartContract: AstarPrimitivesDappStakingSmartContract,
        era: number,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'ClaimDappReward';
          params: { smartContract: AstarPrimitivesDappStakingSmartContract; era: number };
        };
      }>
    >;

    /**
     * Used to unstake funds from a contract that was unregistered after an account staked on it.
     * This is required if staker wants to re-stake these funds on another active contract during the ongoing period.
     *
     * @param {AstarPrimitivesDappStakingSmartContract} smartContract
     **/
    unstakeFromUnregistered: GenericTxCall<
      (smartContract: AstarPrimitivesDappStakingSmartContract) => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'UnstakeFromUnregistered';
          params: { smartContract: AstarPrimitivesDappStakingSmartContract };
        };
      }>
    >;

    /**
     * Cleanup expired stake entries for the contract.
     *
     * Entry is considered to be expired if:
     * 1. It's from a past period & the account wasn't a loyal staker, meaning there's no claimable bonus reward.
     * 2. It's from a period older than the oldest claimable period, regardless whether the account was loyal or not.
     *
     **/
    cleanupExpiredEntries: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'CleanupExpiredEntries';
        };
      }>
    >;

    /**
     * Used to force a change of era or subperiod.
     * The effect isn't immediate but will happen on the next block.
     *
     * Used for testing purposes, when we want to force an era change, or a subperiod change.
     * Not intended to be used in production, except in case of unforeseen circumstances.
     *
     * Can only be called by manager origin.
     *
     * @param {PalletDappStakingV3ForcingType} forcingType
     **/
    force: GenericTxCall<
      (forcingType: PalletDappStakingV3ForcingType) => ChainSubmittableExtrinsic<{
        pallet: 'DappStaking';
        palletCall: {
          name: 'Force';
          params: { forcingType: PalletDappStakingV3ForcingType };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `Assets`'s transaction calls
   **/
  assets: {
    /**
     * Issue a new class of fungible assets from a public origin.
     *
     * This new asset class has no assets initially and its owner is the origin.
     *
     * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
     *
     * Funds of sender are reserved by `AssetDeposit`.
     *
     * Parameters:
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset.
     * - `admin`: The admin of this class of assets. The admin is the initial address of each
     * member of the asset class's admin team.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `Created` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {MultiAddressLike} admin
     * @param {bigint} minBalance
     **/
    create: GenericTxCall<
      (
        id: bigint,
        admin: MultiAddressLike,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'Create';
          params: { id: bigint; admin: MultiAddressLike; minBalance: bigint };
        };
      }>
    >;

    /**
     * Issue a new class of fungible assets from a privileged origin.
     *
     * This new asset class has no assets initially.
     *
     * The origin must conform to `ForceOrigin`.
     *
     * Unlike `create`, no funds are reserved.
     *
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset.
     * - `owner`: The owner of this class of assets. The owner has full superuser permissions
     * over this asset, but may later change and configure the permissions using
     * `transfer_ownership` and `set_team`.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `ForceCreated` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {MultiAddressLike} owner
     * @param {boolean} isSufficient
     * @param {bigint} minBalance
     **/
    forceCreate: GenericTxCall<
      (
        id: bigint,
        owner: MultiAddressLike,
        isSufficient: boolean,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'ForceCreate';
          params: { id: bigint; owner: MultiAddressLike; isSufficient: boolean; minBalance: bigint };
        };
      }>
    >;

    /**
     * Start the process of destroying a fungible asset class.
     *
     * `start_destroy` is the first in a series of extrinsics that should be called, to allow
     * destruction of an asset class.
     *
     * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * The asset class must be frozen before calling `start_destroy`.
     *
     * @param {bigint} id
     **/
    startDestroy: GenericTxCall<
      (id: bigint) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'StartDestroy';
          params: { id: bigint };
        };
      }>
    >;

    /**
     * Destroy all accounts associated with a given asset.
     *
     * `destroy_accounts` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedAccounts` event.
     *
     * @param {bigint} id
     **/
    destroyAccounts: GenericTxCall<
      (id: bigint) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'DestroyAccounts';
          params: { id: bigint };
        };
      }>
    >;

    /**
     * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
     *
     * `destroy_approvals` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedApprovals` event.
     *
     * @param {bigint} id
     **/
    destroyApprovals: GenericTxCall<
      (id: bigint) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'DestroyApprovals';
          params: { id: bigint };
        };
      }>
    >;

    /**
     * Complete destroying asset and unreserve currency.
     *
     * `finish_destroy` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
     * hand.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each successful call emits the `Event::Destroyed` event.
     *
     * @param {bigint} id
     **/
    finishDestroy: GenericTxCall<
      (id: bigint) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'FinishDestroy';
          params: { id: bigint };
        };
      }>
    >;

    /**
     * Mint assets of a particular class.
     *
     * The origin must be Signed and the sender must be the Issuer of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount minted.
     * - `beneficiary`: The account to be credited with the minted assets.
     * - `amount`: The amount of the asset to be minted.
     *
     * Emits `Issued` event when successful.
     *
     * Weight: `O(1)`
     * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
     *
     * @param {bigint} id
     * @param {MultiAddressLike} beneficiary
     * @param {bigint} amount
     **/
    mint: GenericTxCall<
      (
        id: bigint,
        beneficiary: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'Mint';
          params: { id: bigint; beneficiary: MultiAddressLike; amount: bigint };
        };
      }>
    >;

    /**
     * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
     *
     * Origin must be Signed and the sender should be the Manager of the asset `id`.
     *
     * Bails with `NoAccount` if the `who` is already dead.
     *
     * - `id`: The identifier of the asset to have some amount burned.
     * - `who`: The account to be debited from.
     * - `amount`: The maximum amount by which `who`'s balance should be reduced.
     *
     * Emits `Burned` with the actual amount burned. If this takes the balance to below the
     * minimum for the asset, then the amount burned is increased to take it to zero.
     *
     * Weight: `O(1)`
     * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
     *
     * @param {bigint} id
     * @param {MultiAddressLike} who
     * @param {bigint} amount
     **/
    burn: GenericTxCall<
      (
        id: bigint,
        who: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'Burn';
          params: { id: bigint; who: MultiAddressLike; amount: bigint };
        };
      }>
    >;

    /**
     * Move some assets from the sender account to another.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     *
     * @param {bigint} id
     * @param {MultiAddressLike} target
     * @param {bigint} amount
     **/
    transfer: GenericTxCall<
      (
        id: bigint,
        target: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'Transfer';
          params: { id: bigint; target: MultiAddressLike; amount: bigint };
        };
      }>
    >;

    /**
     * Move some assets from the sender account to another, keeping the sender account alive.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     *
     * @param {bigint} id
     * @param {MultiAddressLike} target
     * @param {bigint} amount
     **/
    transferKeepAlive: GenericTxCall<
      (
        id: bigint,
        target: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'TransferKeepAlive';
          params: { id: bigint; target: MultiAddressLike; amount: bigint };
        };
      }>
    >;

    /**
     * Move some assets from one account to another.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `source`: The account to be debited.
     * - `dest`: The account to be credited.
     * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
     * `dest`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the `source` balance above zero but
     * below the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
     * `dest`.
     *
     * @param {bigint} id
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} dest
     * @param {bigint} amount
     **/
    forceTransfer: GenericTxCall<
      (
        id: bigint,
        source: MultiAddressLike,
        dest: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'ForceTransfer';
          params: { id: bigint; source: MultiAddressLike; dest: MultiAddressLike; amount: bigint };
        };
      }>
    >;

    /**
     * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
     * must already exist as an entry in `Account`s of the asset. If you want to freeze an
     * account that does not have an entry, use `touch_other` first.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {MultiAddressLike} who
     **/
    freeze: GenericTxCall<
      (
        id: bigint,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'Freeze';
          params: { id: bigint; who: MultiAddressLike };
        };
      }>
    >;

    /**
     * Allow unprivileged transfers to and from an account again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be unfrozen.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {MultiAddressLike} who
     **/
    thaw: GenericTxCall<
      (
        id: bigint,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'Thaw';
          params: { id: bigint; who: MultiAddressLike };
        };
      }>
    >;

    /**
     * Disallow further unprivileged transfers for the asset class.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     **/
    freezeAsset: GenericTxCall<
      (id: bigint) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'FreezeAsset';
          params: { id: bigint };
        };
      }>
    >;

    /**
     * Allow unprivileged transfers for the asset again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be thawed.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     **/
    thawAsset: GenericTxCall<
      (id: bigint) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'ThawAsset';
          params: { id: bigint };
        };
      }>
    >;

    /**
     * Change the Owner of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     *
     * Emits `OwnerChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {MultiAddressLike} owner
     **/
    transferOwnership: GenericTxCall<
      (
        id: bigint,
        owner: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'TransferOwnership';
          params: { id: bigint; owner: MultiAddressLike };
        };
      }>
    >;

    /**
     * Change the Issuer, Admin and Freezer of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     *
     * Emits `TeamChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {MultiAddressLike} issuer
     * @param {MultiAddressLike} admin
     * @param {MultiAddressLike} freezer
     **/
    setTeam: GenericTxCall<
      (
        id: bigint,
        issuer: MultiAddressLike,
        admin: MultiAddressLike,
        freezer: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'SetTeam';
          params: { id: bigint; issuer: MultiAddressLike; admin: MultiAddressLike; freezer: MultiAddressLike };
        };
      }>
    >;

    /**
     * Set the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Funds of sender are reserved according to the formula:
     * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
     * account any already reserved funds.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {BytesLike} name
     * @param {BytesLike} symbol
     * @param {number} decimals
     **/
    setMetadata: GenericTxCall<
      (
        id: bigint,
        name: BytesLike,
        symbol: BytesLike,
        decimals: number,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'SetMetadata';
          params: { id: bigint; name: BytesLike; symbol: BytesLike; decimals: number };
        };
      }>
    >;

    /**
     * Clear the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Any deposit is freed for the asset owner.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     **/
    clearMetadata: GenericTxCall<
      (id: bigint) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'ClearMetadata';
          params: { id: bigint };
        };
      }>
    >;

    /**
     * Force the metadata for an asset to some value.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is left alone.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
     *
     * @param {bigint} id
     * @param {BytesLike} name
     * @param {BytesLike} symbol
     * @param {number} decimals
     * @param {boolean} isFrozen
     **/
    forceSetMetadata: GenericTxCall<
      (
        id: bigint,
        name: BytesLike,
        symbol: BytesLike,
        decimals: number,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'ForceSetMetadata';
          params: { id: bigint; name: BytesLike; symbol: BytesLike; decimals: number; isFrozen: boolean };
        };
      }>
    >;

    /**
     * Clear the metadata for an asset.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is returned.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     **/
    forceClearMetadata: GenericTxCall<
      (id: bigint) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'ForceClearMetadata';
          params: { id: bigint };
        };
      }>
    >;

    /**
     * Alter the attributes of a given asset.
     *
     * Origin must be `ForceOrigin`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
     * value to account for the state bloat associated with its balance storage. If set to
     * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
     * an ED in the Balances pallet or whatever else is used to control user-account state
     * growth).
     * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
     * instructions.
     *
     * Emits `AssetStatusChanged` with the identity of the asset.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} issuer
     * @param {MultiAddressLike} admin
     * @param {MultiAddressLike} freezer
     * @param {bigint} minBalance
     * @param {boolean} isSufficient
     * @param {boolean} isFrozen
     **/
    forceAssetStatus: GenericTxCall<
      (
        id: bigint,
        owner: MultiAddressLike,
        issuer: MultiAddressLike,
        admin: MultiAddressLike,
        freezer: MultiAddressLike,
        minBalance: bigint,
        isSufficient: boolean,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'ForceAssetStatus';
          params: {
            id: bigint;
            owner: MultiAddressLike;
            issuer: MultiAddressLike;
            admin: MultiAddressLike;
            freezer: MultiAddressLike;
            minBalance: bigint;
            isSufficient: boolean;
            isFrozen: boolean;
          };
        };
      }>
    >;

    /**
     * Approve an amount of asset for transfer by a delegated third-party account.
     *
     * Origin must be Signed.
     *
     * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
     * for the purpose of holding the approval. If some non-zero amount of assets is already
     * approved from signing account to `delegate`, then it is topped up or unreserved to
     * meet the right value.
     *
     * NOTE: The signing account does not need to own `amount` of assets at the point of
     * making this call.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account to delegate permission to transfer asset.
     * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
     * already an approval in place, then this acts additively.
     *
     * Emits `ApprovedTransfer` on success.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {MultiAddressLike} delegate
     * @param {bigint} amount
     **/
    approveTransfer: GenericTxCall<
      (
        id: bigint,
        delegate: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'ApproveTransfer';
          params: { id: bigint; delegate: MultiAddressLike; amount: bigint };
        };
      }>
    >;

    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be Signed and there must be an approval in place between signer and
     * `delegate`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {MultiAddressLike} delegate
     **/
    cancelApproval: GenericTxCall<
      (
        id: bigint,
        delegate: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'CancelApproval';
          params: { id: bigint; delegate: MultiAddressLike };
        };
      }>
    >;

    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
     * account of the asset `id`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} delegate
     **/
    forceCancelApproval: GenericTxCall<
      (
        id: bigint,
        owner: MultiAddressLike,
        delegate: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'ForceCancelApproval';
          params: { id: bigint; owner: MultiAddressLike; delegate: MultiAddressLike };
        };
      }>
    >;

    /**
     * Transfer some asset balance from a previously delegated account to some third-party
     * account.
     *
     * Origin must be Signed and there must be an approval in place by the `owner` to the
     * signer.
     *
     * If the entire amount approved for transfer is transferred, then any deposit previously
     * reserved by `approve_transfer` is unreserved.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The account which previously approved for a transfer of at least `amount` and
     * from which the asset balance will be withdrawn.
     * - `destination`: The account to which the asset balance of `amount` will be transferred.
     * - `amount`: The amount of assets to transfer.
     *
     * Emits `TransferredApproved` on success.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} destination
     * @param {bigint} amount
     **/
    transferApproved: GenericTxCall<
      (
        id: bigint,
        owner: MultiAddressLike,
        destination: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'TransferApproved';
          params: { id: bigint; owner: MultiAddressLike; destination: MultiAddressLike; amount: bigint };
        };
      }>
    >;

    /**
     * Create an asset account for non-provider assets.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
     * to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     *
     * Emits `Touched` event when successful.
     *
     * @param {bigint} id
     **/
    touch: GenericTxCall<
      (id: bigint) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'Touch';
          params: { id: bigint };
        };
      }>
    >;

    /**
     * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
     * account.
     *
     * The origin must be Signed.
     *
     * - `id`: The identifier of the asset for which the caller would like the deposit
     * refunded.
     * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
     *
     * Emits `Refunded` event when successful.
     *
     * @param {bigint} id
     * @param {boolean} allowBurn
     **/
    refund: GenericTxCall<
      (
        id: bigint,
        allowBurn: boolean,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'Refund';
          params: { id: bigint; allowBurn: boolean };
        };
      }>
    >;

    /**
     * Sets the minimum balance of an asset.
     *
     * Only works if there aren't any accounts that are holding the asset or if
     * the new value of `min_balance` is less than the old one.
     *
     * Origin must be Signed and the sender has to be the Owner of the
     * asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `min_balance`: The new value of `min_balance`.
     *
     * Emits `AssetMinBalanceChanged` event when successful.
     *
     * @param {bigint} id
     * @param {bigint} minBalance
     **/
    setMinBalance: GenericTxCall<
      (
        id: bigint,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'SetMinBalance';
          params: { id: bigint; minBalance: bigint };
        };
      }>
    >;

    /**
     * Create an asset account for `who`.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
     * must have sufficient funds for a deposit to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     * - `who`: The account to be created.
     *
     * Emits `Touched` event when successful.
     *
     * @param {bigint} id
     * @param {MultiAddressLike} who
     **/
    touchOther: GenericTxCall<
      (
        id: bigint,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'TouchOther';
          params: { id: bigint; who: MultiAddressLike };
        };
      }>
    >;

    /**
     * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
     *
     * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
     * order to burn a non-zero balance of the asset, the caller must be the account and should
     * use `refund`.
     *
     * - `id`: The identifier of the asset for the account holding a deposit.
     * - `who`: The account to refund.
     *
     * Emits `Refunded` event when successful.
     *
     * @param {bigint} id
     * @param {MultiAddressLike} who
     **/
    refundOther: GenericTxCall<
      (
        id: bigint,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'RefundOther';
          params: { id: bigint; who: MultiAddressLike };
        };
      }>
    >;

    /**
     * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the account's asset.
     * - `who`: The account to be unblocked.
     *
     * Emits `Blocked`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {MultiAddressLike} who
     **/
    block: GenericTxCall<
      (
        id: bigint,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Assets';
        palletCall: {
          name: 'Block';
          params: { id: bigint; who: MultiAddressLike };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `CollatorSelection`'s transaction calls
   **/
  collatorSelection: {
    /**
     * Set the list of invulnerable (fixed) collators.
     *
     * @param {Array<AccountId32Like>} new_
     **/
    setInvulnerables: GenericTxCall<
      (new_: Array<AccountId32Like>) => ChainSubmittableExtrinsic<{
        pallet: 'CollatorSelection';
        palletCall: {
          name: 'SetInvulnerables';
          params: { new: Array<AccountId32Like> };
        };
      }>
    >;

    /**
     * Set the ideal number of collators (not including the invulnerables).
     * If lowering this number, then the number of running collators could be higher than this figure.
     * Aside from that edge case, there should be no other way to have more collators than the desired number.
     *
     * @param {number} max
     **/
    setDesiredCandidates: GenericTxCall<
      (max: number) => ChainSubmittableExtrinsic<{
        pallet: 'CollatorSelection';
        palletCall: {
          name: 'SetDesiredCandidates';
          params: { max: number };
        };
      }>
    >;

    /**
     * Set the candidacy bond amount.
     *
     * @param {bigint} bond
     **/
    setCandidacyBond: GenericTxCall<
      (bond: bigint) => ChainSubmittableExtrinsic<{
        pallet: 'CollatorSelection';
        palletCall: {
          name: 'SetCandidacyBond';
          params: { bond: bigint };
        };
      }>
    >;

    /**
     * Register this account as a collator candidate. The account must (a) already have
     * registered session keys and (b) be able to reserve the `CandidacyBond`.
     *
     * This call is not available to `Invulnerable` collators.
     *
     **/
    registerAsCandidate: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'CollatorSelection';
        palletCall: {
          name: 'RegisterAsCandidate';
        };
      }>
    >;

    /**
     * Deregister `origin` as a collator candidate. Note that the collator can only leave on
     * session change. The `CandidacyBond` will be unreserved immediately.
     *
     * This call will fail if the total number of candidates would drop below `MinCandidates`.
     *
     * This call is not available to `Invulnerable` collators.
     *
     **/
    leaveIntent: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'CollatorSelection';
        palletCall: {
          name: 'LeaveIntent';
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `Session`'s transaction calls
   **/
  session: {
    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be signed.
     *
     * ## Complexity
     * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
     * fixed.
     *
     * @param {AstarRuntimeSessionKeys} keys
     * @param {BytesLike} proof
     **/
    setKeys: GenericTxCall<
      (
        keys: AstarRuntimeSessionKeys,
        proof: BytesLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Session';
        palletCall: {
          name: 'SetKeys';
          params: { keys: AstarRuntimeSessionKeys; proof: BytesLike };
        };
      }>
    >;

    /**
     * Removes any session key(s) of the function caller.
     *
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be Signed and the account must be either be
     * convertible to a validator ID using the chain's typical addressing system (this usually
     * means being a controller account) or directly convertible into a validator ID (which
     * usually means being a stash account).
     *
     * ## Complexity
     * - `O(1)` in number of key types. Actual cost depends on the number of length of
     * `T::Keys::key_ids()` which is fixed.
     *
     **/
    purgeKeys: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'Session';
        palletCall: {
          name: 'PurgeKeys';
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `XcmpQueue`'s transaction calls
   **/
  xcmpQueue: {
    /**
     * Services a single overweight XCM.
     *
     * - `origin`: Must pass `ExecuteOverweightOrigin`.
     * - `index`: The index of the overweight XCM to service
     * - `weight_limit`: The amount of weight that XCM execution may take.
     *
     * Errors:
     * - `BadOverweightIndex`: XCM under `index` is not found in the `Overweight` storage map.
     * - `BadXcm`: XCM under `index` cannot be properly decoded into a valid XCM format.
     * - `WeightOverLimit`: XCM execution may use greater `weight_limit`.
     *
     * Events:
     * - `OverweightServiced`: On success.
     *
     * @param {bigint} index
     * @param {SpWeightsWeightV2Weight} weightLimit
     **/
    serviceOverweight: GenericTxCall<
      (
        index: bigint,
        weightLimit: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'XcmpQueue';
        palletCall: {
          name: 'ServiceOverweight';
          params: { index: bigint; weightLimit: SpWeightsWeightV2Weight };
        };
      }>
    >;

    /**
     * Suspends all XCM executions for the XCMP queue, regardless of the sender's origin.
     *
     * - `origin`: Must pass `ControllerOrigin`.
     *
     **/
    suspendXcmExecution: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'XcmpQueue';
        palletCall: {
          name: 'SuspendXcmExecution';
        };
      }>
    >;

    /**
     * Resumes all XCM executions for the XCMP queue.
     *
     * Note that this function doesn't change the status of the in/out bound channels.
     *
     * - `origin`: Must pass `ControllerOrigin`.
     *
     **/
    resumeXcmExecution: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'XcmpQueue';
        palletCall: {
          name: 'ResumeXcmExecution';
        };
      }>
    >;

    /**
     * Overwrites the number of pages of messages which must be in the queue for the other side to be told to
     * suspend their sending.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.suspend_value`
     *
     * @param {number} new_
     **/
    updateSuspendThreshold: GenericTxCall<
      (new_: number) => ChainSubmittableExtrinsic<{
        pallet: 'XcmpQueue';
        palletCall: {
          name: 'UpdateSuspendThreshold';
          params: { new: number };
        };
      }>
    >;

    /**
     * Overwrites the number of pages of messages which must be in the queue after which we drop any further
     * messages from the channel.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.drop_threshold`
     *
     * @param {number} new_
     **/
    updateDropThreshold: GenericTxCall<
      (new_: number) => ChainSubmittableExtrinsic<{
        pallet: 'XcmpQueue';
        palletCall: {
          name: 'UpdateDropThreshold';
          params: { new: number };
        };
      }>
    >;

    /**
     * Overwrites the number of pages of messages which the queue must be reduced to before it signals that
     * message sending may recommence after it has been suspended.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.resume_threshold`
     *
     * @param {number} new_
     **/
    updateResumeThreshold: GenericTxCall<
      (new_: number) => ChainSubmittableExtrinsic<{
        pallet: 'XcmpQueue';
        palletCall: {
          name: 'UpdateResumeThreshold';
          params: { new: number };
        };
      }>
    >;

    /**
     * Overwrites the amount of remaining weight under which we stop processing messages.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.threshold_weight`
     *
     * @param {SpWeightsWeightV2Weight} new_
     **/
    updateThresholdWeight: GenericTxCall<
      (new_: SpWeightsWeightV2Weight) => ChainSubmittableExtrinsic<{
        pallet: 'XcmpQueue';
        palletCall: {
          name: 'UpdateThresholdWeight';
          params: { new: SpWeightsWeightV2Weight };
        };
      }>
    >;

    /**
     * Overwrites the speed to which the available weight approaches the maximum weight.
     * A lower number results in a faster progression. A value of 1 makes the entire weight available initially.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.weight_restrict_decay`.
     *
     * @param {SpWeightsWeightV2Weight} new_
     **/
    updateWeightRestrictDecay: GenericTxCall<
      (new_: SpWeightsWeightV2Weight) => ChainSubmittableExtrinsic<{
        pallet: 'XcmpQueue';
        palletCall: {
          name: 'UpdateWeightRestrictDecay';
          params: { new: SpWeightsWeightV2Weight };
        };
      }>
    >;

    /**
     * Overwrite the maximum amount of weight any individual message may consume.
     * Messages above this weight go into the overweight queue and may only be serviced explicitly.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.xcmp_max_individual_weight`.
     *
     * @param {SpWeightsWeightV2Weight} new_
     **/
    updateXcmpMaxIndividualWeight: GenericTxCall<
      (new_: SpWeightsWeightV2Weight) => ChainSubmittableExtrinsic<{
        pallet: 'XcmpQueue';
        palletCall: {
          name: 'UpdateXcmpMaxIndividualWeight';
          params: { new: SpWeightsWeightV2Weight };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `PolkadotXcm`'s transaction calls
   **/
  polkadotXcm: {
    /**
     *
     * @param {XcmVersionedMultiLocation} dest
     * @param {XcmVersionedXcm} message
     **/
    send: GenericTxCall<
      (
        dest: XcmVersionedMultiLocation,
        message: XcmVersionedXcm,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'PolkadotXcm';
        palletCall: {
          name: 'Send';
          params: { dest: XcmVersionedMultiLocation; message: XcmVersionedXcm };
        };
      }>
    >;

    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     * from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     * an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     * `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     *
     * @param {XcmVersionedMultiLocation} dest
     * @param {XcmVersionedMultiLocation} beneficiary
     * @param {XcmVersionedMultiAssets} assets
     * @param {number} feeAssetItem
     **/
    teleportAssets: GenericTxCall<
      (
        dest: XcmVersionedMultiLocation,
        beneficiary: XcmVersionedMultiLocation,
        assets: XcmVersionedMultiAssets,
        feeAssetItem: number,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'PolkadotXcm';
        palletCall: {
          name: 'TeleportAssets';
          params: {
            dest: XcmVersionedMultiLocation;
            beneficiary: XcmVersionedMultiLocation;
            assets: XcmVersionedMultiAssets;
            feeAssetItem: number;
          };
        };
      }>
    >;

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     * from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     * an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     * `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     *
     * @param {XcmVersionedMultiLocation} dest
     * @param {XcmVersionedMultiLocation} beneficiary
     * @param {XcmVersionedMultiAssets} assets
     * @param {number} feeAssetItem
     **/
    reserveTransferAssets: GenericTxCall<
      (
        dest: XcmVersionedMultiLocation,
        beneficiary: XcmVersionedMultiLocation,
        assets: XcmVersionedMultiAssets,
        feeAssetItem: number,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'PolkadotXcm';
        palletCall: {
          name: 'ReserveTransferAssets';
          params: {
            dest: XcmVersionedMultiLocation;
            beneficiary: XcmVersionedMultiLocation;
            assets: XcmVersionedMultiAssets;
            feeAssetItem: number;
          };
        };
      }>
    >;

    /**
     * Execute an XCM message from a local, signed, origin.
     *
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     *
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     *
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     *
     * @param {XcmVersionedXcm} message
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    execute: GenericTxCall<
      (
        message: XcmVersionedXcm,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'PolkadotXcm';
        palletCall: {
          name: 'Execute';
          params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight };
        };
      }>
    >;

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     *
     * @param {XcmV3MultilocationMultiLocation} location
     * @param {number} xcmVersion
     **/
    forceXcmVersion: GenericTxCall<
      (
        location: XcmV3MultilocationMultiLocation,
        xcmVersion: number,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'PolkadotXcm';
        palletCall: {
          name: 'ForceXcmVersion';
          params: { location: XcmV3MultilocationMultiLocation; xcmVersion: number };
        };
      }>
    >;

    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     *
     * @param {number | undefined} maybeXcmVersion
     **/
    forceDefaultXcmVersion: GenericTxCall<
      (maybeXcmVersion: number | undefined) => ChainSubmittableExtrinsic<{
        pallet: 'PolkadotXcm';
        palletCall: {
          name: 'ForceDefaultXcmVersion';
          params: { maybeXcmVersion: number | undefined };
        };
      }>
    >;

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     *
     * @param {XcmVersionedMultiLocation} location
     **/
    forceSubscribeVersionNotify: GenericTxCall<
      (location: XcmVersionedMultiLocation) => ChainSubmittableExtrinsic<{
        pallet: 'PolkadotXcm';
        palletCall: {
          name: 'ForceSubscribeVersionNotify';
          params: { location: XcmVersionedMultiLocation };
        };
      }>
    >;

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we are currently subscribed for XCM version
     * notifications which we no longer desire.
     *
     * @param {XcmVersionedMultiLocation} location
     **/
    forceUnsubscribeVersionNotify: GenericTxCall<
      (location: XcmVersionedMultiLocation) => ChainSubmittableExtrinsic<{
        pallet: 'PolkadotXcm';
        palletCall: {
          name: 'ForceUnsubscribeVersionNotify';
          params: { location: XcmVersionedMultiLocation };
        };
      }>
    >;

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     * from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     * an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     * `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedMultiLocation} dest
     * @param {XcmVersionedMultiLocation} beneficiary
     * @param {XcmVersionedMultiAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    limitedReserveTransferAssets: GenericTxCall<
      (
        dest: XcmVersionedMultiLocation,
        beneficiary: XcmVersionedMultiLocation,
        assets: XcmVersionedMultiAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'PolkadotXcm';
        palletCall: {
          name: 'LimitedReserveTransferAssets';
          params: {
            dest: XcmVersionedMultiLocation;
            beneficiary: XcmVersionedMultiLocation;
            assets: XcmVersionedMultiAssets;
            feeAssetItem: number;
            weightLimit: XcmV3WeightLimit;
          };
        };
      }>
    >;

    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     * from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     * an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     * `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedMultiLocation} dest
     * @param {XcmVersionedMultiLocation} beneficiary
     * @param {XcmVersionedMultiAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    limitedTeleportAssets: GenericTxCall<
      (
        dest: XcmVersionedMultiLocation,
        beneficiary: XcmVersionedMultiLocation,
        assets: XcmVersionedMultiAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'PolkadotXcm';
        palletCall: {
          name: 'LimitedTeleportAssets';
          params: {
            dest: XcmVersionedMultiLocation;
            beneficiary: XcmVersionedMultiLocation;
            assets: XcmVersionedMultiAssets;
            feeAssetItem: number;
            weightLimit: XcmV3WeightLimit;
          };
        };
      }>
    >;

    /**
     * Set or unset the global suspension state of the XCM executor.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `suspended`: `true` to suspend, `false` to resume.
     *
     * @param {boolean} suspended
     **/
    forceSuspension: GenericTxCall<
      (suspended: boolean) => ChainSubmittableExtrinsic<{
        pallet: 'PolkadotXcm';
        palletCall: {
          name: 'ForceSuspension';
          params: { suspended: boolean };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `CumulusXcm`'s transaction calls
   **/
  cumulusXcm: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `DmpQueue`'s transaction calls
   **/
  dmpQueue: {
    /**
     * Service a single overweight message.
     *
     * @param {bigint} index
     * @param {SpWeightsWeightV2Weight} weightLimit
     **/
    serviceOverweight: GenericTxCall<
      (
        index: bigint,
        weightLimit: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DmpQueue';
        palletCall: {
          name: 'ServiceOverweight';
          params: { index: bigint; weightLimit: SpWeightsWeightV2Weight };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `XcAssetConfig`'s transaction calls
   **/
  xcAssetConfig: {
    /**
     * Register new asset location to asset Id mapping.
     *
     * This makes the asset eligible for XCM interaction.
     *
     * @param {XcmVersionedMultiLocation} assetLocation
     * @param {bigint} assetId
     **/
    registerAssetLocation: GenericTxCall<
      (
        assetLocation: XcmVersionedMultiLocation,
        assetId: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'XcAssetConfig';
        palletCall: {
          name: 'RegisterAssetLocation';
          params: { assetLocation: XcmVersionedMultiLocation; assetId: bigint };
        };
      }>
    >;

    /**
     * Change the amount of units we are charging per execution second
     * for a given AssetLocation.
     *
     * @param {XcmVersionedMultiLocation} assetLocation
     * @param {bigint} unitsPerSecond
     **/
    setAssetUnitsPerSecond: GenericTxCall<
      (
        assetLocation: XcmVersionedMultiLocation,
        unitsPerSecond: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'XcAssetConfig';
        palletCall: {
          name: 'SetAssetUnitsPerSecond';
          params: { assetLocation: XcmVersionedMultiLocation; unitsPerSecond: bigint };
        };
      }>
    >;

    /**
     * Change the xcm type mapping for a given asset Id.
     * The new asset type will inherit old `units per second` value.
     *
     * @param {XcmVersionedMultiLocation} newAssetLocation
     * @param {bigint} assetId
     **/
    changeExistingAssetLocation: GenericTxCall<
      (
        newAssetLocation: XcmVersionedMultiLocation,
        assetId: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'XcAssetConfig';
        palletCall: {
          name: 'ChangeExistingAssetLocation';
          params: { newAssetLocation: XcmVersionedMultiLocation; assetId: bigint };
        };
      }>
    >;

    /**
     * Removes asset from the set of supported payment assets.
     *
     * The asset can still be interacted with via XCM but it cannot be used to pay for execution time.
     *
     * @param {XcmVersionedMultiLocation} assetLocation
     **/
    removePaymentAsset: GenericTxCall<
      (assetLocation: XcmVersionedMultiLocation) => ChainSubmittableExtrinsic<{
        pallet: 'XcAssetConfig';
        palletCall: {
          name: 'RemovePaymentAsset';
          params: { assetLocation: XcmVersionedMultiLocation };
        };
      }>
    >;

    /**
     * Removes all information related to asset, removing it from XCM support.
     *
     * @param {bigint} assetId
     **/
    removeAsset: GenericTxCall<
      (assetId: bigint) => ChainSubmittableExtrinsic<{
        pallet: 'XcAssetConfig';
        palletCall: {
          name: 'RemoveAsset';
          params: { assetId: bigint };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `XTokens`'s transaction calls
   **/
  xTokens: {
    /**
     * Transfer native currencies.
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     *
     * @param {bigint} currencyId
     * @param {bigint} amount
     * @param {XcmVersionedMultiLocation} dest
     * @param {XcmV3WeightLimit} destWeightLimit
     **/
    transfer: GenericTxCall<
      (
        currencyId: bigint,
        amount: bigint,
        dest: XcmVersionedMultiLocation,
        destWeightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'XTokens';
        palletCall: {
          name: 'Transfer';
          params: {
            currencyId: bigint;
            amount: bigint;
            dest: XcmVersionedMultiLocation;
            destWeightLimit: XcmV3WeightLimit;
          };
        };
      }>
    >;

    /**
     * Transfer `MultiAsset`.
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     *
     * @param {XcmVersionedMultiAsset} asset
     * @param {XcmVersionedMultiLocation} dest
     * @param {XcmV3WeightLimit} destWeightLimit
     **/
    transferMultiasset: GenericTxCall<
      (
        asset: XcmVersionedMultiAsset,
        dest: XcmVersionedMultiLocation,
        destWeightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'XTokens';
        palletCall: {
          name: 'TransferMultiasset';
          params: { asset: XcmVersionedMultiAsset; dest: XcmVersionedMultiLocation; destWeightLimit: XcmV3WeightLimit };
        };
      }>
    >;

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     *
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     *
     * @param {bigint} currencyId
     * @param {bigint} amount
     * @param {bigint} fee
     * @param {XcmVersionedMultiLocation} dest
     * @param {XcmV3WeightLimit} destWeightLimit
     **/
    transferWithFee: GenericTxCall<
      (
        currencyId: bigint,
        amount: bigint,
        fee: bigint,
        dest: XcmVersionedMultiLocation,
        destWeightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'XTokens';
        palletCall: {
          name: 'TransferWithFee';
          params: {
            currencyId: bigint;
            amount: bigint;
            fee: bigint;
            dest: XcmVersionedMultiLocation;
            destWeightLimit: XcmV3WeightLimit;
          };
        };
      }>
    >;

    /**
     * Transfer `MultiAsset` specifying the fee and amount as separate.
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * `fee` is the multiasset to be spent to pay for execution in
     * destination chain. Both fee and amount will be subtracted form the
     * callers balance For now we only accept fee and asset having the same
     * `MultiLocation` id.
     *
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     *
     * @param {XcmVersionedMultiAsset} asset
     * @param {XcmVersionedMultiAsset} fee
     * @param {XcmVersionedMultiLocation} dest
     * @param {XcmV3WeightLimit} destWeightLimit
     **/
    transferMultiassetWithFee: GenericTxCall<
      (
        asset: XcmVersionedMultiAsset,
        fee: XcmVersionedMultiAsset,
        dest: XcmVersionedMultiLocation,
        destWeightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'XTokens';
        palletCall: {
          name: 'TransferMultiassetWithFee';
          params: {
            asset: XcmVersionedMultiAsset;
            fee: XcmVersionedMultiAsset;
            dest: XcmVersionedMultiLocation;
            destWeightLimit: XcmV3WeightLimit;
          };
        };
      }>
    >;

    /**
     * Transfer several currencies specifying the item to be used as fee
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     *
     * @param {Array<[bigint, bigint]>} currencies
     * @param {number} feeItem
     * @param {XcmVersionedMultiLocation} dest
     * @param {XcmV3WeightLimit} destWeightLimit
     **/
    transferMulticurrencies: GenericTxCall<
      (
        currencies: Array<[bigint, bigint]>,
        feeItem: number,
        dest: XcmVersionedMultiLocation,
        destWeightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'XTokens';
        palletCall: {
          name: 'TransferMulticurrencies';
          params: {
            currencies: Array<[bigint, bigint]>;
            feeItem: number;
            dest: XcmVersionedMultiLocation;
            destWeightLimit: XcmV3WeightLimit;
          };
        };
      }>
    >;

    /**
     * Transfer several `MultiAsset` specifying the item to be used as fee
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * `fee_item` is index of the MultiAssets that we want to use for
     * payment
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     *
     * @param {XcmVersionedMultiAssets} assets
     * @param {number} feeItem
     * @param {XcmVersionedMultiLocation} dest
     * @param {XcmV3WeightLimit} destWeightLimit
     **/
    transferMultiassets: GenericTxCall<
      (
        assets: XcmVersionedMultiAssets,
        feeItem: number,
        dest: XcmVersionedMultiLocation,
        destWeightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'XTokens';
        palletCall: {
          name: 'TransferMultiassets';
          params: {
            assets: XcmVersionedMultiAssets;
            feeItem: number;
            dest: XcmVersionedMultiLocation;
            destWeightLimit: XcmV3WeightLimit;
          };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `EVM`'s transaction calls
   **/
  evm: {
    /**
     * Withdraw balance from EVM into currency/balances pallet.
     *
     * @param {H160} address
     * @param {bigint} value
     **/
    withdraw: GenericTxCall<
      (
        address: H160,
        value: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Evm';
        palletCall: {
          name: 'Withdraw';
          params: { address: H160; value: bigint };
        };
      }>
    >;

    /**
     * Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
     *
     * @param {H160} source
     * @param {H160} target
     * @param {BytesLike} input
     * @param {U256} value
     * @param {bigint} gasLimit
     * @param {U256} maxFeePerGas
     * @param {U256 | undefined} maxPriorityFeePerGas
     * @param {U256 | undefined} nonce
     * @param {Array<[H160, Array<H256>]>} accessList
     **/
    call: GenericTxCall<
      (
        source: H160,
        target: H160,
        input: BytesLike,
        value: U256,
        gasLimit: bigint,
        maxFeePerGas: U256,
        maxPriorityFeePerGas: U256 | undefined,
        nonce: U256 | undefined,
        accessList: Array<[H160, Array<H256>]>,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Evm';
        palletCall: {
          name: 'Call';
          params: {
            source: H160;
            target: H160;
            input: BytesLike;
            value: U256;
            gasLimit: bigint;
            maxFeePerGas: U256;
            maxPriorityFeePerGas: U256 | undefined;
            nonce: U256 | undefined;
            accessList: Array<[H160, Array<H256>]>;
          };
        };
      }>
    >;

    /**
     * Issue an EVM create operation. This is similar to a contract creation transaction in
     * Ethereum.
     *
     * @param {H160} source
     * @param {BytesLike} init
     * @param {U256} value
     * @param {bigint} gasLimit
     * @param {U256} maxFeePerGas
     * @param {U256 | undefined} maxPriorityFeePerGas
     * @param {U256 | undefined} nonce
     * @param {Array<[H160, Array<H256>]>} accessList
     **/
    create: GenericTxCall<
      (
        source: H160,
        init: BytesLike,
        value: U256,
        gasLimit: bigint,
        maxFeePerGas: U256,
        maxPriorityFeePerGas: U256 | undefined,
        nonce: U256 | undefined,
        accessList: Array<[H160, Array<H256>]>,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Evm';
        palletCall: {
          name: 'Create';
          params: {
            source: H160;
            init: BytesLike;
            value: U256;
            gasLimit: bigint;
            maxFeePerGas: U256;
            maxPriorityFeePerGas: U256 | undefined;
            nonce: U256 | undefined;
            accessList: Array<[H160, Array<H256>]>;
          };
        };
      }>
    >;

    /**
     * Issue an EVM create2 operation.
     *
     * @param {H160} source
     * @param {BytesLike} init
     * @param {H256} salt
     * @param {U256} value
     * @param {bigint} gasLimit
     * @param {U256} maxFeePerGas
     * @param {U256 | undefined} maxPriorityFeePerGas
     * @param {U256 | undefined} nonce
     * @param {Array<[H160, Array<H256>]>} accessList
     **/
    create2: GenericTxCall<
      (
        source: H160,
        init: BytesLike,
        salt: H256,
        value: U256,
        gasLimit: bigint,
        maxFeePerGas: U256,
        maxPriorityFeePerGas: U256 | undefined,
        nonce: U256 | undefined,
        accessList: Array<[H160, Array<H256>]>,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Evm';
        palletCall: {
          name: 'Create2';
          params: {
            source: H160;
            init: BytesLike;
            salt: H256;
            value: U256;
            gasLimit: bigint;
            maxFeePerGas: U256;
            maxPriorityFeePerGas: U256 | undefined;
            nonce: U256 | undefined;
            accessList: Array<[H160, Array<H256>]>;
          };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `Ethereum`'s transaction calls
   **/
  ethereum: {
    /**
     * Transact an Ethereum transaction.
     *
     * @param {EthereumTransactionTransactionV2} transaction
     **/
    transact: GenericTxCall<
      (transaction: EthereumTransactionTransactionV2) => ChainSubmittableExtrinsic<{
        pallet: 'Ethereum';
        palletCall: {
          name: 'Transact';
          params: { transaction: EthereumTransactionTransactionV2 };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `DynamicEvmBaseFee`'s transaction calls
   **/
  dynamicEvmBaseFee: {
    /**
     * `root-only` extrinsic to set the `base_fee_per_gas` value manually.
     * The specified value has to respect min & max limits configured in the runtime.
     *
     * @param {U256} fee
     **/
    setBaseFeePerGas: GenericTxCall<
      (fee: U256) => ChainSubmittableExtrinsic<{
        pallet: 'DynamicEvmBaseFee';
        palletCall: {
          name: 'SetBaseFeePerGas';
          params: { fee: U256 };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `Contracts`'s transaction calls
   **/
  contracts: {
    /**
     * Deprecated version if [`Self::call`] for use in an in-storage `Call`.
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     * @param {bigint} gasLimit
     * @param {bigint | undefined} storageDepositLimit
     * @param {BytesLike} data
     **/
    callOldWeight: GenericTxCall<
      (
        dest: MultiAddressLike,
        value: bigint,
        gasLimit: bigint,
        storageDepositLimit: bigint | undefined,
        data: BytesLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Contracts';
        palletCall: {
          name: 'CallOldWeight';
          params: {
            dest: MultiAddressLike;
            value: bigint;
            gasLimit: bigint;
            storageDepositLimit: bigint | undefined;
            data: BytesLike;
          };
        };
      }>
    >;

    /**
     * Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`.
     *
     * @param {bigint} value
     * @param {bigint} gasLimit
     * @param {bigint | undefined} storageDepositLimit
     * @param {BytesLike} code
     * @param {BytesLike} data
     * @param {BytesLike} salt
     **/
    instantiateWithCodeOldWeight: GenericTxCall<
      (
        value: bigint,
        gasLimit: bigint,
        storageDepositLimit: bigint | undefined,
        code: BytesLike,
        data: BytesLike,
        salt: BytesLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Contracts';
        palletCall: {
          name: 'InstantiateWithCodeOldWeight';
          params: {
            value: bigint;
            gasLimit: bigint;
            storageDepositLimit: bigint | undefined;
            code: BytesLike;
            data: BytesLike;
            salt: BytesLike;
          };
        };
      }>
    >;

    /**
     * Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`.
     *
     * @param {bigint} value
     * @param {bigint} gasLimit
     * @param {bigint | undefined} storageDepositLimit
     * @param {H256} codeHash
     * @param {BytesLike} data
     * @param {BytesLike} salt
     **/
    instantiateOldWeight: GenericTxCall<
      (
        value: bigint,
        gasLimit: bigint,
        storageDepositLimit: bigint | undefined,
        codeHash: H256,
        data: BytesLike,
        salt: BytesLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Contracts';
        palletCall: {
          name: 'InstantiateOldWeight';
          params: {
            value: bigint;
            gasLimit: bigint;
            storageDepositLimit: bigint | undefined;
            codeHash: H256;
            data: BytesLike;
            salt: BytesLike;
          };
        };
      }>
    >;

    /**
     * Upload new `code` without instantiating a contract from it.
     *
     * If the code does not already exist a deposit is reserved from the caller
     * and unreserved only when [`Self::remove_code`] is called. The size of the reserve
     * depends on the instrumented size of the the supplied `code`.
     *
     * If the code already exists in storage it will still return `Ok` and upgrades
     * the in storage version to the current
     * [`InstructionWeights::version`](InstructionWeights).
     *
     * - `determinism`: If this is set to any other value but [`Determinism::Enforced`] then
     * the only way to use this code is to delegate call into it from an offchain execution.
     * Set to [`Determinism::Enforced`] if in doubt.
     *
     * # Note
     *
     * Anyone can instantiate a contract from any uploaded code and thus prevent its removal.
     * To avoid this situation a constructor could employ access control so that it can
     * only be instantiated by permissioned entities. The same is true when uploading
     * through [`Self::instantiate_with_code`].
     *
     * @param {BytesLike} code
     * @param {bigint | undefined} storageDepositLimit
     * @param {PalletContractsWasmDeterminism} determinism
     **/
    uploadCode: GenericTxCall<
      (
        code: BytesLike,
        storageDepositLimit: bigint | undefined,
        determinism: PalletContractsWasmDeterminism,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Contracts';
        palletCall: {
          name: 'UploadCode';
          params: {
            code: BytesLike;
            storageDepositLimit: bigint | undefined;
            determinism: PalletContractsWasmDeterminism;
          };
        };
      }>
    >;

    /**
     * Remove the code stored under `code_hash` and refund the deposit to its owner.
     *
     * A code can only be removed by its original uploader (its owner) and only if it is
     * not used by any contract.
     *
     * @param {H256} codeHash
     **/
    removeCode: GenericTxCall<
      (codeHash: H256) => ChainSubmittableExtrinsic<{
        pallet: 'Contracts';
        palletCall: {
          name: 'RemoveCode';
          params: { codeHash: H256 };
        };
      }>
    >;

    /**
     * Privileged function that changes the code of an existing contract.
     *
     * This takes care of updating refcounts and all other necessary operations. Returns
     * an error if either the `code_hash` or `dest` do not exist.
     *
     * # Note
     *
     * This does **not** change the address of the contract in question. This means
     * that the contract address is no longer derived from its code hash after calling
     * this dispatchable.
     *
     * @param {MultiAddressLike} dest
     * @param {H256} codeHash
     **/
    setCode: GenericTxCall<
      (
        dest: MultiAddressLike,
        codeHash: H256,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Contracts';
        palletCall: {
          name: 'SetCode';
          params: { dest: MultiAddressLike; codeHash: H256 };
        };
      }>
    >;

    /**
     * Makes a call to an account, optionally transferring some balance.
     *
     * # Parameters
     *
     * * `dest`: Address of the contract to call.
     * * `value`: The balance to transfer from the `origin` to `dest`.
     * * `gas_limit`: The gas limit enforced when executing the constructor.
     * * `storage_deposit_limit`: The maximum amount of balance that can be charged from the
     * caller to pay for the storage consumed.
     * * `data`: The input data to pass to the contract.
     *
     * * If the account is a smart-contract account, the associated code will be
     * executed and any value will be transferred.
     * * If the account is a regular account, any value will be transferred.
     * * If no account exists and the call value is not less than `existential_deposit`,
     * a regular account will be created and any value will be transferred.
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     * @param {SpWeightsWeightV2Weight} gasLimit
     * @param {bigint | undefined} storageDepositLimit
     * @param {BytesLike} data
     **/
    call: GenericTxCall<
      (
        dest: MultiAddressLike,
        value: bigint,
        gasLimit: SpWeightsWeightV2Weight,
        storageDepositLimit: bigint | undefined,
        data: BytesLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Contracts';
        palletCall: {
          name: 'Call';
          params: {
            dest: MultiAddressLike;
            value: bigint;
            gasLimit: SpWeightsWeightV2Weight;
            storageDepositLimit: bigint | undefined;
            data: BytesLike;
          };
        };
      }>
    >;

    /**
     * Instantiates a new contract from the supplied `code` optionally transferring
     * some balance.
     *
     * This dispatchable has the same effect as calling [`Self::upload_code`] +
     * [`Self::instantiate`]. Bundling them together provides efficiency gains. Please
     * also check the documentation of [`Self::upload_code`].
     *
     * # Parameters
     *
     * * `value`: The balance to transfer from the `origin` to the newly created contract.
     * * `gas_limit`: The gas limit enforced when executing the constructor.
     * * `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved
     * from the caller to pay for the storage consumed.
     * * `code`: The contract code to deploy in raw bytes.
     * * `data`: The input data to pass to the contract constructor.
     * * `salt`: Used for the address derivation. See [`Pallet::contract_address`].
     *
     * Instantiation is executed as follows:
     *
     * - The supplied `code` is instrumented, deployed, and a `code_hash` is created for that
     * code.
     * - If the `code_hash` already exists on the chain the underlying `code` will be shared.
     * - The destination address is computed based on the sender, code_hash and the salt.
     * - The smart-contract account is created at the computed address.
     * - The `value` is transferred to the new account.
     * - The `deploy` function is executed in the context of the newly-created account.
     *
     * @param {bigint} value
     * @param {SpWeightsWeightV2Weight} gasLimit
     * @param {bigint | undefined} storageDepositLimit
     * @param {BytesLike} code
     * @param {BytesLike} data
     * @param {BytesLike} salt
     **/
    instantiateWithCode: GenericTxCall<
      (
        value: bigint,
        gasLimit: SpWeightsWeightV2Weight,
        storageDepositLimit: bigint | undefined,
        code: BytesLike,
        data: BytesLike,
        salt: BytesLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Contracts';
        palletCall: {
          name: 'InstantiateWithCode';
          params: {
            value: bigint;
            gasLimit: SpWeightsWeightV2Weight;
            storageDepositLimit: bigint | undefined;
            code: BytesLike;
            data: BytesLike;
            salt: BytesLike;
          };
        };
      }>
    >;

    /**
     * Instantiates a contract from a previously deployed wasm binary.
     *
     * This function is identical to [`Self::instantiate_with_code`] but without the
     * code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary
     * must be supplied.
     *
     * @param {bigint} value
     * @param {SpWeightsWeightV2Weight} gasLimit
     * @param {bigint | undefined} storageDepositLimit
     * @param {H256} codeHash
     * @param {BytesLike} data
     * @param {BytesLike} salt
     **/
    instantiate: GenericTxCall<
      (
        value: bigint,
        gasLimit: SpWeightsWeightV2Weight,
        storageDepositLimit: bigint | undefined,
        codeHash: H256,
        data: BytesLike,
        salt: BytesLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Contracts';
        palletCall: {
          name: 'Instantiate';
          params: {
            value: bigint;
            gasLimit: SpWeightsWeightV2Weight;
            storageDepositLimit: bigint | undefined;
            codeHash: H256;
            data: BytesLike;
            salt: BytesLike;
          };
        };
      }>
    >;

    /**
     * When a migration is in progress, this dispatchable can be used to run migration steps.
     * Calls that contribute to advancing the migration have their fees waived, as it's helpful
     * for the chain. Note that while the migration is in progress, the pallet will also
     * leverage the `on_idle` hooks to run migration steps.
     *
     * @param {SpWeightsWeightV2Weight} weightLimit
     **/
    migrate: GenericTxCall<
      (weightLimit: SpWeightsWeightV2Weight) => ChainSubmittableExtrinsic<{
        pallet: 'Contracts';
        palletCall: {
          name: 'Migrate';
          params: { weightLimit: SpWeightsWeightV2Weight };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `Sudo`'s transaction calls
   **/
  sudo: {
    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {AstarRuntimeRuntimeCallLike} call
     **/
    sudo: GenericTxCall<
      (call: AstarRuntimeRuntimeCallLike) => ChainSubmittableExtrinsic<{
        pallet: 'Sudo';
        palletCall: {
          name: 'Sudo';
          params: { call: AstarRuntimeRuntimeCallLike };
        };
      }>
    >;

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {AstarRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    sudoUncheckedWeight: GenericTxCall<
      (
        call: AstarRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Sudo';
        palletCall: {
          name: 'SudoUncheckedWeight';
          params: { call: AstarRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight };
        };
      }>
    >;

    /**
     * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
     * key.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {MultiAddressLike} new_
     **/
    setKey: GenericTxCall<
      (new_: MultiAddressLike) => ChainSubmittableExtrinsic<{
        pallet: 'Sudo';
        palletCall: {
          name: 'SetKey';
          params: { new: MultiAddressLike };
        };
      }>
    >;

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {MultiAddressLike} who
     * @param {AstarRuntimeRuntimeCallLike} call
     **/
    sudoAs: GenericTxCall<
      (
        who: MultiAddressLike,
        call: AstarRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'Sudo';
        palletCall: {
          name: 'SudoAs';
          params: { who: MultiAddressLike; call: AstarRuntimeRuntimeCallLike };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `StaticPriceProvider`'s transaction calls
   **/
  staticPriceProvider: {
    /**
     * Privileged action used to set the active native currency price.
     *
     * This is a temporary solution before oracle is implemented & operational.
     *
     * @param {FixedU64} price
     **/
    forceSetPrice: GenericTxCall<
      (price: FixedU64) => ChainSubmittableExtrinsic<{
        pallet: 'StaticPriceProvider';
        palletCall: {
          name: 'ForceSetPrice';
          params: { price: FixedU64 };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `DappStakingMigration`'s transaction calls
   **/
  dappStakingMigration: {
    /**
     * Attempt to execute migration steps, consuming up to the specified amount of weight.
     * If no weight is specified, max allowed weight is used.
     *
     * Regardless of the specified weight limit, it will be clamped between the minimum & maximum allowed values.
     * This means that even if user specifies `Weight::zero()` as the limit,
     * the call will be charged & executed using the minimum allowed weight.
     *
     * @param {SpWeightsWeightV2Weight | undefined} weightLimit
     **/
    migrate: GenericTxCall<
      (weightLimit: SpWeightsWeightV2Weight | undefined) => ChainSubmittableExtrinsic<{
        pallet: 'DappStakingMigration';
        palletCall: {
          name: 'Migrate';
          params: { weightLimit: SpWeightsWeightV2Weight | undefined };
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
  /**
   * Pallet `DappsStaking`'s transaction calls
   **/
  dappsStaking: {
    /**
     * Used to register contract for dapps staking.
     * The origin account used is treated as the `developer` account.
     *
     * Depending on the pallet configuration/state it is possible that developer needs to be whitelisted prior to registration.
     *
     * As part of this call, `RegisterDeposit` will be reserved from devs account.
     *
     * @param {AccountId32Like} developer
     * @param {AstarPrimitivesDappStakingSmartContract} contractId
     **/
    register: GenericTxCall<
      (
        developer: AccountId32Like,
        contractId: AstarPrimitivesDappStakingSmartContract,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'Register';
          params: { developer: AccountId32Like; contractId: AstarPrimitivesDappStakingSmartContract };
        };
      }>
    >;

    /**
     * Unregister existing contract from dapps staking, making it ineligible for rewards from current era onwards.
     * This must be called by the root (at the moment).
     *
     * Deposit is returned to the developer but existing stakers should manually call `withdraw_from_unregistered` if they wish to to unstake.
     *
     * **Warning**: After this action ,contract can not be registered for dapps staking again.
     *
     * @param {AstarPrimitivesDappStakingSmartContract} contractId
     **/
    unregister: GenericTxCall<
      (contractId: AstarPrimitivesDappStakingSmartContract) => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'Unregister';
          params: { contractId: AstarPrimitivesDappStakingSmartContract };
        };
      }>
    >;

    /**
     * Withdraw locked funds from a contract that was unregistered.
     *
     * Funds don't need to undergo the unbonding period - they are returned immediately to the staker's free balance.
     *
     * @param {AstarPrimitivesDappStakingSmartContract} contractId
     **/
    withdrawFromUnregistered: GenericTxCall<
      (contractId: AstarPrimitivesDappStakingSmartContract) => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'WithdrawFromUnregistered';
          params: { contractId: AstarPrimitivesDappStakingSmartContract };
        };
      }>
    >;

    /**
     * Lock up and stake balance of the origin account.
     *
     * `value` must be more than the `minimum_balance` specified by `MinimumStakingAmount`
     * unless account already has bonded value equal or more than 'minimum_balance'.
     *
     * The dispatch origin for this call must be _Signed_ by the staker's account.
     *
     * @param {AstarPrimitivesDappStakingSmartContract} contractId
     * @param {bigint} value
     **/
    bondAndStake: GenericTxCall<
      (
        contractId: AstarPrimitivesDappStakingSmartContract,
        value: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'BondAndStake';
          params: { contractId: AstarPrimitivesDappStakingSmartContract; value: bigint };
        };
      }>
    >;

    /**
     * Start unbonding process and unstake balance from the contract.
     *
     * The unstaked amount will no longer be eligible for rewards but still won't be unlocked.
     * User needs to wait for the unbonding period to finish before being able to withdraw
     * the funds via `withdraw_unbonded` call.
     *
     * In case remaining staked balance on contract is below minimum staking amount,
     * entire stake for that contract will be unstaked.
     *
     * @param {AstarPrimitivesDappStakingSmartContract} contractId
     * @param {bigint} value
     **/
    unbondAndUnstake: GenericTxCall<
      (
        contractId: AstarPrimitivesDappStakingSmartContract,
        value: bigint,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'UnbondAndUnstake';
          params: { contractId: AstarPrimitivesDappStakingSmartContract; value: bigint };
        };
      }>
    >;

    /**
     * Withdraw all funds that have completed the unbonding process.
     *
     * If there are unbonding chunks which will be fully unbonded in future eras,
     * they will remain and can be withdrawn later.
     *
     **/
    withdrawUnbonded: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'WithdrawUnbonded';
        };
      }>
    >;

    /**
     * Transfer nomination from one contract to another.
     *
     * Same rules as for `bond_and_stake` and `unbond_and_unstake` apply.
     * Minor difference is that there is no unbonding period so this call won't
     * check whether max number of unbonding chunks is exceeded.
     *
     *
     * @param {AstarPrimitivesDappStakingSmartContract} originContractId
     * @param {bigint} value
     * @param {AstarPrimitivesDappStakingSmartContract} targetContractId
     **/
    nominationTransfer: GenericTxCall<
      (
        originContractId: AstarPrimitivesDappStakingSmartContract,
        value: bigint,
        targetContractId: AstarPrimitivesDappStakingSmartContract,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'NominationTransfer';
          params: {
            originContractId: AstarPrimitivesDappStakingSmartContract;
            value: bigint;
            targetContractId: AstarPrimitivesDappStakingSmartContract;
          };
        };
      }>
    >;

    /**
     * Claim earned staker rewards for the oldest unclaimed era.
     * In order to claim multiple eras, this call has to be called multiple times.
     *
     * The rewards are always added to the staker's free balance (account) but depending on the reward destination configuration,
     * they might be immediately re-staked.
     *
     * @param {AstarPrimitivesDappStakingSmartContract} contractId
     **/
    claimStaker: GenericTxCall<
      (contractId: AstarPrimitivesDappStakingSmartContract) => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'ClaimStaker';
          params: { contractId: AstarPrimitivesDappStakingSmartContract };
        };
      }>
    >;

    /**
     * Claim earned dapp rewards for the specified era.
     *
     * Call must ensure that the specified era is eligible for reward payout and that it hasn't already been paid out for the dapp.
     *
     * @param {AstarPrimitivesDappStakingSmartContract} contractId
     * @param {number} era
     **/
    claimDapp: GenericTxCall<
      (
        contractId: AstarPrimitivesDappStakingSmartContract,
        era: number,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'ClaimDapp';
          params: { contractId: AstarPrimitivesDappStakingSmartContract; era: number };
        };
      }>
    >;

    /**
     * Force a new era at the start of the next block.
     *
     * The dispatch origin must be Root.
     *
     **/
    forceNewEra: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'ForceNewEra';
        };
      }>
    >;

    /**
     * `true` will disable pallet, enabling maintenance mode. `false` will do the opposite.
     *
     * The dispatch origin must be Root.
     *
     * @param {boolean} enableMaintenance
     **/
    maintenanceMode: GenericTxCall<
      (enableMaintenance: boolean) => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'MaintenanceMode';
          params: { enableMaintenance: boolean };
        };
      }>
    >;

    /**
     * Used to set reward destination for staker rewards.
     *
     * User must be an active staker in order to use this call.
     * This will apply to all existing unclaimed rewards.
     *
     * @param {PalletDappsStakingRewardDestination} rewardDestination
     **/
    setRewardDestination: GenericTxCall<
      (rewardDestination: PalletDappsStakingRewardDestination) => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'SetRewardDestination';
          params: { rewardDestination: PalletDappsStakingRewardDestination };
        };
      }>
    >;

    /**
     * Used to force set `ContractEraStake` storage values.
     * The purpose of this call is only for fixing one of the issues detected with dapps-staking.
     *
     * The dispatch origin must be Root.
     *
     * @param {AstarPrimitivesDappStakingSmartContract} contract
     * @param {number} era
     * @param {PalletDappsStakingContractStakeInfo} contractStakeInfo
     **/
    setContractStakeInfo: GenericTxCall<
      (
        contract: AstarPrimitivesDappStakingSmartContract,
        era: number,
        contractStakeInfo: PalletDappsStakingContractStakeInfo,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'SetContractStakeInfo';
          params: {
            contract: AstarPrimitivesDappStakingSmartContract;
            era: number;
            contractStakeInfo: PalletDappsStakingContractStakeInfo;
          };
        };
      }>
    >;

    /**
     * Used to burn unclaimed & stale rewards from an unregistered contract.
     *
     * @param {AstarPrimitivesDappStakingSmartContract} contractId
     * @param {number} era
     **/
    burnStaleReward: GenericTxCall<
      (
        contractId: AstarPrimitivesDappStakingSmartContract,
        era: number,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'BurnStaleReward';
          params: { contractId: AstarPrimitivesDappStakingSmartContract; era: number };
        };
      }>
    >;

    /**
     * Claim earned staker rewards for the given staker, and the oldest unclaimed era.
     * In order to claim multiple eras, this call has to be called multiple times.
     *
     * This call can only be used during the pallet decommission process.
     *
     * @param {AccountId32Like} staker
     * @param {AstarPrimitivesDappStakingSmartContract} contractId
     **/
    claimStakerFor: GenericTxCall<
      (
        staker: AccountId32Like,
        contractId: AstarPrimitivesDappStakingSmartContract,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'ClaimStakerFor';
          params: { staker: AccountId32Like; contractId: AstarPrimitivesDappStakingSmartContract };
        };
      }>
    >;

    /**
     * Used to set reward destination for staker rewards, for the given staker
     *
     *
     * @param {AccountId32Like} staker
     * @param {PalletDappsStakingRewardDestination} rewardDestination
     **/
    setRewardDestinationFor: GenericTxCall<
      (
        staker: AccountId32Like,
        rewardDestination: PalletDappsStakingRewardDestination,
      ) => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'SetRewardDestinationFor';
          params: { staker: AccountId32Like; rewardDestination: PalletDappsStakingRewardDestination };
        };
      }>
    >;

    /**
     * Enable the `decommission` flag for the pallet.
     *
     * The dispatch origin must be Root.
     *
     **/
    decommission: GenericTxCall<
      () => ChainSubmittableExtrinsic<{
        pallet: 'DappsStaking';
        palletCall: {
          name: 'Decommission';
        };
      }>
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall>;
  };
}
