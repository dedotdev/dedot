// Generated by @delightfuldot/codegen

import type { GenericChainStorage, GenericStorageQuery } from '@delightfuldot/types';
import type {
  AccountId32Like,
  H256,
  Bytes,
  Digest,
  Phase,
  FixedU128,
  AccountId32,
  BytesLike,
  FixedBytes,
} from '@delightfuldot/codecs';
import type {
  FrameSystemAccountInfo,
  FrameSupportDispatchPerDispatchClass,
  FrameSystemEventRecord,
  FrameSystemLastRuntimeUpgradeInfo,
  FrameSystemCodeUpgradeAuthorization,
  CumulusPalletParachainSystemUnincludedSegmentAncestor,
  CumulusPalletParachainSystemUnincludedSegmentSegmentTracker,
  PolkadotPrimitivesV6PersistedValidationData,
  PolkadotPrimitivesV6UpgradeRestriction,
  PolkadotPrimitivesV6UpgradeGoAhead,
  SpTrieStorageProof,
  CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot,
  PolkadotPrimitivesV6AbridgedHostConfiguration,
  CumulusPrimitivesParachainInherentMessageQueueChain,
  PolkadotParachainPrimitivesPrimitivesId,
  PolkadotCorePrimitivesOutboundHrmpMessage,
  SpWeightsWeightV2Weight,
  PalletBalancesAccountData,
  PalletBalancesBalanceLock,
  PalletBalancesReserveData,
  PalletBalancesIdAmount,
  PalletBalancesIdAmount002,
  PalletTransactionPaymentReleases,
  PalletCollatorSelectionCandidateInfo,
  AssetHubRococoRuntimeSessionKeys,
  SpCoreCryptoKeyTypeId,
  SpConsensusAuraSr25519AppSr25519Public,
  SpConsensusSlotsSlot,
  CumulusPalletXcmpQueueOutboundChannelDetails,
  CumulusPalletXcmpQueueQueueConfigData,
  PalletXcmQueryStatus,
  XcmVersionedLocation,
  PalletXcmVersionMigrationStage,
  PalletXcmRemoteLockedFungibleRecord,
  XcmVersionedAssetId,
  PalletMessageQueueBookState,
  CumulusPrimitivesCoreAggregateMessageOrigin,
  PalletMessageQueuePage,
  PalletMultisigMultisig,
  PalletProxyProxyDefinition,
  PalletProxyAnnouncement,
  BpXcmBridgeHubRouterBridgeState,
  PalletAssetsAssetDetails,
  PalletAssetsAssetAccount,
  PalletAssetsApproval,
  PalletAssetsAssetMetadata,
  PalletUniquesCollectionDetails,
  PalletUniquesItemDetails,
  PalletUniquesCollectionMetadata,
  PalletUniquesItemMetadata,
  PalletNftsCollectionDetails,
  PalletNftsBitFlagsCollectionRole,
  PalletNftsItemDetails,
  PalletNftsCollectionMetadata,
  PalletNftsItemMetadata,
  PalletNftsAttributeDeposit,
  PalletNftsAttributeNamespace,
  PalletNftsPendingSwap,
  PalletNftsCollectionConfig,
  PalletNftsItemConfig,
  StagingXcmV3MultilocationMultiLocation,
  PalletNftFractionalizationDetails,
  PalletAssetConversionPoolInfo,
} from './types';

export interface ChainStorage extends GenericChainStorage {
  /**
   * Pallet `System`'s storage queries
   **/
  system: {
    /**
     * The full account information for a particular account ID.
     *
     * @param {AccountId32Like} arg
     **/
    account: GenericStorageQuery<(arg: AccountId32Like) => FrameSystemAccountInfo>;

    /**
     * Total extrinsics count for the current block.
     **/
    extrinsicCount: GenericStorageQuery<() => number | undefined>;

    /**
     * The current weight for the block.
     **/
    blockWeight: GenericStorageQuery<() => FrameSupportDispatchPerDispatchClass>;

    /**
     * Total length (in bytes) for all extrinsics put together, for the current block.
     **/
    allExtrinsicsLen: GenericStorageQuery<() => number | undefined>;

    /**
     * Map of block numbers to block hashes.
     *
     * @param {number} arg
     **/
    blockHash: GenericStorageQuery<(arg: number) => H256>;

    /**
     * Extrinsics data for the current block (maps an extrinsic's index to its data).
     *
     * @param {number} arg
     **/
    extrinsicData: GenericStorageQuery<(arg: number) => Bytes>;

    /**
     * The current block number being processed. Set by `execute_block`.
     **/
    number: GenericStorageQuery<() => number>;

    /**
     * Hash of the previous block.
     **/
    parentHash: GenericStorageQuery<() => H256>;

    /**
     * Digest of the current block, also part of the block header.
     **/
    digest: GenericStorageQuery<() => Digest>;

    /**
     * Events deposited for the current block.
     *
     * NOTE: The item is unbound and should therefore never be read on chain.
     * It could otherwise inflate the PoV size of a block.
     *
     * Events have a large in-memory size. Box the events to not go out-of-memory
     * just in case someone still reads them from within the runtime.
     **/
    events: GenericStorageQuery<() => Array<FrameSystemEventRecord>>;

    /**
     * The number of events in the `Events<T>` list.
     **/
    eventCount: GenericStorageQuery<() => number>;

    /**
     * Mapping between a topic (represented by T::Hash) and a vector of indexes
     * of events in the `<Events<T>>` list.
     *
     * All topic vectors have deterministic storage locations depending on the topic. This
     * allows light-clients to leverage the changes trie storage tracking mechanism and
     * in case of changes fetch the list of events of interest.
     *
     * The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just
     * the `EventIndex` then in case if the topic has the same contents on the next block
     * no notification will be triggered thus the event might be lost.
     *
     * @param {H256} arg
     **/
    eventTopics: GenericStorageQuery<(arg: H256) => Array<[number, number]>>;

    /**
     * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
     **/
    lastRuntimeUpgrade: GenericStorageQuery<() => FrameSystemLastRuntimeUpgradeInfo | undefined>;

    /**
     * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.
     **/
    upgradedToU32RefCount: GenericStorageQuery<() => boolean>;

    /**
     * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
     * (default) if not.
     **/
    upgradedToTripleRefCount: GenericStorageQuery<() => boolean>;

    /**
     * The execution phase of the block.
     **/
    executionPhase: GenericStorageQuery<() => Phase | undefined>;

    /**
     * `Some` if a code upgrade has been authorized.
     **/
    authorizedUpgrade: GenericStorageQuery<() => FrameSystemCodeUpgradeAuthorization | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ParachainSystem`'s storage queries
   **/
  parachainSystem: {
    /**
     * Latest included block descendants the runtime accepted. In other words, these are
     * ancestors of the currently executing block which have not been included in the observed
     * relay-chain state.
     *
     * The segment length is limited by the capacity returned from the [`ConsensusHook`] configured
     * in the pallet.
     **/
    unincludedSegment: GenericStorageQuery<() => Array<CumulusPalletParachainSystemUnincludedSegmentAncestor>>;

    /**
     * Storage field that keeps track of bandwidth used by the unincluded segment along with the
     * latest HRMP watermark. Used for limiting the acceptance of new blocks with
     * respect to relay chain constraints.
     **/
    aggregatedUnincludedSegment: GenericStorageQuery<
      () => CumulusPalletParachainSystemUnincludedSegmentSegmentTracker | undefined
    >;

    /**
     * In case of a scheduled upgrade, this storage field contains the validation code to be
     * applied.
     *
     * As soon as the relay chain gives us the go-ahead signal, we will overwrite the
     * [`:code`][sp_core::storage::well_known_keys::CODE] which will result the next block process
     * with the new validation code. This concludes the upgrade process.
     **/
    pendingValidationCode: GenericStorageQuery<() => Bytes>;

    /**
     * Validation code that is set by the parachain and is to be communicated to collator and
     * consequently the relay-chain.
     *
     * This will be cleared in `on_initialize` of each new block if no other pallet already set
     * the value.
     **/
    newValidationCode: GenericStorageQuery<() => Bytes | undefined>;

    /**
     * The [`PersistedValidationData`] set for this block.
     * This value is expected to be set only once per block and it's never stored
     * in the trie.
     **/
    validationData: GenericStorageQuery<() => PolkadotPrimitivesV6PersistedValidationData | undefined>;

    /**
     * Were the validation data set to notify the relay chain?
     **/
    didSetValidationCode: GenericStorageQuery<() => boolean>;

    /**
     * The relay chain block number associated with the last parachain block.
     *
     * This is updated in `on_finalize`.
     **/
    lastRelayChainBlockNumber: GenericStorageQuery<() => number>;

    /**
     * An option which indicates if the relay-chain restricts signalling a validation code upgrade.
     * In other words, if this is `Some` and [`NewValidationCode`] is `Some` then the produced
     * candidate will be invalid.
     *
     * This storage item is a mirror of the corresponding value for the current parachain from the
     * relay-chain. This value is ephemeral which means it doesn't hit the storage. This value is
     * set after the inherent.
     **/
    upgradeRestrictionSignal: GenericStorageQuery<() => PolkadotPrimitivesV6UpgradeRestriction | undefined>;

    /**
     * Optional upgrade go-ahead signal from the relay-chain.
     *
     * This storage item is a mirror of the corresponding value for the current parachain from the
     * relay-chain. This value is ephemeral which means it doesn't hit the storage. This value is
     * set after the inherent.
     **/
    upgradeGoAhead: GenericStorageQuery<() => PolkadotPrimitivesV6UpgradeGoAhead | undefined>;

    /**
     * The state proof for the last relay parent block.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     **/
    relayStateProof: GenericStorageQuery<() => SpTrieStorageProof | undefined>;

    /**
     * The snapshot of some state related to messaging relevant to the current parachain as per
     * the relay parent.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     **/
    relevantMessagingState: GenericStorageQuery<
      () => CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot | undefined
    >;

    /**
     * The parachain host configuration that was obtained from the relay parent.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     **/
    hostConfiguration: GenericStorageQuery<() => PolkadotPrimitivesV6AbridgedHostConfiguration | undefined>;

    /**
     * The last downward message queue chain head we have observed.
     *
     * This value is loaded before and saved after processing inbound downward messages carried
     * by the system inherent.
     **/
    lastDmqMqcHead: GenericStorageQuery<() => CumulusPrimitivesParachainInherentMessageQueueChain>;

    /**
     * The message queue chain heads we have observed per each channel incoming channel.
     *
     * This value is loaded before and saved after processing inbound downward messages carried
     * by the system inherent.
     **/
    lastHrmpMqcHeads: GenericStorageQuery<
      () => Array<[PolkadotParachainPrimitivesPrimitivesId, CumulusPrimitivesParachainInherentMessageQueueChain]>
    >;

    /**
     * Number of downward messages processed in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     **/
    processedDownwardMessages: GenericStorageQuery<() => number>;

    /**
     * HRMP watermark that was set in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     **/
    hrmpWatermark: GenericStorageQuery<() => number>;

    /**
     * HRMP messages that were sent in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     **/
    hrmpOutboundMessages: GenericStorageQuery<() => Array<PolkadotCorePrimitivesOutboundHrmpMessage>>;

    /**
     * Upward messages that were sent in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     **/
    upwardMessages: GenericStorageQuery<() => Array<Bytes>>;

    /**
     * Upward messages that are still pending and not yet send to the relay chain.
     **/
    pendingUpwardMessages: GenericStorageQuery<() => Array<Bytes>>;

    /**
     * The factor to multiply the base delivery fee by for UMP.
     **/
    upwardDeliveryFeeFactor: GenericStorageQuery<() => FixedU128>;

    /**
     * The number of HRMP messages we observed in `on_initialize` and thus used that number for
     * announcing the weight of `on_initialize` and `on_finalize`.
     **/
    announcedHrmpMessagesPerCandidate: GenericStorageQuery<() => number>;

    /**
     * The weight we reserve at the beginning of the block for processing XCMP messages. This
     * overrides the amount set in the Config trait.
     **/
    reservedXcmpWeightOverride: GenericStorageQuery<() => SpWeightsWeightV2Weight | undefined>;

    /**
     * The weight we reserve at the beginning of the block for processing DMP messages. This
     * overrides the amount set in the Config trait.
     **/
    reservedDmpWeightOverride: GenericStorageQuery<() => SpWeightsWeightV2Weight | undefined>;

    /**
     * A custom head data that should be returned as result of `validate_block`.
     *
     * See `Pallet::set_custom_validation_head_data` for more information.
     **/
    customValidationHeadData: GenericStorageQuery<() => Bytes | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Timestamp`'s storage queries
   **/
  timestamp: {
    /**
     * The current time for the current block.
     **/
    now: GenericStorageQuery<() => bigint>;

    /**
     * Whether the timestamp has been updated in this block.
     *
     * This value is updated to `true` upon successful submission of a timestamp by a node.
     * It is then checked at the end of each block execution in the `on_finalize` hook.
     **/
    didUpdate: GenericStorageQuery<() => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ParachainInfo`'s storage queries
   **/
  parachainInfo: {
    parachainId: GenericStorageQuery<() => PolkadotParachainPrimitivesPrimitivesId>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Balances`'s storage queries
   **/
  balances: {
    /**
     * The total units issued in the system.
     **/
    totalIssuance: GenericStorageQuery<() => bigint>;

    /**
     * The total units of outstanding deactivated balance in the system.
     **/
    inactiveIssuance: GenericStorageQuery<() => bigint>;

    /**
     * The Balances pallet example of storing the balance of an account.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
     * }
     * ```
     *
     * You can also store the balance of an account in the `System` pallet.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = System
     * }
     * ```
     *
     * But this comes with tradeoffs, storing account balances in the system pallet stores
     * `frame_system` data alongside the account data contrary to storing account balances in the
     * `Balances` pallet, which uses a `StorageMap` to store balances data only.
     * NOTE: This is only used in the case that this pallet is used to store balances.
     *
     * @param {AccountId32Like} arg
     **/
    account: GenericStorageQuery<(arg: AccountId32Like) => PalletBalancesAccountData>;

    /**
     * Any liquidity locks on some account balances.
     * NOTE: Should only be accessed when setting, changing and freeing a lock.
     *
     * @param {AccountId32Like} arg
     **/
    locks: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesBalanceLock>>;

    /**
     * Named reserves on some account balances.
     *
     * @param {AccountId32Like} arg
     **/
    reserves: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesReserveData>>;

    /**
     * Holds on account balances.
     *
     * @param {AccountId32Like} arg
     **/
    holds: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesIdAmount>>;

    /**
     * Freeze locks on account balances.
     *
     * @param {AccountId32Like} arg
     **/
    freezes: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesIdAmount002>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `TransactionPayment`'s storage queries
   **/
  transactionPayment: {
    nextFeeMultiplier: GenericStorageQuery<() => FixedU128>;
    storageVersion: GenericStorageQuery<() => PalletTransactionPaymentReleases>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Authorship`'s storage queries
   **/
  authorship: {
    /**
     * Author of current block.
     **/
    author: GenericStorageQuery<() => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `CollatorSelection`'s storage queries
   **/
  collatorSelection: {
    /**
     * The invulnerable, permissioned collators. This list must be sorted.
     **/
    invulnerables: GenericStorageQuery<() => Array<AccountId32>>;

    /**
     * The (community, limited) collation candidates. `Candidates` and `Invulnerables` should be
     * mutually exclusive.
     *
     * This list is sorted in ascending order by deposit and when the deposits are equal, the least
     * recently updated is considered greater.
     **/
    candidateList: GenericStorageQuery<() => Array<PalletCollatorSelectionCandidateInfo>>;

    /**
     * Last block authored by collator.
     *
     * @param {AccountId32Like} arg
     **/
    lastAuthoredBlock: GenericStorageQuery<(arg: AccountId32Like) => number>;

    /**
     * Desired number of candidates.
     *
     * This should ideally always be less than [`Config::MaxCandidates`] for weights to be correct.
     **/
    desiredCandidates: GenericStorageQuery<() => number>;

    /**
     * Fixed amount to deposit to become a collator.
     *
     * When a collator calls `leave_intent` they immediately receive the deposit back.
     **/
    candidacyBond: GenericStorageQuery<() => bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Session`'s storage queries
   **/
  session: {
    /**
     * The current set of validators.
     **/
    validators: GenericStorageQuery<() => Array<AccountId32>>;

    /**
     * Current index of the session.
     **/
    currentIndex: GenericStorageQuery<() => number>;

    /**
     * True if the underlying economic identities or weighting behind the validators
     * has changed in the queued validator set.
     **/
    queuedChanged: GenericStorageQuery<() => boolean>;

    /**
     * The queued keys for the next session. When the next session begins, these keys
     * will be used to determine the validator's session keys.
     **/
    queuedKeys: GenericStorageQuery<() => Array<[AccountId32, AssetHubRococoRuntimeSessionKeys]>>;

    /**
     * Indices of disabled validators.
     *
     * The vec is always kept sorted so that we can find whether a given validator is
     * disabled using binary search. It gets cleared when `on_session_ending` returns
     * a new set of identities.
     **/
    disabledValidators: GenericStorageQuery<() => Array<number>>;

    /**
     * The next session keys for a validator.
     *
     * @param {AccountId32Like} arg
     **/
    nextKeys: GenericStorageQuery<(arg: AccountId32Like) => AssetHubRococoRuntimeSessionKeys | undefined>;

    /**
     * The owner of a key. The key is the `KeyTypeId` + the encoded key.
     *
     * @param {[SpCoreCryptoKeyTypeId, BytesLike]} arg
     **/
    keyOwner: GenericStorageQuery<(arg: [SpCoreCryptoKeyTypeId, BytesLike]) => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Aura`'s storage queries
   **/
  aura: {
    /**
     * The current authority set.
     **/
    authorities: GenericStorageQuery<() => Array<SpConsensusAuraSr25519AppSr25519Public>>;

    /**
     * The current slot of this block.
     *
     * This will be set in `on_initialize`.
     **/
    currentSlot: GenericStorageQuery<() => SpConsensusSlotsSlot>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `AuraExt`'s storage queries
   **/
  auraExt: {
    /**
     * Serves as cache for the authorities.
     *
     * The authorities in AuRa are overwritten in `on_initialize` when we switch to a new session,
     * but we require the old authorities to verify the seal when validating a PoV. This will
     * always be updated to the latest AuRa authorities in `on_finalize`.
     **/
    authorities: GenericStorageQuery<() => Array<SpConsensusAuraSr25519AppSr25519Public>>;

    /**
     * Current slot paired with a number of authored blocks.
     *
     * Updated on each block initialization.
     **/
    slotInfo: GenericStorageQuery<() => [SpConsensusSlotsSlot, number] | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `XcmpQueue`'s storage queries
   **/
  xcmpQueue: {
    /**
     * The suspended inbound XCMP channels. All others are not suspended.
     *
     * This is a `StorageValue` instead of a `StorageMap` since we expect multiple reads per block
     * to different keys with a one byte payload. The access to `BoundedBTreeSet` will be cached
     * within the block and therefore only included once in the proof size.
     *
     * NOTE: The PoV benchmarking cannot know this and will over-estimate, but the actual proof
     * will be smaller.
     **/
    inboundXcmpSuspended: GenericStorageQuery<() => Array<PolkadotParachainPrimitivesPrimitivesId>>;

    /**
     * The non-empty XCMP channels in order of becoming non-empty, and the index of the first
     * and last outbound message. If the two indices are equal, then it indicates an empty
     * queue and there must be a non-`Ok` `OutboundStatus`. We assume queues grow no greater
     * than 65535 items. Queue indices for normal messages begin at one; zero is reserved in
     * case of the need to send a high-priority signal message this block.
     * The bool is true if there is a signal message waiting to be sent.
     **/
    outboundXcmpStatus: GenericStorageQuery<() => Array<CumulusPalletXcmpQueueOutboundChannelDetails>>;

    /**
     * The messages outbound in a given XCMP channel.
     *
     * @param {[PolkadotParachainPrimitivesPrimitivesId, number]} arg
     **/
    outboundXcmpMessages: GenericStorageQuery<(arg: [PolkadotParachainPrimitivesPrimitivesId, number]) => Bytes>;

    /**
     * Any signal messages waiting to be sent.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     **/
    signalMessages: GenericStorageQuery<(arg: PolkadotParachainPrimitivesPrimitivesId) => Bytes>;

    /**
     * The configuration which controls the dynamics of the outbound queue.
     **/
    queueConfig: GenericStorageQuery<() => CumulusPalletXcmpQueueQueueConfigData>;

    /**
     * Whether or not the XCMP queue is suspended from executing incoming XCMs or not.
     **/
    queueSuspended: GenericStorageQuery<() => boolean>;

    /**
     * The factor to multiply the base delivery fee by.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     **/
    deliveryFeeFactor: GenericStorageQuery<(arg: PolkadotParachainPrimitivesPrimitivesId) => FixedU128>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `PolkadotXcm`'s storage queries
   **/
  polkadotXcm: {
    /**
     * The latest available query index.
     **/
    queryCounter: GenericStorageQuery<() => bigint>;

    /**
     * The ongoing queries.
     *
     * @param {bigint} arg
     **/
    queries: GenericStorageQuery<(arg: bigint) => PalletXcmQueryStatus | undefined>;

    /**
     * The existing asset traps.
     *
     * Key is the blake2 256 hash of (origin, versioned `Assets`) pair. Value is the number of
     * times this pair has been trapped (usually just 1 if it exists at all).
     *
     * @param {H256} arg
     **/
    assetTraps: GenericStorageQuery<(arg: H256) => number>;

    /**
     * Default version to encode XCM when latest version of destination is unknown. If `None`,
     * then the destinations whose XCM version is unknown are considered unreachable.
     **/
    safeXcmVersion: GenericStorageQuery<() => number | undefined>;

    /**
     * The Latest versions that we know various locations support.
     *
     * @param {[number, XcmVersionedLocation]} arg
     **/
    supportedVersion: GenericStorageQuery<(arg: [number, XcmVersionedLocation]) => number | undefined>;

    /**
     * All locations that we have requested version notifications from.
     *
     * @param {[number, XcmVersionedLocation]} arg
     **/
    versionNotifiers: GenericStorageQuery<(arg: [number, XcmVersionedLocation]) => bigint | undefined>;

    /**
     * The target locations that are subscribed to our version changes, as well as the most recent
     * of our versions we informed them of.
     *
     * @param {[number, XcmVersionedLocation]} arg
     **/
    versionNotifyTargets: GenericStorageQuery<
      (arg: [number, XcmVersionedLocation]) => [bigint, SpWeightsWeightV2Weight, number] | undefined
    >;

    /**
     * Destinations whose latest XCM version we would like to know. Duplicates not allowed, and
     * the `u32` counter is the number of times that a send to the destination has been attempted,
     * which is used as a prioritization.
     **/
    versionDiscoveryQueue: GenericStorageQuery<() => Array<[XcmVersionedLocation, number]>>;

    /**
     * The current migration's stage, if any.
     **/
    currentMigration: GenericStorageQuery<() => PalletXcmVersionMigrationStage | undefined>;

    /**
     * Fungible assets which we know are locked on a remote chain.
     *
     * @param {[number, AccountId32Like, XcmVersionedAssetId]} arg
     **/
    remoteLockedFungibles: GenericStorageQuery<
      (arg: [number, AccountId32Like, XcmVersionedAssetId]) => PalletXcmRemoteLockedFungibleRecord | undefined
    >;

    /**
     * Fungible assets which we know are locked on this chain.
     *
     * @param {AccountId32Like} arg
     **/
    lockedFungibles: GenericStorageQuery<(arg: AccountId32Like) => Array<[bigint, XcmVersionedLocation]> | undefined>;

    /**
     * Global suspension state of the XCM executor.
     **/
    xcmExecutionSuspended: GenericStorageQuery<() => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `MessageQueue`'s storage queries
   **/
  messageQueue: {
    /**
     * The index of the first and last (non-empty) pages.
     *
     * @param {CumulusPrimitivesCoreAggregateMessageOrigin} arg
     **/
    bookStateFor: GenericStorageQuery<
      (arg: CumulusPrimitivesCoreAggregateMessageOrigin) => PalletMessageQueueBookState
    >;

    /**
     * The origin at which we should begin servicing.
     **/
    serviceHead: GenericStorageQuery<() => CumulusPrimitivesCoreAggregateMessageOrigin | undefined>;

    /**
     * The map of page indices to pages.
     *
     * @param {[CumulusPrimitivesCoreAggregateMessageOrigin, number]} arg
     **/
    pages: GenericStorageQuery<
      (arg: [CumulusPrimitivesCoreAggregateMessageOrigin, number]) => PalletMessageQueuePage | undefined
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Multisig`'s storage queries
   **/
  multisig: {
    /**
     * The set of open multisig operations.
     *
     * @param {[AccountId32Like, FixedBytes<32>]} arg
     **/
    multisigs: GenericStorageQuery<(arg: [AccountId32Like, FixedBytes<32>]) => PalletMultisigMultisig | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Proxy`'s storage queries
   **/
  proxy: {
    /**
     * The set of account proxies. Maps the account which has delegated to the accounts
     * which are being delegated to, together with the amount held on deposit.
     *
     * @param {AccountId32Like} arg
     **/
    proxies: GenericStorageQuery<(arg: AccountId32Like) => [Array<PalletProxyProxyDefinition>, bigint]>;

    /**
     * The announcements made by the proxy (key).
     *
     * @param {AccountId32Like} arg
     **/
    announcements: GenericStorageQuery<(arg: AccountId32Like) => [Array<PalletProxyAnnouncement>, bigint]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ToWestendXcmRouter`'s storage queries
   **/
  toWestendXcmRouter: {
    /**
     * Bridge that we are using.
     *
     * **bridges-v1** assumptions: all outbound messages through this router are using single lane
     * and to single remote consensus. If there is some other remote consensus that uses the same
     * bridge hub, the separate pallet instance shall be used, In `v2` we'll have all required
     * primitives (lane-id aka bridge-id, derived from XCM locations) to support multiple bridges
     * by the same pallet instance.
     **/
    bridge: GenericStorageQuery<() => BpXcmBridgeHubRouterBridgeState>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Assets`'s storage queries
   **/
  assets: {
    /**
     * Details of an asset.
     *
     * @param {number} arg
     **/
    asset: GenericStorageQuery<(arg: number) => PalletAssetsAssetDetails | undefined>;

    /**
     * The holdings of a specific account for a specific asset.
     *
     * @param {[number, AccountId32Like]} arg
     **/
    account: GenericStorageQuery<(arg: [number, AccountId32Like]) => PalletAssetsAssetAccount | undefined>;

    /**
     * Approved balance transfers. First balance is the amount approved for transfer. Second
     * is the amount of `T::Currency` reserved for storing this.
     * First key is the asset ID, second key is the owner and third key is the delegate.
     *
     * @param {[number, AccountId32Like, AccountId32Like]} arg
     **/
    approvals: GenericStorageQuery<
      (arg: [number, AccountId32Like, AccountId32Like]) => PalletAssetsApproval | undefined
    >;

    /**
     * Metadata of an asset.
     *
     * @param {number} arg
     **/
    metadata: GenericStorageQuery<(arg: number) => PalletAssetsAssetMetadata>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Uniques`'s storage queries
   **/
  uniques: {
    /**
     * Details of a collection.
     *
     * @param {number} arg
     **/
    class: GenericStorageQuery<(arg: number) => PalletUniquesCollectionDetails | undefined>;

    /**
     * The collection, if any, of which an account is willing to take ownership.
     *
     * @param {AccountId32Like} arg
     **/
    ownershipAcceptance: GenericStorageQuery<(arg: AccountId32Like) => number | undefined>;

    /**
     * The items held by any given account; set out this way so that items owned by a single
     * account can be enumerated.
     *
     * @param {[AccountId32Like, number, number]} arg
     **/
    account: GenericStorageQuery<(arg: [AccountId32Like, number, number]) => [] | undefined>;

    /**
     * The collections owned by any given account; set out this way so that collections owned by
     * a single account can be enumerated.
     *
     * @param {[AccountId32Like, number]} arg
     **/
    classAccount: GenericStorageQuery<(arg: [AccountId32Like, number]) => [] | undefined>;

    /**
     * The items in existence and their ownership details.
     *
     * @param {[number, number]} arg
     **/
    asset: GenericStorageQuery<(arg: [number, number]) => PalletUniquesItemDetails | undefined>;

    /**
     * Metadata of a collection.
     *
     * @param {number} arg
     **/
    classMetadataOf: GenericStorageQuery<(arg: number) => PalletUniquesCollectionMetadata | undefined>;

    /**
     * Metadata of an item.
     *
     * @param {[number, number]} arg
     **/
    instanceMetadataOf: GenericStorageQuery<(arg: [number, number]) => PalletUniquesItemMetadata | undefined>;

    /**
     * Attributes of a collection.
     *
     * @param {[number, number | undefined, BytesLike]} arg
     **/
    attribute: GenericStorageQuery<(arg: [number, number | undefined, BytesLike]) => [Bytes, bigint] | undefined>;

    /**
     * Price of an asset instance.
     *
     * @param {[number, number]} arg
     **/
    itemPriceOf: GenericStorageQuery<(arg: [number, number]) => [bigint, AccountId32 | undefined] | undefined>;

    /**
     * Keeps track of the number of items a collection might have.
     *
     * @param {number} arg
     **/
    collectionMaxSupply: GenericStorageQuery<(arg: number) => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Nfts`'s storage queries
   **/
  nfts: {
    /**
     * Details of a collection.
     *
     * @param {number} arg
     **/
    collection: GenericStorageQuery<(arg: number) => PalletNftsCollectionDetails | undefined>;

    /**
     * The collection, if any, of which an account is willing to take ownership.
     *
     * @param {AccountId32Like} arg
     **/
    ownershipAcceptance: GenericStorageQuery<(arg: AccountId32Like) => number | undefined>;

    /**
     * The items held by any given account; set out this way so that items owned by a single
     * account can be enumerated.
     *
     * @param {[AccountId32Like, number, number]} arg
     **/
    account: GenericStorageQuery<(arg: [AccountId32Like, number, number]) => [] | undefined>;

    /**
     * The collections owned by any given account; set out this way so that collections owned by
     * a single account can be enumerated.
     *
     * @param {[AccountId32Like, number]} arg
     **/
    collectionAccount: GenericStorageQuery<(arg: [AccountId32Like, number]) => [] | undefined>;

    /**
     * The items in existence and their ownership details.
     * Stores collection roles as per account.
     *
     * @param {[number, AccountId32Like]} arg
     **/
    collectionRoleOf: GenericStorageQuery<
      (arg: [number, AccountId32Like]) => PalletNftsBitFlagsCollectionRole | undefined
    >;

    /**
     * The items in existence and their ownership details.
     *
     * @param {[number, number]} arg
     **/
    item: GenericStorageQuery<(arg: [number, number]) => PalletNftsItemDetails | undefined>;

    /**
     * Metadata of a collection.
     *
     * @param {number} arg
     **/
    collectionMetadataOf: GenericStorageQuery<(arg: number) => PalletNftsCollectionMetadata | undefined>;

    /**
     * Metadata of an item.
     *
     * @param {[number, number]} arg
     **/
    itemMetadataOf: GenericStorageQuery<(arg: [number, number]) => PalletNftsItemMetadata | undefined>;

    /**
     * Attributes of a collection.
     *
     * @param {[number, number | undefined, PalletNftsAttributeNamespace, BytesLike]} arg
     **/
    attribute: GenericStorageQuery<
      (
        arg: [number, number | undefined, PalletNftsAttributeNamespace, BytesLike],
      ) => [Bytes, PalletNftsAttributeDeposit] | undefined
    >;

    /**
     * A price of an item.
     *
     * @param {[number, number]} arg
     **/
    itemPriceOf: GenericStorageQuery<(arg: [number, number]) => [bigint, AccountId32 | undefined] | undefined>;

    /**
     * Item attribute approvals.
     *
     * @param {[number, number]} arg
     **/
    itemAttributesApprovalsOf: GenericStorageQuery<(arg: [number, number]) => Array<AccountId32>>;

    /**
     * Stores the `CollectionId` that is going to be used for the next collection.
     * This gets incremented whenever a new collection is created.
     **/
    nextCollectionId: GenericStorageQuery<() => number | undefined>;

    /**
     * Handles all the pending swaps.
     *
     * @param {[number, number]} arg
     **/
    pendingSwapOf: GenericStorageQuery<(arg: [number, number]) => PalletNftsPendingSwap | undefined>;

    /**
     * Config of a collection.
     *
     * @param {number} arg
     **/
    collectionConfigOf: GenericStorageQuery<(arg: number) => PalletNftsCollectionConfig | undefined>;

    /**
     * Config of an item.
     *
     * @param {[number, number]} arg
     **/
    itemConfigOf: GenericStorageQuery<(arg: [number, number]) => PalletNftsItemConfig | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ForeignAssets`'s storage queries
   **/
  foreignAssets: {
    /**
     * Details of an asset.
     *
     * @param {StagingXcmV3MultilocationMultiLocation} arg
     **/
    asset: GenericStorageQuery<(arg: StagingXcmV3MultilocationMultiLocation) => PalletAssetsAssetDetails | undefined>;

    /**
     * The holdings of a specific account for a specific asset.
     *
     * @param {[StagingXcmV3MultilocationMultiLocation, AccountId32Like]} arg
     **/
    account: GenericStorageQuery<
      (arg: [StagingXcmV3MultilocationMultiLocation, AccountId32Like]) => PalletAssetsAssetAccount | undefined
    >;

    /**
     * Approved balance transfers. First balance is the amount approved for transfer. Second
     * is the amount of `T::Currency` reserved for storing this.
     * First key is the asset ID, second key is the owner and third key is the delegate.
     *
     * @param {[StagingXcmV3MultilocationMultiLocation, AccountId32Like, AccountId32Like]} arg
     **/
    approvals: GenericStorageQuery<
      (
        arg: [StagingXcmV3MultilocationMultiLocation, AccountId32Like, AccountId32Like],
      ) => PalletAssetsApproval | undefined
    >;

    /**
     * Metadata of an asset.
     *
     * @param {StagingXcmV3MultilocationMultiLocation} arg
     **/
    metadata: GenericStorageQuery<(arg: StagingXcmV3MultilocationMultiLocation) => PalletAssetsAssetMetadata>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `NftFractionalization`'s storage queries
   **/
  nftFractionalization: {
    /**
     * Keeps track of the corresponding NFT ID, asset ID and amount minted.
     *
     * @param {[number, number]} arg
     **/
    nftToAsset: GenericStorageQuery<(arg: [number, number]) => PalletNftFractionalizationDetails | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `PoolAssets`'s storage queries
   **/
  poolAssets: {
    /**
     * Details of an asset.
     *
     * @param {number} arg
     **/
    asset: GenericStorageQuery<(arg: number) => PalletAssetsAssetDetails | undefined>;

    /**
     * The holdings of a specific account for a specific asset.
     *
     * @param {[number, AccountId32Like]} arg
     **/
    account: GenericStorageQuery<(arg: [number, AccountId32Like]) => PalletAssetsAssetAccount | undefined>;

    /**
     * Approved balance transfers. First balance is the amount approved for transfer. Second
     * is the amount of `T::Currency` reserved for storing this.
     * First key is the asset ID, second key is the owner and third key is the delegate.
     *
     * @param {[number, AccountId32Like, AccountId32Like]} arg
     **/
    approvals: GenericStorageQuery<
      (arg: [number, AccountId32Like, AccountId32Like]) => PalletAssetsApproval | undefined
    >;

    /**
     * Metadata of an asset.
     *
     * @param {number} arg
     **/
    metadata: GenericStorageQuery<(arg: number) => PalletAssetsAssetMetadata>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `AssetConversion`'s storage queries
   **/
  assetConversion: {
    /**
     * Map from `PoolAssetId` to `PoolInfo`. This establishes whether a pool has been officially
     * created rather than people sending tokens directly to a pool's public account.
     *
     * @param {[StagingXcmV3MultilocationMultiLocation, StagingXcmV3MultilocationMultiLocation]} arg
     **/
    pools: GenericStorageQuery<
      (
        arg: [StagingXcmV3MultilocationMultiLocation, StagingXcmV3MultilocationMultiLocation],
      ) => PalletAssetConversionPoolInfo | undefined
    >;

    /**
     * Stores the `PoolAssetId` that is going to be used for the next lp token.
     * This gets incremented whenever a new lp pool is created.
     **/
    nextPoolAssetId: GenericStorageQuery<() => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
}
