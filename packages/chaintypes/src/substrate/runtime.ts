// Generated by @delightfuldot/codegen

import type { GenericRuntimeApis, GenericRuntimeApiMethod } from '@delightfuldot/types';
import type {
  RuntimeVersion,
  Header,
  DispatchError,
  Result,
  UncheckedExtrinsicLike,
  UncheckedExtrinsic,
  H256,
  AccountId32Like,
  BytesLike,
  Bytes,
  AccountId32,
} from '@delightfuldot/codecs';
import type {
  SpRuntimeBlock,
  SpCoreOpaqueMetadata,
  SpRuntimeTransactionValidityTransactionValidityError,
  SpInherentsInherentData,
  SpInherentsCheckInherentsResult,
  SpRuntimeTransactionValidityValidTransaction,
  SpRuntimeTransactionValidityTransactionSource,
  SpStatementStoreRuntimeApiValidStatement,
  SpStatementStoreRuntimeApiInvalidStatement,
  SpStatementStoreRuntimeApiStatementSource,
  SpStatementStoreStatement,
  SpConsensusGrandpaAppPublic,
  SpConsensusGrandpaEquivocationProof,
  SpConsensusGrandpaOpaqueKeyOwnershipProof,
  SpConsensusBabeBabeConfiguration,
  SpConsensusSlotsSlot,
  SpConsensusBabeEpoch,
  SpConsensusBabeOpaqueKeyOwnershipProof,
  SpConsensusBabeAppPublic,
  SpConsensusSlotsEquivocationProof,
  SpAuthorityDiscoveryAppPublic,
  PalletContractsPrimitivesContractResult,
  SpWeightsWeightV2Weight,
  PalletContractsPrimitivesContractResultResult,
  PalletContractsPrimitivesCode,
  PalletContractsPrimitivesCodeUploadReturnValue,
  PalletContractsWasmDeterminism,
  PalletContractsPrimitivesContractAccessError,
  PalletTransactionPaymentRuntimeDispatchInfo,
  PalletTransactionPaymentFeeDetails,
  PalletAssetConversionNativeOrAssetId,
  KitchensinkRuntimeRuntimeCallLike,
  SpMmrPrimitivesError,
  SpMmrPrimitivesEncodableOpaqueLeaf,
  SpMmrPrimitivesProof,
  SpCoreCryptoKeyTypeId,
} from './types';

export interface RuntimeApis extends GenericRuntimeApis {
  /**
   * @runtimeapi: Core - 0xdf6acb689907609b
   **/
  core: {
    /**
     * Returns the version of the runtime.
     *
     * @callname: Core_version
     **/
    version: GenericRuntimeApiMethod<() => Promise<RuntimeVersion>>;

    /**
     * Execute the given block.
     *
     * @callname: Core_execute_block
     **/
    executeBlock: GenericRuntimeApiMethod<(block: SpRuntimeBlock) => Promise<[]>>;

    /**
     * Initialize a block with the given header.
     *
     * @callname: Core_initialize_block
     **/
    initializeBlock: GenericRuntimeApiMethod<(header: Header) => Promise<[]>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: Metadata - 0x37e397fc7c91f5e4
   **/
  metadata: {
    /**
     * Returns the metadata of a runtime.
     *
     * @callname: Metadata_metadata
     **/
    metadata: GenericRuntimeApiMethod<() => Promise<SpCoreOpaqueMetadata>>;

    /**
     * Returns the metadata at a given version.
     *
     * If the given `version` isn't supported, this will return `None`.
     * Use [`Self::metadata_versions`] to find out about supported metadata version of the runtime.
     *
     * @callname: Metadata_metadata_at_version
     **/
    metadataAtVersion: GenericRuntimeApiMethod<(version: number) => Promise<SpCoreOpaqueMetadata | undefined>>;

    /**
     * Returns the supported metadata versions.
     *
     * This can be used to call `metadata_at_version`.
     *
     * @callname: Metadata_metadata_versions
     **/
    metadataVersions: GenericRuntimeApiMethod<() => Promise<Array<number>>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: BlockBuilder - 0x40fe3ad401f8959a
   **/
  blockBuilder: {
    /**
     * Apply the given extrinsic.
     *
     * Returns an inclusion outcome which specifies if this extrinsic is included in
     * this block or not.
     *
     * @callname: BlockBuilder_apply_extrinsic
     **/
    applyExtrinsic: GenericRuntimeApiMethod<
      (
        extrinsic: UncheckedExtrinsicLike,
      ) => Promise<Result<Result<[], DispatchError>, SpRuntimeTransactionValidityTransactionValidityError>>
    >;

    /**
     * Finish the current block.
     *
     * @callname: BlockBuilder_finalize_block
     **/
    finalizeBlock: GenericRuntimeApiMethod<() => Promise<Header>>;

    /**
     * Generate inherent extrinsics. The inherent data will vary from chain to chain.
     *
     * @callname: BlockBuilder_inherent_extrinsics
     **/
    inherentExtrinsics: GenericRuntimeApiMethod<
      (inherent: SpInherentsInherentData) => Promise<Array<UncheckedExtrinsic>>
    >;

    /**
     * Check that the inherents are valid. The inherent data will vary from chain to chain.
     *
     * @callname: BlockBuilder_check_inherents
     **/
    checkInherents: GenericRuntimeApiMethod<
      (block: SpRuntimeBlock, data: SpInherentsInherentData) => Promise<SpInherentsCheckInherentsResult>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: TaggedTransactionQueue - 0xd2bc9897eed08f15
   **/
  taggedTransactionQueue: {
    /**
     * Validate the transaction.
     *
     * This method is invoked by the transaction pool to learn details about given transaction.
     * The implementation should make sure to verify the correctness of the transaction
     * against current state. The given `block_hash` corresponds to the hash of the block
     * that is used as current state.
     *
     * Note that this call may be performed by the pool multiple times and transactions
     * might be verified in any possible order.
     *
     * @callname: TaggedTransactionQueue_validate_transaction
     **/
    validateTransaction: GenericRuntimeApiMethod<
      (
        source: SpRuntimeTransactionValidityTransactionSource,
        tx: UncheckedExtrinsicLike,
        blockHash: H256,
      ) => Promise<
        Result<SpRuntimeTransactionValidityValidTransaction, SpRuntimeTransactionValidityTransactionValidityError>
      >
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: ValidateStatement - 0xbe9fb0c91a8046cf
   **/
  validateStatement: {
    /**
     * Validate the statement.
     *
     * @callname: ValidateStatement_validate_statement
     **/
    validateStatement: GenericRuntimeApiMethod<
      (
        source: SpStatementStoreRuntimeApiStatementSource,
        statement: SpStatementStoreStatement,
      ) => Promise<Result<SpStatementStoreRuntimeApiValidStatement, SpStatementStoreRuntimeApiInvalidStatement>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: OffchainWorkerApi - 0xf78b278be53f454c
   **/
  offchainWorkerApi: {
    /**
     * Starts the off-chain task for given block header.
     *
     * @callname: OffchainWorkerApi_offchain_worker
     **/
    offchainWorker: GenericRuntimeApiMethod<(header: Header) => Promise<[]>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: GrandpaApi - 0xed99c5acb25eedf5
   **/
  grandpaApi: {
    /**
     * Get the current GRANDPA authorities and weights. This should not change except
     * for when changes are scheduled and the corresponding delay has passed.
     *
     * When called at block B, it will return the set of authorities that should be
     * used to finalize descendants of this block (B+1, B+2, ...). The block B itself
     * is finalized by the authorities from block B-1.
     *
     * @callname: GrandpaApi_grandpa_authorities
     **/
    grandpaAuthorities: GenericRuntimeApiMethod<() => Promise<Array<[SpConsensusGrandpaAppPublic, bigint]>>>;

    /**
     * Submits an unsigned extrinsic to report an equivocation. The caller
     * must provide the equivocation proof and a key ownership proof
     * (should be obtained using `generate_key_ownership_proof`). The
     * extrinsic will be unsigned and should only be accepted for local
     * authorship (not to be broadcast to the network). This method returns
     * `None` when creation of the extrinsic fails, e.g. if equivocation
     * reporting is disabled for the given runtime (i.e. this method is
     * hardcoded to return `None`). Only useful in an offchain context.
     *
     * @callname: GrandpaApi_submit_report_equivocation_unsigned_extrinsic
     **/
    submitReportEquivocationUnsignedExtrinsic: GenericRuntimeApiMethod<
      (
        equivocationProof: SpConsensusGrandpaEquivocationProof,
        keyOwnerProof: SpConsensusGrandpaOpaqueKeyOwnershipProof,
      ) => Promise<[] | undefined>
    >;

    /**
     * Generates a proof of key ownership for the given authority in the
     * given set. An example usage of this module is coupled with the
     * session historical module to prove that a given authority key is
     * tied to a given staking identity during a specific session. Proofs
     * of key ownership are necessary for submitting equivocation reports.
     * NOTE: even though the API takes a `set_id` as parameter the current
     * implementations ignore this parameter and instead rely on this
     * method being called at the correct block height, i.e. any point at
     * which the given set id is live on-chain. Future implementations will
     * instead use indexed data through an offchain worker, not requiring
     * older states to be available.
     *
     * @callname: GrandpaApi_generate_key_ownership_proof
     **/
    generateKeyOwnershipProof: GenericRuntimeApiMethod<
      (
        setId: bigint,
        authorityId: SpConsensusGrandpaAppPublic,
      ) => Promise<SpConsensusGrandpaOpaqueKeyOwnershipProof | undefined>
    >;

    /**
     * Get current GRANDPA authority set id.
     *
     * @callname: GrandpaApi_current_set_id
     **/
    currentSetId: GenericRuntimeApiMethod<() => Promise<bigint>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: NominationPoolsApi - 0x17a6bc0d0062aeb3
   **/
  nominationPoolsApi: {
    /**
     * Returns the pending rewards for the member that the AccountId was given for.
     *
     * @callname: NominationPoolsApi_pending_rewards
     **/
    pendingRewards: GenericRuntimeApiMethod<(who: AccountId32Like) => Promise<bigint>>;

    /**
     * Returns the equivalent balance of `points` for a given pool.
     *
     * @callname: NominationPoolsApi_points_to_balance
     **/
    pointsToBalance: GenericRuntimeApiMethod<(poolId: number, points: bigint) => Promise<bigint>>;

    /**
     * Returns the equivalent points of `new_funds` for a given pool.
     *
     * @callname: NominationPoolsApi_balance_to_points
     **/
    balanceToPoints: GenericRuntimeApiMethod<(poolId: number, newFunds: bigint) => Promise<bigint>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: StakingApi - 0x18ef58a3b67ba770
   **/
  stakingApi: {
    /**
     * Returns the nominations quota for a nominator with a given balance.
     *
     * @callname: StakingApi_nominations_quota
     **/
    nominationsQuota: GenericRuntimeApiMethod<(balance: bigint) => Promise<number>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: BabeApi - 0xcbca25e39f142387
   **/
  babeApi: {
    /**
     * Return the configuration for BABE.
     *
     * @callname: BabeApi_configuration
     **/
    configuration: GenericRuntimeApiMethod<() => Promise<SpConsensusBabeBabeConfiguration>>;

    /**
     * Returns the slot that started the current epoch.
     *
     * @callname: BabeApi_current_epoch_start
     **/
    currentEpochStart: GenericRuntimeApiMethod<() => Promise<SpConsensusSlotsSlot>>;

    /**
     * Returns information regarding the current epoch.
     *
     * @callname: BabeApi_current_epoch
     **/
    currentEpoch: GenericRuntimeApiMethod<() => Promise<SpConsensusBabeEpoch>>;

    /**
     * Returns information regarding the next epoch (which was already
     * previously announced).
     *
     * @callname: BabeApi_next_epoch
     **/
    nextEpoch: GenericRuntimeApiMethod<() => Promise<SpConsensusBabeEpoch>>;

    /**
     * Generates a proof of key ownership for the given authority in the
     * current epoch. An example usage of this module is coupled with the
     * session historical module to prove that a given authority key is
     * tied to a given staking identity during a specific session. Proofs
     * of key ownership are necessary for submitting equivocation reports.
     * NOTE: even though the API takes a `slot` as parameter the current
     * implementations ignores this parameter and instead relies on this
     * method being called at the correct block height, i.e. any point at
     * which the epoch for the given slot is live on-chain. Future
     * implementations will instead use indexed data through an offchain
     * worker, not requiring older states to be available.
     *
     * @callname: BabeApi_generate_key_ownership_proof
     **/
    generateKeyOwnershipProof: GenericRuntimeApiMethod<
      (
        slot: SpConsensusSlotsSlot,
        authorityId: SpConsensusBabeAppPublic,
      ) => Promise<SpConsensusBabeOpaqueKeyOwnershipProof | undefined>
    >;

    /**
     * Submits an unsigned extrinsic to report an equivocation. The caller
     * must provide the equivocation proof and a key ownership proof
     * (should be obtained using `generate_key_ownership_proof`). The
     * extrinsic will be unsigned and should only be accepted for local
     * authorship (not to be broadcast to the network). This method returns
     * `None` when creation of the extrinsic fails, e.g. if equivocation
     * reporting is disabled for the given runtime (i.e. this method is
     * hardcoded to return `None`). Only useful in an offchain context.
     *
     * @callname: BabeApi_submit_report_equivocation_unsigned_extrinsic
     **/
    submitReportEquivocationUnsignedExtrinsic: GenericRuntimeApiMethod<
      (
        equivocationProof: SpConsensusSlotsEquivocationProof,
        keyOwnerProof: SpConsensusBabeOpaqueKeyOwnershipProof,
      ) => Promise<[] | undefined>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: AuthorityDiscoveryApi - 0x687ad44ad37f03c2
   **/
  authorityDiscoveryApi: {
    /**
     * Retrieve authority identifiers of the current and next authority set.
     *
     * @callname: AuthorityDiscoveryApi_authorities
     **/
    authorities: GenericRuntimeApiMethod<() => Promise<Array<SpAuthorityDiscoveryAppPublic>>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: AccountNonceApi - 0xbc9d89904f5b923f
   **/
  accountNonceApi: {
    /**
     * Get current account nonce of given `AccountId`.
     *
     * @callname: AccountNonceApi_account_nonce
     **/
    accountNonce: GenericRuntimeApiMethod<(account: AccountId32Like) => Promise<number>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: AssetsApi - 0x8453b50b22293977
   **/
  assetsApi: {
    /**
     * Returns the list of `AssetId`s and corresponding balance that an `AccountId` has.
     *
     * @callname: AssetsApi_account_balances
     **/
    accountBalances: GenericRuntimeApiMethod<(account: AccountId32Like) => Promise<Array<[number, bigint]>>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: ContractsApi - 0x68b66ba122c93fa7
   **/
  contractsApi: {
    /**
     * Perform a call from a specified account to a given contract.
     *
     * See [`crate::Pallet::bare_call`].
     *
     * @callname: ContractsApi_call
     **/
    call: GenericRuntimeApiMethod<
      (
        origin: AccountId32Like,
        dest: AccountId32Like,
        value: bigint,
        gasLimit?: SpWeightsWeightV2Weight | undefined,
        storageDepositLimit?: bigint | undefined,
        inputData: BytesLike,
      ) => Promise<PalletContractsPrimitivesContractResult>
    >;

    /**
     * Instantiate a new contract.
     *
     * See `[crate::Pallet::bare_instantiate]`.
     *
     * @callname: ContractsApi_instantiate
     **/
    instantiate: GenericRuntimeApiMethod<
      (
        origin: AccountId32Like,
        value: bigint,
        gasLimit?: SpWeightsWeightV2Weight | undefined,
        storageDepositLimit?: bigint | undefined,
        code: PalletContractsPrimitivesCode,
        data: BytesLike,
        salt: BytesLike,
      ) => Promise<PalletContractsPrimitivesContractResultResult>
    >;

    /**
     * Upload new code without instantiating a contract from it.
     *
     * See [`crate::Pallet::bare_upload_code`].
     *
     * @callname: ContractsApi_upload_code
     **/
    uploadCode: GenericRuntimeApiMethod<
      (
        origin: AccountId32Like,
        code: BytesLike,
        storageDepositLimit?: bigint | undefined,
        determinism: PalletContractsWasmDeterminism,
      ) => Promise<Result<PalletContractsPrimitivesCodeUploadReturnValue, DispatchError>>
    >;

    /**
     * Query a given storage key in a given contract.
     *
     * Returns `Ok(Some(Vec<u8>))` if the storage value exists under the given key in the
     * specified account and `Ok(None)` if it doesn't. If the account specified by the address
     * doesn't exist, or doesn't have a contract then `Err` is returned.
     *
     * @callname: ContractsApi_get_storage
     **/
    getStorage: GenericRuntimeApiMethod<
      (
        address: AccountId32Like,
        key: BytesLike,
      ) => Promise<Result<Bytes | undefined, PalletContractsPrimitivesContractAccessError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: TransactionPaymentApi - 0x37c8bb1350a9a2a8
   **/
  transactionPaymentApi: {
    /**
     *
     * @callname: TransactionPaymentApi_query_info
     **/
    queryInfo: GenericRuntimeApiMethod<
      (uxt: UncheckedExtrinsicLike, len: number) => Promise<PalletTransactionPaymentRuntimeDispatchInfo>
    >;

    /**
     *
     * @callname: TransactionPaymentApi_query_fee_details
     **/
    queryFeeDetails: GenericRuntimeApiMethod<
      (uxt: UncheckedExtrinsicLike, len: number) => Promise<PalletTransactionPaymentFeeDetails>
    >;

    /**
     *
     * @callname: TransactionPaymentApi_query_weight_to_fee
     **/
    queryWeightToFee: GenericRuntimeApiMethod<(weight: SpWeightsWeightV2Weight) => Promise<bigint>>;

    /**
     *
     * @callname: TransactionPaymentApi_query_length_to_fee
     **/
    queryLengthToFee: GenericRuntimeApiMethod<(length: number) => Promise<bigint>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: AssetConversionApi - 0x8a8047a53a8277ec
   **/
  assetConversionApi: {
    /**
     * Provides a quote for [`Pallet::swap_tokens_for_exact_tokens`].
     *
     * Note that the price may have changed by the time the transaction is executed.
     * (Use `amount_in_max` to control slippage.)
     *
     * @callname: AssetConversionApi_quote_price_tokens_for_exact_tokens
     **/
    quotePriceTokensForExactTokens: GenericRuntimeApiMethod<
      (
        asset1: PalletAssetConversionNativeOrAssetId,
        asset2: PalletAssetConversionNativeOrAssetId,
        amount: bigint,
        includeFee: boolean,
      ) => Promise<bigint | undefined>
    >;

    /**
     * Provides a quote for [`Pallet::swap_exact_tokens_for_tokens`].
     *
     * Note that the price may have changed by the time the transaction is executed.
     * (Use `amount_out_min` to control slippage.)
     *
     * @callname: AssetConversionApi_quote_price_exact_tokens_for_tokens
     **/
    quotePriceExactTokensForTokens: GenericRuntimeApiMethod<
      (
        asset1: PalletAssetConversionNativeOrAssetId,
        asset2: PalletAssetConversionNativeOrAssetId,
        amount: bigint,
        includeFee: boolean,
      ) => Promise<bigint | undefined>
    >;

    /**
     * Returns the size of the liquidity pool for the given asset pair.
     *
     * @callname: AssetConversionApi_get_reserves
     **/
    getReserves: GenericRuntimeApiMethod<
      (
        asset1: PalletAssetConversionNativeOrAssetId,
        asset2: PalletAssetConversionNativeOrAssetId,
      ) => Promise<[bigint, bigint] | undefined>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: TransactionPaymentCallApi - 0xf3ff14d5ab527059
   **/
  transactionPaymentCallApi: {
    /**
     * Query information of a dispatch class, weight, and fee of a given encoded `Call`.
     *
     * @callname: TransactionPaymentCallApi_query_call_info
     **/
    queryCallInfo: GenericRuntimeApiMethod<
      (call: KitchensinkRuntimeRuntimeCallLike, len: number) => Promise<PalletTransactionPaymentRuntimeDispatchInfo>
    >;

    /**
     * Query fee details of a given encoded `Call`.
     *
     * @callname: TransactionPaymentCallApi_query_call_fee_details
     **/
    queryCallFeeDetails: GenericRuntimeApiMethod<
      (call: KitchensinkRuntimeRuntimeCallLike, len: number) => Promise<PalletTransactionPaymentFeeDetails>
    >;

    /**
     * Query the output of the current `WeightToFee` given some input.
     *
     * @callname: TransactionPaymentCallApi_query_weight_to_fee
     **/
    queryWeightToFee: GenericRuntimeApiMethod<(weight: SpWeightsWeightV2Weight) => Promise<bigint>>;

    /**
     * Query the output of the current `LengthToFee` given some input.
     *
     * @callname: TransactionPaymentCallApi_query_length_to_fee
     **/
    queryLengthToFee: GenericRuntimeApiMethod<(length: number) => Promise<bigint>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: NftsApi - 0x899a250cbe84f250
   **/
  nftsApi: {
    /**
     *
     * @callname: NftsApi_owner
     **/
    owner: GenericRuntimeApiMethod<(collection: number, item: number) => Promise<AccountId32 | undefined>>;

    /**
     *
     * @callname: NftsApi_collection_owner
     **/
    collectionOwner: GenericRuntimeApiMethod<(collection: number) => Promise<AccountId32 | undefined>>;

    /**
     *
     * @callname: NftsApi_attribute
     **/
    attribute: GenericRuntimeApiMethod<
      (collection: number, item: number, key: BytesLike) => Promise<Bytes | undefined>
    >;

    /**
     *
     * @callname: NftsApi_custom_attribute
     **/
    customAttribute: GenericRuntimeApiMethod<
      (account: AccountId32Like, collection: number, item: number, key: BytesLike) => Promise<Bytes | undefined>
    >;

    /**
     *
     * @callname: NftsApi_system_attribute
     **/
    systemAttribute: GenericRuntimeApiMethod<
      (collection: number, item: number, key: BytesLike) => Promise<Bytes | undefined>
    >;

    /**
     *
     * @callname: NftsApi_collection_attribute
     **/
    collectionAttribute: GenericRuntimeApiMethod<(collection: number, key: BytesLike) => Promise<Bytes | undefined>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: MmrApi - 0x91d5df18b0d2cf58
   **/
  mmrApi: {
    /**
     * Return the on-chain MMR root hash.
     *
     * @callname: MmrApi_mmr_root
     **/
    mmrRoot: GenericRuntimeApiMethod<() => Promise<Result<H256, SpMmrPrimitivesError>>>;

    /**
     * Return the number of MMR blocks in the chain.
     *
     * @callname: MmrApi_mmr_leaf_count
     **/
    mmrLeafCount: GenericRuntimeApiMethod<() => Promise<Result<bigint, SpMmrPrimitivesError>>>;

    /**
     * Generate MMR proof for a series of block numbers. If `best_known_block_number = Some(n)`,
     * use historical MMR state at given block height `n`. Else, use current MMR state.
     *
     * @callname: MmrApi_generate_proof
     **/
    generateProof: GenericRuntimeApiMethod<
      (
        blockNumbers: Array<number>,
        bestKnownBlockNumber?: number | undefined,
      ) => Promise<Result<[Array<SpMmrPrimitivesEncodableOpaqueLeaf>, SpMmrPrimitivesProof], SpMmrPrimitivesError>>
    >;

    /**
     * Verify MMR proof against on-chain MMR for a batch of leaves.
     *
     * Note this function will use on-chain MMR root hash and check if the proof matches the hash.
     * Note, the leaves should be sorted such that corresponding leaves and leaf indices have the
     * same position in both the `leaves` vector and the `leaf_indices` vector contained in the [Proof]
     *
     * @callname: MmrApi_verify_proof
     **/
    verifyProof: GenericRuntimeApiMethod<
      (
        leaves: Array<SpMmrPrimitivesEncodableOpaqueLeaf>,
        proof: SpMmrPrimitivesProof,
      ) => Promise<Result<[], SpMmrPrimitivesError>>
    >;

    /**
     * Verify MMR proof against given root hash for a batch of leaves.
     *
     * Note this function does not require any on-chain storage - the
     * proof is verified against given MMR root hash.
     *
     * Note, the leaves should be sorted such that corresponding leaves and leaf indices have the
     * same position in both the `leaves` vector and the `leaf_indices` vector contained in the [Proof]
     *
     * @callname: MmrApi_verify_proof_stateless
     **/
    verifyProofStateless: GenericRuntimeApiMethod<
      (
        root: H256,
        leaves: Array<SpMmrPrimitivesEncodableOpaqueLeaf>,
        proof: SpMmrPrimitivesProof,
      ) => Promise<Result<[], SpMmrPrimitivesError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: SessionKeys - 0xab3c0572291feb8b
   **/
  sessionKeys: {
    /**
     * Generate a set of session keys with optionally using the given seed.
     * The keys should be stored within the keystore exposed via runtime
     * externalities.
     *
     * The seed needs to be a valid `utf8` string.
     *
     * Returns the concatenated SCALE encoded public keys.
     *
     * @callname: SessionKeys_generate_session_keys
     **/
    generateSessionKeys: GenericRuntimeApiMethod<(seed?: BytesLike | undefined) => Promise<Bytes>>;

    /**
     * Decode the given public session keys.
     *
     * Returns the list of public raw public keys + key type.
     *
     * @callname: SessionKeys_decode_session_keys
     **/
    decodeSessionKeys: GenericRuntimeApiMethod<
      (encoded: BytesLike) => Promise<Array<[Bytes, SpCoreCryptoKeyTypeId]> | undefined>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
}
