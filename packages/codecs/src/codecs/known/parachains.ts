import * as $ from '@dedot/shape';
import { $AccountId32, $BlockNumber, $Hash } from '../generic';
import { $H256, $H512 } from './primitives';

/**
 * Approval voting configuration parameters
 */
export const $ApprovalVotingParams = $.Struct({
  // The maximum number of candidates `approval-voting` can vote for with
  // a single signatures.
  //
  // Setting it to 1, means we send the approval as soon as we have it available.
  maxApprovalCoalesceCount: $.u32,
});

export type ApprovalVotingParams = $.Input<typeof $ApprovalVotingParams>;

/**
 * Identity that parachain validators use when signing validation messages.
 */
export const $ValidatorId = $AccountId32;

export type ValidatorId = $.Input<typeof $ValidatorId>;

/**
 * Index of the validator is used as a lightweight replacement of the `ValidatorId` when
 * appropriate.
 */
export const $ParaValidatorIndex = $.u32;

export type ParaValidatorIndex = $.Input<typeof $ParaValidatorIndex>;

/**
 * A helper data-type for tracking validator-group rotations.
 */
export const $GroupRotationInfo = $.Struct({
  // The block number where the session started.
  sessionStartBlock: $BlockNumber,
  // How often groups rotate. 0 means never.
  groupRotationFrequency: $BlockNumber,
  // The current block number.
  now: $BlockNumber,
});

export type GroupRotationInfo = $.Input<typeof $GroupRotationInfo>;

/**
 * Unique identifier of a parachain.
 */
export const $ParaId = $.u32;

export type ParaId = $.Input<typeof $ParaId>;

/**
 * Identity that collators use.
 */
export const $CollatorId = $H256;

export type CollatorId = $.Input<typeof $CollatorId>;

/**
 * Information about a core which is currently occupied.
 */
export const $ScheduledCore = $.Struct({
  // The ID of a para scheduled.
  paraId: $ParaId,
  // DEPRECATED: see: <https://github.com/paritytech/polkadot/issues/7575>
  //
  // Will be removed in a future version.
  collator: $.Option($CollatorId),
});

export type ScheduledCore = $.Input<typeof $ScheduledCore>;

/**
 * The unique (during session) index of a validator group.
 */
export const $GroupIndex = $.u32;

export type GroupIndex = $.Input<typeof $GroupIndex>;

/**
 * Unit type wrapper around [`type@Hash`] that represents a candidate hash.
 *
 * This type is produced by `CandidateReceipt::hash`.
 *
 * This type makes it easy to enforce that a hash is a candidate hash on the type level.
 */
export const $CandidateHash = $Hash;

export type CandidateHash = $.Input<typeof $CandidateHash>;

/**
 * Signature on candidate's block data by a collator.
 */
export const $CollatorSignature = $H512;

export type CollatorSignature = $.Input<typeof $CollatorSignature>;

/**
 * Unit type wrapper around [`type@Hash`] that represents the blake2-256 hash
 * of validation code in particular.
 *
 * This type is produced by [`ValidationCode::hash`].
 *
 * This type makes it easy to enforce that a hash is a validation code hash on the type level.
 */
export const $ValidationCodeHash = $Hash;

export type ValidationCodeHash = $.Input<typeof $ValidationCodeHash>;

/**
 * Candidate's acceptance limitations for asynchronous backing per relay parent.
 */
export const $CandidateDescriptor = $.Struct({
  // The ID of the para this is a candidate for.
  paraId: $ParaId,
  // The hash of the relay-chain block this is executed in the context of.
  relayParent: $Hash,
  // The collator's sr25519 public key.
  collator: $CollatorId,
  // The blake2-256 hash of the persisted validation data. This is extra data derived from
  // relay-chain state which may vary based on bitfields included before the candidate.
  // Thus it cannot be derived entirely from the relay-parent.
  persistedValidationDataHash: $Hash,
  // The blake2-256 hash of the PoV.
  povHash: $Hash,
  // The root of a block's erasure encoding Merkle tree.
  erasureRoot: $Hash,
  // Signature on blake2-256 of components of this receipt:
  // The parachain index, the relay parent, the validation data hash, and the `pov_hash`.
  signature: $CollatorSignature,
  // Hash of the para header that is being generated by this candidate.
  paraHead: $Hash,
  // The blake2-256 hash of the validation code bytes.
  validationCodeHash: $ValidationCodeHash,
});

export type CandidateDescriptor = $.Input<typeof $CandidateDescriptor>;

/**
 * Information about a core which is currently occupied.
 */
export const $OccupiedCore = $.Struct({
  // If this core is freed by availability, this is the assignment that is next up on this
  // core, if any. None if there is nothing queued for this core.
  nextUpOnAvailable: $.Option($ScheduledCore),
  // The relay-chain block number this began occupying the core at.
  occupiedSince: $BlockNumber,
  // The relay-chain block this will time-out at, if any.
  timeOutAt: $BlockNumber,
  // If this core is freed by being timed-out, this is the assignment that is next up on this
  // core. None if there is nothing queued for this core or there is no possibility of timing
  // out.
  nextUpOnTimeOut: $.Option($ScheduledCore),
  // A bitfield with 1 bit for each validator in the set. `1` bits mean that the corresponding
  // validators has attested to availability on-chain. A 2/3+ majority of `1` bits means that
  // this will be available.
  availability: $.bitSequence, //BitVec<u8, bitvec::order::Lsb0>,
  // The group assigned to distribute availability pieces of this candidate.
  groupResponsible: $GroupIndex,
  // The hash of the candidate occupying the core.
  candidateHash: $CandidateHash,
  // The descriptor of the candidate occupying the core.
  candidateDescriptor: $CandidateDescriptor,
});

export type OccupiedCore = $.Input<typeof $OccupiedCore>;

/**
 * The state of a particular availability core.
 */
export const $CoreState = $.Enum({
  // The core is currently occupied.
  Occupied: $OccupiedCore,
  // The core is currently free, with a para scheduled and given the opportunity
  // to occupy.
  //
  // If a particular Collator is required to author this block, that is also present in this
  // variant.
  Scheduled: $ScheduledCore,
  // The core is currently free and there is nothing scheduled. This can be the case for
  // parathread cores when there are no parathread blocks queued. Parachain cores will never be
  // left idle.
  Free: null,
});

export type CoreState = $.Input<typeof $CoreState>;

/**
 * An assumption being made about the state of an occupied core.
 */
export const $OccupiedCoreAssumption = $.FlatEnum([
  // The candidate occupying the core was made available and included to free the core.
  'Included',
  // The candidate occupying the core timed out and freed the core without advancing the para.
  'TimedOut',
  // The core was not occupied to begin with.
  'Free',
]);

export type OccupiedCoreAssumption = $.Input<typeof $OccupiedCoreAssumption>;

/**
 * Parachain head data included in the chain.
 */
export const $HeadData = $.PrefixedHex;

export type HeadData = $.Input<typeof $HeadData>;

/**
 * The validation data provides information about how to create the inputs for validation of a
 * candidate. This information is derived from the chain state and will vary from para to para,
 * although some fields may be the same for every para.
 *
 * Since this data is used to form inputs to the validation function, it needs to be persisted by
 * the availability system to avoid dependence on availability of the relay-chain state.
 *
 * Furthermore, the validation data acts as a way to authorize the additional data the collator
 * needs to pass to the validation function. For example, the validation function can check whether
 * the incoming messages (e.g. downward messages) were actually sent by using the data provided in
 * the validation data using so called MQC heads.
 *
 * Since the commitments of the validation function are checked by the relay-chain, secondary
 * checkers can rely on the invariant that the relay-chain only includes para-blocks for which
 * these checks have already been done. As such, there is no need for the validation data used to
 * inform validators and collators about the checks the relay-chain will perform to be persisted by
 * the availability system.
 *
 * The `PersistedValidationData` should be relatively lightweight primarily because it is
 * constructed during inclusion for each candidate and therefore lies on the critical path of
 * inclusion.
 */
export const $PersistedValidationData = $.Struct({
  // The parent head-data.
  parentHead: $HeadData,
  // The relay-chain block number this is in the context of.
  relayParentNumber: $BlockNumber,
  // The relay-chain block storage root this is in the context of.
  relayParentStorageRoot: $Hash,
  // The maximum legal size of a POV block, in bytes.
  maxPovSize: $.u32,
});

export type PersistedValidationData = $.Input<typeof $PersistedValidationData>;

/**
 * A message from a parachain to its Relay Chain.
 */
export const $UpwardMessage = $.PrefixedHex;

export type UpwardMessage = $.Input<typeof $UpwardMessage>;

export const $UpwardMessages = $.Vec($UpwardMessage);

export type UpwardMessages = $.Input<typeof $UpwardMessages>;

/**
 * An HRMP message seen from the perspective of a sender.
 */
export const $OutboundHrmpMessage = $.Struct({
  // The para that will get this message in its downward message queue.
  recipient: $ParaId,
  // The message payload.
  data: $.PrefixedHex,
});

export type OutboundHrmpMessage = $.Input<typeof $OutboundHrmpMessage>;

export const $HorizontalMessages = $.Vec($OutboundHrmpMessage);

export type HorizontalMessages = $.Input<typeof $HorizontalMessages>;

/**
 * Parachain validation code.
 */
export const $ValidationCode = $.PrefixedHex;

export type ValidationCode = $.Input<typeof $ValidationCode>;

export const $CandidateCommitments = $.Struct({
  // Messages destined to be interpreted by the Relay chain itself.
  upwardMessages: $UpwardMessages,
  // Horizontal messages sent by the parachain.
  horizontalMessages: $HorizontalMessages,
  // New validation code.
  newValidationCode: $.Option($ValidationCode),
  // The head-data produced as a result of execution.
  headData: $HeadData,
  // The number of messages processed from the DMQ.
  processedDownwardMessages: $.u32,
  // The mark which specifies the block number up to which all inbound HRMP messages are
  // processed.
  hrmpWatermark: $BlockNumber,
});

export type CandidateCommitments = $.Input<typeof $CandidateCommitments>;

/**
 * Simple index type with which we can count sessions.
 */
export const $SessionIndex = $.u32;

export type SessionIndex = $.Input<typeof $SessionIndex>;

/**
 * A candidate-receipt with commitments directly included.
 */
export const $CommittedCandidateReceipt = $.Struct({
  // The descriptor of the candidate.
  descriptor: $CandidateDescriptor,
  // The commitments of the candidate receipt.
  commitments: $CandidateCommitments,
});

export type CommittedCandidateReceipt = $.Input<typeof $CommittedCandidateReceipt>;

/**
 * A candidate-receipt.
 */
export const $CandidateReceipt = $.Struct({
  // The descriptor of the candidate.
  descriptor: $CandidateDescriptor,
  // The hash of the encoded commitments made as a result of candidate execution.
  commitmentsHash: $Hash,
});

export type CandidateReceipt = $.Input<typeof $CandidateReceipt>;

/**
 * The unique (during session) index of a core.
 */
export const $CoreIndex = $.u32;

export type CoreIndex = $.Input<typeof $CoreIndex>;

/**
 * An even concerning a candidate.
 */
export const $CandidateEvent = $.Enum({
  // This candidate receipt was backed in the most recent block.
  // This includes the core index the candidate is now occupying.
  CandidateBacked: $.Tuple($CandidateReceipt, $HeadData, $CoreIndex, $GroupIndex),
  // This candidate receipt was included and became a parablock at the most recent block.
  // This includes the core index the candidate was occupying as well as the group responsible
  // for backing the candidate.
  CandidateIncluded: $.Tuple($CandidateReceipt, $HeadData, $CoreIndex, $GroupIndex),
  // This candidate receipt was not made available in time and timed out.
  // This includes the core index the candidate was occupying.
  CandidateTimedOut: $.Tuple($CandidateReceipt, $HeadData, $CoreIndex),
});

export type CandidateEvent = $.Input<typeof $CandidateEvent>;

/**
 * A message sent from the relay-chain down to a parachain.
 */
export const $DownwardMessage = $.PrefixedHex;

export type DownwardMessage = $.Input<typeof $DownwardMessage>;

/**
 * A wrapped version of `DownwardMessage`. The difference is that it has attached the block number
 * when the message was sent.
 */
export const $InboundDownwardMessage = $.Struct({
  // The block number at which these messages were put into the downward message queue.
  sentAt: $BlockNumber,
  // The actual downward message to processes.
  msg: $DownwardMessage,
});

export type InboundDownwardMessage = $.Input<typeof $InboundDownwardMessage>;

export const $InboundHrmpMessage = $.Struct({
  // The block number at which this message was sent.
  // Specifically, it is the block number at which the candidate that sends this message was
  // enacted.
  sentAt: $BlockNumber,
  // The message payload.
  data: $.PrefixedHex,
});

export type InboundHrmpMessage = $.Input<typeof $InboundHrmpMessage>;

/**
 * Signature with which parachain validators sign blocks.
 *
 * For now we assert that parachain validator set is exactly equivalent to the authority set, and
 * so we define it to be the same type as `SessionKey`. In the future it may have different crypto.
 */
export const $ValidatorSignature = $H512;

export type ValidatorSignature = $.Input<typeof $ValidatorSignature>;

/**
 * An either implicit or explicit attestation to the validity of a parachain
 * candidate.
 */
export const $ValidityAttestation = $.Enum({
  // Implicit validity attestation by issuing.
  // This corresponds to issuance of a `Candidate` statement.
  Implicit: { index: 1, value: $ValidatorSignature },
  // An explicit attestation. This corresponds to issuance of a
  // `Valid` statement.
  Explicit: { index: 2, value: $ValidatorSignature },
});

export type ValidityAttestation = $.Input<typeof $ValidityAttestation>;

/**
 * Different kinds of statements of validity on  a candidate.
 */
export const $ValidDisputeStatementKind = $.Enum({
  // An explicit statement issued as part of a dispute.
  Explicit: null,
  // A seconded statement on a candidate from the backing phase.
  BackingSeconded: $Hash,
  // A valid statement on a candidate from the backing phase.
  BackingValid: $Hash,
  // An approval vote from the approval checking phase.
  ApprovalChecking: null,
  // An approval vote from the new version.
  // We can't create this version untill all nodes
  // have been updated to support it and max_approval_coalesce_count
  // is set to more than 1.
  ApprovalCheckingMultipleCandidates: $.Vec($CandidateHash),
});

export type ValidDisputeStatementKind = $.Input<typeof $ValidDisputeStatementKind>;

/**
 * Different kinds of statements of invalidity on a candidate.
 */
export const $InvalidDisputeStatementKind = $.Enum({
  // An explicit statement issued as part of a dispute.
  Explicit: null,
});

export type InvalidDisputeStatementKind = $.Input<typeof $InvalidDisputeStatementKind>;

/**
 * A statement about a candidate, to be used within the dispute resolution process.
 *
 * Statements are either in favor of the candidate's validity or against it.
 */
export const $DisputeStatement = $.Enum({
  // A valid statement, of the given kind.
  Valid: $ValidDisputeStatementKind,
  // An invalid statement, of the given kind.
  Invalid: $InvalidDisputeStatementKind,
});

export type DisputeStatement = $.Input<typeof $DisputeStatement>;

/**
 * A set of statements about a specific candidate.
 */
export const $DisputeStatementSet = $.Struct({
  // The candidate referenced by this set.
  candidateHash: $CandidateHash,
  // The session index of the candidate.
  session: $SessionIndex,
  // Statements about the candidate.
  statements: $.Vec($.Tuple($DisputeStatement, $ParaValidatorIndex, $ValidatorSignature)),
});

export type DisputeStatementSet = $.Input<typeof $DisputeStatementSet>;

/**
 * A set of dispute statements.
 */
export const $MultiDisputeStatementSet = $.Vec($DisputeStatementSet);

export type MultiDisputeStatementSet = $.Input<typeof $MultiDisputeStatementSet>;

export const $ScrapedOnChainVotes = $.Struct({
  // The session in which the block was included.
  session: $SessionIndex,
  // Set of backing validators for each candidate, represented by its candidate
  // receipt.
  backingValidatorsPerCandidate: $.Vec(
    $.Tuple($CandidateReceipt, $.Vec($.Tuple($ParaValidatorIndex, $ValidityAttestation))),
  ),
  // On-chain-recorded set of disputes.
  // Note that the above `backing_validators` are
  // unrelated to the backers of the disputes candidates.
  disputes: $MultiDisputeStatementSet,
});

export type ScrapedOnChainVotes = $.Input<typeof $ScrapedOnChainVotes>;

/**
 * Information about validator sets of a session.
 *
 * Ref: https://github.com/paritytech/polkadot-sdk/blob/0ff3f4d3af0036bbae624011b720bfd5e93ce91b/polkadot/primitives/src/v6/mod.rs#L1714-L1774
 */
export const $SessionInfo = $.Struct({
  // All the validators actively participating in parachain consensus.
  // Indices are into the broader validator set.
  activeValidatorIndices: $.Vec($ParaValidatorIndex),
  // A secure random seed for the session, gathered from BABE.
  randomSeed: $.FixedHex(32),
  // The amount of sessions to keep for disputes.
  disputePeriod: $SessionIndex,
  // Validators in canonical ordering.
  validators: $.Vec($ValidatorId),
  // Validators' authority discovery keys for the session in canonical ordering.
  discoveryKeys: $.Vec($AccountId32),
  // The assignment keys for validators.
  assignmentKeys: $.Vec($AccountId32),
  // Validators in shuffled ordering - these are the validator groups as produced
  // by the `Scheduler` module for the session and are typically referred to by
  // `GroupIndex`.
  validatorGroups: $.Vec($.Vec($ParaValidatorIndex)),
  // The number of availability cores used by the protocol during this session.
  nCores: $.u32,
  // The zeroth delay tranche width.
  zerothDelayTrancheWidth: $.u32,
  // The number of samples we do of `relay_vrf_modulo`.
  relayVrfModuloSamples: $.u32,
  // The number of delay tranches in total.
  nDelayTranches: $.u32,
  // How many slots (BABE / SASSAFRAS) must pass before an assignment is considered a
  // no-show.
  noShowSlots: $.u32,
  // The number of validators needed to approve a block.
  neededApprovals: $.u32,
});

export type SessionInfo = $.Input<typeof $SessionInfo>;

/**
 * A statement from the specified validator whether the given validation code passes PVF
 * pre-checking or not anchored to the given session index.
 */
export const $PvfCheckStatement = $.Struct({
  // `true` if the subject passed pre-checking and `false` otherwise.
  accept: $.bool,
  // The validation code hash that was checked.
  subject: $ValidationCodeHash,
  // The index of a session during which this statement is considered valid.
  sessionIndex: $SessionIndex,
  // The index of the validator from which this statement originates.
  validatorIndex: $ParaValidatorIndex,
});

export type PvfCheckStatement = $.Input<typeof $PvfCheckStatement>;

/**
 * The entire state of a dispute.
 */
export const $DisputeState = $.Struct({
  // A bitfield indicating all validators for the candidate.
  validatorsFor: $.bitSequence, //BitVec<u8, bitvec::order::Lsb0>, // one bit per validator.
  // A bitfield indicating all validators against the candidate.
  validatorsAgainst: $.bitSequence, //BitVec<u8, bitvec::order::Lsb0>, // one bit per validator.
  // The block number at which the dispute started on-chain.
  start: $BlockNumber,
  // The block number at which the dispute concluded on-chain.
  concludedAt: $.Option($BlockNumber),
});

export type DisputeState = $.Input<typeof $DisputeState>;

/**
 * Type discriminator for PVF preparation
 */
export const $PvfPrepKind = $.FlatEnum([
  // For prechecking requests.
  'Precheck',
  // For execution and heads-up requests.
  'Prepare',
]);

export type PvfPrepKind = $.Input<typeof $PvfPrepKind>;

/**
 * Type discriminator for PVF execution.
 */
export const $PvfExecKind = $.FlatEnum([
  // For backing requests.
  'Backing',
  // For approval and dispute request.
  'Approval',
]);

export type PvfExecKind = $.Input<typeof $PvfExecKind>;

/**
 * The different executor parameters for changing the execution environment semantics.
 */
export const $ExecutorParam = $.Enum({
  // Maximum number of memory pages (64KiB bytes per page) the executor can allocate.
  // A valid value lies within (0, 65536].
  MaxMemoryPages: { index: 1, value: $.u32 },
  // Wasm logical stack size limit (max. number of Wasm values on stack).
  // A valid value lies within [[`LOGICAL_MAX_LO`], [`LOGICAL_MAX_HI`]].
  //
  // For WebAssembly, the stack limit is subject to implementations, meaning that it may vary on
  // different platforms. However, we want execution to be deterministic across machines of
  // different architectures, including failures like stack overflow. For deterministic
  // overflow, we rely on a **logical** limit, the maximum number of values allowed to be pushed
  // on the stack.
  StackLogicalMax: { index: 2, value: $.u32 },
  // Executor machine stack size limit, in bytes.
  // If `StackLogicalMax` is also present, a valid value should not fall below
  // 128 * `StackLogicalMax`.
  //
  // For deterministic overflow, `StackLogicalMax` should be reached before the native stack is
  // exhausted.
  StackNativeMax: { index: 3, value: $.u32 },
  // Max. amount of memory the preparation worker is allowed to use during
  // pre-checking, in bytes.
  // Valid max. memory ranges from [`PRECHECK_MEM_MAX_LO`] to [`PRECHECK_MEM_MAX_HI`].
  PrecheckingMaxMemory: { index: 4, value: $.u64 },
  // PVF preparation timeouts, in millisecond.
  // Always ensure that `precheck_timeout` < `lenient_timeout`.
  // When absent, the default values will be used.
  PvfPrepTimeout: { index: 5, value: $.Tuple($PvfPrepKind, $.u64) },
  // PVF execution timeouts, in millisecond.
  // Always ensure that `backing_timeout` < `approval_timeout`.
  // When absent, the default values will be used.
  PvfExecTimeout: { index: 6, value: $.Tuple($PvfExecKind, $.u64) },
  // Enables WASM bulk memory proposal
  WasmExtBulkMemory: null,
});

export type ExecutorParam = $.Input<typeof $ExecutorParam>;

/**
 * # Deterministically serialized execution environment semantics
 * Represents an arbitrary semantics of an arbitrary execution environment, so should be kept as
 * abstract as possible.
 */
export const $ExecutorParams = $.Vec($ExecutorParam);

export type ExecutorParams = $.Input<typeof $ExecutorParams>;

/**
 * The kind of the dispute offence.
 */
export const $SlashingOffenceKind = $.FlatEnum([
  // A severe offence when a validator backed an invalid block.
  'ForInvalid',
  // A minor offence when a validator disputed a valid block.
  'AgainstValid',
]);

export type SlashingOffenceKind = $.Input<typeof $SlashingOffenceKind>;

/**
 * Slashes that are waiting to be applied once we have validator key
 * identification.
 */
export const $PendingSlashes = $.Struct({
  // Indices and keys of the validators who lost a dispute and are pending
  // slashes.
  keys: $.map($ParaValidatorIndex, $ValidatorId),
  // The dispute outcome.
  kind: $SlashingOffenceKind,
});

export type PendingSlashes = $.Input<typeof $PendingSlashes>;

/**
 * Timeslots should uniquely identify offences and are used for the offence
 * deduplication.
 */
export const $DisputesTimeSlot = $.Struct({
  // The order of the fields matters for `derive(Ord)`.
  // Session index when the candidate was backed/included.
  sessionIndex: $SessionIndex,
  // Candidate hash of the disputed candidate.
  candidateHash: $CandidateHash,
});

export type DisputesTimeSlot = $.Input<typeof $DisputesTimeSlot>;

/**
 * We store most of the information about a lost dispute on chain. This struct
 * is required to identify and verify it.
 */
export const $DisputeProof = $.Struct({
  // Time slot when the dispute occured.
  timeSlot: $DisputesTimeSlot,
  // The dispute outcome.
  kind: $SlashingOffenceKind,
  // The index of the validator who lost a dispute.
  validatorIndex: $ParaValidatorIndex,
  // The parachain session key of the validator.
  validatorId: $ValidatorId,
});

export type DisputeProof = $.Input<typeof $DisputeProof>;

/**
 * Constraints on inbound HRMP channels.
 */
export const $InboundHrmpLimitations = $.Struct({
  // An exhaustive set of all valid watermarks, sorted ascending.
  //
  // It's only expected to contain block numbers at which messages were
  // previously sent to a para, excluding most recent head.
  valid_watermarks: $.Vec($BlockNumber),
});

export type InboundHrmpLimitations = $.Input<typeof $InboundHrmpLimitations>;

/**
 * Constraints on outbound HRMP channels.
 */
export const $OutboundHrmpChannelLimitations = $.Struct({
  // The maximum bytes that can be written to the channel.
  bytesRemaining: $.u32,
  // The maximum messages that can be written to the channel.
  messagesRemaining: $.u32,
});

export type OutboundHrmpChannelLimitations = $.Input<typeof $OutboundHrmpChannelLimitations>;

/**
 * A possible upgrade restriction that prevents a parachain from performing an upgrade.
 */
export const $UpgradeRestriction = $.Enum({
  // There is an upgrade restriction and there are no details about its specifics nor how long
  // it could last.
  Present: null,
});

export type UpgradeRestriction = $.Input<typeof $UpgradeRestriction>;

/**
 * Constraints on the actions that can be taken by a new parachain
 * block. These limitations are implicitly associated with some particular
 * parachain, which should be apparent from usage.
 */
export const $Constraints = $.Struct({
  // The minimum relay-parent number accepted under these constraints.
  minRelayParentNumber: $BlockNumber,
  // The maximum Proof-of-Validity size allowed, in bytes.
  maxPovSize: $.u32,
  // The maximum new validation code size allowed, in bytes.
  maxCodeSize: $.u32,
  // The amount of UMP messages remaining.
  umpRemaining: $.u32,
  // The amount of UMP bytes remaining.
  umpRemainingBytes: $.u32,
  // The maximum number of UMP messages allowed per candidate.
  maxUmpNumPerCandidate: $.u32,
  // Remaining DMP queue. Only includes sent-at block numbers.
  dmpRemainingMessages: $.Vec($BlockNumber),
  // The limitations of all registered inbound HRMP channels.
  hrmpInbound: $InboundHrmpLimitations,
  // The limitations of all registered outbound HRMP channels.
  hrmpChannelsOut: $.Vec($.Tuple($ParaId, $OutboundHrmpChannelLimitations)),
  // The maximum number of HRMP messages allowed per candidate.
  maxHrmpNumPerCandidate: $.u32,
  // The required parent head-data of the parachain.
  requiredParent: $HeadData,
  // The expected validation-code-hash of this parachain.
  validationCodeHash: $ValidationCodeHash,
  // The code upgrade restriction signal as-of this parachain.
  upgradeRestriction: $.Option($UpgradeRestriction),
  // The future validation code hash, if any, and at what relay-parent
  // number the upgrade would be minimally applied.
  futureValidationCode: $.Option($.Tuple($BlockNumber, $ValidationCodeHash)),
});

export type Constraints = $.Input<typeof $Constraints>;

/**
 * A candidate pending availability.
 */
export const $CandidatePendingAvailability = $.Struct({
  // The hash of the candidate.
  candidateHash: $CandidateHash,
  // The candidate's descriptor.
  descriptor: $CandidateDescriptor,
  // The commitments of the candidate.
  commitments: $CandidateCommitments,
  // The candidate's relay parent's number.
  relayParentNumber: $BlockNumber,
  // The maximum Proof-of-Validity size allowed, in bytes.
  maxPovSize: $.u32,
});

export type CandidatePendingAvailability = $.Input<typeof $CandidatePendingAvailability>;

export const $BackingState = $.Struct({
  // The state-machine constraints of the parachain.
  constraints: $Constraints,
  // The candidates pending availability. These should be ordered, i.e. they should form
  // a sub-chain, where the first candidate builds on top of the required parent of the
  // constraints and each subsequent builds on top of the previous head-data.
  pendingAvailability: $.Vec($CandidatePendingAvailability),
});

export type BackingState = $.Input<typeof $BackingState>;

/**
 * Candidate's acceptance limitations for asynchronous backing per relay parent.
 */
export const $AsyncBackingParams = $.Struct({
  // The maximum number of para blocks between the para head in a relay parent
  // and a new candidate. Restricts nodes from building arbitrary long chains
  // and spamming other validators.
  //
  // When async backing is disabled, the only valid value is 0.
  maxCandidateDepth: $.u32,
  // How many ancestors of a relay parent are allowed to build candidates on top
  // of.
  //
  // When async backing is disabled, the only valid value is 0.
  allowedAncestryLen: $.u32,
});

export type AsyncBackingParams = $.Input<typeof $AsyncBackingParams>;

/**
 * Bit indices in the `HostConfiguration.node_features` that correspond to different node features.
 */
export const $NodeFeatures = $.bitSequence;

export type NodeFeatures = $.Input<typeof $NodeFeatures>;
