// Generated by @dedot/codegen

import type {
  AccountId32,
  AccountId32Like,
  Bytes,
  BytesLike,
  Data,
  DispatchError,
  DispatchInfo,
  Era,
  FixedArray,
  FixedBytes,
  FixedI64,
  FixedU128,
  FixedU64,
  H256,
  Header,
  MultiAddress,
  MultiAddressLike,
  PerU16,
  Perbill,
  Percent,
  Permill,
  Perquintill,
  Phase,
  Result,
  UncheckedExtrinsic,
} from '@dedot/codecs';

export type FrameSystemAccountInfo = {
  nonce: number;
  consumers: number;
  providers: number;
  sufficients: number;
  data: PalletBalancesAccountData;
};

export type PalletBalancesAccountData = {
  free: bigint;
  reserved: bigint;
  frozen: bigint;
  flags: PalletBalancesExtraFlags;
};

export type PalletBalancesExtraFlags = bigint;

export type FrameSupportDispatchPerDispatchClass = {
  normal: SpWeightsWeightV2Weight;
  operational: SpWeightsWeightV2Weight;
  mandatory: SpWeightsWeightV2Weight;
};

export type SpWeightsWeightV2Weight = { refTime: bigint; proofSize: bigint };

export type FrameSystemEventRecord = { phase: Phase; event: KitchensinkRuntimeRuntimeEvent; topics: Array<H256> };

export type KitchensinkRuntimeRuntimeEvent =
  | { pallet: 'System'; palletEvent: FrameSystemEvent }
  | { pallet: 'Utility'; palletEvent: PalletUtilityEvent }
  | { pallet: 'Indices'; palletEvent: PalletIndicesEvent }
  | { pallet: 'Balances'; palletEvent: PalletBalancesEvent }
  | { pallet: 'TransactionPayment'; palletEvent: PalletTransactionPaymentEvent }
  | { pallet: 'AssetTxPayment'; palletEvent: PalletAssetTxPaymentEvent }
  | { pallet: 'AssetConversionTxPayment'; palletEvent: PalletAssetConversionTxPaymentEvent }
  | { pallet: 'ElectionProviderMultiPhase'; palletEvent: PalletElectionProviderMultiPhaseEvent }
  | { pallet: 'Staking'; palletEvent: PalletStakingPalletEvent }
  | { pallet: 'Session'; palletEvent: PalletSessionEvent }
  | { pallet: 'Democracy'; palletEvent: PalletDemocracyEvent }
  | { pallet: 'Council'; palletEvent: PalletCollectiveEvent }
  | { pallet: 'TechnicalCommittee'; palletEvent: PalletCollectiveEvent }
  | { pallet: 'Elections'; palletEvent: PalletElectionsPhragmenEvent }
  | { pallet: 'TechnicalMembership'; palletEvent: PalletMembershipEvent }
  | { pallet: 'Grandpa'; palletEvent: PalletGrandpaEvent }
  | { pallet: 'Treasury'; palletEvent: PalletTreasuryEvent }
  | { pallet: 'AssetRate'; palletEvent: PalletAssetRateEvent }
  | { pallet: 'Contracts'; palletEvent: PalletContractsEvent }
  | { pallet: 'Sudo'; palletEvent: PalletSudoEvent }
  | { pallet: 'ImOnline'; palletEvent: PalletImOnlineEvent }
  | { pallet: 'Offences'; palletEvent: PalletOffencesEvent }
  | { pallet: 'Identity'; palletEvent: PalletIdentityEvent }
  | { pallet: 'Society'; palletEvent: PalletSocietyEvent }
  | { pallet: 'Recovery'; palletEvent: PalletRecoveryEvent }
  | { pallet: 'Vesting'; palletEvent: PalletVestingEvent }
  | { pallet: 'Scheduler'; palletEvent: PalletSchedulerEvent }
  | { pallet: 'Glutton'; palletEvent: PalletGluttonEvent }
  | { pallet: 'Preimage'; palletEvent: PalletPreimageEvent }
  | { pallet: 'Proxy'; palletEvent: PalletProxyEvent }
  | { pallet: 'Multisig'; palletEvent: PalletMultisigEvent }
  | { pallet: 'Bounties'; palletEvent: PalletBountiesEvent }
  | { pallet: 'Tips'; palletEvent: PalletTipsEvent }
  | { pallet: 'Assets'; palletEvent: PalletAssetsEvent }
  | { pallet: 'PoolAssets'; palletEvent: PalletAssetsEvent }
  | { pallet: 'Lottery'; palletEvent: PalletLotteryEvent }
  | { pallet: 'Nis'; palletEvent: PalletNisEvent }
  | { pallet: 'Uniques'; palletEvent: PalletUniquesEvent }
  | { pallet: 'Nfts'; palletEvent: PalletNftsEvent }
  | { pallet: 'NftFractionalization'; palletEvent: PalletNftFractionalizationEvent }
  | { pallet: 'Salary'; palletEvent: PalletSalaryEvent }
  | { pallet: 'CoreFellowship'; palletEvent: PalletCoreFellowshipEvent }
  | { pallet: 'TransactionStorage'; palletEvent: PalletTransactionStorageEvent }
  | { pallet: 'VoterList'; palletEvent: PalletBagsListEvent }
  | { pallet: 'StateTrieMigration'; palletEvent: PalletStateTrieMigrationEvent }
  | { pallet: 'ChildBounties'; palletEvent: PalletChildBountiesEvent }
  | { pallet: 'Referenda'; palletEvent: PalletReferendaEvent }
  | { pallet: 'Remark'; palletEvent: PalletRemarkEvent }
  | { pallet: 'RootTesting'; palletEvent: PalletRootTestingEvent }
  | { pallet: 'ConvictionVoting'; palletEvent: PalletConvictionVotingEvent }
  | { pallet: 'Whitelist'; palletEvent: PalletWhitelistEvent }
  | { pallet: 'AllianceMotion'; palletEvent: PalletCollectiveEvent }
  | { pallet: 'Alliance'; palletEvent: PalletAllianceEvent }
  | { pallet: 'NominationPools'; palletEvent: PalletNominationPoolsEvent }
  | { pallet: 'RankedPolls'; palletEvent: PalletReferendaEvent002 }
  | { pallet: 'RankedCollective'; palletEvent: PalletRankedCollectiveEvent }
  | { pallet: 'AssetConversion'; palletEvent: PalletAssetConversionEvent }
  | { pallet: 'FastUnstake'; palletEvent: PalletFastUnstakeEvent }
  | { pallet: 'MessageQueue'; palletEvent: PalletMessageQueueEvent }
  | { pallet: 'Pov'; palletEvent: FrameBenchmarkingPalletPovEvent }
  | { pallet: 'TxPause'; palletEvent: PalletTxPauseEvent }
  | { pallet: 'SafeMode'; palletEvent: PalletSafeModeEvent }
  | { pallet: 'Statement'; palletEvent: PalletStatementEvent }
  | { pallet: 'MultiBlockMigrations'; palletEvent: PalletMigrationsEvent }
  | { pallet: 'Broker'; palletEvent: PalletBrokerEvent }
  | { pallet: 'Parameters'; palletEvent: PalletParametersEvent }
  | { pallet: 'SkipFeelessPayment'; palletEvent: PalletSkipFeelessPaymentEvent };

/**
 * Event for the System pallet.
 **/
export type FrameSystemEvent =
  /**
   * An extrinsic completed successfully.
   **/
  | { name: 'ExtrinsicSuccess'; data: { dispatchInfo: DispatchInfo } }
  /**
   * An extrinsic failed.
   **/
  | { name: 'ExtrinsicFailed'; data: { dispatchError: DispatchError; dispatchInfo: DispatchInfo } }
  /**
   * `:code` was updated.
   **/
  | { name: 'CodeUpdated' }
  /**
   * A new account was created.
   **/
  | { name: 'NewAccount'; data: { account: AccountId32 } }
  /**
   * An account was reaped.
   **/
  | { name: 'KilledAccount'; data: { account: AccountId32 } }
  /**
   * On on-chain remark happened.
   **/
  | { name: 'Remarked'; data: { sender: AccountId32; hash: H256 } }
  /**
   * An upgrade was authorized.
   **/
  | { name: 'UpgradeAuthorized'; data: { codeHash: H256; checkVersion: boolean } };

export type FrameSupportDispatchDispatchClass = 'Normal' | 'Operational' | 'Mandatory';

export type FrameSupportDispatchPays = 'Yes' | 'No';

/**
 * The `Event` enum of this pallet
 **/
export type PalletUtilityEvent =
  /**
   * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
   * well as the error.
   **/
  | { name: 'BatchInterrupted'; data: { index: number; error: DispatchError } }
  /**
   * Batch of dispatches completed fully with no error.
   **/
  | { name: 'BatchCompleted' }
  /**
   * Batch of dispatches completed but has errors.
   **/
  | { name: 'BatchCompletedWithErrors' }
  /**
   * A single item within a Batch of dispatches has completed with no error.
   **/
  | { name: 'ItemCompleted' }
  /**
   * A single item within a Batch of dispatches has completed with error.
   **/
  | { name: 'ItemFailed'; data: { error: DispatchError } }
  /**
   * A call was dispatched.
   **/
  | { name: 'DispatchedAs'; data: { result: Result<[], DispatchError> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletIndicesEvent =
  /**
   * A account index was assigned.
   **/
  | { name: 'IndexAssigned'; data: { who: AccountId32; index: number } }
  /**
   * A account index has been freed up (unassigned).
   **/
  | { name: 'IndexFreed'; data: { index: number } }
  /**
   * A account index has been frozen to its current account ID.
   **/
  | { name: 'IndexFrozen'; data: { index: number; who: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBalancesEvent =
  /**
   * An account was created with some free balance.
   **/
  | { name: 'Endowed'; data: { account: AccountId32; freeBalance: bigint } }
  /**
   * An account was removed whose balance was non-zero but below ExistentialDeposit,
   * resulting in an outright loss.
   **/
  | { name: 'DustLost'; data: { account: AccountId32; amount: bigint } }
  /**
   * Transfer succeeded.
   **/
  | { name: 'Transfer'; data: { from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * A balance was set by root.
   **/
  | { name: 'BalanceSet'; data: { who: AccountId32; free: bigint } }
  /**
   * Some balance was reserved (moved from free to reserved).
   **/
  | { name: 'Reserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unreserved (moved from reserved to free).
   **/
  | { name: 'Unreserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was moved from the reserve of the first account to the second account.
   * Final argument indicates the destination balance type.
   **/
  | {
      name: 'ReserveRepatriated';
      data: {
        from: AccountId32;
        to: AccountId32;
        amount: bigint;
        destinationStatus: FrameSupportTokensMiscBalanceStatus;
      };
    }
  /**
   * Some amount was deposited (e.g. for transaction fees).
   **/
  | { name: 'Deposit'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was withdrawn from the account (e.g. for transaction fees).
   **/
  | { name: 'Withdraw'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was removed from the account (e.g. for misbehavior).
   **/
  | { name: 'Slashed'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was minted into an account.
   **/
  | { name: 'Minted'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was burned from an account.
   **/
  | { name: 'Burned'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was suspended from an account (it can be restored later).
   **/
  | { name: 'Suspended'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was restored into an account.
   **/
  | { name: 'Restored'; data: { who: AccountId32; amount: bigint } }
  /**
   * An account was upgraded.
   **/
  | { name: 'Upgraded'; data: { who: AccountId32 } }
  /**
   * Total issuance was increased by `amount`, creating a credit to be balanced.
   **/
  | { name: 'Issued'; data: { amount: bigint } }
  /**
   * Total issuance was decreased by `amount`, creating a debt to be balanced.
   **/
  | { name: 'Rescinded'; data: { amount: bigint } }
  /**
   * Some balance was locked.
   **/
  | { name: 'Locked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unlocked.
   **/
  | { name: 'Unlocked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was frozen.
   **/
  | { name: 'Frozen'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was thawed.
   **/
  | { name: 'Thawed'; data: { who: AccountId32; amount: bigint } }
  /**
   * The `TotalIssuance` was forcefully changed.
   **/
  | { name: 'TotalIssuanceForced'; data: { old: bigint; new: bigint } };

export type FrameSupportTokensMiscBalanceStatus = 'Free' | 'Reserved';

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who`.
   **/
  { name: 'TransactionFeePaid'; data: { who: AccountId32; actualFee: bigint; tip: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetTxPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who` in an asset `asset_id`.
   **/
  { name: 'AssetTxFeePaid'; data: { who: AccountId32; actualFee: bigint; tip: bigint; assetId?: number | undefined } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetConversionTxPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who` in an asset `asset_id`.
   **/
  | { name: 'AssetTxFeePaid'; data: { who: AccountId32; actualFee: bigint; tip: bigint; assetId: number } }
  /**
   * A swap of the refund in native currency back to asset failed.
   **/
  | { name: 'AssetRefundFailed'; data: { nativeAmountKept: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletElectionProviderMultiPhaseEvent =
  /**
   * A solution was stored with the given compute.
   *
   * The `origin` indicates the origin of the solution. If `origin` is `Some(AccountId)`,
   * the stored solution was submited in the signed phase by a miner with the `AccountId`.
   * Otherwise, the solution was stored either during the unsigned phase or by
   * `T::ForceOrigin`. The `bool` is `true` when a previous solution was ejected to make
   * room for this one.
   **/
  | {
      name: 'SolutionStored';
      data: {
        compute: PalletElectionProviderMultiPhaseElectionCompute;
        origin?: AccountId32 | undefined;
        prevEjected: boolean;
      };
    }
  /**
   * The election has been finalized, with the given computation and score.
   **/
  | {
      name: 'ElectionFinalized';
      data: { compute: PalletElectionProviderMultiPhaseElectionCompute; score: SpNposElectionsElectionScore };
    }
  /**
   * An election failed.
   *
   * Not much can be said about which computes failed in the process.
   **/
  | { name: 'ElectionFailed' }
  /**
   * An account has been rewarded for their signed submission being finalized.
   **/
  | { name: 'Rewarded'; data: { account: AccountId32; value: bigint } }
  /**
   * An account has been slashed for submitting an invalid signed submission.
   **/
  | { name: 'Slashed'; data: { account: AccountId32; value: bigint } }
  /**
   * There was a phase transition in a given round.
   **/
  | {
      name: 'PhaseTransitioned';
      data: { from: PalletElectionProviderMultiPhasePhase; to: PalletElectionProviderMultiPhasePhase; round: number };
    };

export type PalletElectionProviderMultiPhaseElectionCompute =
  | 'OnChain'
  | 'Signed'
  | 'Unsigned'
  | 'Fallback'
  | 'Emergency';

export type SpNposElectionsElectionScore = { minimalStake: bigint; sumStake: bigint; sumStakeSquared: bigint };

export type PalletElectionProviderMultiPhasePhase =
  | { tag: 'Off' }
  | { tag: 'Signed' }
  | { tag: 'Unsigned'; value: [boolean, number] }
  | { tag: 'Emergency' };

/**
 * The `Event` enum of this pallet
 **/
export type PalletStakingPalletEvent =
  /**
   * The era payout has been set; the first balance is the validator-payout; the second is
   * the remainder from the maximum amount of reward.
   **/
  | { name: 'EraPaid'; data: { eraIndex: number; validatorPayout: bigint; remainder: bigint } }
  /**
   * The nominator has been rewarded by this amount to this destination.
   **/
  | { name: 'Rewarded'; data: { stash: AccountId32; dest: PalletStakingRewardDestination; amount: bigint } }
  /**
   * A staker (validator or nominator) has been slashed by the given amount.
   **/
  | { name: 'Slashed'; data: { staker: AccountId32; amount: bigint } }
  /**
   * A slash for the given validator, for the given percentage of their stake, at the given
   * era as been reported.
   **/
  | { name: 'SlashReported'; data: { validator: AccountId32; fraction: Perbill; slashEra: number } }
  /**
   * An old slashing report from a prior era was discarded because it could
   * not be processed.
   **/
  | { name: 'OldSlashingReportDiscarded'; data: { sessionIndex: number } }
  /**
   * A new set of stakers was elected.
   **/
  | { name: 'StakersElected' }
  /**
   * An account has bonded this amount. \[stash, amount\]
   *
   * NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,
   * it will not be emitted for staking rewards when they are added to stake.
   **/
  | { name: 'Bonded'; data: { stash: AccountId32; amount: bigint } }
  /**
   * An account has unbonded this amount.
   **/
  | { name: 'Unbonded'; data: { stash: AccountId32; amount: bigint } }
  /**
   * An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`
   * from the unlocking queue.
   **/
  | { name: 'Withdrawn'; data: { stash: AccountId32; amount: bigint } }
  /**
   * A nominator has been kicked from a validator.
   **/
  | { name: 'Kicked'; data: { nominator: AccountId32; stash: AccountId32 } }
  /**
   * The election failed. No new era is planned.
   **/
  | { name: 'StakingElectionFailed' }
  /**
   * An account has stopped participating as either a validator or nominator.
   **/
  | { name: 'Chilled'; data: { stash: AccountId32 } }
  /**
   * The stakers' rewards are getting paid.
   **/
  | { name: 'PayoutStarted'; data: { eraIndex: number; validatorStash: AccountId32 } }
  /**
   * A validator has set their preferences.
   **/
  | { name: 'ValidatorPrefsSet'; data: { stash: AccountId32; prefs: PalletStakingValidatorPrefs } }
  /**
   * Voters size limit reached.
   **/
  | { name: 'SnapshotVotersSizeExceeded'; data: { size: number } }
  /**
   * Targets size limit reached.
   **/
  | { name: 'SnapshotTargetsSizeExceeded'; data: { size: number } }
  /**
   * A new force era mode was set.
   **/
  | { name: 'ForceEra'; data: { mode: PalletStakingForcing } }
  /**
   * Report of a controller batch deprecation.
   **/
  | { name: 'ControllerBatchDeprecated'; data: { failures: number } };

export type PalletStakingRewardDestination =
  | { tag: 'Staked' }
  | { tag: 'Stash' }
  | { tag: 'Controller' }
  | { tag: 'Account'; value: AccountId32 }
  | { tag: 'None' };

export type PalletStakingValidatorPrefs = { commission: Perbill; blocked: boolean };

export type PalletStakingForcing = 'NotForcing' | 'ForceNew' | 'ForceNone' | 'ForceAlways';

/**
 * The `Event` enum of this pallet
 **/
export type PalletSessionEvent =
  /**
   * New session has happened. Note that the argument is the session index, not the
   * block number as the type might suggest.
   **/
  { name: 'NewSession'; data: { sessionIndex: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletDemocracyEvent =
  /**
   * A motion has been proposed by a public account.
   **/
  | { name: 'Proposed'; data: { proposalIndex: number; deposit: bigint } }
  /**
   * A public proposal has been tabled for referendum vote.
   **/
  | { name: 'Tabled'; data: { proposalIndex: number; deposit: bigint } }
  /**
   * An external proposal has been tabled.
   **/
  | { name: 'ExternalTabled' }
  /**
   * A referendum has begun.
   **/
  | { name: 'Started'; data: { refIndex: number; threshold: PalletDemocracyVoteThreshold } }
  /**
   * A proposal has been approved by referendum.
   **/
  | { name: 'Passed'; data: { refIndex: number } }
  /**
   * A proposal has been rejected by referendum.
   **/
  | { name: 'NotPassed'; data: { refIndex: number } }
  /**
   * A referendum has been cancelled.
   **/
  | { name: 'Cancelled'; data: { refIndex: number } }
  /**
   * An account has delegated their vote to another account.
   **/
  | { name: 'Delegated'; data: { who: AccountId32; target: AccountId32 } }
  /**
   * An account has cancelled a previous delegation operation.
   **/
  | { name: 'Undelegated'; data: { account: AccountId32 } }
  /**
   * An external proposal has been vetoed.
   **/
  | { name: 'Vetoed'; data: { who: AccountId32; proposalHash: H256; until: number } }
  /**
   * A proposal_hash has been blacklisted permanently.
   **/
  | { name: 'Blacklisted'; data: { proposalHash: H256 } }
  /**
   * An account has voted in a referendum
   **/
  | { name: 'Voted'; data: { voter: AccountId32; refIndex: number; vote: PalletDemocracyVoteAccountVote } }
  /**
   * An account has secconded a proposal
   **/
  | { name: 'Seconded'; data: { seconder: AccountId32; propIndex: number } }
  /**
   * A proposal got canceled.
   **/
  | { name: 'ProposalCanceled'; data: { propIndex: number } }
  /**
   * Metadata for a proposal or a referendum has been set.
   **/
  | {
      name: 'MetadataSet';
      data: {
        /**
         * Metadata owner.
         **/
        owner: PalletDemocracyMetadataOwner;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  /**
   * Metadata for a proposal or a referendum has been cleared.
   **/
  | {
      name: 'MetadataCleared';
      data: {
        /**
         * Metadata owner.
         **/
        owner: PalletDemocracyMetadataOwner;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  /**
   * Metadata has been transferred to new owner.
   **/
  | {
      name: 'MetadataTransferred';
      data: {
        /**
         * Previous metadata owner.
         **/
        prevOwner: PalletDemocracyMetadataOwner;

        /**
         * New metadata owner.
         **/
        owner: PalletDemocracyMetadataOwner;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    };

export type PalletDemocracyVoteThreshold = 'SuperMajorityApprove' | 'SuperMajorityAgainst' | 'SimpleMajority';

export type PalletDemocracyVoteAccountVote =
  | { tag: 'Standard'; value: { vote: PalletDemocracyVote; balance: bigint } }
  | { tag: 'Split'; value: { aye: bigint; nay: bigint } };

export type PalletDemocracyVote = number;

export type PalletDemocracyMetadataOwner =
  | { tag: 'External' }
  | { tag: 'Proposal'; value: number }
  | { tag: 'Referendum'; value: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletCollectiveEvent =
  /**
   * A motion (given hash) has been proposed (by given account) with a threshold (given
   * `MemberCount`).
   **/
  | { name: 'Proposed'; data: { account: AccountId32; proposalIndex: number; proposalHash: H256; threshold: number } }
  /**
   * A motion (given hash) has been voted on by given account, leaving
   * a tally (yes votes and no votes given respectively as `MemberCount`).
   **/
  | { name: 'Voted'; data: { account: AccountId32; proposalHash: H256; voted: boolean; yes: number; no: number } }
  /**
   * A motion was approved by the required threshold.
   **/
  | { name: 'Approved'; data: { proposalHash: H256 } }
  /**
   * A motion was not approved by the required threshold.
   **/
  | { name: 'Disapproved'; data: { proposalHash: H256 } }
  /**
   * A motion was executed; result will be `Ok` if it returned without error.
   **/
  | { name: 'Executed'; data: { proposalHash: H256; result: Result<[], DispatchError> } }
  /**
   * A single member did some action; result will be `Ok` if it returned without error.
   **/
  | { name: 'MemberExecuted'; data: { proposalHash: H256; result: Result<[], DispatchError> } }
  /**
   * A proposal was closed because its threshold was reached or after its duration was up.
   **/
  | { name: 'Closed'; data: { proposalHash: H256; yes: number; no: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletElectionsPhragmenEvent =
  /**
   * A new term with new_members. This indicates that enough candidates existed to run
   * the election, not that enough have has been elected. The inner value must be examined
   * for this purpose. A `NewTerm(\[\])` indicates that some candidates got their bond
   * slashed and none were elected, whilst `EmptyTerm` means that no candidates existed to
   * begin with.
   **/
  | { name: 'NewTerm'; data: { newMembers: Array<[AccountId32, bigint]> } }
  /**
   * No (or not enough) candidates existed for this round. This is different from
   * `NewTerm(\[\])`. See the description of `NewTerm`.
   **/
  | { name: 'EmptyTerm' }
  /**
   * Internal error happened while trying to perform election.
   **/
  | { name: 'ElectionError' }
  /**
   * A member has been removed. This should always be followed by either `NewTerm` or
   * `EmptyTerm`.
   **/
  | { name: 'MemberKicked'; data: { member: AccountId32 } }
  /**
   * Someone has renounced their candidacy.
   **/
  | { name: 'Renounced'; data: { candidate: AccountId32 } }
  /**
   * A candidate was slashed by amount due to failing to obtain a seat as member or
   * runner-up.
   *
   * Note that old members and runners-up are also candidates.
   **/
  | { name: 'CandidateSlashed'; data: { candidate: AccountId32; amount: bigint } }
  /**
   * A seat holder was slashed by amount by being forcefully removed from the set.
   **/
  | { name: 'SeatHolderSlashed'; data: { seatHolder: AccountId32; amount: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMembershipEvent =
  /**
   * The given member was added; see the transaction for who.
   **/
  | 'MemberAdded'
  /**
   * The given member was removed; see the transaction for who.
   **/
  | 'MemberRemoved'
  /**
   * Two members were swapped; see the transaction for who.
   **/
  | 'MembersSwapped'
  /**
   * The membership was reset; see the transaction for who the new set is.
   **/
  | 'MembersReset'
  /**
   * One of the members' keys changed.
   **/
  | 'KeyChanged'
  /**
   * Phantom member, never used.
   **/
  | 'Dummy';

/**
 * The `Event` enum of this pallet
 **/
export type PalletGrandpaEvent =
  /**
   * New authority set has been applied.
   **/
  | { name: 'NewAuthorities'; data: { authoritySet: Array<[SpConsensusGrandpaAppPublic, bigint]> } }
  /**
   * Current authority set has been paused.
   **/
  | { name: 'Paused' }
  /**
   * Current authority set has been resumed.
   **/
  | { name: 'Resumed' };

export type SpConsensusGrandpaAppPublic = SpCoreEd25519Public;

export type SpCoreEd25519Public = FixedBytes<32>;

/**
 * The `Event` enum of this pallet
 **/
export type PalletTreasuryEvent =
  /**
   * New proposal.
   **/
  | { name: 'Proposed'; data: { proposalIndex: number } }
  /**
   * We have ended a spend period and will now allocate funds.
   **/
  | { name: 'Spending'; data: { budgetRemaining: bigint } }
  /**
   * Some funds have been allocated.
   **/
  | { name: 'Awarded'; data: { proposalIndex: number; award: bigint; account: AccountId32 } }
  /**
   * A proposal was rejected; funds were slashed.
   **/
  | { name: 'Rejected'; data: { proposalIndex: number; slashed: bigint } }
  /**
   * Some of our funds have been burnt.
   **/
  | { name: 'Burnt'; data: { burntFunds: bigint } }
  /**
   * Spending has finished; this is the amount that rolls over until next spend.
   **/
  | { name: 'Rollover'; data: { rolloverBalance: bigint } }
  /**
   * Some funds have been deposited.
   **/
  | { name: 'Deposit'; data: { value: bigint } }
  /**
   * A new spend proposal has been approved.
   **/
  | { name: 'SpendApproved'; data: { proposalIndex: number; amount: bigint; beneficiary: AccountId32 } }
  /**
   * The inactive funds of the pallet have been updated.
   **/
  | { name: 'UpdatedInactive'; data: { reactivated: bigint; deactivated: bigint } }
  /**
   * A new asset spend proposal has been approved.
   **/
  | {
      name: 'AssetSpendApproved';
      data: {
        index: number;
        assetKind: number;
        amount: bigint;
        beneficiary: AccountId32;
        validFrom: number;
        expireAt: number;
      };
    }
  /**
   * An approved spend was voided.
   **/
  | { name: 'AssetSpendVoided'; data: { index: number } }
  /**
   * A payment happened.
   **/
  | { name: 'Paid'; data: { index: number; paymentId: [] } }
  /**
   * A payment failed and can be retried.
   **/
  | { name: 'PaymentFailed'; data: { index: number; paymentId: [] } }
  /**
   * A spend was processed and removed from the storage. It might have been successfully
   * paid or it may have expired.
   **/
  | { name: 'SpendProcessed'; data: { index: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetRateEvent =
  | { name: 'AssetRateCreated'; data: { assetKind: number; rate: FixedU128 } }
  | { name: 'AssetRateRemoved'; data: { assetKind: number } }
  | { name: 'AssetRateUpdated'; data: { assetKind: number; old: FixedU128; new: FixedU128 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletContractsEvent =
  /**
   * Contract deployed by address at the specified address.
   **/
  | { name: 'Instantiated'; data: { deployer: AccountId32; contract: AccountId32 } }
  /**
   * Contract has been removed.
   *
   * # Note
   *
   * The only way for a contract to be removed and emitting this event is by calling
   * `seal_terminate`.
   **/
  | {
      name: 'Terminated';
      data: {
        /**
         * The contract that was terminated.
         **/
        contract: AccountId32;

        /**
         * The account that received the contracts remaining balance
         **/
        beneficiary: AccountId32;
      };
    }
  /**
   * Code with the specified hash has been stored.
   **/
  | { name: 'CodeStored'; data: { codeHash: H256; depositHeld: bigint; uploader: AccountId32 } }
  /**
   * A custom event emitted by the contract.
   **/
  | {
      name: 'ContractEmitted';
      data: {
        /**
         * The contract that emitted the event.
         **/
        contract: AccountId32;

        /**
         * Data supplied by the contract. Metadata generated during contract compilation
         * is needed to decode it.
         **/
        data: Bytes;
      };
    }
  /**
   * A code with the specified hash was removed.
   **/
  | { name: 'CodeRemoved'; data: { codeHash: H256; depositReleased: bigint; remover: AccountId32 } }
  /**
   * A contract's code was updated.
   **/
  | {
      name: 'ContractCodeUpdated';
      data: {
        /**
         * The contract that has been updated.
         **/
        contract: AccountId32;

        /**
         * New code hash that was set for the contract.
         **/
        newCodeHash: H256;

        /**
         * Previous code hash of the contract.
         **/
        oldCodeHash: H256;
      };
    }
  /**
   * A contract was called either by a plain account or another contract.
   *
   * # Note
   *
   * Please keep in mind that like all events this is only emitted for successful
   * calls. This is because on failure all storage changes including events are
   * rolled back.
   **/
  | {
      name: 'Called';
      data: {
        /**
         * The caller of the `contract`.
         **/
        caller: PalletContractsOrigin;

        /**
         * The contract that was called.
         **/
        contract: AccountId32;
      };
    }
  /**
   * A contract delegate called a code hash.
   *
   * # Note
   *
   * Please keep in mind that like all events this is only emitted for successful
   * calls. This is because on failure all storage changes including events are
   * rolled back.
   **/
  | {
      name: 'DelegateCalled';
      data: {
        /**
         * The contract that performed the delegate call and hence in whose context
         * the `code_hash` is executed.
         **/
        contract: AccountId32;

        /**
         * The code hash that was delegate called.
         **/
        codeHash: H256;
      };
    }
  /**
   * Some funds have been transferred and held as storage deposit.
   **/
  | { name: 'StorageDepositTransferredAndHeld'; data: { from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * Some storage deposit funds have been transferred and released.
   **/
  | { name: 'StorageDepositTransferredAndReleased'; data: { from: AccountId32; to: AccountId32; amount: bigint } };

export type PalletContractsOrigin = { tag: 'Root' } | { tag: 'Signed'; value: AccountId32 };

export type KitchensinkRuntimeRuntime = {};

/**
 * The `Event` enum of this pallet
 **/
export type PalletSudoEvent =
  /**
   * A sudo call just took place.
   **/
  | {
      name: 'Sudid';
      data: {
        /**
         * The result of the call made by the sudo user.
         **/
        sudoResult: Result<[], DispatchError>;
      };
    }
  /**
   * The sudo key has been updated.
   **/
  | {
      name: 'KeyChanged';
      data: {
        /**
         * The old sudo key (if one was previously set).
         **/
        old?: AccountId32 | undefined;

        /**
         * The new sudo key (if one was set).
         **/
        new: AccountId32;
      };
    }
  /**
   * The key was permanently removed.
   **/
  | { name: 'KeyRemoved' }
  /**
   * A [sudo_as](Pallet::sudo_as) call just took place.
   **/
  | {
      name: 'SudoAsDone';
      data: {
        /**
         * The result of the call made by the sudo user.
         **/
        sudoResult: Result<[], DispatchError>;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletImOnlineEvent =
  /**
   * A new heartbeat was received from `AuthorityId`.
   **/
  | { name: 'HeartbeatReceived'; data: { authorityId: PalletImOnlineSr25519AppSr25519Public } }
  /**
   * At the end of the session, no offence was committed.
   **/
  | { name: 'AllGood' }
  /**
   * At the end of the session, at least one validator was found to be offline.
   **/
  | { name: 'SomeOffline'; data: { offline: Array<[AccountId32, SpStakingExposure]> } };

export type PalletImOnlineSr25519AppSr25519Public = SpCoreSr25519Public;

export type SpCoreSr25519Public = FixedBytes<32>;

export type SpStakingExposure = { total: bigint; own: bigint; others: Array<SpStakingIndividualExposure> };

export type SpStakingIndividualExposure = { who: AccountId32; value: bigint };

/**
 * Events type.
 **/
export type PalletOffencesEvent =
  /**
   * There is an offence reported of the given `kind` happened at the `session_index` and
   * (kind-specific) time slot. This event is not deposited for duplicate slashes.
   * \[kind, timeslot\].
   **/
  { name: 'Offence'; data: { kind: FixedBytes<16>; timeslot: Bytes } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletIdentityEvent =
  /**
   * A name was set or reset (which will remove all judgements).
   **/
  | { name: 'IdentitySet'; data: { who: AccountId32 } }
  /**
   * A name was cleared, and the given balance returned.
   **/
  | { name: 'IdentityCleared'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A name was removed and the given balance slashed.
   **/
  | { name: 'IdentityKilled'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A judgement was asked from a registrar.
   **/
  | { name: 'JudgementRequested'; data: { who: AccountId32; registrarIndex: number } }
  /**
   * A judgement request was retracted.
   **/
  | { name: 'JudgementUnrequested'; data: { who: AccountId32; registrarIndex: number } }
  /**
   * A judgement was given by a registrar.
   **/
  | { name: 'JudgementGiven'; data: { target: AccountId32; registrarIndex: number } }
  /**
   * A registrar was added.
   **/
  | { name: 'RegistrarAdded'; data: { registrarIndex: number } }
  /**
   * A sub-identity was added to an identity and the deposit paid.
   **/
  | { name: 'SubIdentityAdded'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A sub-identity was removed from an identity and the deposit freed.
   **/
  | { name: 'SubIdentityRemoved'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A sub-identity was cleared, and the given deposit repatriated from the
   * main identity account to the sub-identity account.
   **/
  | { name: 'SubIdentityRevoked'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A username authority was added.
   **/
  | { name: 'AuthorityAdded'; data: { authority: AccountId32 } }
  /**
   * A username authority was removed.
   **/
  | { name: 'AuthorityRemoved'; data: { authority: AccountId32 } }
  /**
   * A username was set for `who`.
   **/
  | { name: 'UsernameSet'; data: { who: AccountId32; username: Bytes } }
  /**
   * A username was queued, but `who` must accept it prior to `expiration`.
   **/
  | { name: 'UsernameQueued'; data: { who: AccountId32; username: Bytes; expiration: number } }
  /**
   * A queued username passed its expiration without being claimed and was removed.
   **/
  | { name: 'PreapprovalExpired'; data: { whose: AccountId32 } }
  /**
   * A username was set as a primary and can be looked up from `who`.
   **/
  | { name: 'PrimaryUsernameSet'; data: { who: AccountId32; username: Bytes } }
  /**
   * A dangling username (as in, a username corresponding to an account that has removed its
   * identity) has been removed.
   **/
  | { name: 'DanglingUsernameRemoved'; data: { who: AccountId32; username: Bytes } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSocietyEvent =
  /**
   * The society is founded by the given identity.
   **/
  | { name: 'Founded'; data: { founder: AccountId32 } }
  /**
   * A membership bid just happened. The given account is the candidate's ID and their offer
   * is the second.
   **/
  | { name: 'Bid'; data: { candidateId: AccountId32; offer: bigint } }
  /**
   * A membership bid just happened by vouching. The given account is the candidate's ID and
   * their offer is the second. The vouching party is the third.
   **/
  | { name: 'Vouch'; data: { candidateId: AccountId32; offer: bigint; vouching: AccountId32 } }
  /**
   * A candidate was dropped (due to an excess of bids in the system).
   **/
  | { name: 'AutoUnbid'; data: { candidate: AccountId32 } }
  /**
   * A candidate was dropped (by their request).
   **/
  | { name: 'Unbid'; data: { candidate: AccountId32 } }
  /**
   * A candidate was dropped (by request of who vouched for them).
   **/
  | { name: 'Unvouch'; data: { candidate: AccountId32 } }
  /**
   * A group of candidates have been inducted. The batch's primary is the first value, the
   * batch in full is the second.
   **/
  | { name: 'Inducted'; data: { primary: AccountId32; candidates: Array<AccountId32> } }
  /**
   * A suspended member has been judged.
   **/
  | { name: 'SuspendedMemberJudgement'; data: { who: AccountId32; judged: boolean } }
  /**
   * A candidate has been suspended
   **/
  | { name: 'CandidateSuspended'; data: { candidate: AccountId32 } }
  /**
   * A member has been suspended
   **/
  | { name: 'MemberSuspended'; data: { member: AccountId32 } }
  /**
   * A member has been challenged
   **/
  | { name: 'Challenged'; data: { member: AccountId32 } }
  /**
   * A vote has been placed
   **/
  | { name: 'Vote'; data: { candidate: AccountId32; voter: AccountId32; vote: boolean } }
  /**
   * A vote has been placed for a defending member
   **/
  | { name: 'DefenderVote'; data: { voter: AccountId32; vote: boolean } }
  /**
   * A new set of \[params\] has been set for the group.
   **/
  | { name: 'NewParams'; data: { params: PalletSocietyGroupParams } }
  /**
   * Society is unfounded.
   **/
  | { name: 'Unfounded'; data: { founder: AccountId32 } }
  /**
   * Some funds were deposited into the society account.
   **/
  | { name: 'Deposit'; data: { value: bigint } }
  /**
   * A \[member\] got elevated to \[rank\].
   **/
  | { name: 'Elevated'; data: { member: AccountId32; rank: number } };

export type PalletSocietyGroupParams = {
  maxMembers: number;
  maxIntake: number;
  maxStrikes: number;
  candidateDeposit: bigint;
};

/**
 * Events type.
 **/
export type PalletRecoveryEvent =
  /**
   * A recovery process has been set up for an account.
   **/
  | { name: 'RecoveryCreated'; data: { account: AccountId32 } }
  /**
   * A recovery process has been initiated for lost account by rescuer account.
   **/
  | { name: 'RecoveryInitiated'; data: { lostAccount: AccountId32; rescuerAccount: AccountId32 } }
  /**
   * A recovery process for lost account by rescuer account has been vouched for by sender.
   **/
  | { name: 'RecoveryVouched'; data: { lostAccount: AccountId32; rescuerAccount: AccountId32; sender: AccountId32 } }
  /**
   * A recovery process for lost account by rescuer account has been closed.
   **/
  | { name: 'RecoveryClosed'; data: { lostAccount: AccountId32; rescuerAccount: AccountId32 } }
  /**
   * Lost account has been successfully recovered by rescuer account.
   **/
  | { name: 'AccountRecovered'; data: { lostAccount: AccountId32; rescuerAccount: AccountId32 } }
  /**
   * A recovery process has been removed for an account.
   **/
  | { name: 'RecoveryRemoved'; data: { lostAccount: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletVestingEvent =
  /**
   * The amount vested has been updated. This could indicate a change in funds available.
   * The balance given is the amount which is left unvested (and thus locked).
   **/
  | { name: 'VestingUpdated'; data: { account: AccountId32; unvested: bigint } }
  /**
   * An \[account\] has become fully vested.
   **/
  | { name: 'VestingCompleted'; data: { account: AccountId32 } };

/**
 * Events type.
 **/
export type PalletSchedulerEvent =
  /**
   * Scheduled some task.
   **/
  | { name: 'Scheduled'; data: { when: number; index: number } }
  /**
   * Canceled some task.
   **/
  | { name: 'Canceled'; data: { when: number; index: number } }
  /**
   * Dispatched some task.
   **/
  | {
      name: 'Dispatched';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined; result: Result<[], DispatchError> };
    }
  /**
   * Set a retry configuration for some task.
   **/
  | {
      name: 'RetrySet';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined; period: number; retries: number };
    }
  /**
   * Cancel a retry configuration for some task.
   **/
  | { name: 'RetryCancelled'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The call for the provided hash was not found so the task has been aborted.
   **/
  | { name: 'CallUnavailable'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task was unable to be renewed since the agenda is full at that block.
   **/
  | { name: 'PeriodicFailed'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task was unable to be retried since the agenda is full at that block or there
   * was not enough weight to reschedule it.
   **/
  | { name: 'RetryFailed'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task can never be executed since it is overweight.
   **/
  | { name: 'PermanentlyOverweight'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletGluttonEvent =
  /**
   * The pallet has been (re)initialized.
   **/
  | {
      name: 'PalletInitialized';
      data: {
        /**
         * Whether the pallet has been re-initialized.
         **/
        reinit: boolean;
      };
    }
  /**
   * The computation limit has been updated.
   **/
  | {
      name: 'ComputationLimitSet';
      data: {
        /**
         * The computation limit.
         **/
        compute: FixedU64;
      };
    }
  /**
   * The storage limit has been updated.
   **/
  | {
      name: 'StorageLimitSet';
      data: {
        /**
         * The storage limit.
         **/
        storage: FixedU64;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletPreimageEvent =
  /**
   * A preimage has been noted.
   **/
  | { name: 'Noted'; data: { hash: H256 } }
  /**
   * A preimage has been requested.
   **/
  | { name: 'Requested'; data: { hash: H256 } }
  /**
   * A preimage has ben cleared.
   **/
  | { name: 'Cleared'; data: { hash: H256 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletProxyEvent =
  /**
   * A proxy was executed correctly, with the given.
   **/
  | { name: 'ProxyExecuted'; data: { result: Result<[], DispatchError> } }
  /**
   * A pure account has been created by new proxy with given
   * disambiguation index and proxy type.
   **/
  | {
      name: 'PureCreated';
      data: {
        pure: AccountId32;
        who: AccountId32;
        proxyType: KitchensinkRuntimeProxyType;
        disambiguationIndex: number;
      };
    }
  /**
   * An announcement was placed to make a call in the future.
   **/
  | { name: 'Announced'; data: { real: AccountId32; proxy: AccountId32; callHash: H256 } }
  /**
   * A proxy was added.
   **/
  | {
      name: 'ProxyAdded';
      data: { delegator: AccountId32; delegatee: AccountId32; proxyType: KitchensinkRuntimeProxyType; delay: number };
    }
  /**
   * A proxy was removed.
   **/
  | {
      name: 'ProxyRemoved';
      data: { delegator: AccountId32; delegatee: AccountId32; proxyType: KitchensinkRuntimeProxyType; delay: number };
    };

export type KitchensinkRuntimeProxyType = 'Any' | 'NonTransfer' | 'Governance' | 'Staking';

/**
 * The `Event` enum of this pallet
 **/
export type PalletMultisigEvent =
  /**
   * A new multisig operation has begun.
   **/
  | { name: 'NewMultisig'; data: { approving: AccountId32; multisig: AccountId32; callHash: FixedBytes<32> } }
  /**
   * A multisig operation has been approved by someone.
   **/
  | {
      name: 'MultisigApproval';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been executed.
   **/
  | {
      name: 'MultisigExecuted';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
        result: Result<[], DispatchError>;
      };
    }
  /**
   * A multisig operation has been cancelled.
   **/
  | {
      name: 'MultisigCancelled';
      data: {
        cancelling: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigTimepoint = { height: number; index: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBountiesEvent =
  /**
   * New bounty proposal.
   **/
  | { name: 'BountyProposed'; data: { index: number } }
  /**
   * A bounty proposal was rejected; funds were slashed.
   **/
  | { name: 'BountyRejected'; data: { index: number; bond: bigint } }
  /**
   * A bounty proposal is funded and became active.
   **/
  | { name: 'BountyBecameActive'; data: { index: number } }
  /**
   * A bounty is awarded to a beneficiary.
   **/
  | { name: 'BountyAwarded'; data: { index: number; beneficiary: AccountId32 } }
  /**
   * A bounty is claimed by beneficiary.
   **/
  | { name: 'BountyClaimed'; data: { index: number; payout: bigint; beneficiary: AccountId32 } }
  /**
   * A bounty is cancelled.
   **/
  | { name: 'BountyCanceled'; data: { index: number } }
  /**
   * A bounty expiry is extended.
   **/
  | { name: 'BountyExtended'; data: { index: number } }
  /**
   * A bounty is approved.
   **/
  | { name: 'BountyApproved'; data: { index: number } }
  /**
   * A bounty curator is proposed.
   **/
  | { name: 'CuratorProposed'; data: { bountyId: number; curator: AccountId32 } }
  /**
   * A bounty curator is unassigned.
   **/
  | { name: 'CuratorUnassigned'; data: { bountyId: number } }
  /**
   * A bounty curator is accepted.
   **/
  | { name: 'CuratorAccepted'; data: { bountyId: number; curator: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletTipsEvent =
  /**
   * A new tip suggestion has been opened.
   **/
  | { name: 'NewTip'; data: { tipHash: H256 } }
  /**
   * A tip suggestion has reached threshold and is closing.
   **/
  | { name: 'TipClosing'; data: { tipHash: H256 } }
  /**
   * A tip suggestion has been closed.
   **/
  | { name: 'TipClosed'; data: { tipHash: H256; who: AccountId32; payout: bigint } }
  /**
   * A tip suggestion has been retracted.
   **/
  | { name: 'TipRetracted'; data: { tipHash: H256 } }
  /**
   * A tip suggestion has been slashed.
   **/
  | { name: 'TipSlashed'; data: { tipHash: H256; finder: AccountId32; deposit: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetsEvent =
  /**
   * Some asset class was created.
   **/
  | { name: 'Created'; data: { assetId: number; creator: AccountId32; owner: AccountId32 } }
  /**
   * Some assets were issued.
   **/
  | { name: 'Issued'; data: { assetId: number; owner: AccountId32; amount: bigint } }
  /**
   * Some assets were transferred.
   **/
  | { name: 'Transferred'; data: { assetId: number; from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * Some assets were destroyed.
   **/
  | { name: 'Burned'; data: { assetId: number; owner: AccountId32; balance: bigint } }
  /**
   * The management team changed.
   **/
  | { name: 'TeamChanged'; data: { assetId: number; issuer: AccountId32; admin: AccountId32; freezer: AccountId32 } }
  /**
   * The owner changed.
   **/
  | { name: 'OwnerChanged'; data: { assetId: number; owner: AccountId32 } }
  /**
   * Some account `who` was frozen.
   **/
  | { name: 'Frozen'; data: { assetId: number; who: AccountId32 } }
  /**
   * Some account `who` was thawed.
   **/
  | { name: 'Thawed'; data: { assetId: number; who: AccountId32 } }
  /**
   * Some asset `asset_id` was frozen.
   **/
  | { name: 'AssetFrozen'; data: { assetId: number } }
  /**
   * Some asset `asset_id` was thawed.
   **/
  | { name: 'AssetThawed'; data: { assetId: number } }
  /**
   * Accounts were destroyed for given asset.
   **/
  | { name: 'AccountsDestroyed'; data: { assetId: number; accountsDestroyed: number; accountsRemaining: number } }
  /**
   * Approvals were destroyed for given asset.
   **/
  | { name: 'ApprovalsDestroyed'; data: { assetId: number; approvalsDestroyed: number; approvalsRemaining: number } }
  /**
   * An asset class is in the process of being destroyed.
   **/
  | { name: 'DestructionStarted'; data: { assetId: number } }
  /**
   * An asset class was destroyed.
   **/
  | { name: 'Destroyed'; data: { assetId: number } }
  /**
   * Some asset class was force-created.
   **/
  | { name: 'ForceCreated'; data: { assetId: number; owner: AccountId32 } }
  /**
   * New metadata has been set for an asset.
   **/
  | { name: 'MetadataSet'; data: { assetId: number; name: Bytes; symbol: Bytes; decimals: number; isFrozen: boolean } }
  /**
   * Metadata has been cleared for an asset.
   **/
  | { name: 'MetadataCleared'; data: { assetId: number } }
  /**
   * (Additional) funds have been approved for transfer to a destination account.
   **/
  | { name: 'ApprovedTransfer'; data: { assetId: number; source: AccountId32; delegate: AccountId32; amount: bigint } }
  /**
   * An approval for account `delegate` was cancelled by `owner`.
   **/
  | { name: 'ApprovalCancelled'; data: { assetId: number; owner: AccountId32; delegate: AccountId32 } }
  /**
   * An `amount` was transferred in its entirety from `owner` to `destination` by
   * the approved `delegate`.
   **/
  | {
      name: 'TransferredApproved';
      data: { assetId: number; owner: AccountId32; delegate: AccountId32; destination: AccountId32; amount: bigint };
    }
  /**
   * An asset has had its attributes changed by the `Force` origin.
   **/
  | { name: 'AssetStatusChanged'; data: { assetId: number } }
  /**
   * The min_balance of an asset has been updated by the asset owner.
   **/
  | { name: 'AssetMinBalanceChanged'; data: { assetId: number; newMinBalance: bigint } }
  /**
   * Some account `who` was created with a deposit from `depositor`.
   **/
  | { name: 'Touched'; data: { assetId: number; who: AccountId32; depositor: AccountId32 } }
  /**
   * Some account `who` was blocked.
   **/
  | { name: 'Blocked'; data: { assetId: number; who: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletLotteryEvent =
  /**
   * A lottery has been started!
   **/
  | { name: 'LotteryStarted' }
  /**
   * A new set of calls have been set!
   **/
  | { name: 'CallsUpdated' }
  /**
   * A winner has been chosen!
   **/
  | { name: 'Winner'; data: { winner: AccountId32; lotteryBalance: bigint } }
  /**
   * A ticket has been bought!
   **/
  | { name: 'TicketBought'; data: { who: AccountId32; callIndex: [number, number] } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletNisEvent =
  /**
   * A bid was successfully placed.
   **/
  | { name: 'BidPlaced'; data: { who: AccountId32; amount: bigint; duration: number } }
  /**
   * A bid was successfully removed (before being accepted).
   **/
  | { name: 'BidRetracted'; data: { who: AccountId32; amount: bigint; duration: number } }
  /**
   * A bid was dropped from a queue because of another, more substantial, bid was present.
   **/
  | { name: 'BidDropped'; data: { who: AccountId32; amount: bigint; duration: number } }
  /**
   * A bid was accepted. The balance may not be released until expiry.
   **/
  | {
      name: 'Issued';
      data: {
        /**
         * The identity of the receipt.
         **/
        index: number;

        /**
         * The block number at which the receipt may be thawed.
         **/
        expiry: number;

        /**
         * The owner of the receipt.
         **/
        who: AccountId32;

        /**
         * The proportion of the effective total issuance which the receipt represents.
         **/
        proportion: Perquintill;

        /**
         * The amount of funds which were debited from the owner.
         **/
        amount: bigint;
      };
    }
  /**
   * An receipt has been (at least partially) thawed.
   **/
  | {
      name: 'Thawed';
      data: {
        /**
         * The identity of the receipt.
         **/
        index: number;

        /**
         * The owner.
         **/
        who: AccountId32;

        /**
         * The proportion of the effective total issuance by which the owner was debited.
         **/
        proportion: Perquintill;

        /**
         * The amount by which the owner was credited.
         **/
        amount: bigint;

        /**
         * If `true` then the receipt is done.
         **/
        dropped: boolean;
      };
    }
  /**
   * An automatic funding of the deficit was made.
   **/
  | { name: 'Funded'; data: { deficit: bigint } }
  /**
   * A receipt was transfered.
   **/
  | { name: 'Transferred'; data: { from: AccountId32; to: AccountId32; index: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletUniquesEvent =
  /**
   * A `collection` was created.
   **/
  | { name: 'Created'; data: { collection: number; creator: AccountId32; owner: AccountId32 } }
  /**
   * A `collection` was force-created.
   **/
  | { name: 'ForceCreated'; data: { collection: number; owner: AccountId32 } }
  /**
   * A `collection` was destroyed.
   **/
  | { name: 'Destroyed'; data: { collection: number } }
  /**
   * An `item` was issued.
   **/
  | { name: 'Issued'; data: { collection: number; item: number; owner: AccountId32 } }
  /**
   * An `item` was transferred.
   **/
  | { name: 'Transferred'; data: { collection: number; item: number; from: AccountId32; to: AccountId32 } }
  /**
   * An `item` was destroyed.
   **/
  | { name: 'Burned'; data: { collection: number; item: number; owner: AccountId32 } }
  /**
   * Some `item` was frozen.
   **/
  | { name: 'Frozen'; data: { collection: number; item: number } }
  /**
   * Some `item` was thawed.
   **/
  | { name: 'Thawed'; data: { collection: number; item: number } }
  /**
   * Some `collection` was frozen.
   **/
  | { name: 'CollectionFrozen'; data: { collection: number } }
  /**
   * Some `collection` was thawed.
   **/
  | { name: 'CollectionThawed'; data: { collection: number } }
  /**
   * The owner changed.
   **/
  | { name: 'OwnerChanged'; data: { collection: number; newOwner: AccountId32 } }
  /**
   * The management team changed.
   **/
  | { name: 'TeamChanged'; data: { collection: number; issuer: AccountId32; admin: AccountId32; freezer: AccountId32 } }
  /**
   * An `item` of a `collection` has been approved by the `owner` for transfer by
   * a `delegate`.
   **/
  | { name: 'ApprovedTransfer'; data: { collection: number; item: number; owner: AccountId32; delegate: AccountId32 } }
  /**
   * An approval for a `delegate` account to transfer the `item` of an item
   * `collection` was cancelled by its `owner`.
   **/
  | { name: 'ApprovalCancelled'; data: { collection: number; item: number; owner: AccountId32; delegate: AccountId32 } }
  /**
   * A `collection` has had its attributes changed by the `Force` origin.
   **/
  | { name: 'ItemStatusChanged'; data: { collection: number } }
  /**
   * New metadata has been set for a `collection`.
   **/
  | { name: 'CollectionMetadataSet'; data: { collection: number; data: Bytes; isFrozen: boolean } }
  /**
   * Metadata has been cleared for a `collection`.
   **/
  | { name: 'CollectionMetadataCleared'; data: { collection: number } }
  /**
   * New metadata has been set for an item.
   **/
  | { name: 'MetadataSet'; data: { collection: number; item: number; data: Bytes; isFrozen: boolean } }
  /**
   * Metadata has been cleared for an item.
   **/
  | { name: 'MetadataCleared'; data: { collection: number; item: number } }
  /**
   * Metadata has been cleared for an item.
   **/
  | { name: 'Redeposited'; data: { collection: number; successfulItems: Array<number> } }
  /**
   * New attribute metadata has been set for a `collection` or `item`.
   **/
  | { name: 'AttributeSet'; data: { collection: number; maybeItem?: number | undefined; key: Bytes; value: Bytes } }
  /**
   * Attribute metadata has been cleared for a `collection` or `item`.
   **/
  | { name: 'AttributeCleared'; data: { collection: number; maybeItem?: number | undefined; key: Bytes } }
  /**
   * Ownership acceptance has changed for an account.
   **/
  | { name: 'OwnershipAcceptanceChanged'; data: { who: AccountId32; maybeCollection?: number | undefined } }
  /**
   * Max supply has been set for a collection.
   **/
  | { name: 'CollectionMaxSupplySet'; data: { collection: number; maxSupply: number } }
  /**
   * The price was set for the instance.
   **/
  | {
      name: 'ItemPriceSet';
      data: { collection: number; item: number; price: bigint; whitelistedBuyer?: AccountId32 | undefined };
    }
  /**
   * The price for the instance was removed.
   **/
  | { name: 'ItemPriceRemoved'; data: { collection: number; item: number } }
  /**
   * An item was bought.
   **/
  | {
      name: 'ItemBought';
      data: { collection: number; item: number; price: bigint; seller: AccountId32; buyer: AccountId32 };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletNftsEvent =
  /**
   * A `collection` was created.
   **/
  | { name: 'Created'; data: { collection: number; creator: AccountId32; owner: AccountId32 } }
  /**
   * A `collection` was force-created.
   **/
  | { name: 'ForceCreated'; data: { collection: number; owner: AccountId32 } }
  /**
   * A `collection` was destroyed.
   **/
  | { name: 'Destroyed'; data: { collection: number } }
  /**
   * An `item` was issued.
   **/
  | { name: 'Issued'; data: { collection: number; item: number; owner: AccountId32 } }
  /**
   * An `item` was transferred.
   **/
  | { name: 'Transferred'; data: { collection: number; item: number; from: AccountId32; to: AccountId32 } }
  /**
   * An `item` was destroyed.
   **/
  | { name: 'Burned'; data: { collection: number; item: number; owner: AccountId32 } }
  /**
   * An `item` became non-transferable.
   **/
  | { name: 'ItemTransferLocked'; data: { collection: number; item: number } }
  /**
   * An `item` became transferable.
   **/
  | { name: 'ItemTransferUnlocked'; data: { collection: number; item: number } }
  /**
   * `item` metadata or attributes were locked.
   **/
  | {
      name: 'ItemPropertiesLocked';
      data: { collection: number; item: number; lockMetadata: boolean; lockAttributes: boolean };
    }
  /**
   * Some `collection` was locked.
   **/
  | { name: 'CollectionLocked'; data: { collection: number } }
  /**
   * The owner changed.
   **/
  | { name: 'OwnerChanged'; data: { collection: number; newOwner: AccountId32 } }
  /**
   * The management team changed.
   **/
  | {
      name: 'TeamChanged';
      data: {
        collection: number;
        issuer?: AccountId32 | undefined;
        admin?: AccountId32 | undefined;
        freezer?: AccountId32 | undefined;
      };
    }
  /**
   * An `item` of a `collection` has been approved by the `owner` for transfer by
   * a `delegate`.
   **/
  | {
      name: 'TransferApproved';
      data: {
        collection: number;
        item: number;
        owner: AccountId32;
        delegate: AccountId32;
        deadline?: number | undefined;
      };
    }
  /**
   * An approval for a `delegate` account to transfer the `item` of an item
   * `collection` was cancelled by its `owner`.
   **/
  | { name: 'ApprovalCancelled'; data: { collection: number; item: number; owner: AccountId32; delegate: AccountId32 } }
  /**
   * All approvals of an item got cancelled.
   **/
  | { name: 'AllApprovalsCancelled'; data: { collection: number; item: number; owner: AccountId32 } }
  /**
   * A `collection` has had its config changed by the `Force` origin.
   **/
  | { name: 'CollectionConfigChanged'; data: { collection: number } }
  /**
   * New metadata has been set for a `collection`.
   **/
  | { name: 'CollectionMetadataSet'; data: { collection: number; data: Bytes } }
  /**
   * Metadata has been cleared for a `collection`.
   **/
  | { name: 'CollectionMetadataCleared'; data: { collection: number } }
  /**
   * New metadata has been set for an item.
   **/
  | { name: 'ItemMetadataSet'; data: { collection: number; item: number; data: Bytes } }
  /**
   * Metadata has been cleared for an item.
   **/
  | { name: 'ItemMetadataCleared'; data: { collection: number; item: number } }
  /**
   * The deposit for a set of `item`s within a `collection` has been updated.
   **/
  | { name: 'Redeposited'; data: { collection: number; successfulItems: Array<number> } }
  /**
   * New attribute metadata has been set for a `collection` or `item`.
   **/
  | {
      name: 'AttributeSet';
      data: {
        collection: number;
        maybeItem?: number | undefined;
        key: Bytes;
        value: Bytes;
        namespace: PalletNftsAttributeNamespace;
      };
    }
  /**
   * Attribute metadata has been cleared for a `collection` or `item`.
   **/
  | {
      name: 'AttributeCleared';
      data: { collection: number; maybeItem?: number | undefined; key: Bytes; namespace: PalletNftsAttributeNamespace };
    }
  /**
   * A new approval to modify item attributes was added.
   **/
  | { name: 'ItemAttributesApprovalAdded'; data: { collection: number; item: number; delegate: AccountId32 } }
  /**
   * A new approval to modify item attributes was removed.
   **/
  | { name: 'ItemAttributesApprovalRemoved'; data: { collection: number; item: number; delegate: AccountId32 } }
  /**
   * Ownership acceptance has changed for an account.
   **/
  | { name: 'OwnershipAcceptanceChanged'; data: { who: AccountId32; maybeCollection?: number | undefined } }
  /**
   * Max supply has been set for a collection.
   **/
  | { name: 'CollectionMaxSupplySet'; data: { collection: number; maxSupply: number } }
  /**
   * Mint settings for a collection had changed.
   **/
  | { name: 'CollectionMintSettingsUpdated'; data: { collection: number } }
  /**
   * Event gets emitted when the `NextCollectionId` gets incremented.
   **/
  | { name: 'NextCollectionIdIncremented'; data: { nextId?: number | undefined } }
  /**
   * The price was set for the item.
   **/
  | {
      name: 'ItemPriceSet';
      data: { collection: number; item: number; price: bigint; whitelistedBuyer?: AccountId32 | undefined };
    }
  /**
   * The price for the item was removed.
   **/
  | { name: 'ItemPriceRemoved'; data: { collection: number; item: number } }
  /**
   * An item was bought.
   **/
  | {
      name: 'ItemBought';
      data: { collection: number; item: number; price: bigint; seller: AccountId32; buyer: AccountId32 };
    }
  /**
   * A tip was sent.
   **/
  | {
      name: 'TipSent';
      data: { collection: number; item: number; sender: AccountId32; receiver: AccountId32; amount: bigint };
    }
  /**
   * An `item` swap intent was created.
   **/
  | {
      name: 'SwapCreated';
      data: {
        offeredCollection: number;
        offeredItem: number;
        desiredCollection: number;
        desiredItem?: number | undefined;
        price?: PalletNftsPriceWithDirection | undefined;
        deadline: number;
      };
    }
  /**
   * The swap was cancelled.
   **/
  | {
      name: 'SwapCancelled';
      data: {
        offeredCollection: number;
        offeredItem: number;
        desiredCollection: number;
        desiredItem?: number | undefined;
        price?: PalletNftsPriceWithDirection | undefined;
        deadline: number;
      };
    }
  /**
   * The swap has been claimed.
   **/
  | {
      name: 'SwapClaimed';
      data: {
        sentCollection: number;
        sentItem: number;
        sentItemOwner: AccountId32;
        receivedCollection: number;
        receivedItem: number;
        receivedItemOwner: AccountId32;
        price?: PalletNftsPriceWithDirection | undefined;
        deadline: number;
      };
    }
  /**
   * New attributes have been set for an `item` of the `collection`.
   **/
  | {
      name: 'PreSignedAttributesSet';
      data: { collection: number; item: number; namespace: PalletNftsAttributeNamespace };
    }
  /**
   * A new attribute in the `Pallet` namespace was set for the `collection` or an `item`
   * within that `collection`.
   **/
  | {
      name: 'PalletAttributeSet';
      data: { collection: number; item?: number | undefined; attribute: PalletNftsPalletAttributes; value: Bytes };
    };

export type PalletNftsAttributeNamespace =
  | { tag: 'Pallet' }
  | { tag: 'CollectionOwner' }
  | { tag: 'ItemOwner' }
  | { tag: 'Account'; value: AccountId32 };

export type PalletNftsPriceWithDirection = { amount: bigint; direction: PalletNftsPriceDirection };

export type PalletNftsPriceDirection = 'Send' | 'Receive';

export type PalletNftsPalletAttributes = { tag: 'UsedToClaim'; value: number } | { tag: 'TransferDisabled' };

/**
 * The `Event` enum of this pallet
 **/
export type PalletNftFractionalizationEvent =
  /**
   * An NFT was successfully fractionalized.
   **/
  | {
      name: 'NftFractionalized';
      data: { nftCollection: number; nft: number; fractions: bigint; asset: number; beneficiary: AccountId32 };
    }
  /**
   * An NFT was successfully returned back.
   **/
  | { name: 'NftUnified'; data: { nftCollection: number; nft: number; asset: number; beneficiary: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSalaryEvent =
  /**
   * A member is inducted into the payroll.
   **/
  | { name: 'Inducted'; data: { who: AccountId32 } }
  /**
   * A member registered for a payout.
   **/
  | { name: 'Registered'; data: { who: AccountId32; amount: bigint } }
  /**
   * A payment happened.
   **/
  | { name: 'Paid'; data: { who: AccountId32; beneficiary: AccountId32; amount: bigint; id: [] } }
  /**
   * The next cycle begins.
   **/
  | { name: 'CycleStarted'; data: { index: number } }
  /**
   * A member swapped their account.
   **/
  | { name: 'Swapped'; data: { who: AccountId32; newWho: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletCoreFellowshipEvent =
  /**
   * Parameters for the pallet have changed.
   **/
  | { name: 'ParamsChanged'; data: { params: PalletCoreFellowshipParamsType } }
  /**
   * Member activity flag has been set.
   **/
  | { name: 'ActiveChanged'; data: { who: AccountId32; isActive: boolean } }
  /**
   * Member has begun being tracked in this pallet.
   **/
  | { name: 'Inducted'; data: { who: AccountId32 } }
  /**
   * Member has been removed from being tracked in this pallet (i.e. because rank is now
   * zero).
   **/
  | { name: 'Offboarded'; data: { who: AccountId32 } }
  /**
   * Member has been promoted to the given rank.
   **/
  | { name: 'Promoted'; data: { who: AccountId32; toRank: number } }
  /**
   * Member has been demoted to the given (non-zero) rank.
   **/
  | { name: 'Demoted'; data: { who: AccountId32; toRank: number } }
  /**
   * Member has been proven at their current rank, postponing auto-demotion.
   **/
  | { name: 'Proven'; data: { who: AccountId32; atRank: number } }
  /**
   * Member has stated evidence of their efforts their request for rank.
   **/
  | { name: 'Requested'; data: { who: AccountId32; wish: PalletCoreFellowshipWish } }
  /**
   * Some submitted evidence was judged and removed. There may or may not have been a change
   * to the rank, but in any case, `last_proof` is reset.
   **/
  | {
      name: 'EvidenceJudged';
      data: {
        /**
         * The member/candidate.
         **/
        who: AccountId32;

        /**
         * The desired outcome for which the evidence was presented.
         **/
        wish: PalletCoreFellowshipWish;

        /**
         * The evidence of efforts.
         **/
        evidence: Bytes;

        /**
         * The old rank, prior to this change.
         **/
        oldRank: number;

        /**
         * New rank. If `None` then candidate record was removed entirely.
         **/
        newRank?: number | undefined;
      };
    }
  /**
   * Pre-ranked account has been inducted at their current rank.
   **/
  | { name: 'Imported'; data: { who: AccountId32; rank: number } }
  /**
   * A member had its AccountId swapped.
   **/
  | { name: 'Swapped'; data: { who: AccountId32; newWho: AccountId32 } };

export type PalletCoreFellowshipParamsType = {
  activeSalary: FixedArray<bigint, 9>;
  passiveSalary: FixedArray<bigint, 9>;
  demotionPeriod: FixedArray<number, 9>;
  minPromotionPeriod: FixedArray<number, 9>;
  offboardTimeout: number;
};

export type PalletCoreFellowshipWish = 'Retention' | 'Promotion';

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionStorageEvent =
  /**
   * Stored data under specified index.
   **/
  | { name: 'Stored'; data: { index: number } }
  /**
   * Renewed data under specified index.
   **/
  | { name: 'Renewed'; data: { index: number } }
  /**
   * Storage proof was successfully checked.
   **/
  | { name: 'ProofChecked' };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBagsListEvent =
  /**
   * Moved an account from one bag to another.
   **/
  | { name: 'Rebagged'; data: { who: AccountId32; from: bigint; to: bigint } }
  /**
   * Updated the score of some account to the given amount.
   **/
  | { name: 'ScoreUpdated'; data: { who: AccountId32; newScore: bigint } };

/**
 * Inner events of this pallet.
 **/
export type PalletStateTrieMigrationEvent =
  /**
   * Given number of `(top, child)` keys were migrated respectively, with the given
   * `compute`.
   **/
  | { name: 'Migrated'; data: { top: number; child: number; compute: PalletStateTrieMigrationMigrationCompute } }
  /**
   * Some account got slashed by the given amount.
   **/
  | { name: 'Slashed'; data: { who: AccountId32; amount: bigint } }
  /**
   * The auto migration task finished.
   **/
  | { name: 'AutoMigrationFinished' }
  /**
   * Migration got halted due to an error or miss-configuration.
   **/
  | { name: 'Halted'; data: { error: PalletStateTrieMigrationError } };

export type PalletStateTrieMigrationMigrationCompute = 'Signed' | 'Auto';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletStateTrieMigrationError =
  /**
   * Max signed limits not respected.
   **/
  | 'MaxSignedLimits'
  /**
   * A key was longer than the configured maximum.
   *
   * This means that the migration halted at the current [`Progress`] and
   * can be resumed with a larger [`crate::Config::MaxKeyLen`] value.
   * Retrying with the same [`crate::Config::MaxKeyLen`] value will not work.
   * The value should only be increased to avoid a storage migration for the currently
   * stored [`crate::Progress::LastKey`].
   **/
  | 'KeyTooLong'
  /**
   * submitter does not have enough funds.
   **/
  | 'NotEnoughFunds'
  /**
   * Bad witness data provided.
   **/
  | 'BadWitness'
  /**
   * Signed migration is not allowed because the maximum limit is not set yet.
   **/
  | 'SignedMigrationNotAllowed'
  /**
   * Bad child root provided.
   **/
  | 'BadChildRoot';

/**
 * The `Event` enum of this pallet
 **/
export type PalletChildBountiesEvent =
  /**
   * A child-bounty is added.
   **/
  | { name: 'Added'; data: { index: number; childIndex: number } }
  /**
   * A child-bounty is awarded to a beneficiary.
   **/
  | { name: 'Awarded'; data: { index: number; childIndex: number; beneficiary: AccountId32 } }
  /**
   * A child-bounty is claimed by beneficiary.
   **/
  | { name: 'Claimed'; data: { index: number; childIndex: number; payout: bigint; beneficiary: AccountId32 } }
  /**
   * A child-bounty is cancelled.
   **/
  | { name: 'Canceled'; data: { index: number; childIndex: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletReferendaEvent =
  /**
   * A referendum has been submitted.
   **/
  | {
      name: 'Submitted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;
      };
    }
  /**
   * The decision deposit has been placed.
   **/
  | {
      name: 'DecisionDepositPlaced';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * The decision deposit has been refunded.
   **/
  | {
      name: 'DecisionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A deposit has been slashed.
   **/
  | {
      name: 'DepositSlashed';
      data: {
        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A referendum has moved into the deciding phase.
   **/
  | {
      name: 'DecisionStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;

        /**
         * The current tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  | {
      name: 'ConfirmStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  | {
      name: 'ConfirmAborted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A referendum has ended its confirmation phase and is ready for approval.
   **/
  | {
      name: 'Confirmed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been approved and its proposal has been scheduled.
   **/
  | {
      name: 'Approved';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A proposal has been rejected by referendum.
   **/
  | {
      name: 'Rejected';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been timed out without being decided.
   **/
  | {
      name: 'TimedOut';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been cancelled.
   **/
  | {
      name: 'Cancelled';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been killed.
   **/
  | {
      name: 'Killed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * The submission deposit has been refunded.
   **/
  | {
      name: 'SubmissionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * Metadata for a referendum has been set.
   **/
  | {
      name: 'MetadataSet';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  /**
   * Metadata for a referendum has been cleared.
   **/
  | {
      name: 'MetadataCleared';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    };

export type FrameSupportPreimagesBounded =
  | { tag: 'Legacy'; value: { hash: H256 } }
  | { tag: 'Inline'; value: Bytes }
  | { tag: 'Lookup'; value: { hash: H256; len: number } };

export type KitchensinkRuntimeRuntimeCall =
  | { pallet: 'System'; palletCall: FrameSystemCall }
  | { pallet: 'Utility'; palletCall: PalletUtilityCall }
  | { pallet: 'Babe'; palletCall: PalletBabeCall }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCall }
  | { pallet: 'Indices'; palletCall: PalletIndicesCall }
  | { pallet: 'Balances'; palletCall: PalletBalancesCall }
  | { pallet: 'ElectionProviderMultiPhase'; palletCall: PalletElectionProviderMultiPhaseCall }
  | { pallet: 'Staking'; palletCall: PalletStakingPalletCall }
  | { pallet: 'Session'; palletCall: PalletSessionCall }
  | { pallet: 'Democracy'; palletCall: PalletDemocracyCall }
  | { pallet: 'Council'; palletCall: PalletCollectiveCall }
  | { pallet: 'TechnicalCommittee'; palletCall: PalletCollectiveCall }
  | { pallet: 'Elections'; palletCall: PalletElectionsPhragmenCall }
  | { pallet: 'TechnicalMembership'; palletCall: PalletMembershipCall }
  | { pallet: 'Grandpa'; palletCall: PalletGrandpaCall }
  | { pallet: 'Treasury'; palletCall: PalletTreasuryCall }
  | { pallet: 'AssetRate'; palletCall: PalletAssetRateCall }
  | { pallet: 'Contracts'; palletCall: PalletContractsCall }
  | { pallet: 'Sudo'; palletCall: PalletSudoCall }
  | { pallet: 'ImOnline'; palletCall: PalletImOnlineCall }
  | { pallet: 'Identity'; palletCall: PalletIdentityCall }
  | { pallet: 'Society'; palletCall: PalletSocietyCall }
  | { pallet: 'Recovery'; palletCall: PalletRecoveryCall }
  | { pallet: 'Vesting'; palletCall: PalletVestingCall }
  | { pallet: 'Scheduler'; palletCall: PalletSchedulerCall }
  | { pallet: 'Glutton'; palletCall: PalletGluttonCall }
  | { pallet: 'Preimage'; palletCall: PalletPreimageCall }
  | { pallet: 'Proxy'; palletCall: PalletProxyCall }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCall }
  | { pallet: 'Bounties'; palletCall: PalletBountiesCall }
  | { pallet: 'Tips'; palletCall: PalletTipsCall }
  | { pallet: 'Assets'; palletCall: PalletAssetsCall }
  | { pallet: 'PoolAssets'; palletCall: PalletAssetsCall }
  | { pallet: 'Beefy'; palletCall: PalletBeefyCall }
  | { pallet: 'Lottery'; palletCall: PalletLotteryCall }
  | { pallet: 'Nis'; palletCall: PalletNisCall }
  | { pallet: 'Uniques'; palletCall: PalletUniquesCall }
  | { pallet: 'Nfts'; palletCall: PalletNftsCall }
  | { pallet: 'NftFractionalization'; palletCall: PalletNftFractionalizationCall }
  | { pallet: 'Salary'; palletCall: PalletSalaryCall }
  | { pallet: 'CoreFellowship'; palletCall: PalletCoreFellowshipCall }
  | { pallet: 'TransactionStorage'; palletCall: PalletTransactionStorageCall }
  | { pallet: 'VoterList'; palletCall: PalletBagsListCall }
  | { pallet: 'StateTrieMigration'; palletCall: PalletStateTrieMigrationCall }
  | { pallet: 'ChildBounties'; palletCall: PalletChildBountiesCall }
  | { pallet: 'Referenda'; palletCall: PalletReferendaCall }
  | { pallet: 'Remark'; palletCall: PalletRemarkCall }
  | { pallet: 'RootTesting'; palletCall: PalletRootTestingCall }
  | { pallet: 'ConvictionVoting'; palletCall: PalletConvictionVotingCall }
  | { pallet: 'Whitelist'; palletCall: PalletWhitelistCall }
  | { pallet: 'AllianceMotion'; palletCall: PalletCollectiveCall }
  | { pallet: 'Alliance'; palletCall: PalletAllianceCall }
  | { pallet: 'NominationPools'; palletCall: PalletNominationPoolsCall }
  | { pallet: 'RankedPolls'; palletCall: PalletReferendaCall }
  | { pallet: 'RankedCollective'; palletCall: PalletRankedCollectiveCall }
  | { pallet: 'AssetConversion'; palletCall: PalletAssetConversionCall }
  | { pallet: 'FastUnstake'; palletCall: PalletFastUnstakeCall }
  | { pallet: 'MessageQueue'; palletCall: PalletMessageQueueCall }
  | { pallet: 'Pov'; palletCall: FrameBenchmarkingPalletPovCall }
  | { pallet: 'TxPause'; palletCall: PalletTxPauseCall }
  | { pallet: 'SafeMode'; palletCall: PalletSafeModeCall }
  | { pallet: 'MultiBlockMigrations'; palletCall: PalletMigrationsCall }
  | { pallet: 'Broker'; palletCall: PalletBrokerCall }
  | { pallet: 'Mixnet'; palletCall: PalletMixnetCall }
  | { pallet: 'Parameters'; palletCall: PalletParametersCall };

export type KitchensinkRuntimeRuntimeCallLike =
  | { pallet: 'System'; palletCall: FrameSystemCallLike }
  | { pallet: 'Utility'; palletCall: PalletUtilityCallLike }
  | { pallet: 'Babe'; palletCall: PalletBabeCallLike }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCallLike }
  | { pallet: 'Indices'; palletCall: PalletIndicesCallLike }
  | { pallet: 'Balances'; palletCall: PalletBalancesCallLike }
  | { pallet: 'ElectionProviderMultiPhase'; palletCall: PalletElectionProviderMultiPhaseCallLike }
  | { pallet: 'Staking'; palletCall: PalletStakingPalletCallLike }
  | { pallet: 'Session'; palletCall: PalletSessionCallLike }
  | { pallet: 'Democracy'; palletCall: PalletDemocracyCallLike }
  | { pallet: 'Council'; palletCall: PalletCollectiveCallLike }
  | { pallet: 'TechnicalCommittee'; palletCall: PalletCollectiveCallLike }
  | { pallet: 'Elections'; palletCall: PalletElectionsPhragmenCallLike }
  | { pallet: 'TechnicalMembership'; palletCall: PalletMembershipCallLike }
  | { pallet: 'Grandpa'; palletCall: PalletGrandpaCallLike }
  | { pallet: 'Treasury'; palletCall: PalletTreasuryCallLike }
  | { pallet: 'AssetRate'; palletCall: PalletAssetRateCallLike }
  | { pallet: 'Contracts'; palletCall: PalletContractsCallLike }
  | { pallet: 'Sudo'; palletCall: PalletSudoCallLike }
  | { pallet: 'ImOnline'; palletCall: PalletImOnlineCallLike }
  | { pallet: 'Identity'; palletCall: PalletIdentityCallLike }
  | { pallet: 'Society'; palletCall: PalletSocietyCallLike }
  | { pallet: 'Recovery'; palletCall: PalletRecoveryCallLike }
  | { pallet: 'Vesting'; palletCall: PalletVestingCallLike }
  | { pallet: 'Scheduler'; palletCall: PalletSchedulerCallLike }
  | { pallet: 'Glutton'; palletCall: PalletGluttonCallLike }
  | { pallet: 'Preimage'; palletCall: PalletPreimageCallLike }
  | { pallet: 'Proxy'; palletCall: PalletProxyCallLike }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCallLike }
  | { pallet: 'Bounties'; palletCall: PalletBountiesCallLike }
  | { pallet: 'Tips'; palletCall: PalletTipsCallLike }
  | { pallet: 'Assets'; palletCall: PalletAssetsCallLike }
  | { pallet: 'PoolAssets'; palletCall: PalletAssetsCallLike }
  | { pallet: 'Beefy'; palletCall: PalletBeefyCallLike }
  | { pallet: 'Lottery'; palletCall: PalletLotteryCallLike }
  | { pallet: 'Nis'; palletCall: PalletNisCallLike }
  | { pallet: 'Uniques'; palletCall: PalletUniquesCallLike }
  | { pallet: 'Nfts'; palletCall: PalletNftsCallLike }
  | { pallet: 'NftFractionalization'; palletCall: PalletNftFractionalizationCallLike }
  | { pallet: 'Salary'; palletCall: PalletSalaryCallLike }
  | { pallet: 'CoreFellowship'; palletCall: PalletCoreFellowshipCallLike }
  | { pallet: 'TransactionStorage'; palletCall: PalletTransactionStorageCallLike }
  | { pallet: 'VoterList'; palletCall: PalletBagsListCallLike }
  | { pallet: 'StateTrieMigration'; palletCall: PalletStateTrieMigrationCallLike }
  | { pallet: 'ChildBounties'; palletCall: PalletChildBountiesCallLike }
  | { pallet: 'Referenda'; palletCall: PalletReferendaCallLike }
  | { pallet: 'Remark'; palletCall: PalletRemarkCallLike }
  | { pallet: 'RootTesting'; palletCall: PalletRootTestingCallLike }
  | { pallet: 'ConvictionVoting'; palletCall: PalletConvictionVotingCallLike }
  | { pallet: 'Whitelist'; palletCall: PalletWhitelistCallLike }
  | { pallet: 'AllianceMotion'; palletCall: PalletCollectiveCallLike }
  | { pallet: 'Alliance'; palletCall: PalletAllianceCallLike }
  | { pallet: 'NominationPools'; palletCall: PalletNominationPoolsCallLike }
  | { pallet: 'RankedPolls'; palletCall: PalletReferendaCallLike }
  | { pallet: 'RankedCollective'; palletCall: PalletRankedCollectiveCallLike }
  | { pallet: 'AssetConversion'; palletCall: PalletAssetConversionCallLike }
  | { pallet: 'FastUnstake'; palletCall: PalletFastUnstakeCallLike }
  | { pallet: 'MessageQueue'; palletCall: PalletMessageQueueCallLike }
  | { pallet: 'Pov'; palletCall: FrameBenchmarkingPalletPovCallLike }
  | { pallet: 'TxPause'; palletCall: PalletTxPauseCallLike }
  | { pallet: 'SafeMode'; palletCall: PalletSafeModeCallLike }
  | { pallet: 'MultiBlockMigrations'; palletCall: PalletMigrationsCallLike }
  | { pallet: 'Broker'; palletCall: PalletBrokerCallLike }
  | { pallet: 'Mixnet'; palletCall: PalletMixnetCallLike }
  | { pallet: 'Parameters'; palletCall: PalletParametersCallLike };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type FrameSystemCall =
  /**
   * Make some on-chain remark.
   *
   * Can be executed by every `origin`.
   **/
  | { name: 'Remark'; params: { remark: Bytes } }
  /**
   * Set the number of pages in the WebAssembly environment's heap.
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * Set the new runtime code.
   **/
  | { name: 'SetCode'; params: { code: Bytes } }
  /**
   * Set the new runtime code without doing any checks of the given `code`.
   *
   * Note that runtime upgrades will not run if this is called with a not-increasing spec
   * version!
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: Bytes } }
  /**
   * Set some items of storage.
   **/
  | { name: 'SetStorage'; params: { items: Array<[Bytes, Bytes]> } }
  /**
   * Kill some items from storage.
   **/
  | { name: 'KillStorage'; params: { keys: Array<Bytes> } }
  /**
   * Kill all storage items with a key that starts with the given prefix.
   *
   * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
   * the prefix we are removing to accurately calculate the weight of this function.
   **/
  | { name: 'KillPrefix'; params: { prefix: Bytes; subkeys: number } }
  /**
   * Make some on-chain remark and emit event.
   **/
  | { name: 'RemarkWithEvent'; params: { remark: Bytes } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256 } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * WARNING: This authorizes an upgrade that will take place without any safety checks, for
   * example that the spec name remains the same and that the version number increases. Not
   * recommended for normal use. Use `authorize_upgrade` instead.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgradeWithoutChecks'; params: { codeHash: H256 } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
   * the new `code` in the same block or attempt to schedule the upgrade.
   *
   * All origins are allowed.
   **/
  | { name: 'ApplyAuthorizedUpgrade'; params: { code: Bytes } };

export type FrameSystemCallLike =
  /**
   * Make some on-chain remark.
   *
   * Can be executed by every `origin`.
   **/
  | { name: 'Remark'; params: { remark: BytesLike } }
  /**
   * Set the number of pages in the WebAssembly environment's heap.
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * Set the new runtime code.
   **/
  | { name: 'SetCode'; params: { code: BytesLike } }
  /**
   * Set the new runtime code without doing any checks of the given `code`.
   *
   * Note that runtime upgrades will not run if this is called with a not-increasing spec
   * version!
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: BytesLike } }
  /**
   * Set some items of storage.
   **/
  | { name: 'SetStorage'; params: { items: Array<[BytesLike, BytesLike]> } }
  /**
   * Kill some items from storage.
   **/
  | { name: 'KillStorage'; params: { keys: Array<BytesLike> } }
  /**
   * Kill all storage items with a key that starts with the given prefix.
   *
   * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
   * the prefix we are removing to accurately calculate the weight of this function.
   **/
  | { name: 'KillPrefix'; params: { prefix: BytesLike; subkeys: number } }
  /**
   * Make some on-chain remark and emit event.
   **/
  | { name: 'RemarkWithEvent'; params: { remark: BytesLike } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256 } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * WARNING: This authorizes an upgrade that will take place without any safety checks, for
   * example that the spec name remains the same and that the version number increases. Not
   * recommended for normal use. Use `authorize_upgrade` instead.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgradeWithoutChecks'; params: { codeHash: H256 } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
   * the new `code` in the same block or attempt to schedule the upgrade.
   *
   * All origins are allowed.
   **/
  | { name: 'ApplyAuthorizedUpgrade'; params: { code: BytesLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUtilityCall =
  /**
   * Send a batch of dispatch calls.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   *
   * This will return `Ok` in all circumstances. To determine the success of the batch, an
   * event is deposited. If a call failed and the batch was interrupted, then the
   * `BatchInterrupted` event is deposited, along with the number of successful calls made
   * and the error of the failed call. If all were successful, then the `BatchCompleted`
   * event is deposited.
   **/
  | { name: 'Batch'; params: { calls: Array<KitchensinkRuntimeRuntimeCall> } }
  /**
   * Send a call through an indexed pseudonym of the sender.
   *
   * Filter from origin are passed along. The call will be dispatched with an origin which
   * use the same filter as the origin of this call.
   *
   * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
   * because you expect `proxy` to have been used prior in the call stack and you do not want
   * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
   * in the Multisig pallet instead.
   *
   * NOTE: Prior to version *12, this was called `as_limited_sub`.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'AsDerivative'; params: { index: number; call: KitchensinkRuntimeRuntimeCall } }
  /**
   * Send a batch of dispatch calls and atomically execute them.
   * The whole transaction will rollback and fail if any of the calls failed.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'BatchAll'; params: { calls: Array<KitchensinkRuntimeRuntimeCall> } }
  /**
   * Dispatches a function call with a provided origin.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'DispatchAs'; params: { asOrigin: KitchensinkRuntimeOriginCaller; call: KitchensinkRuntimeRuntimeCall } }
  /**
   * Send a batch of dispatch calls.
   * Unlike `batch`, it allows errors and won't interrupt.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatch without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'ForceBatch'; params: { calls: Array<KitchensinkRuntimeRuntimeCall> } }
  /**
   * Dispatch a function call with a specified weight.
   *
   * This function does not check the weight of the call, and instead allows the
   * Root origin to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Root_.
   **/
  | { name: 'WithWeight'; params: { call: KitchensinkRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight } };

export type PalletUtilityCallLike =
  /**
   * Send a batch of dispatch calls.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   *
   * This will return `Ok` in all circumstances. To determine the success of the batch, an
   * event is deposited. If a call failed and the batch was interrupted, then the
   * `BatchInterrupted` event is deposited, along with the number of successful calls made
   * and the error of the failed call. If all were successful, then the `BatchCompleted`
   * event is deposited.
   **/
  | { name: 'Batch'; params: { calls: Array<KitchensinkRuntimeRuntimeCallLike> } }
  /**
   * Send a call through an indexed pseudonym of the sender.
   *
   * Filter from origin are passed along. The call will be dispatched with an origin which
   * use the same filter as the origin of this call.
   *
   * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
   * because you expect `proxy` to have been used prior in the call stack and you do not want
   * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
   * in the Multisig pallet instead.
   *
   * NOTE: Prior to version *12, this was called `as_limited_sub`.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'AsDerivative'; params: { index: number; call: KitchensinkRuntimeRuntimeCallLike } }
  /**
   * Send a batch of dispatch calls and atomically execute them.
   * The whole transaction will rollback and fail if any of the calls failed.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'BatchAll'; params: { calls: Array<KitchensinkRuntimeRuntimeCallLike> } }
  /**
   * Dispatches a function call with a provided origin.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * ## Complexity
   * - O(1).
   **/
  | {
      name: 'DispatchAs';
      params: { asOrigin: KitchensinkRuntimeOriginCaller; call: KitchensinkRuntimeRuntimeCallLike };
    }
  /**
   * Send a batch of dispatch calls.
   * Unlike `batch`, it allows errors and won't interrupt.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatch without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'ForceBatch'; params: { calls: Array<KitchensinkRuntimeRuntimeCallLike> } }
  /**
   * Dispatch a function call with a specified weight.
   *
   * This function does not check the weight of the call, and instead allows the
   * Root origin to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Root_.
   **/
  | { name: 'WithWeight'; params: { call: KitchensinkRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight } };

export type KitchensinkRuntimeOriginCaller =
  | { tag: 'System'; value: FrameSupportDispatchRawOrigin }
  | { tag: 'Council'; value: PalletCollectiveRawOrigin }
  | { tag: 'TechnicalCommittee'; value: PalletCollectiveRawOrigin }
  | { tag: 'AllianceMotion'; value: PalletCollectiveRawOrigin }
  | { tag: 'Void'; value: SpCoreVoid };

export type FrameSupportDispatchRawOrigin = { tag: 'Root' } | { tag: 'Signed'; value: AccountId32 } | { tag: 'None' };

export type PalletCollectiveRawOrigin =
  | { tag: 'Members'; value: [number, number] }
  | { tag: 'Member'; value: AccountId32 }
  | { tag: 'Phantom' };

export type SpCoreVoid = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBabeCall =
  /**
   * Report authority equivocation/misbehavior. This method will verify
   * the equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence will
   * be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Report authority equivocation/misbehavior. This method will verify
   * the equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence will
   * be reported.
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Plan an epoch config change. The epoch config change is recorded and will be enacted on
   * the next call to `enact_epoch_change`. The config will be activated one epoch after.
   * Multiple calls to this method will replace any existing planned config change that had
   * not been enacted yet.
   **/
  | { name: 'PlanConfigChange'; params: { config: SpConsensusBabeDigestsNextConfigDescriptor } };

export type PalletBabeCallLike =
  /**
   * Report authority equivocation/misbehavior. This method will verify
   * the equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence will
   * be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Report authority equivocation/misbehavior. This method will verify
   * the equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence will
   * be reported.
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Plan an epoch config change. The epoch config change is recorded and will be enacted on
   * the next call to `enact_epoch_change`. The config will be activated one epoch after.
   * Multiple calls to this method will replace any existing planned config change that had
   * not been enacted yet.
   **/
  | { name: 'PlanConfigChange'; params: { config: SpConsensusBabeDigestsNextConfigDescriptor } };

export type SpConsensusSlotsEquivocationProof = {
  offender: SpConsensusBabeAppPublic;
  slot: SpConsensusSlotsSlot;
  firstHeader: Header;
  secondHeader: Header;
};

export type SpConsensusBabeAppPublic = SpCoreSr25519Public;

export type SpConsensusSlotsSlot = bigint;

export type SpSessionMembershipProof = { session: number; trieNodes: Array<Bytes>; validatorCount: number };

export type SpConsensusBabeDigestsNextConfigDescriptor = {
  tag: 'V1';
  value: { c: [bigint, bigint]; allowedSlots: SpConsensusBabeAllowedSlots };
};

export type SpConsensusBabeAllowedSlots =
  | 'PrimarySlots'
  | 'PrimaryAndSecondaryPlainSlots'
  | 'PrimaryAndSecondaryVRFSlots';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTimestampCall =
  /**
   * Set the current time.
   *
   * This call should be invoked exactly once per block. It will panic at the finalization
   * phase, if this call hasn't been invoked by that time.
   *
   * The timestamp should be greater than the previous one by the amount specified by
   * [`Config::MinimumPeriod`].
   *
   * The dispatch origin for this call must be _None_.
   *
   * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
   * that changing the complexity of this call could result exhausting the resources in a
   * block to execute any other calls.
   *
   * ## Complexity
   * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
   * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
   * `on_finalize`)
   * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
   **/
  { name: 'Set'; params: { now: bigint } };

export type PalletTimestampCallLike =
  /**
   * Set the current time.
   *
   * This call should be invoked exactly once per block. It will panic at the finalization
   * phase, if this call hasn't been invoked by that time.
   *
   * The timestamp should be greater than the previous one by the amount specified by
   * [`Config::MinimumPeriod`].
   *
   * The dispatch origin for this call must be _None_.
   *
   * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
   * that changing the complexity of this call could result exhausting the resources in a
   * block to execute any other calls.
   *
   * ## Complexity
   * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
   * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
   * `on_finalize`)
   * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
   **/
  { name: 'Set'; params: { now: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletIndicesCall =
  /**
   * Assign an previously unassigned index.
   *
   * Payment: `Deposit` is reserved from the sender account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `index`: the index to be claimed. This must not be in use.
   *
   * Emits `IndexAssigned` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Claim'; params: { index: number } }
  /**
   * Assign an index already owned by the sender to another account. The balance reservation
   * is effectively transferred to the new account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `index`: the index to be re-assigned. This must be owned by the sender.
   * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
   *
   * Emits `IndexAssigned` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Transfer'; params: { new: MultiAddress; index: number } }
  /**
   * Free up an index owned by the sender.
   *
   * Payment: Any previous deposit placed for the index is unreserved in the sender account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must own the index.
   *
   * - `index`: the index to be freed. This must be owned by the sender.
   *
   * Emits `IndexFreed` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Free'; params: { index: number } }
  /**
   * Force an index to an account. This doesn't require a deposit. If the index is already
   * held, then any deposit is reimbursed to its current owner.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `index`: the index to be (re-)assigned.
   * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
   * - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
   *
   * Emits `IndexAssigned` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'ForceTransfer'; params: { new: MultiAddress; index: number; freeze: boolean } }
  /**
   * Freeze an index so it will always point to the sender account. This consumes the
   * deposit.
   *
   * The dispatch origin for this call must be _Signed_ and the signing account must have a
   * non-frozen account `index`.
   *
   * - `index`: the index to be frozen in place.
   *
   * Emits `IndexFrozen` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Freeze'; params: { index: number } };

export type PalletIndicesCallLike =
  /**
   * Assign an previously unassigned index.
   *
   * Payment: `Deposit` is reserved from the sender account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `index`: the index to be claimed. This must not be in use.
   *
   * Emits `IndexAssigned` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Claim'; params: { index: number } }
  /**
   * Assign an index already owned by the sender to another account. The balance reservation
   * is effectively transferred to the new account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `index`: the index to be re-assigned. This must be owned by the sender.
   * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
   *
   * Emits `IndexAssigned` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Transfer'; params: { new: MultiAddressLike; index: number } }
  /**
   * Free up an index owned by the sender.
   *
   * Payment: Any previous deposit placed for the index is unreserved in the sender account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must own the index.
   *
   * - `index`: the index to be freed. This must be owned by the sender.
   *
   * Emits `IndexFreed` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Free'; params: { index: number } }
  /**
   * Force an index to an account. This doesn't require a deposit. If the index is already
   * held, then any deposit is reimbursed to its current owner.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `index`: the index to be (re-)assigned.
   * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
   * - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
   *
   * Emits `IndexAssigned` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'ForceTransfer'; params: { new: MultiAddressLike; index: number; freeze: boolean } }
  /**
   * Freeze an index so it will always point to the sender account. This consumes the
   * deposit.
   *
   * The dispatch origin for this call must be _Signed_ and the signing account must have a
   * non-frozen account `index`.
   *
   * - `index`: the index to be frozen in place.
   *
   * Emits `IndexFrozen` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Freeze'; params: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBalancesCall =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
   * If the sender's account is below the existential deposit as a result
   * of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the transactor.
   **/
  | { name: 'TransferAllowDeath'; params: { dest: MultiAddress; value: bigint } }
  /**
   * Exactly as `transfer_allow_death`, except the origin must be root and the source account
   * may be specified.
   **/
  | { name: 'ForceTransfer'; params: { source: MultiAddress; dest: MultiAddress; value: bigint } }
  /**
   * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
   * kill the origin account.
   *
   * 99% of the time you want [`transfer_allow_death`] instead.
   *
   * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
   **/
  | { name: 'TransferKeepAlive'; params: { dest: MultiAddress; value: bigint } }
  /**
   * Transfer the entire transferable balance from the caller account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the account has, causing the sender account to be killed (false), or
   * transfer everything except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | { name: 'TransferAll'; params: { dest: MultiAddress; keepAlive: boolean } }
  /**
   * Unreserve some balance from a user by force.
   *
   * Can only be called by ROOT.
   **/
  | { name: 'ForceUnreserve'; params: { who: MultiAddress; amount: bigint } }
  /**
   * Upgrade a specified account.
   *
   * - `origin`: Must be `Signed`.
   * - `who`: The account to be upgraded.
   *
   * This will waive the transaction fee if at least all but 10% of the accounts needed to
   * be upgraded. (We let some not have to be upgraded just in order to allow for the
   * possibililty of churn).
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32> } }
  /**
   * Set the regular balance of a given account.
   *
   * The dispatch origin for this call is `root`.
   **/
  | { name: 'ForceSetBalance'; params: { who: MultiAddress; newFree: bigint } }
  /**
   * Adjust the total issuance in a saturating way.
   *
   * Can only be called by root and always needs a positive `delta`.
   *
   * # Example
   **/
  | { name: 'ForceAdjustTotalIssuance'; params: { direction: PalletBalancesAdjustmentDirection; delta: bigint } };

export type PalletBalancesCallLike =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
   * If the sender's account is below the existential deposit as a result
   * of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the transactor.
   **/
  | { name: 'TransferAllowDeath'; params: { dest: MultiAddressLike; value: bigint } }
  /**
   * Exactly as `transfer_allow_death`, except the origin must be root and the source account
   * may be specified.
   **/
  | { name: 'ForceTransfer'; params: { source: MultiAddressLike; dest: MultiAddressLike; value: bigint } }
  /**
   * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
   * kill the origin account.
   *
   * 99% of the time you want [`transfer_allow_death`] instead.
   *
   * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
   **/
  | { name: 'TransferKeepAlive'; params: { dest: MultiAddressLike; value: bigint } }
  /**
   * Transfer the entire transferable balance from the caller account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the account has, causing the sender account to be killed (false), or
   * transfer everything except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | { name: 'TransferAll'; params: { dest: MultiAddressLike; keepAlive: boolean } }
  /**
   * Unreserve some balance from a user by force.
   *
   * Can only be called by ROOT.
   **/
  | { name: 'ForceUnreserve'; params: { who: MultiAddressLike; amount: bigint } }
  /**
   * Upgrade a specified account.
   *
   * - `origin`: Must be `Signed`.
   * - `who`: The account to be upgraded.
   *
   * This will waive the transaction fee if at least all but 10% of the accounts needed to
   * be upgraded. (We let some not have to be upgraded just in order to allow for the
   * possibililty of churn).
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32Like> } }
  /**
   * Set the regular balance of a given account.
   *
   * The dispatch origin for this call is `root`.
   **/
  | { name: 'ForceSetBalance'; params: { who: MultiAddressLike; newFree: bigint } }
  /**
   * Adjust the total issuance in a saturating way.
   *
   * Can only be called by root and always needs a positive `delta`.
   *
   * # Example
   **/
  | { name: 'ForceAdjustTotalIssuance'; params: { direction: PalletBalancesAdjustmentDirection; delta: bigint } };

export type PalletBalancesAdjustmentDirection = 'Increase' | 'Decrease';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletElectionProviderMultiPhaseCall =
  /**
   * Submit a solution for the unsigned phase.
   *
   * The dispatch origin fo this call must be __none__.
   *
   * This submission is checked on the fly. Moreover, this unsigned solution is only
   * validated when submitted to the pool from the **local** node. Effectively, this means
   * that only active validators can submit this transaction when authoring a block (similar
   * to an inherent).
   *
   * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
   * panic if the solution submitted by the validator is invalid in any way, effectively
   * putting their authoring reward at risk.
   *
   * No deposit or reward is associated with this submission.
   **/
  | {
      name: 'SubmitUnsigned';
      params: {
        rawSolution: PalletElectionProviderMultiPhaseRawSolution;
        witness: PalletElectionProviderMultiPhaseSolutionOrSnapshotSize;
      };
    }
  /**
   * Set a new value for `MinimumUntrustedScore`.
   *
   * Dispatch origin must be aligned with `T::ForceOrigin`.
   *
   * This check can be turned off by setting the value to `None`.
   **/
  | { name: 'SetMinimumUntrustedScore'; params: { maybeNextScore?: SpNposElectionsElectionScore | undefined } }
  /**
   * Set a solution in the queue, to be handed out to the client of this pallet in the next
   * call to `ElectionProvider::elect`.
   *
   * This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
   *
   * The solution is not checked for any feasibility and is assumed to be trustworthy, as any
   * feasibility check itself can in principle cause the election process to fail (due to
   * memory/weight constrains).
   **/
  | { name: 'SetEmergencyElectionResult'; params: { supports: Array<[AccountId32, SpNposElectionsSupport]> } }
  /**
   * Submit a solution for the signed phase.
   *
   * The dispatch origin fo this call must be __signed__.
   *
   * The solution is potentially queued, based on the claimed score and processed at the end
   * of the signed phase.
   *
   * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
   * might be rewarded, slashed, or get all or a part of the deposit back.
   **/
  | { name: 'Submit'; params: { rawSolution: PalletElectionProviderMultiPhaseRawSolution } }
  /**
   * Trigger the governance fallback.
   *
   * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
   * calling [`Call::set_emergency_election_result`].
   **/
  | {
      name: 'GovernanceFallback';
      params: { maybeMaxVoters?: number | undefined; maybeMaxTargets?: number | undefined };
    };

export type PalletElectionProviderMultiPhaseCallLike =
  /**
   * Submit a solution for the unsigned phase.
   *
   * The dispatch origin fo this call must be __none__.
   *
   * This submission is checked on the fly. Moreover, this unsigned solution is only
   * validated when submitted to the pool from the **local** node. Effectively, this means
   * that only active validators can submit this transaction when authoring a block (similar
   * to an inherent).
   *
   * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
   * panic if the solution submitted by the validator is invalid in any way, effectively
   * putting their authoring reward at risk.
   *
   * No deposit or reward is associated with this submission.
   **/
  | {
      name: 'SubmitUnsigned';
      params: {
        rawSolution: PalletElectionProviderMultiPhaseRawSolution;
        witness: PalletElectionProviderMultiPhaseSolutionOrSnapshotSize;
      };
    }
  /**
   * Set a new value for `MinimumUntrustedScore`.
   *
   * Dispatch origin must be aligned with `T::ForceOrigin`.
   *
   * This check can be turned off by setting the value to `None`.
   **/
  | { name: 'SetMinimumUntrustedScore'; params: { maybeNextScore?: SpNposElectionsElectionScore | undefined } }
  /**
   * Set a solution in the queue, to be handed out to the client of this pallet in the next
   * call to `ElectionProvider::elect`.
   *
   * This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
   *
   * The solution is not checked for any feasibility and is assumed to be trustworthy, as any
   * feasibility check itself can in principle cause the election process to fail (due to
   * memory/weight constrains).
   **/
  | { name: 'SetEmergencyElectionResult'; params: { supports: Array<[AccountId32Like, SpNposElectionsSupport]> } }
  /**
   * Submit a solution for the signed phase.
   *
   * The dispatch origin fo this call must be __signed__.
   *
   * The solution is potentially queued, based on the claimed score and processed at the end
   * of the signed phase.
   *
   * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
   * might be rewarded, slashed, or get all or a part of the deposit back.
   **/
  | { name: 'Submit'; params: { rawSolution: PalletElectionProviderMultiPhaseRawSolution } }
  /**
   * Trigger the governance fallback.
   *
   * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
   * calling [`Call::set_emergency_election_result`].
   **/
  | {
      name: 'GovernanceFallback';
      params: { maybeMaxVoters?: number | undefined; maybeMaxTargets?: number | undefined };
    };

export type PalletElectionProviderMultiPhaseRawSolution = {
  solution: KitchensinkRuntimeNposSolution16;
  score: SpNposElectionsElectionScore;
  round: number;
};

export type KitchensinkRuntimeNposSolution16 = {
  votes1: Array<[number, number]>;
  votes2: Array<[number, [number, PerU16], number]>;
  votes3: Array<[number, FixedArray<[number, PerU16], 2>, number]>;
  votes4: Array<[number, FixedArray<[number, PerU16], 3>, number]>;
  votes5: Array<[number, FixedArray<[number, PerU16], 4>, number]>;
  votes6: Array<[number, FixedArray<[number, PerU16], 5>, number]>;
  votes7: Array<[number, FixedArray<[number, PerU16], 6>, number]>;
  votes8: Array<[number, FixedArray<[number, PerU16], 7>, number]>;
  votes9: Array<[number, FixedArray<[number, PerU16], 8>, number]>;
  votes10: Array<[number, FixedArray<[number, PerU16], 9>, number]>;
  votes11: Array<[number, FixedArray<[number, PerU16], 10>, number]>;
  votes12: Array<[number, FixedArray<[number, PerU16], 11>, number]>;
  votes13: Array<[number, FixedArray<[number, PerU16], 12>, number]>;
  votes14: Array<[number, FixedArray<[number, PerU16], 13>, number]>;
  votes15: Array<[number, FixedArray<[number, PerU16], 14>, number]>;
  votes16: Array<[number, FixedArray<[number, PerU16], 15>, number]>;
};

export type PalletElectionProviderMultiPhaseSolutionOrSnapshotSize = { voters: number; targets: number };

export type SpNposElectionsSupport = { total: bigint; voters: Array<[AccountId32, bigint]> };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletStakingPalletCall =
  /**
   * Take the origin account as a stash and lock up `value` of its balance. `controller` will
   * be the account that controls it.
   *
   * `value` must be more than the `minimum_balance` specified by `T::Currency`.
   *
   * The dispatch origin for this call must be _Signed_ by the stash account.
   *
   * Emits `Bonded`.
   * ## Complexity
   * - Independent of the arguments. Moderate complexity.
   * - O(1).
   * - Three extra DB entries.
   *
   * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
   * unless the `origin` falls below _existential deposit_ and gets removed as dust.
   **/
  | { name: 'Bond'; params: { value: bigint; payee: PalletStakingRewardDestination } }
  /**
   * Add some extra amount that have appeared in the stash `free_balance` into the balance up
   * for staking.
   *
   * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
   *
   * Use this if there are additional funds in your stash account that you wish to bond.
   * Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
   * any limitation on the amount that can be added.
   *
   * Emits `Bonded`.
   *
   * ## Complexity
   * - Independent of the arguments. Insignificant complexity.
   * - O(1).
   **/
  | { name: 'BondExtra'; params: { maxAdditional: bigint } }
  /**
   * Schedule a portion of the stash to be unlocked ready for transfer out after the bond
   * period ends. If this leaves an amount actively bonded less than
   * T::Currency::minimum_balance(), then it is increased to the full amount.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * Once the unlock period is done, you can call `withdraw_unbonded` to actually move
   * the funds out of management ready for transfer.
   *
   * No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
   * can co-exists at the same time. If there are no unlocking chunks slots available
   * [`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible).
   *
   * If a user encounters the `InsufficientBond` error when calling this extrinsic,
   * they should call `chill` first in order to free up their bonded funds.
   *
   * Emits `Unbonded`.
   *
   * See also [`Call::withdraw_unbonded`].
   **/
  | { name: 'Unbond'; params: { value: bigint } }
  /**
   * Remove any unlocked chunks from the `unlocking` queue from our management.
   *
   * This essentially frees up that balance to be used by the stash account to do whatever
   * it wants.
   *
   * The dispatch origin for this call must be _Signed_ by the controller.
   *
   * Emits `Withdrawn`.
   *
   * See also [`Call::unbond`].
   *
   * ## Parameters
   *
   * - `num_slashing_spans` indicates the number of metadata slashing spans to clear when
   * this call results in a complete removal of all the data related to the stash account.
   * In this case, the `num_slashing_spans` must be larger or equal to the number of
   * slashing spans associated with the stash account in the [`SlashingSpans`] storage type,
   * otherwise the call will fail. The call weight is directly propotional to
   * `num_slashing_spans`.
   *
   * ## Complexity
   * O(S) where S is the number of slashing spans to remove
   * NOTE: Weight annotation is the kill scenario, we refund otherwise.
   **/
  | { name: 'WithdrawUnbonded'; params: { numSlashingSpans: number } }
  /**
   * Declare the desire to validate for the origin controller.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   **/
  | { name: 'Validate'; params: { prefs: PalletStakingValidatorPrefs } }
  /**
   * Declare the desire to nominate `targets` for the origin controller.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * ## Complexity
   * - The transaction's complexity is proportional to the size of `targets` (N)
   * which is capped at CompactAssignments::LIMIT (T::MaxNominations).
   * - Both the reads and writes follow a similar pattern.
   **/
  | { name: 'Nominate'; params: { targets: Array<MultiAddress> } }
  /**
   * Declare no desire to either validate or nominate.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * ## Complexity
   * - Independent of the arguments. Insignificant complexity.
   * - Contains one read.
   * - Writes are limited to the `origin` account key.
   **/
  | { name: 'Chill' }
  /**
   * (Re-)set the payment target for a controller.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * ## Complexity
   * - O(1)
   * - Independent of the arguments. Insignificant complexity.
   * - Contains a limited number of reads.
   * - Writes are limited to the `origin` account key.
   * ---------
   **/
  | { name: 'SetPayee'; params: { payee: PalletStakingRewardDestination } }
  /**
   * (Re-)sets the controller of a stash to the stash itself. This function previously
   * accepted a `controller` argument to set the controller to an account other than the
   * stash itself. This functionality has now been removed, now only setting the controller
   * to the stash, if it is not already.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
   *
   * ## Complexity
   * O(1)
   * - Independent of the arguments. Insignificant complexity.
   * - Contains a limited number of reads.
   * - Writes are limited to the `origin` account key.
   **/
  | { name: 'SetController' }
  /**
   * Sets the ideal number of validators.
   *
   * The dispatch origin must be Root.
   *
   * ## Complexity
   * O(1)
   **/
  | { name: 'SetValidatorCount'; params: { new: number } }
  /**
   * Increments the ideal number of validators upto maximum of
   * `ElectionProviderBase::MaxWinners`.
   *
   * The dispatch origin must be Root.
   *
   * ## Complexity
   * Same as [`Self::set_validator_count`].
   **/
  | { name: 'IncreaseValidatorCount'; params: { additional: number } }
  /**
   * Scale up the ideal number of validators by a factor upto maximum of
   * `ElectionProviderBase::MaxWinners`.
   *
   * The dispatch origin must be Root.
   *
   * ## Complexity
   * Same as [`Self::set_validator_count`].
   **/
  | { name: 'ScaleValidatorCount'; params: { factor: Percent } }
  /**
   * Force there to be no new eras indefinitely.
   *
   * The dispatch origin must be Root.
   *
   * # Warning
   *
   * The election process starts multiple blocks before the end of the era.
   * Thus the election process may be ongoing when this is called. In this case the
   * election will continue until the next era is triggered.
   *
   * ## Complexity
   * - No arguments.
   * - Weight: O(1)
   **/
  | { name: 'ForceNoEras' }
  /**
   * Force there to be a new era at the end of the next session. After this, it will be
   * reset to normal (non-forced) behaviour.
   *
   * The dispatch origin must be Root.
   *
   * # Warning
   *
   * The election process starts multiple blocks before the end of the era.
   * If this is called just before a new era is triggered, the election process may not
   * have enough blocks to get a result.
   *
   * ## Complexity
   * - No arguments.
   * - Weight: O(1)
   **/
  | { name: 'ForceNewEra' }
  /**
   * Set the validators who cannot be slashed (if any).
   *
   * The dispatch origin must be Root.
   **/
  | { name: 'SetInvulnerables'; params: { invulnerables: Array<AccountId32> } }
  /**
   * Force a current staker to become completely unstaked, immediately.
   *
   * The dispatch origin must be Root.
   *
   * ## Parameters
   *
   * - `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more
   * details.
   **/
  | { name: 'ForceUnstake'; params: { stash: AccountId32; numSlashingSpans: number } }
  /**
   * Force there to be a new era at the end of sessions indefinitely.
   *
   * The dispatch origin must be Root.
   *
   * # Warning
   *
   * The election process starts multiple blocks before the end of the era.
   * If this is called just before a new era is triggered, the election process may not
   * have enough blocks to get a result.
   **/
  | { name: 'ForceNewEraAlways' }
  /**
   * Cancel enactment of a deferred slash.
   *
   * Can be called by the `T::AdminOrigin`.
   *
   * Parameters: era and indices of the slashes for that era to kill.
   **/
  | { name: 'CancelDeferredSlash'; params: { era: number; slashIndices: Array<number> } }
  /**
   * Pay out next page of the stakers behind a validator for the given era.
   *
   * - `validator_stash` is the stash account of the validator.
   * - `era` may be any era between `[current_era - history_depth; current_era]`.
   *
   * The origin of this call must be _Signed_. Any account can call this function, even if
   * it is not one of the stakers.
   *
   * The reward payout could be paged in case there are too many nominators backing the
   * `validator_stash`. This call will payout unpaid pages in an ascending order. To claim a
   * specific page, use `payout_stakers_by_page`.`
   *
   * If all pages are claimed, it returns an error `InvalidPage`.
   **/
  | { name: 'PayoutStakers'; params: { validatorStash: AccountId32; era: number } }
  /**
   * Rebond a portion of the stash scheduled to be unlocked.
   *
   * The dispatch origin must be signed by the controller.
   *
   * ## Complexity
   * - Time complexity: O(L), where L is unlocking chunks
   * - Bounded by `MaxUnlockingChunks`.
   **/
  | { name: 'Rebond'; params: { value: bigint } }
  /**
   * Remove all data structures concerning a staker/stash once it is at a state where it can
   * be considered `dust` in the staking system. The requirements are:
   *
   * 1. the `total_balance` of the stash is below existential deposit.
   * 2. or, the `ledger.total` of the stash is below existential deposit.
   *
   * The former can happen in cases like a slash; the latter when a fully unbonded account
   * is still receiving staking rewards in `RewardDestination::Staked`.
   *
   * It can be called by anyone, as long as `stash` meets the above requirements.
   *
   * Refunds the transaction fees upon successful execution.
   *
   * ## Parameters
   *
   * - `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more
   * details.
   **/
  | { name: 'ReapStash'; params: { stash: AccountId32; numSlashingSpans: number } }
  /**
   * Remove the given nominations from the calling validator.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * - `who`: A list of nominator stash accounts who are nominating this validator which
   * should no longer be nominating this validator.
   *
   * Note: Making this call only makes sense if you first set the validator preferences to
   * block any further nominations.
   **/
  | { name: 'Kick'; params: { who: Array<MultiAddress> } }
  /**
   * Update the various staking configurations .
   *
   * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
   * * `min_validator_bond`: The minimum active bond needed to be a validator.
   * * `max_nominator_count`: The max number of users who can be a nominator at once. When
   * set to `None`, no limit is enforced.
   * * `max_validator_count`: The max number of users who can be a validator at once. When
   * set to `None`, no limit is enforced.
   * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
   * should be filled in order for the `chill_other` transaction to work.
   * * `min_commission`: The minimum amount of commission that each validators must maintain.
   * This is checked only upon calling `validate`. Existing validators are not affected.
   *
   * RuntimeOrigin must be Root to call this function.
   *
   * NOTE: Existing nominators and validators will not be affected by this update.
   * to kick people under the new limits, `chill_other` should be called.
   **/
  | {
      name: 'SetStakingConfigs';
      params: {
        minNominatorBond: PalletStakingPalletConfigOp;
        minValidatorBond: PalletStakingPalletConfigOp;
        maxNominatorCount: PalletStakingPalletConfigOpU32;
        maxValidatorCount: PalletStakingPalletConfigOpU32;
        chillThreshold: PalletStakingPalletConfigOpPercent;
        minCommission: PalletStakingPalletConfigOpPerbill;
        maxStakedRewards: PalletStakingPalletConfigOpPercent;
      };
    }
  /**
   * Declare a `controller` to stop participating as either a validator or nominator.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_, but can be called by anyone.
   *
   * If the caller is the same as the controller being targeted, then no further checks are
   * enforced, and this function behaves just like `chill`.
   *
   * If the caller is different than the controller being targeted, the following conditions
   * must be met:
   *
   * * `controller` must belong to a nominator who has become non-decodable,
   *
   * Or:
   *
   * * A `ChillThreshold` must be set and checked which defines how close to the max
   * nominators or validators we must reach before users can start chilling one-another.
   * * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
   * how close we are to the threshold.
   * * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
   * if this is a person that should be chilled because they have not met the threshold
   * bond required.
   *
   * This can be helpful if bond requirements are updated, and we need to remove old users
   * who do not satisfy these requirements.
   **/
  | { name: 'ChillOther'; params: { stash: AccountId32 } }
  /**
   * Force a validator to have at least the minimum commission. This will not affect a
   * validator who already has a commission greater than or equal to the minimum. Any account
   * can call this.
   **/
  | { name: 'ForceApplyMinCommission'; params: { validatorStash: AccountId32 } }
  /**
   * Sets the minimum amount of commission that each validators must maintain.
   *
   * This call has lower privilege requirements than `set_staking_config` and can be called
   * by the `T::AdminOrigin`. Root can always call this.
   **/
  | { name: 'SetMinCommission'; params: { new: Perbill } }
  /**
   * Pay out a page of the stakers behind a validator for the given era and page.
   *
   * - `validator_stash` is the stash account of the validator.
   * - `era` may be any era between `[current_era - history_depth; current_era]`.
   * - `page` is the page index of nominators to pay out with value between 0 and
   * `num_nominators / T::MaxExposurePageSize`.
   *
   * The origin of this call must be _Signed_. Any account can call this function, even if
   * it is not one of the stakers.
   *
   * If a validator has more than [`Config::MaxExposurePageSize`] nominators backing
   * them, then the list of nominators is paged, with each page being capped at
   * [`Config::MaxExposurePageSize`.] If a validator has more than one page of nominators,
   * the call needs to be made for each page separately in order for all the nominators
   * backing a validator to receive the reward. The nominators are not sorted across pages
   * and so it should not be assumed the highest staker would be on the topmost page and vice
   * versa. If rewards are not claimed in [`Config::HistoryDepth`] eras, they are lost.
   **/
  | { name: 'PayoutStakersByPage'; params: { validatorStash: AccountId32; era: number; page: number } }
  /**
   * Migrates an account's `RewardDestination::Controller` to
   * `RewardDestination::Account(controller)`.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * This will waive the transaction fee if the `payee` is successfully migrated.
   **/
  | { name: 'UpdatePayee'; params: { controller: AccountId32 } }
  /**
   * Updates a batch of controller accounts to their corresponding stash account if they are
   * not the same. Ignores any controller accounts that do not exist, and does not operate if
   * the stash and controller are already the same.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * The dispatch origin must be `T::AdminOrigin`.
   **/
  | { name: 'DeprecateControllerBatch'; params: { controllers: Array<AccountId32> } };

export type PalletStakingPalletCallLike =
  /**
   * Take the origin account as a stash and lock up `value` of its balance. `controller` will
   * be the account that controls it.
   *
   * `value` must be more than the `minimum_balance` specified by `T::Currency`.
   *
   * The dispatch origin for this call must be _Signed_ by the stash account.
   *
   * Emits `Bonded`.
   * ## Complexity
   * - Independent of the arguments. Moderate complexity.
   * - O(1).
   * - Three extra DB entries.
   *
   * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
   * unless the `origin` falls below _existential deposit_ and gets removed as dust.
   **/
  | { name: 'Bond'; params: { value: bigint; payee: PalletStakingRewardDestination } }
  /**
   * Add some extra amount that have appeared in the stash `free_balance` into the balance up
   * for staking.
   *
   * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
   *
   * Use this if there are additional funds in your stash account that you wish to bond.
   * Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
   * any limitation on the amount that can be added.
   *
   * Emits `Bonded`.
   *
   * ## Complexity
   * - Independent of the arguments. Insignificant complexity.
   * - O(1).
   **/
  | { name: 'BondExtra'; params: { maxAdditional: bigint } }
  /**
   * Schedule a portion of the stash to be unlocked ready for transfer out after the bond
   * period ends. If this leaves an amount actively bonded less than
   * T::Currency::minimum_balance(), then it is increased to the full amount.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * Once the unlock period is done, you can call `withdraw_unbonded` to actually move
   * the funds out of management ready for transfer.
   *
   * No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
   * can co-exists at the same time. If there are no unlocking chunks slots available
   * [`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible).
   *
   * If a user encounters the `InsufficientBond` error when calling this extrinsic,
   * they should call `chill` first in order to free up their bonded funds.
   *
   * Emits `Unbonded`.
   *
   * See also [`Call::withdraw_unbonded`].
   **/
  | { name: 'Unbond'; params: { value: bigint } }
  /**
   * Remove any unlocked chunks from the `unlocking` queue from our management.
   *
   * This essentially frees up that balance to be used by the stash account to do whatever
   * it wants.
   *
   * The dispatch origin for this call must be _Signed_ by the controller.
   *
   * Emits `Withdrawn`.
   *
   * See also [`Call::unbond`].
   *
   * ## Parameters
   *
   * - `num_slashing_spans` indicates the number of metadata slashing spans to clear when
   * this call results in a complete removal of all the data related to the stash account.
   * In this case, the `num_slashing_spans` must be larger or equal to the number of
   * slashing spans associated with the stash account in the [`SlashingSpans`] storage type,
   * otherwise the call will fail. The call weight is directly propotional to
   * `num_slashing_spans`.
   *
   * ## Complexity
   * O(S) where S is the number of slashing spans to remove
   * NOTE: Weight annotation is the kill scenario, we refund otherwise.
   **/
  | { name: 'WithdrawUnbonded'; params: { numSlashingSpans: number } }
  /**
   * Declare the desire to validate for the origin controller.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   **/
  | { name: 'Validate'; params: { prefs: PalletStakingValidatorPrefs } }
  /**
   * Declare the desire to nominate `targets` for the origin controller.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * ## Complexity
   * - The transaction's complexity is proportional to the size of `targets` (N)
   * which is capped at CompactAssignments::LIMIT (T::MaxNominations).
   * - Both the reads and writes follow a similar pattern.
   **/
  | { name: 'Nominate'; params: { targets: Array<MultiAddressLike> } }
  /**
   * Declare no desire to either validate or nominate.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * ## Complexity
   * - Independent of the arguments. Insignificant complexity.
   * - Contains one read.
   * - Writes are limited to the `origin` account key.
   **/
  | { name: 'Chill' }
  /**
   * (Re-)set the payment target for a controller.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * ## Complexity
   * - O(1)
   * - Independent of the arguments. Insignificant complexity.
   * - Contains a limited number of reads.
   * - Writes are limited to the `origin` account key.
   * ---------
   **/
  | { name: 'SetPayee'; params: { payee: PalletStakingRewardDestination } }
  /**
   * (Re-)sets the controller of a stash to the stash itself. This function previously
   * accepted a `controller` argument to set the controller to an account other than the
   * stash itself. This functionality has now been removed, now only setting the controller
   * to the stash, if it is not already.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
   *
   * ## Complexity
   * O(1)
   * - Independent of the arguments. Insignificant complexity.
   * - Contains a limited number of reads.
   * - Writes are limited to the `origin` account key.
   **/
  | { name: 'SetController' }
  /**
   * Sets the ideal number of validators.
   *
   * The dispatch origin must be Root.
   *
   * ## Complexity
   * O(1)
   **/
  | { name: 'SetValidatorCount'; params: { new: number } }
  /**
   * Increments the ideal number of validators upto maximum of
   * `ElectionProviderBase::MaxWinners`.
   *
   * The dispatch origin must be Root.
   *
   * ## Complexity
   * Same as [`Self::set_validator_count`].
   **/
  | { name: 'IncreaseValidatorCount'; params: { additional: number } }
  /**
   * Scale up the ideal number of validators by a factor upto maximum of
   * `ElectionProviderBase::MaxWinners`.
   *
   * The dispatch origin must be Root.
   *
   * ## Complexity
   * Same as [`Self::set_validator_count`].
   **/
  | { name: 'ScaleValidatorCount'; params: { factor: Percent } }
  /**
   * Force there to be no new eras indefinitely.
   *
   * The dispatch origin must be Root.
   *
   * # Warning
   *
   * The election process starts multiple blocks before the end of the era.
   * Thus the election process may be ongoing when this is called. In this case the
   * election will continue until the next era is triggered.
   *
   * ## Complexity
   * - No arguments.
   * - Weight: O(1)
   **/
  | { name: 'ForceNoEras' }
  /**
   * Force there to be a new era at the end of the next session. After this, it will be
   * reset to normal (non-forced) behaviour.
   *
   * The dispatch origin must be Root.
   *
   * # Warning
   *
   * The election process starts multiple blocks before the end of the era.
   * If this is called just before a new era is triggered, the election process may not
   * have enough blocks to get a result.
   *
   * ## Complexity
   * - No arguments.
   * - Weight: O(1)
   **/
  | { name: 'ForceNewEra' }
  /**
   * Set the validators who cannot be slashed (if any).
   *
   * The dispatch origin must be Root.
   **/
  | { name: 'SetInvulnerables'; params: { invulnerables: Array<AccountId32Like> } }
  /**
   * Force a current staker to become completely unstaked, immediately.
   *
   * The dispatch origin must be Root.
   *
   * ## Parameters
   *
   * - `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more
   * details.
   **/
  | { name: 'ForceUnstake'; params: { stash: AccountId32Like; numSlashingSpans: number } }
  /**
   * Force there to be a new era at the end of sessions indefinitely.
   *
   * The dispatch origin must be Root.
   *
   * # Warning
   *
   * The election process starts multiple blocks before the end of the era.
   * If this is called just before a new era is triggered, the election process may not
   * have enough blocks to get a result.
   **/
  | { name: 'ForceNewEraAlways' }
  /**
   * Cancel enactment of a deferred slash.
   *
   * Can be called by the `T::AdminOrigin`.
   *
   * Parameters: era and indices of the slashes for that era to kill.
   **/
  | { name: 'CancelDeferredSlash'; params: { era: number; slashIndices: Array<number> } }
  /**
   * Pay out next page of the stakers behind a validator for the given era.
   *
   * - `validator_stash` is the stash account of the validator.
   * - `era` may be any era between `[current_era - history_depth; current_era]`.
   *
   * The origin of this call must be _Signed_. Any account can call this function, even if
   * it is not one of the stakers.
   *
   * The reward payout could be paged in case there are too many nominators backing the
   * `validator_stash`. This call will payout unpaid pages in an ascending order. To claim a
   * specific page, use `payout_stakers_by_page`.`
   *
   * If all pages are claimed, it returns an error `InvalidPage`.
   **/
  | { name: 'PayoutStakers'; params: { validatorStash: AccountId32Like; era: number } }
  /**
   * Rebond a portion of the stash scheduled to be unlocked.
   *
   * The dispatch origin must be signed by the controller.
   *
   * ## Complexity
   * - Time complexity: O(L), where L is unlocking chunks
   * - Bounded by `MaxUnlockingChunks`.
   **/
  | { name: 'Rebond'; params: { value: bigint } }
  /**
   * Remove all data structures concerning a staker/stash once it is at a state where it can
   * be considered `dust` in the staking system. The requirements are:
   *
   * 1. the `total_balance` of the stash is below existential deposit.
   * 2. or, the `ledger.total` of the stash is below existential deposit.
   *
   * The former can happen in cases like a slash; the latter when a fully unbonded account
   * is still receiving staking rewards in `RewardDestination::Staked`.
   *
   * It can be called by anyone, as long as `stash` meets the above requirements.
   *
   * Refunds the transaction fees upon successful execution.
   *
   * ## Parameters
   *
   * - `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more
   * details.
   **/
  | { name: 'ReapStash'; params: { stash: AccountId32Like; numSlashingSpans: number } }
  /**
   * Remove the given nominations from the calling validator.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * - `who`: A list of nominator stash accounts who are nominating this validator which
   * should no longer be nominating this validator.
   *
   * Note: Making this call only makes sense if you first set the validator preferences to
   * block any further nominations.
   **/
  | { name: 'Kick'; params: { who: Array<MultiAddressLike> } }
  /**
   * Update the various staking configurations .
   *
   * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
   * * `min_validator_bond`: The minimum active bond needed to be a validator.
   * * `max_nominator_count`: The max number of users who can be a nominator at once. When
   * set to `None`, no limit is enforced.
   * * `max_validator_count`: The max number of users who can be a validator at once. When
   * set to `None`, no limit is enforced.
   * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
   * should be filled in order for the `chill_other` transaction to work.
   * * `min_commission`: The minimum amount of commission that each validators must maintain.
   * This is checked only upon calling `validate`. Existing validators are not affected.
   *
   * RuntimeOrigin must be Root to call this function.
   *
   * NOTE: Existing nominators and validators will not be affected by this update.
   * to kick people under the new limits, `chill_other` should be called.
   **/
  | {
      name: 'SetStakingConfigs';
      params: {
        minNominatorBond: PalletStakingPalletConfigOp;
        minValidatorBond: PalletStakingPalletConfigOp;
        maxNominatorCount: PalletStakingPalletConfigOpU32;
        maxValidatorCount: PalletStakingPalletConfigOpU32;
        chillThreshold: PalletStakingPalletConfigOpPercent;
        minCommission: PalletStakingPalletConfigOpPerbill;
        maxStakedRewards: PalletStakingPalletConfigOpPercent;
      };
    }
  /**
   * Declare a `controller` to stop participating as either a validator or nominator.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_, but can be called by anyone.
   *
   * If the caller is the same as the controller being targeted, then no further checks are
   * enforced, and this function behaves just like `chill`.
   *
   * If the caller is different than the controller being targeted, the following conditions
   * must be met:
   *
   * * `controller` must belong to a nominator who has become non-decodable,
   *
   * Or:
   *
   * * A `ChillThreshold` must be set and checked which defines how close to the max
   * nominators or validators we must reach before users can start chilling one-another.
   * * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
   * how close we are to the threshold.
   * * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
   * if this is a person that should be chilled because they have not met the threshold
   * bond required.
   *
   * This can be helpful if bond requirements are updated, and we need to remove old users
   * who do not satisfy these requirements.
   **/
  | { name: 'ChillOther'; params: { stash: AccountId32Like } }
  /**
   * Force a validator to have at least the minimum commission. This will not affect a
   * validator who already has a commission greater than or equal to the minimum. Any account
   * can call this.
   **/
  | { name: 'ForceApplyMinCommission'; params: { validatorStash: AccountId32Like } }
  /**
   * Sets the minimum amount of commission that each validators must maintain.
   *
   * This call has lower privilege requirements than `set_staking_config` and can be called
   * by the `T::AdminOrigin`. Root can always call this.
   **/
  | { name: 'SetMinCommission'; params: { new: Perbill } }
  /**
   * Pay out a page of the stakers behind a validator for the given era and page.
   *
   * - `validator_stash` is the stash account of the validator.
   * - `era` may be any era between `[current_era - history_depth; current_era]`.
   * - `page` is the page index of nominators to pay out with value between 0 and
   * `num_nominators / T::MaxExposurePageSize`.
   *
   * The origin of this call must be _Signed_. Any account can call this function, even if
   * it is not one of the stakers.
   *
   * If a validator has more than [`Config::MaxExposurePageSize`] nominators backing
   * them, then the list of nominators is paged, with each page being capped at
   * [`Config::MaxExposurePageSize`.] If a validator has more than one page of nominators,
   * the call needs to be made for each page separately in order for all the nominators
   * backing a validator to receive the reward. The nominators are not sorted across pages
   * and so it should not be assumed the highest staker would be on the topmost page and vice
   * versa. If rewards are not claimed in [`Config::HistoryDepth`] eras, they are lost.
   **/
  | { name: 'PayoutStakersByPage'; params: { validatorStash: AccountId32Like; era: number; page: number } }
  /**
   * Migrates an account's `RewardDestination::Controller` to
   * `RewardDestination::Account(controller)`.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * This will waive the transaction fee if the `payee` is successfully migrated.
   **/
  | { name: 'UpdatePayee'; params: { controller: AccountId32Like } }
  /**
   * Updates a batch of controller accounts to their corresponding stash account if they are
   * not the same. Ignores any controller accounts that do not exist, and does not operate if
   * the stash and controller are already the same.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * The dispatch origin must be `T::AdminOrigin`.
   **/
  | { name: 'DeprecateControllerBatch'; params: { controllers: Array<AccountId32Like> } };

export type PalletStakingPalletConfigOp = { tag: 'Noop' } | { tag: 'Set'; value: bigint } | { tag: 'Remove' };

export type PalletStakingPalletConfigOpU32 = { tag: 'Noop' } | { tag: 'Set'; value: number } | { tag: 'Remove' };

export type PalletStakingPalletConfigOpPercent = { tag: 'Noop' } | { tag: 'Set'; value: Percent } | { tag: 'Remove' };

export type PalletStakingPalletConfigOpPerbill = { tag: 'Noop' } | { tag: 'Set'; value: Perbill } | { tag: 'Remove' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSessionCall =
  /**
   * Sets the session key(s) of the function caller to `keys`.
   * Allows an account to set its session key prior to becoming a validator.
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be signed.
   *
   * ## Complexity
   * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
   * fixed.
   **/
  | { name: 'SetKeys'; params: { keys: KitchensinkRuntimeSessionKeys; proof: Bytes } }
  /**
   * Removes any session key(s) of the function caller.
   *
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be Signed and the account must be either be
   * convertible to a validator ID using the chain's typical addressing system (this usually
   * means being a controller account) or directly convertible into a validator ID (which
   * usually means being a stash account).
   *
   * ## Complexity
   * - `O(1)` in number of key types. Actual cost depends on the number of length of
   * `T::Keys::key_ids()` which is fixed.
   **/
  | { name: 'PurgeKeys' };

export type PalletSessionCallLike =
  /**
   * Sets the session key(s) of the function caller to `keys`.
   * Allows an account to set its session key prior to becoming a validator.
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be signed.
   *
   * ## Complexity
   * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
   * fixed.
   **/
  | { name: 'SetKeys'; params: { keys: KitchensinkRuntimeSessionKeys; proof: BytesLike } }
  /**
   * Removes any session key(s) of the function caller.
   *
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be Signed and the account must be either be
   * convertible to a validator ID using the chain's typical addressing system (this usually
   * means being a controller account) or directly convertible into a validator ID (which
   * usually means being a stash account).
   *
   * ## Complexity
   * - `O(1)` in number of key types. Actual cost depends on the number of length of
   * `T::Keys::key_ids()` which is fixed.
   **/
  | { name: 'PurgeKeys' };

export type KitchensinkRuntimeSessionKeys = {
  grandpa: SpConsensusGrandpaAppPublic;
  babe: SpConsensusBabeAppPublic;
  imOnline: PalletImOnlineSr25519AppSr25519Public;
  authorityDiscovery: SpAuthorityDiscoveryAppPublic;
  mixnet: SpMixnetAppPublic;
  beefy: SpConsensusBeefyEcdsaCryptoPublic;
};

export type SpAuthorityDiscoveryAppPublic = SpCoreSr25519Public;

export type SpMixnetAppPublic = SpCoreSr25519Public;

export type SpConsensusBeefyEcdsaCryptoPublic = SpCoreEcdsaPublic;

export type SpCoreEcdsaPublic = FixedBytes<33>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletDemocracyCall =
  /**
   * Propose a sensitive action to be taken.
   *
   * The dispatch origin of this call must be _Signed_ and the sender must
   * have funds to cover the deposit.
   *
   * - `proposal_hash`: The hash of the proposal preimage.
   * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
   *
   * Emits `Proposed`.
   **/
  | { name: 'Propose'; params: { proposal: FrameSupportPreimagesBounded; value: bigint } }
  /**
   * Signals agreement with a particular proposal.
   *
   * The dispatch origin of this call must be _Signed_ and the sender
   * must have funds to cover the deposit, equal to the original deposit.
   *
   * - `proposal`: The index of the proposal to second.
   **/
  | { name: 'Second'; params: { proposal: number } }
  /**
   * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `ref_index`: The index of the referendum to vote for.
   * - `vote`: The vote configuration.
   **/
  | { name: 'Vote'; params: { refIndex: number; vote: PalletDemocracyVoteAccountVote } }
  /**
   * Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
   * referendum.
   *
   * The dispatch origin of this call must be `CancellationOrigin`.
   *
   * -`ref_index`: The index of the referendum to cancel.
   *
   * Weight: `O(1)`.
   **/
  | { name: 'EmergencyCancel'; params: { refIndex: number } }
  /**
   * Schedule a referendum to be tabled once it is legal to schedule an external
   * referendum.
   *
   * The dispatch origin of this call must be `ExternalOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   **/
  | { name: 'ExternalPropose'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
   * an external referendum.
   *
   * The dispatch of this call must be `ExternalMajorityOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   *
   * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
   * pre-scheduled `external_propose` call.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ExternalProposeMajority'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
   * schedule an external referendum.
   *
   * The dispatch of this call must be `ExternalDefaultOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   *
   * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
   * pre-scheduled `external_propose` call.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ExternalProposeDefault'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * Schedule the currently externally-proposed majority-carries referendum to be tabled
   * immediately. If there is no externally-proposed referendum currently, or if there is one
   * but it is not a majority-carries referendum then it fails.
   *
   * The dispatch of this call must be `FastTrackOrigin`.
   *
   * - `proposal_hash`: The hash of the current external proposal.
   * - `voting_period`: The period that is allowed for voting on this proposal. Increased to
   * Must be always greater than zero.
   * For `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`.
   * - `delay`: The number of block after voting has ended in approval and this should be
   * enacted. This doesn't have a minimum amount.
   *
   * Emits `Started`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'FastTrack'; params: { proposalHash: H256; votingPeriod: number; delay: number } }
  /**
   * Veto and blacklist the external proposal hash.
   *
   * The dispatch origin of this call must be `VetoOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
   *
   * Emits `Vetoed`.
   *
   * Weight: `O(V + log(V))` where V is number of `existing vetoers`
   **/
  | { name: 'VetoExternal'; params: { proposalHash: H256 } }
  /**
   * Remove a referendum.
   *
   * The dispatch origin of this call must be _Root_.
   *
   * - `ref_index`: The index of the referendum to cancel.
   *
   * # Weight: `O(1)`.
   **/
  | { name: 'CancelReferendum'; params: { refIndex: number } }
  /**
   * Delegate the voting power (with some given conviction) of the sending account.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   * - be delegating already; or
   * - have no voting activity (if there is, then it will need to be removed/consolidated
   * through `reap_vote` or `unvote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   * account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   * be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of referendums the voter delegating to has
   * voted on. Weight is charged as if maximum votes.
   **/
  | { name: 'Delegate'; params: { to: MultiAddress; conviction: PalletDemocracyConviction; balance: bigint } }
  /**
   * Undelegate the voting power of the sending account.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of referendums the voter delegating to has
   * voted on. Weight is charged as if maximum votes.
   **/
  | { name: 'Undelegate' }
  /**
   * Clears all public proposals.
   *
   * The dispatch origin of this call must be _Root_.
   *
   * Weight: `O(1)`.
   **/
  | { name: 'ClearPublicProposals' }
  /**
   * Unlock tokens that have an expired lock.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   **/
  | { name: 'Unlock'; params: { target: MultiAddress } }
  /**
   * Remove a vote for a referendum.
   *
   * If:
   * - the referendum was cancelled, or
   * - the referendum is ongoing, or
   * - the referendum has ended such that
   * - the vote of the account was in opposition to the result; or
   * - there was no conviction to the account's vote; or
   * - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the referendum has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for referendum `index`.
   *
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveVote'; params: { index: number } }
  /**
   * Remove a vote for a referendum.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the referendum was cancelled, because the voter lost the referendum or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for
   * referendum `index`.
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveOtherVote'; params: { target: MultiAddress; index: number } }
  /**
   * Permanently place a proposal into the blacklist. This prevents it from ever being
   * proposed again.
   *
   * If called on a queued public or external proposal, then this will result in it being
   * removed. If the `ref_index` supplied is an active referendum with the proposal hash,
   * then it will be cancelled.
   *
   * The dispatch origin of this call must be `BlacklistOrigin`.
   *
   * - `proposal_hash`: The proposal hash to blacklist permanently.
   * - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
   * cancelled.
   *
   * Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
   * reasonable value).
   **/
  | { name: 'Blacklist'; params: { proposalHash: H256; maybeRefIndex?: number | undefined } }
  /**
   * Remove a proposal.
   *
   * The dispatch origin of this call must be `CancelProposalOrigin`.
   *
   * - `prop_index`: The index of the proposal to cancel.
   *
   * Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
   **/
  | { name: 'CancelProposal'; params: { propIndex: number } }
  /**
   * Set or clear a metadata of a proposal or a referendum.
   *
   * Parameters:
   * - `origin`: Must correspond to the `MetadataOwner`.
   * - `ExternalOrigin` for an external proposal with the `SuperMajorityApprove`
   * threshold.
   * - `ExternalDefaultOrigin` for an external proposal with the `SuperMajorityAgainst`
   * threshold.
   * - `ExternalMajorityOrigin` for an external proposal with the `SimpleMajority`
   * threshold.
   * - `Signed` by a creator for a public proposal.
   * - `Signed` to clear a metadata for a finished referendum.
   * - `Root` to set a metadata for an ongoing referendum.
   * - `owner`: an identifier of a metadata owner.
   * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
   **/
  | { name: 'SetMetadata'; params: { owner: PalletDemocracyMetadataOwner; maybeHash?: H256 | undefined } };

export type PalletDemocracyCallLike =
  /**
   * Propose a sensitive action to be taken.
   *
   * The dispatch origin of this call must be _Signed_ and the sender must
   * have funds to cover the deposit.
   *
   * - `proposal_hash`: The hash of the proposal preimage.
   * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
   *
   * Emits `Proposed`.
   **/
  | { name: 'Propose'; params: { proposal: FrameSupportPreimagesBounded; value: bigint } }
  /**
   * Signals agreement with a particular proposal.
   *
   * The dispatch origin of this call must be _Signed_ and the sender
   * must have funds to cover the deposit, equal to the original deposit.
   *
   * - `proposal`: The index of the proposal to second.
   **/
  | { name: 'Second'; params: { proposal: number } }
  /**
   * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `ref_index`: The index of the referendum to vote for.
   * - `vote`: The vote configuration.
   **/
  | { name: 'Vote'; params: { refIndex: number; vote: PalletDemocracyVoteAccountVote } }
  /**
   * Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
   * referendum.
   *
   * The dispatch origin of this call must be `CancellationOrigin`.
   *
   * -`ref_index`: The index of the referendum to cancel.
   *
   * Weight: `O(1)`.
   **/
  | { name: 'EmergencyCancel'; params: { refIndex: number } }
  /**
   * Schedule a referendum to be tabled once it is legal to schedule an external
   * referendum.
   *
   * The dispatch origin of this call must be `ExternalOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   **/
  | { name: 'ExternalPropose'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
   * an external referendum.
   *
   * The dispatch of this call must be `ExternalMajorityOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   *
   * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
   * pre-scheduled `external_propose` call.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ExternalProposeMajority'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
   * schedule an external referendum.
   *
   * The dispatch of this call must be `ExternalDefaultOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   *
   * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
   * pre-scheduled `external_propose` call.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ExternalProposeDefault'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * Schedule the currently externally-proposed majority-carries referendum to be tabled
   * immediately. If there is no externally-proposed referendum currently, or if there is one
   * but it is not a majority-carries referendum then it fails.
   *
   * The dispatch of this call must be `FastTrackOrigin`.
   *
   * - `proposal_hash`: The hash of the current external proposal.
   * - `voting_period`: The period that is allowed for voting on this proposal. Increased to
   * Must be always greater than zero.
   * For `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`.
   * - `delay`: The number of block after voting has ended in approval and this should be
   * enacted. This doesn't have a minimum amount.
   *
   * Emits `Started`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'FastTrack'; params: { proposalHash: H256; votingPeriod: number; delay: number } }
  /**
   * Veto and blacklist the external proposal hash.
   *
   * The dispatch origin of this call must be `VetoOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
   *
   * Emits `Vetoed`.
   *
   * Weight: `O(V + log(V))` where V is number of `existing vetoers`
   **/
  | { name: 'VetoExternal'; params: { proposalHash: H256 } }
  /**
   * Remove a referendum.
   *
   * The dispatch origin of this call must be _Root_.
   *
   * - `ref_index`: The index of the referendum to cancel.
   *
   * # Weight: `O(1)`.
   **/
  | { name: 'CancelReferendum'; params: { refIndex: number } }
  /**
   * Delegate the voting power (with some given conviction) of the sending account.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   * - be delegating already; or
   * - have no voting activity (if there is, then it will need to be removed/consolidated
   * through `reap_vote` or `unvote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   * account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   * be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of referendums the voter delegating to has
   * voted on. Weight is charged as if maximum votes.
   **/
  | { name: 'Delegate'; params: { to: MultiAddressLike; conviction: PalletDemocracyConviction; balance: bigint } }
  /**
   * Undelegate the voting power of the sending account.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of referendums the voter delegating to has
   * voted on. Weight is charged as if maximum votes.
   **/
  | { name: 'Undelegate' }
  /**
   * Clears all public proposals.
   *
   * The dispatch origin of this call must be _Root_.
   *
   * Weight: `O(1)`.
   **/
  | { name: 'ClearPublicProposals' }
  /**
   * Unlock tokens that have an expired lock.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   **/
  | { name: 'Unlock'; params: { target: MultiAddressLike } }
  /**
   * Remove a vote for a referendum.
   *
   * If:
   * - the referendum was cancelled, or
   * - the referendum is ongoing, or
   * - the referendum has ended such that
   * - the vote of the account was in opposition to the result; or
   * - there was no conviction to the account's vote; or
   * - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the referendum has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for referendum `index`.
   *
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveVote'; params: { index: number } }
  /**
   * Remove a vote for a referendum.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the referendum was cancelled, because the voter lost the referendum or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for
   * referendum `index`.
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveOtherVote'; params: { target: MultiAddressLike; index: number } }
  /**
   * Permanently place a proposal into the blacklist. This prevents it from ever being
   * proposed again.
   *
   * If called on a queued public or external proposal, then this will result in it being
   * removed. If the `ref_index` supplied is an active referendum with the proposal hash,
   * then it will be cancelled.
   *
   * The dispatch origin of this call must be `BlacklistOrigin`.
   *
   * - `proposal_hash`: The proposal hash to blacklist permanently.
   * - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
   * cancelled.
   *
   * Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
   * reasonable value).
   **/
  | { name: 'Blacklist'; params: { proposalHash: H256; maybeRefIndex?: number | undefined } }
  /**
   * Remove a proposal.
   *
   * The dispatch origin of this call must be `CancelProposalOrigin`.
   *
   * - `prop_index`: The index of the proposal to cancel.
   *
   * Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
   **/
  | { name: 'CancelProposal'; params: { propIndex: number } }
  /**
   * Set or clear a metadata of a proposal or a referendum.
   *
   * Parameters:
   * - `origin`: Must correspond to the `MetadataOwner`.
   * - `ExternalOrigin` for an external proposal with the `SuperMajorityApprove`
   * threshold.
   * - `ExternalDefaultOrigin` for an external proposal with the `SuperMajorityAgainst`
   * threshold.
   * - `ExternalMajorityOrigin` for an external proposal with the `SimpleMajority`
   * threshold.
   * - `Signed` by a creator for a public proposal.
   * - `Signed` to clear a metadata for a finished referendum.
   * - `Root` to set a metadata for an ongoing referendum.
   * - `owner`: an identifier of a metadata owner.
   * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
   **/
  | { name: 'SetMetadata'; params: { owner: PalletDemocracyMetadataOwner; maybeHash?: H256 | undefined } };

export type PalletDemocracyConviction =
  | 'None'
  | 'Locked1x'
  | 'Locked2x'
  | 'Locked3x'
  | 'Locked4x'
  | 'Locked5x'
  | 'Locked6x';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCollectiveCall =
  /**
   * Set the collective's membership.
   *
   * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
   * - `prime`: The prime member whose vote sets the default.
   * - `old_count`: The upper bound for the previous number of members in storage. Used for
   * weight estimation.
   *
   * The dispatch of this call must be `SetMembersOrigin`.
   *
   * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
   * the weight estimations rely on it to estimate dispatchable weight.
   *
   * # WARNING:
   *
   * The `pallet-collective` can also be managed by logic outside of the pallet through the
   * implementation of the trait [`ChangeMembers`].
   * Any call to `set_members` must be careful that the member set doesn't get out of sync
   * with other logic managing the member set.
   *
   * ## Complexity:
   * - `O(MP + N)` where:
   * - `M` old-members-count (code- and governance-bounded)
   * - `N` new-members-count (code- and governance-bounded)
   * - `P` proposals-count (code-bounded)
   **/
  | {
      name: 'SetMembers';
      params: { newMembers: Array<AccountId32>; prime?: AccountId32 | undefined; oldCount: number };
    }
  /**
   * Dispatch a proposal from a member using the `Member` origin.
   *
   * Origin must be a member of the collective.
   *
   * ## Complexity:
   * - `O(B + M + P)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` members-count (code-bounded)
   * - `P` complexity of dispatching `proposal`
   **/
  | { name: 'Execute'; params: { proposal: KitchensinkRuntimeRuntimeCall; lengthBound: number } }
  /**
   * Add a new proposal to either be voted on or executed directly.
   *
   * Requires the sender to be member.
   *
   * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
   * or put up for voting.
   *
   * ## Complexity
   * - `O(B + M + P1)` or `O(B + M + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - branching is influenced by `threshold` where:
   * - `P1` is proposal execution complexity (`threshold < 2`)
   * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
   **/
  | { name: 'Propose'; params: { threshold: number; proposal: KitchensinkRuntimeRuntimeCall; lengthBound: number } }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * Requires the sender to be a member.
   *
   * Transaction fees will be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   * ## Complexity
   * - `O(M)` where `M` is members-count (code- and governance-bounded)
   **/
  | { name: 'Vote'; params: { proposal: H256; index: number; approve: boolean } }
  /**
   * Disapprove a proposal, close, and remove it from the system, regardless of its current
   * state.
   *
   * Must be called by the Root origin.
   *
   * Parameters:
   * * `proposal_hash`: The hash of the proposal that should be disapproved.
   *
   * ## Complexity
   * O(P) where P is the number of max proposals
   **/
  | { name: 'DisapproveProposal'; params: { proposalHash: H256 } }
  /**
   * Close a vote that is either approved, disapproved or whose voting period has ended.
   *
   * May be called by any signed account in order to finish voting and close the proposal.
   *
   * If called before the end of the voting period it will only close the vote if it is
   * has enough votes to be approved or disapproved.
   *
   * If called after the end of the voting period abstentions are counted as rejections
   * unless there is a prime member set and the prime member cast an approval.
   *
   * If the close operation completes successfully with disapproval, the transaction fee will
   * be waived. Otherwise execution of the approved operation will be charged to the caller.
   *
   * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
   * proposal.
   * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
   * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
   *
   * ## Complexity
   * - `O(B + M + P1 + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - `P1` is the complexity of `proposal` preimage.
   * - `P2` is proposal-count (code-bounded)
   **/
  | {
      name: 'Close';
      params: { proposalHash: H256; index: number; proposalWeightBound: SpWeightsWeightV2Weight; lengthBound: number };
    };

export type PalletCollectiveCallLike =
  /**
   * Set the collective's membership.
   *
   * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
   * - `prime`: The prime member whose vote sets the default.
   * - `old_count`: The upper bound for the previous number of members in storage. Used for
   * weight estimation.
   *
   * The dispatch of this call must be `SetMembersOrigin`.
   *
   * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
   * the weight estimations rely on it to estimate dispatchable weight.
   *
   * # WARNING:
   *
   * The `pallet-collective` can also be managed by logic outside of the pallet through the
   * implementation of the trait [`ChangeMembers`].
   * Any call to `set_members` must be careful that the member set doesn't get out of sync
   * with other logic managing the member set.
   *
   * ## Complexity:
   * - `O(MP + N)` where:
   * - `M` old-members-count (code- and governance-bounded)
   * - `N` new-members-count (code- and governance-bounded)
   * - `P` proposals-count (code-bounded)
   **/
  | {
      name: 'SetMembers';
      params: { newMembers: Array<AccountId32Like>; prime?: AccountId32Like | undefined; oldCount: number };
    }
  /**
   * Dispatch a proposal from a member using the `Member` origin.
   *
   * Origin must be a member of the collective.
   *
   * ## Complexity:
   * - `O(B + M + P)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` members-count (code-bounded)
   * - `P` complexity of dispatching `proposal`
   **/
  | { name: 'Execute'; params: { proposal: KitchensinkRuntimeRuntimeCallLike; lengthBound: number } }
  /**
   * Add a new proposal to either be voted on or executed directly.
   *
   * Requires the sender to be member.
   *
   * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
   * or put up for voting.
   *
   * ## Complexity
   * - `O(B + M + P1)` or `O(B + M + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - branching is influenced by `threshold` where:
   * - `P1` is proposal execution complexity (`threshold < 2`)
   * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
   **/
  | { name: 'Propose'; params: { threshold: number; proposal: KitchensinkRuntimeRuntimeCallLike; lengthBound: number } }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * Requires the sender to be a member.
   *
   * Transaction fees will be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   * ## Complexity
   * - `O(M)` where `M` is members-count (code- and governance-bounded)
   **/
  | { name: 'Vote'; params: { proposal: H256; index: number; approve: boolean } }
  /**
   * Disapprove a proposal, close, and remove it from the system, regardless of its current
   * state.
   *
   * Must be called by the Root origin.
   *
   * Parameters:
   * * `proposal_hash`: The hash of the proposal that should be disapproved.
   *
   * ## Complexity
   * O(P) where P is the number of max proposals
   **/
  | { name: 'DisapproveProposal'; params: { proposalHash: H256 } }
  /**
   * Close a vote that is either approved, disapproved or whose voting period has ended.
   *
   * May be called by any signed account in order to finish voting and close the proposal.
   *
   * If called before the end of the voting period it will only close the vote if it is
   * has enough votes to be approved or disapproved.
   *
   * If called after the end of the voting period abstentions are counted as rejections
   * unless there is a prime member set and the prime member cast an approval.
   *
   * If the close operation completes successfully with disapproval, the transaction fee will
   * be waived. Otherwise execution of the approved operation will be charged to the caller.
   *
   * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
   * proposal.
   * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
   * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
   *
   * ## Complexity
   * - `O(B + M + P1 + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - `P1` is the complexity of `proposal` preimage.
   * - `P2` is proposal-count (code-bounded)
   **/
  | {
      name: 'Close';
      params: { proposalHash: H256; index: number; proposalWeightBound: SpWeightsWeightV2Weight; lengthBound: number };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletElectionsPhragmenCall =
  /**
   * Vote for a set of candidates for the upcoming round of election. This can be called to
   * set the initial votes, or update already existing votes.
   *
   * Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
   * reserved. The deposit is based on the number of votes and can be updated over time.
   *
   * The `votes` should:
   * - not be empty.
   * - be less than the number of possible candidates. Note that all current members and
   * runners-up are also automatically candidates for the next round.
   *
   * If `value` is more than `who`'s free balance, then the maximum of the two is used.
   *
   * The dispatch origin of this call must be signed.
   *
   * ### Warning
   *
   * It is the responsibility of the caller to **NOT** place all of their balance into the
   * lock and keep some for further operations.
   **/
  | { name: 'Vote'; params: { votes: Array<AccountId32>; value: bigint } }
  /**
   * Remove `origin` as a voter.
   *
   * This removes the lock and returns the deposit.
   *
   * The dispatch origin of this call must be signed and be a voter.
   **/
  | { name: 'RemoveVoter' }
  /**
   * Submit oneself for candidacy. A fixed amount of deposit is recorded.
   *
   * All candidates are wiped at the end of the term. They either become a member/runner-up,
   * or leave the system while their deposit is slashed.
   *
   * The dispatch origin of this call must be signed.
   *
   * ### Warning
   *
   * Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
   * to get their deposit back. Losing the spot in an election will always lead to a slash.
   *
   * The number of current candidates must be provided as witness data.
   * ## Complexity
   * O(C + log(C)) where C is candidate_count.
   **/
  | { name: 'SubmitCandidacy'; params: { candidateCount: number } }
  /**
   * Renounce one's intention to be a candidate for the next election round. 3 potential
   * outcomes exist:
   *
   * - `origin` is a candidate and not elected in any set. In this case, the deposit is
   * unreserved, returned and origin is removed as a candidate.
   * - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
   * origin is removed as a runner-up.
   * - `origin` is a current member. In this case, the deposit is unreserved and origin is
   * removed as a member, consequently not being a candidate for the next round anymore.
   * Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they
   * are immediately used. If the prime is renouncing, then no prime will exist until the
   * next round.
   *
   * The dispatch origin of this call must be signed, and have one of the above roles.
   * The type of renouncing must be provided as witness data.
   *
   * ## Complexity
   * - Renouncing::Candidate(count): O(count + log(count))
   * - Renouncing::Member: O(1)
   * - Renouncing::RunnerUp: O(1)
   **/
  | { name: 'RenounceCandidacy'; params: { renouncing: PalletElectionsPhragmenRenouncing } }
  /**
   * Remove a particular member from the set. This is effective immediately and the bond of
   * the outgoing member is slashed.
   *
   * If a runner-up is available, then the best runner-up will be removed and replaces the
   * outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is
   * started, else, nothing happens.
   *
   * If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,
   * it is returned.
   *
   * The dispatch origin of this call must be root.
   *
   * Note that this does not affect the designated block number of the next election.
   *
   * ## Complexity
   * - Check details of remove_and_replace_member() and do_phragmen().
   **/
  | { name: 'RemoveMember'; params: { who: MultiAddress; slashBond: boolean; rerunElection: boolean } }
  /**
   * Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
   * deposit of the removed voters are returned.
   *
   * This is an root function to be used only for cleaning the state.
   *
   * The dispatch origin of this call must be root.
   *
   * ## Complexity
   * - Check is_defunct_voter() details.
   **/
  | { name: 'CleanDefunctVoters'; params: { numVoters: number; numDefunct: number } };

export type PalletElectionsPhragmenCallLike =
  /**
   * Vote for a set of candidates for the upcoming round of election. This can be called to
   * set the initial votes, or update already existing votes.
   *
   * Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
   * reserved. The deposit is based on the number of votes and can be updated over time.
   *
   * The `votes` should:
   * - not be empty.
   * - be less than the number of possible candidates. Note that all current members and
   * runners-up are also automatically candidates for the next round.
   *
   * If `value` is more than `who`'s free balance, then the maximum of the two is used.
   *
   * The dispatch origin of this call must be signed.
   *
   * ### Warning
   *
   * It is the responsibility of the caller to **NOT** place all of their balance into the
   * lock and keep some for further operations.
   **/
  | { name: 'Vote'; params: { votes: Array<AccountId32Like>; value: bigint } }
  /**
   * Remove `origin` as a voter.
   *
   * This removes the lock and returns the deposit.
   *
   * The dispatch origin of this call must be signed and be a voter.
   **/
  | { name: 'RemoveVoter' }
  /**
   * Submit oneself for candidacy. A fixed amount of deposit is recorded.
   *
   * All candidates are wiped at the end of the term. They either become a member/runner-up,
   * or leave the system while their deposit is slashed.
   *
   * The dispatch origin of this call must be signed.
   *
   * ### Warning
   *
   * Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
   * to get their deposit back. Losing the spot in an election will always lead to a slash.
   *
   * The number of current candidates must be provided as witness data.
   * ## Complexity
   * O(C + log(C)) where C is candidate_count.
   **/
  | { name: 'SubmitCandidacy'; params: { candidateCount: number } }
  /**
   * Renounce one's intention to be a candidate for the next election round. 3 potential
   * outcomes exist:
   *
   * - `origin` is a candidate and not elected in any set. In this case, the deposit is
   * unreserved, returned and origin is removed as a candidate.
   * - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
   * origin is removed as a runner-up.
   * - `origin` is a current member. In this case, the deposit is unreserved and origin is
   * removed as a member, consequently not being a candidate for the next round anymore.
   * Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they
   * are immediately used. If the prime is renouncing, then no prime will exist until the
   * next round.
   *
   * The dispatch origin of this call must be signed, and have one of the above roles.
   * The type of renouncing must be provided as witness data.
   *
   * ## Complexity
   * - Renouncing::Candidate(count): O(count + log(count))
   * - Renouncing::Member: O(1)
   * - Renouncing::RunnerUp: O(1)
   **/
  | { name: 'RenounceCandidacy'; params: { renouncing: PalletElectionsPhragmenRenouncing } }
  /**
   * Remove a particular member from the set. This is effective immediately and the bond of
   * the outgoing member is slashed.
   *
   * If a runner-up is available, then the best runner-up will be removed and replaces the
   * outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is
   * started, else, nothing happens.
   *
   * If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,
   * it is returned.
   *
   * The dispatch origin of this call must be root.
   *
   * Note that this does not affect the designated block number of the next election.
   *
   * ## Complexity
   * - Check details of remove_and_replace_member() and do_phragmen().
   **/
  | { name: 'RemoveMember'; params: { who: MultiAddressLike; slashBond: boolean; rerunElection: boolean } }
  /**
   * Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
   * deposit of the removed voters are returned.
   *
   * This is an root function to be used only for cleaning the state.
   *
   * The dispatch origin of this call must be root.
   *
   * ## Complexity
   * - Check is_defunct_voter() details.
   **/
  | { name: 'CleanDefunctVoters'; params: { numVoters: number; numDefunct: number } };

export type PalletElectionsPhragmenRenouncing =
  | { tag: 'Member' }
  | { tag: 'RunnerUp' }
  | { tag: 'Candidate'; value: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMembershipCall =
  /**
   * Add a member `who` to the set.
   *
   * May only be called from `T::AddOrigin`.
   **/
  | { name: 'AddMember'; params: { who: MultiAddress } }
  /**
   * Remove a member `who` from the set.
   *
   * May only be called from `T::RemoveOrigin`.
   **/
  | { name: 'RemoveMember'; params: { who: MultiAddress } }
  /**
   * Swap out one member `remove` for another `add`.
   *
   * May only be called from `T::SwapOrigin`.
   *
   * Prime membership is *not* passed from `remove` to `add`, if extant.
   **/
  | { name: 'SwapMember'; params: { remove: MultiAddress; add: MultiAddress } }
  /**
   * Change the membership to a new set, disregarding the existing membership. Be nice and
   * pass `members` pre-sorted.
   *
   * May only be called from `T::ResetOrigin`.
   **/
  | { name: 'ResetMembers'; params: { members: Array<AccountId32> } }
  /**
   * Swap out the sending member for some other key `new`.
   *
   * May only be called from `Signed` origin of a current member.
   *
   * Prime membership is passed from the origin account to `new`, if extant.
   **/
  | { name: 'ChangeKey'; params: { new: MultiAddress } }
  /**
   * Set the prime member. Must be a current member.
   *
   * May only be called from `T::PrimeOrigin`.
   **/
  | { name: 'SetPrime'; params: { who: MultiAddress } }
  /**
   * Remove the prime member if it exists.
   *
   * May only be called from `T::PrimeOrigin`.
   **/
  | { name: 'ClearPrime' };

export type PalletMembershipCallLike =
  /**
   * Add a member `who` to the set.
   *
   * May only be called from `T::AddOrigin`.
   **/
  | { name: 'AddMember'; params: { who: MultiAddressLike } }
  /**
   * Remove a member `who` from the set.
   *
   * May only be called from `T::RemoveOrigin`.
   **/
  | { name: 'RemoveMember'; params: { who: MultiAddressLike } }
  /**
   * Swap out one member `remove` for another `add`.
   *
   * May only be called from `T::SwapOrigin`.
   *
   * Prime membership is *not* passed from `remove` to `add`, if extant.
   **/
  | { name: 'SwapMember'; params: { remove: MultiAddressLike; add: MultiAddressLike } }
  /**
   * Change the membership to a new set, disregarding the existing membership. Be nice and
   * pass `members` pre-sorted.
   *
   * May only be called from `T::ResetOrigin`.
   **/
  | { name: 'ResetMembers'; params: { members: Array<AccountId32Like> } }
  /**
   * Swap out the sending member for some other key `new`.
   *
   * May only be called from `Signed` origin of a current member.
   *
   * Prime membership is passed from the origin account to `new`, if extant.
   **/
  | { name: 'ChangeKey'; params: { new: MultiAddressLike } }
  /**
   * Set the prime member. Must be a current member.
   *
   * May only be called from `T::PrimeOrigin`.
   **/
  | { name: 'SetPrime'; params: { who: MultiAddressLike } }
  /**
   * Remove the prime member if it exists.
   *
   * May only be called from `T::PrimeOrigin`.
   **/
  | { name: 'ClearPrime' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletGrandpaCall =
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   *
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Note that the current authority set of the GRANDPA finality gadget has stalled.
   *
   * This will trigger a forced authority set change at the beginning of the next session, to
   * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
   * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
   * The block production rate (which may be slowed down because of finality lagging) should
   * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
   * authority will start voting on top of `best_finalized_block_number` for new finalized
   * blocks. `best_finalized_block_number` should be the highest of the latest finalized
   * block of all validators of the new authority set.
   *
   * Only callable by root.
   **/
  | { name: 'NoteStalled'; params: { delay: number; bestFinalizedBlockNumber: number } };

export type PalletGrandpaCallLike =
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   *
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Note that the current authority set of the GRANDPA finality gadget has stalled.
   *
   * This will trigger a forced authority set change at the beginning of the next session, to
   * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
   * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
   * The block production rate (which may be slowed down because of finality lagging) should
   * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
   * authority will start voting on top of `best_finalized_block_number` for new finalized
   * blocks. `best_finalized_block_number` should be the highest of the latest finalized
   * block of all validators of the new authority set.
   *
   * Only callable by root.
   **/
  | { name: 'NoteStalled'; params: { delay: number; bestFinalizedBlockNumber: number } };

export type SpConsensusGrandpaEquivocationProof = { setId: bigint; equivocation: SpConsensusGrandpaEquivocation };

export type SpConsensusGrandpaEquivocation =
  | { tag: 'Prevote'; value: FinalityGrandpaEquivocation }
  | { tag: 'Precommit'; value: FinalityGrandpaEquivocationPrecommit };

export type FinalityGrandpaEquivocation = {
  roundNumber: bigint;
  identity: SpConsensusGrandpaAppPublic;
  first: [FinalityGrandpaPrevote, SpConsensusGrandpaAppSignature];
  second: [FinalityGrandpaPrevote, SpConsensusGrandpaAppSignature];
};

export type FinalityGrandpaPrevote = { targetHash: H256; targetNumber: number };

export type SpConsensusGrandpaAppSignature = SpCoreEd25519Signature;

export type SpCoreEd25519Signature = FixedBytes<64>;

export type FinalityGrandpaEquivocationPrecommit = {
  roundNumber: bigint;
  identity: SpConsensusGrandpaAppPublic;
  first: [FinalityGrandpaPrecommit, SpConsensusGrandpaAppSignature];
  second: [FinalityGrandpaPrecommit, SpConsensusGrandpaAppSignature];
};

export type FinalityGrandpaPrecommit = { targetHash: H256; targetNumber: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTreasuryCall =
  /**
   * Put forward a suggestion for spending.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   * A deposit proportional to the value is reserved and slashed if the proposal is rejected.
   * It is returned once the proposal is awarded.
   *
   * ### Complexity
   * - O(1)
   *
   * ## Events
   *
   * Emits [`Event::Proposed`] if successful.
   **/
  | { name: 'ProposeSpend'; params: { value: bigint; beneficiary: MultiAddress } }
  /**
   * Reject a proposed spend.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   * The original deposit will be slashed.
   *
   * ### Complexity
   * - O(1)
   *
   * ## Events
   *
   * Emits [`Event::Rejected`] if successful.
   **/
  | { name: 'RejectProposal'; params: { proposalId: number } }
  /**
   * Approve a proposal.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::ApproveOrigin`].
   *
   * ## Details
   *
   * At a later time, the proposal will be allocated to the beneficiary and the original
   * deposit will be returned.
   *
   * ### Complexity
   * - O(1).
   *
   * ## Events
   *
   * No events are emitted from this dispatch.
   **/
  | { name: 'ApproveProposal'; params: { proposalId: number } }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
   *
   * ### Details
   * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
   * beneficiary.
   *
   * ### Parameters
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The destination account for the transfer.
   *
   * ## Events
   *
   * Emits [`Event::SpendApproved`] if successful.
   **/
  | { name: 'SpendLocal'; params: { amount: bigint; beneficiary: MultiAddress } }
  /**
   * Force a previously approved proposal to be removed from the approval queue.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * The original deposit will no longer be returned.
   *
   * ### Parameters
   * - `proposal_id`: The index of a proposal
   *
   * ### Complexity
   * - O(A) where `A` is the number of approvals
   *
   * ### Errors
   * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
   * approval queue, i.e., the proposal has not been approved. This could also mean the
   * proposal does not exist altogether, thus there is no way it would have been approved
   * in the first place.
   **/
  | { name: 'RemoveApproval'; params: { proposalId: number } }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least
   * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
   * for assertion using the [`Config::BalanceConverter`].
   *
   * ## Details
   *
   * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
   * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
   * the [`Config::PayoutPeriod`].
   *
   * ### Parameters
   * - `asset_kind`: An indicator of the specific asset class to be spent.
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The beneficiary of the spend.
   * - `valid_from`: The block number from which the spend can be claimed. It can refer to
   * the past if the resulting spend has not yet expired according to the
   * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
   * approval.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendApproved`] if successful.
   **/
  | {
      name: 'Spend';
      params: { assetKind: number; amount: bigint; beneficiary: MultiAddress; validFrom?: number | undefined };
    }
  /**
   * Claim a spend.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   *
   * Spends must be claimed within some temporal bounds. A spend may be claimed within one
   * [`Config::PayoutPeriod`] from the `valid_from` block.
   * In case of a payout failure, the spend status must be updated with the `check_status`
   * dispatchable before retrying with the current function.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::Paid`] if successful.
   **/
  | { name: 'Payout'; params: { index: number } }
  /**
   * Check the status of the spend and remove it from the storage if processed.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   *
   * The status check is a prerequisite for retrying a failed payout.
   * If a spend has either succeeded or expired, it is removed from the storage by this
   * function. In such instances, transaction fees are refunded.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::PaymentFailed`] if the spend payout has failed.
   * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
   **/
  | { name: 'CheckStatus'; params: { index: number } }
  /**
   * Void previously approved spend.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * A spend void is only possible if the payout has not been attempted yet.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendVoided`] if successful.
   **/
  | { name: 'VoidSpend'; params: { index: number } };

export type PalletTreasuryCallLike =
  /**
   * Put forward a suggestion for spending.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   * A deposit proportional to the value is reserved and slashed if the proposal is rejected.
   * It is returned once the proposal is awarded.
   *
   * ### Complexity
   * - O(1)
   *
   * ## Events
   *
   * Emits [`Event::Proposed`] if successful.
   **/
  | { name: 'ProposeSpend'; params: { value: bigint; beneficiary: MultiAddressLike } }
  /**
   * Reject a proposed spend.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   * The original deposit will be slashed.
   *
   * ### Complexity
   * - O(1)
   *
   * ## Events
   *
   * Emits [`Event::Rejected`] if successful.
   **/
  | { name: 'RejectProposal'; params: { proposalId: number } }
  /**
   * Approve a proposal.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::ApproveOrigin`].
   *
   * ## Details
   *
   * At a later time, the proposal will be allocated to the beneficiary and the original
   * deposit will be returned.
   *
   * ### Complexity
   * - O(1).
   *
   * ## Events
   *
   * No events are emitted from this dispatch.
   **/
  | { name: 'ApproveProposal'; params: { proposalId: number } }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
   *
   * ### Details
   * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
   * beneficiary.
   *
   * ### Parameters
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The destination account for the transfer.
   *
   * ## Events
   *
   * Emits [`Event::SpendApproved`] if successful.
   **/
  | { name: 'SpendLocal'; params: { amount: bigint; beneficiary: MultiAddressLike } }
  /**
   * Force a previously approved proposal to be removed from the approval queue.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * The original deposit will no longer be returned.
   *
   * ### Parameters
   * - `proposal_id`: The index of a proposal
   *
   * ### Complexity
   * - O(A) where `A` is the number of approvals
   *
   * ### Errors
   * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
   * approval queue, i.e., the proposal has not been approved. This could also mean the
   * proposal does not exist altogether, thus there is no way it would have been approved
   * in the first place.
   **/
  | { name: 'RemoveApproval'; params: { proposalId: number } }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least
   * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
   * for assertion using the [`Config::BalanceConverter`].
   *
   * ## Details
   *
   * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
   * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
   * the [`Config::PayoutPeriod`].
   *
   * ### Parameters
   * - `asset_kind`: An indicator of the specific asset class to be spent.
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The beneficiary of the spend.
   * - `valid_from`: The block number from which the spend can be claimed. It can refer to
   * the past if the resulting spend has not yet expired according to the
   * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
   * approval.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendApproved`] if successful.
   **/
  | {
      name: 'Spend';
      params: { assetKind: number; amount: bigint; beneficiary: MultiAddressLike; validFrom?: number | undefined };
    }
  /**
   * Claim a spend.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   *
   * Spends must be claimed within some temporal bounds. A spend may be claimed within one
   * [`Config::PayoutPeriod`] from the `valid_from` block.
   * In case of a payout failure, the spend status must be updated with the `check_status`
   * dispatchable before retrying with the current function.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::Paid`] if successful.
   **/
  | { name: 'Payout'; params: { index: number } }
  /**
   * Check the status of the spend and remove it from the storage if processed.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   *
   * The status check is a prerequisite for retrying a failed payout.
   * If a spend has either succeeded or expired, it is removed from the storage by this
   * function. In such instances, transaction fees are refunded.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::PaymentFailed`] if the spend payout has failed.
   * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
   **/
  | { name: 'CheckStatus'; params: { index: number } }
  /**
   * Void previously approved spend.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * A spend void is only possible if the payout has not been attempted yet.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendVoided`] if successful.
   **/
  | { name: 'VoidSpend'; params: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAssetRateCall =
  /**
   * Initialize a conversion rate to native balance for the given asset.
   *
   * ## Complexity
   * - O(1)
   **/
  | { name: 'Create'; params: { assetKind: number; rate: FixedU128 } }
  /**
   * Update the conversion rate to native balance for the given asset.
   *
   * ## Complexity
   * - O(1)
   **/
  | { name: 'Update'; params: { assetKind: number; rate: FixedU128 } }
  /**
   * Remove an existing conversion rate to native balance for the given asset.
   *
   * ## Complexity
   * - O(1)
   **/
  | { name: 'Remove'; params: { assetKind: number } };

export type PalletAssetRateCallLike =
  /**
   * Initialize a conversion rate to native balance for the given asset.
   *
   * ## Complexity
   * - O(1)
   **/
  | { name: 'Create'; params: { assetKind: number; rate: FixedU128 } }
  /**
   * Update the conversion rate to native balance for the given asset.
   *
   * ## Complexity
   * - O(1)
   **/
  | { name: 'Update'; params: { assetKind: number; rate: FixedU128 } }
  /**
   * Remove an existing conversion rate to native balance for the given asset.
   *
   * ## Complexity
   * - O(1)
   **/
  | { name: 'Remove'; params: { assetKind: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletContractsCall =
  /**
   * Deprecated version if [`Self::call`] for use in an in-storage `Call`.
   **/
  | {
      name: 'CallOldWeight';
      params: {
        dest: MultiAddress;
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        data: Bytes;
      };
    }
  /**
   * Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`.
   **/
  | {
      name: 'InstantiateWithCodeOldWeight';
      params: {
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        code: Bytes;
        data: Bytes;
        salt: Bytes;
      };
    }
  /**
   * Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`.
   **/
  | {
      name: 'InstantiateOldWeight';
      params: {
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        codeHash: H256;
        data: Bytes;
        salt: Bytes;
      };
    }
  /**
   * Upload new `code` without instantiating a contract from it.
   *
   * If the code does not already exist a deposit is reserved from the caller
   * and unreserved only when [`Self::remove_code`] is called. The size of the reserve
   * depends on the size of the supplied `code`.
   *
   * If the code already exists in storage it will still return `Ok` and upgrades
   * the in storage version to the current
   * [`InstructionWeights::version`](InstructionWeights).
   *
   * - `determinism`: If this is set to any other value but [`Determinism::Enforced`] then
   * the only way to use this code is to delegate call into it from an offchain execution.
   * Set to [`Determinism::Enforced`] if in doubt.
   *
   * # Note
   *
   * Anyone can instantiate a contract from any uploaded code and thus prevent its removal.
   * To avoid this situation a constructor could employ access control so that it can
   * only be instantiated by permissioned entities. The same is true when uploading
   * through [`Self::instantiate_with_code`].
   *
   * Use [`Determinism::Relaxed`] exclusively for non-deterministic code. If the uploaded
   * code is deterministic, specifying [`Determinism::Relaxed`] will be disregarded and
   * result in higher gas costs.
   **/
  | {
      name: 'UploadCode';
      params: { code: Bytes; storageDepositLimit?: bigint | undefined; determinism: PalletContractsWasmDeterminism };
    }
  /**
   * Remove the code stored under `code_hash` and refund the deposit to its owner.
   *
   * A code can only be removed by its original uploader (its owner) and only if it is
   * not used by any contract.
   **/
  | { name: 'RemoveCode'; params: { codeHash: H256 } }
  /**
   * Privileged function that changes the code of an existing contract.
   *
   * This takes care of updating refcounts and all other necessary operations. Returns
   * an error if either the `code_hash` or `dest` do not exist.
   *
   * # Note
   *
   * This does **not** change the address of the contract in question. This means
   * that the contract address is no longer derived from its code hash after calling
   * this dispatchable.
   **/
  | { name: 'SetCode'; params: { dest: MultiAddress; codeHash: H256 } }
  /**
   * Makes a call to an account, optionally transferring some balance.
   *
   * # Parameters
   *
   * * `dest`: Address of the contract to call.
   * * `value`: The balance to transfer from the `origin` to `dest`.
   * * `gas_limit`: The gas limit enforced when executing the constructor.
   * * `storage_deposit_limit`: The maximum amount of balance that can be charged from the
   * caller to pay for the storage consumed.
   * * `data`: The input data to pass to the contract.
   *
   * * If the account is a smart-contract account, the associated code will be
   * executed and any value will be transferred.
   * * If the account is a regular account, any value will be transferred.
   * * If no account exists and the call value is not less than `existential_deposit`,
   * a regular account will be created and any value will be transferred.
   **/
  | {
      name: 'Call';
      params: {
        dest: MultiAddress;
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        data: Bytes;
      };
    }
  /**
   * Instantiates a new contract from the supplied `code` optionally transferring
   * some balance.
   *
   * This dispatchable has the same effect as calling [`Self::upload_code`] +
   * [`Self::instantiate`]. Bundling them together provides efficiency gains. Please
   * also check the documentation of [`Self::upload_code`].
   *
   * # Parameters
   *
   * * `value`: The balance to transfer from the `origin` to the newly created contract.
   * * `gas_limit`: The gas limit enforced when executing the constructor.
   * * `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved
   * from the caller to pay for the storage consumed.
   * * `code`: The contract code to deploy in raw bytes.
   * * `data`: The input data to pass to the contract constructor.
   * * `salt`: Used for the address derivation. See [`Pallet::contract_address`].
   *
   * Instantiation is executed as follows:
   *
   * - The supplied `code` is deployed, and a `code_hash` is created for that code.
   * - If the `code_hash` already exists on the chain the underlying `code` will be shared.
   * - The destination address is computed based on the sender, code_hash and the salt.
   * - The smart-contract account is created at the computed address.
   * - The `value` is transferred to the new account.
   * - The `deploy` function is executed in the context of the newly-created account.
   **/
  | {
      name: 'InstantiateWithCode';
      params: {
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        code: Bytes;
        data: Bytes;
        salt: Bytes;
      };
    }
  /**
   * Instantiates a contract from a previously deployed wasm binary.
   *
   * This function is identical to [`Self::instantiate_with_code`] but without the
   * code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary
   * must be supplied.
   **/
  | {
      name: 'Instantiate';
      params: {
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        codeHash: H256;
        data: Bytes;
        salt: Bytes;
      };
    }
  /**
   * When a migration is in progress, this dispatchable can be used to run migration steps.
   * Calls that contribute to advancing the migration have their fees waived, as it's helpful
   * for the chain. Note that while the migration is in progress, the pallet will also
   * leverage the `on_idle` hooks to run migration steps.
   **/
  | { name: 'Migrate'; params: { weightLimit: SpWeightsWeightV2Weight } };

export type PalletContractsCallLike =
  /**
   * Deprecated version if [`Self::call`] for use in an in-storage `Call`.
   **/
  | {
      name: 'CallOldWeight';
      params: {
        dest: MultiAddressLike;
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        data: BytesLike;
      };
    }
  /**
   * Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`.
   **/
  | {
      name: 'InstantiateWithCodeOldWeight';
      params: {
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        code: BytesLike;
        data: BytesLike;
        salt: BytesLike;
      };
    }
  /**
   * Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`.
   **/
  | {
      name: 'InstantiateOldWeight';
      params: {
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        codeHash: H256;
        data: BytesLike;
        salt: BytesLike;
      };
    }
  /**
   * Upload new `code` without instantiating a contract from it.
   *
   * If the code does not already exist a deposit is reserved from the caller
   * and unreserved only when [`Self::remove_code`] is called. The size of the reserve
   * depends on the size of the supplied `code`.
   *
   * If the code already exists in storage it will still return `Ok` and upgrades
   * the in storage version to the current
   * [`InstructionWeights::version`](InstructionWeights).
   *
   * - `determinism`: If this is set to any other value but [`Determinism::Enforced`] then
   * the only way to use this code is to delegate call into it from an offchain execution.
   * Set to [`Determinism::Enforced`] if in doubt.
   *
   * # Note
   *
   * Anyone can instantiate a contract from any uploaded code and thus prevent its removal.
   * To avoid this situation a constructor could employ access control so that it can
   * only be instantiated by permissioned entities. The same is true when uploading
   * through [`Self::instantiate_with_code`].
   *
   * Use [`Determinism::Relaxed`] exclusively for non-deterministic code. If the uploaded
   * code is deterministic, specifying [`Determinism::Relaxed`] will be disregarded and
   * result in higher gas costs.
   **/
  | {
      name: 'UploadCode';
      params: {
        code: BytesLike;
        storageDepositLimit?: bigint | undefined;
        determinism: PalletContractsWasmDeterminism;
      };
    }
  /**
   * Remove the code stored under `code_hash` and refund the deposit to its owner.
   *
   * A code can only be removed by its original uploader (its owner) and only if it is
   * not used by any contract.
   **/
  | { name: 'RemoveCode'; params: { codeHash: H256 } }
  /**
   * Privileged function that changes the code of an existing contract.
   *
   * This takes care of updating refcounts and all other necessary operations. Returns
   * an error if either the `code_hash` or `dest` do not exist.
   *
   * # Note
   *
   * This does **not** change the address of the contract in question. This means
   * that the contract address is no longer derived from its code hash after calling
   * this dispatchable.
   **/
  | { name: 'SetCode'; params: { dest: MultiAddressLike; codeHash: H256 } }
  /**
   * Makes a call to an account, optionally transferring some balance.
   *
   * # Parameters
   *
   * * `dest`: Address of the contract to call.
   * * `value`: The balance to transfer from the `origin` to `dest`.
   * * `gas_limit`: The gas limit enforced when executing the constructor.
   * * `storage_deposit_limit`: The maximum amount of balance that can be charged from the
   * caller to pay for the storage consumed.
   * * `data`: The input data to pass to the contract.
   *
   * * If the account is a smart-contract account, the associated code will be
   * executed and any value will be transferred.
   * * If the account is a regular account, any value will be transferred.
   * * If no account exists and the call value is not less than `existential_deposit`,
   * a regular account will be created and any value will be transferred.
   **/
  | {
      name: 'Call';
      params: {
        dest: MultiAddressLike;
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        data: BytesLike;
      };
    }
  /**
   * Instantiates a new contract from the supplied `code` optionally transferring
   * some balance.
   *
   * This dispatchable has the same effect as calling [`Self::upload_code`] +
   * [`Self::instantiate`]. Bundling them together provides efficiency gains. Please
   * also check the documentation of [`Self::upload_code`].
   *
   * # Parameters
   *
   * * `value`: The balance to transfer from the `origin` to the newly created contract.
   * * `gas_limit`: The gas limit enforced when executing the constructor.
   * * `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved
   * from the caller to pay for the storage consumed.
   * * `code`: The contract code to deploy in raw bytes.
   * * `data`: The input data to pass to the contract constructor.
   * * `salt`: Used for the address derivation. See [`Pallet::contract_address`].
   *
   * Instantiation is executed as follows:
   *
   * - The supplied `code` is deployed, and a `code_hash` is created for that code.
   * - If the `code_hash` already exists on the chain the underlying `code` will be shared.
   * - The destination address is computed based on the sender, code_hash and the salt.
   * - The smart-contract account is created at the computed address.
   * - The `value` is transferred to the new account.
   * - The `deploy` function is executed in the context of the newly-created account.
   **/
  | {
      name: 'InstantiateWithCode';
      params: {
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        code: BytesLike;
        data: BytesLike;
        salt: BytesLike;
      };
    }
  /**
   * Instantiates a contract from a previously deployed wasm binary.
   *
   * This function is identical to [`Self::instantiate_with_code`] but without the
   * code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary
   * must be supplied.
   **/
  | {
      name: 'Instantiate';
      params: {
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        codeHash: H256;
        data: BytesLike;
        salt: BytesLike;
      };
    }
  /**
   * When a migration is in progress, this dispatchable can be used to run migration steps.
   * Calls that contribute to advancing the migration have their fees waived, as it's helpful
   * for the chain. Note that while the migration is in progress, the pallet will also
   * leverage the `on_idle` hooks to run migration steps.
   **/
  | { name: 'Migrate'; params: { weightLimit: SpWeightsWeightV2Weight } };

export type PalletContractsWasmDeterminism = 'Enforced' | 'Relaxed';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSudoCall =
  /**
   * Authenticates the sudo key and dispatches a function call with `Root` origin.
   **/
  | { name: 'Sudo'; params: { call: KitchensinkRuntimeRuntimeCall } }
  /**
   * Authenticates the sudo key and dispatches a function call with `Root` origin.
   * This function does not check the weight of the call, and instead allows the
   * Sudo user to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'SudoUncheckedWeight'; params: { call: KitchensinkRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight } }
  /**
   * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
   * key.
   **/
  | { name: 'SetKey'; params: { new: MultiAddress } }
  /**
   * Authenticates the sudo key and dispatches a function call with `Signed` origin from
   * a given account.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'SudoAs'; params: { who: MultiAddress; call: KitchensinkRuntimeRuntimeCall } }
  /**
   * Permanently removes the sudo key.
   *
   * **This cannot be un-done.**
   **/
  | { name: 'RemoveKey' };

export type PalletSudoCallLike =
  /**
   * Authenticates the sudo key and dispatches a function call with `Root` origin.
   **/
  | { name: 'Sudo'; params: { call: KitchensinkRuntimeRuntimeCallLike } }
  /**
   * Authenticates the sudo key and dispatches a function call with `Root` origin.
   * This function does not check the weight of the call, and instead allows the
   * Sudo user to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | {
      name: 'SudoUncheckedWeight';
      params: { call: KitchensinkRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight };
    }
  /**
   * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
   * key.
   **/
  | { name: 'SetKey'; params: { new: MultiAddressLike } }
  /**
   * Authenticates the sudo key and dispatches a function call with `Signed` origin from
   * a given account.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'SudoAs'; params: { who: MultiAddressLike; call: KitchensinkRuntimeRuntimeCallLike } }
  /**
   * Permanently removes the sudo key.
   *
   * **This cannot be un-done.**
   **/
  | { name: 'RemoveKey' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletImOnlineCall =
  /**
   * ## Complexity:
   * - `O(K)` where K is length of `Keys` (heartbeat.validators_len)
   * - `O(K)`: decoding of length `K`
   **/
  {
    name: 'Heartbeat';
    params: { heartbeat: PalletImOnlineHeartbeat; signature: PalletImOnlineSr25519AppSr25519Signature };
  };

export type PalletImOnlineCallLike =
  /**
   * ## Complexity:
   * - `O(K)` where K is length of `Keys` (heartbeat.validators_len)
   * - `O(K)`: decoding of length `K`
   **/
  {
    name: 'Heartbeat';
    params: { heartbeat: PalletImOnlineHeartbeat; signature: PalletImOnlineSr25519AppSr25519Signature };
  };

export type PalletImOnlineHeartbeat = {
  blockNumber: number;
  sessionIndex: number;
  authorityIndex: number;
  validatorsLen: number;
};

export type PalletImOnlineSr25519AppSr25519Signature = SpCoreSr25519Signature;

export type SpCoreSr25519Signature = FixedBytes<64>;

/**
 * Identity pallet declaration.
 **/
export type PalletIdentityCall =
  /**
   * Add a registrar to the system.
   *
   * The dispatch origin for this call must be `T::RegistrarOrigin`.
   *
   * - `account`: the account of the registrar.
   *
   * Emits `RegistrarAdded` if successful.
   **/
  | { name: 'AddRegistrar'; params: { account: MultiAddress } }
  /**
   * Set an account's identity information and reserve the appropriate deposit.
   *
   * If the account already has identity information, the deposit is taken as part payment
   * for the new deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `info`: The identity information.
   *
   * Emits `IdentitySet` if successful.
   **/
  | { name: 'SetIdentity'; params: { info: PalletIdentityLegacyIdentityInfo } }
  /**
   * Set the sub-accounts of the sender.
   *
   * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
   * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * - `subs`: The identity's (new) sub-accounts.
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId32, Data]> } }
  /**
   * Clear an account's identity info and all sub-accounts and return all deposits.
   *
   * Payment: All reserved balances on the account are returned.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * Emits `IdentityCleared` if successful.
   **/
  | { name: 'ClearIdentity' }
  /**
   * Request a judgement from a registrar.
   *
   * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
   * given.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is requested.
   * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
   *
   * ```nocompile
   * Self::registrars().get(reg_index).unwrap().fee
   * ```
   *
   * Emits `JudgementRequested` if successful.
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * Cancel a previous request.
   *
   * Payment: A previously reserved deposit is returned on success.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is no longer requested.
   *
   * Emits `JudgementUnrequested` if successful.
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * Set the fee required for a judgement to be requested from a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fee`: the new fee.
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * Change the account associated with a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `new`: the new account ID.
   **/
  | { name: 'SetAccountId'; params: { index: number; new: MultiAddress } }
  /**
   * Set the field information for a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fields`: the fields that the registrar concerns themselves with.
   **/
  | { name: 'SetFields'; params: { index: number; fields: bigint } }
  /**
   * Provide a judgement for an account's identity.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `reg_index`.
   *
   * - `reg_index`: the index of the registrar whose judgement is being made.
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
   * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
   * provided.
   *
   * Note: Judgements do not apply to a username.
   *
   * Emits `JudgementGiven` if successful.
   **/
  | {
      name: 'ProvideJudgement';
      params: { regIndex: number; target: MultiAddress; judgement: PalletIdentityJudgement; identity: H256 };
    }
  /**
   * Remove an account's identity and sub-account information and slash the deposits.
   *
   * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
   * `Slash`. Verification request deposits are not returned; they should be cancelled
   * manually using `cancel_request`.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   *
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   *
   * Emits `IdentityKilled` if successful.
   **/
  | { name: 'KillIdentity'; params: { target: MultiAddress } }
  /**
   * Add the given account to the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'AddSub'; params: { sub: MultiAddress; data: Data } }
  /**
   * Alter the associated name of the given sub-account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RenameSub'; params: { sub: MultiAddress; data: Data } }
  /**
   * Remove the given account from the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RemoveSub'; params: { sub: MultiAddress } }
  /**
   * Remove the sender as a sub-account.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender (*not* the original depositor).
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * super-identity.
   *
   * NOTE: This should not normally be used, but is provided in the case that the non-
   * controller of an account is maliciously registered as a sub-account.
   **/
  | { name: 'QuitSub' }
  /**
   * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
   *
   * The authority can grant up to `allocation` usernames. To top up their allocation, they
   * should just issue (or request via governance) a new `add_username_authority` call.
   **/
  | { name: 'AddUsernameAuthority'; params: { authority: MultiAddress; suffix: Bytes; allocation: number } }
  /**
   * Remove `authority` from the username authorities.
   **/
  | { name: 'RemoveUsernameAuthority'; params: { authority: MultiAddress } }
  /**
   * Set the username for `who`. Must be called by a username authority.
   *
   * The authority must have an `allocation`. Users can either pre-sign their usernames or
   * accept them later.
   *
   * Usernames must:
   * - Only contain lowercase ASCII characters or digits.
   * - When combined with the suffix of the issuing authority be _less than_ the
   * `MaxUsernameLength`.
   **/
  | {
      name: 'SetUsernameFor';
      params: { who: MultiAddress; username: Bytes; signature?: SpRuntimeMultiSignature | undefined };
    }
  /**
   * Accept a given username that an `authority` granted. The call must include the full
   * username, as in `username.suffix`.
   **/
  | { name: 'AcceptUsername'; params: { username: Bytes } }
  /**
   * Remove an expired username approval. The username was approved by an authority but never
   * accepted by the user and must now be beyond its expiration. The call must include the
   * full username, as in `username.suffix`.
   **/
  | { name: 'RemoveExpiredApproval'; params: { username: Bytes } }
  /**
   * Set a given username as the primary. The username should include the suffix.
   **/
  | { name: 'SetPrimaryUsername'; params: { username: Bytes } }
  /**
   * Remove a username that corresponds to an account with no identity. Exists when a user
   * gets a username but then calls `clear_identity`.
   **/
  | { name: 'RemoveDanglingUsername'; params: { username: Bytes } };

export type PalletIdentityCallLike =
  /**
   * Add a registrar to the system.
   *
   * The dispatch origin for this call must be `T::RegistrarOrigin`.
   *
   * - `account`: the account of the registrar.
   *
   * Emits `RegistrarAdded` if successful.
   **/
  | { name: 'AddRegistrar'; params: { account: MultiAddressLike } }
  /**
   * Set an account's identity information and reserve the appropriate deposit.
   *
   * If the account already has identity information, the deposit is taken as part payment
   * for the new deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `info`: The identity information.
   *
   * Emits `IdentitySet` if successful.
   **/
  | { name: 'SetIdentity'; params: { info: PalletIdentityLegacyIdentityInfo } }
  /**
   * Set the sub-accounts of the sender.
   *
   * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
   * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * - `subs`: The identity's (new) sub-accounts.
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId32Like, Data]> } }
  /**
   * Clear an account's identity info and all sub-accounts and return all deposits.
   *
   * Payment: All reserved balances on the account are returned.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * Emits `IdentityCleared` if successful.
   **/
  | { name: 'ClearIdentity' }
  /**
   * Request a judgement from a registrar.
   *
   * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
   * given.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is requested.
   * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
   *
   * ```nocompile
   * Self::registrars().get(reg_index).unwrap().fee
   * ```
   *
   * Emits `JudgementRequested` if successful.
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * Cancel a previous request.
   *
   * Payment: A previously reserved deposit is returned on success.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is no longer requested.
   *
   * Emits `JudgementUnrequested` if successful.
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * Set the fee required for a judgement to be requested from a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fee`: the new fee.
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * Change the account associated with a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `new`: the new account ID.
   **/
  | { name: 'SetAccountId'; params: { index: number; new: MultiAddressLike } }
  /**
   * Set the field information for a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fields`: the fields that the registrar concerns themselves with.
   **/
  | { name: 'SetFields'; params: { index: number; fields: bigint } }
  /**
   * Provide a judgement for an account's identity.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `reg_index`.
   *
   * - `reg_index`: the index of the registrar whose judgement is being made.
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
   * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
   * provided.
   *
   * Note: Judgements do not apply to a username.
   *
   * Emits `JudgementGiven` if successful.
   **/
  | {
      name: 'ProvideJudgement';
      params: { regIndex: number; target: MultiAddressLike; judgement: PalletIdentityJudgement; identity: H256 };
    }
  /**
   * Remove an account's identity and sub-account information and slash the deposits.
   *
   * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
   * `Slash`. Verification request deposits are not returned; they should be cancelled
   * manually using `cancel_request`.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   *
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   *
   * Emits `IdentityKilled` if successful.
   **/
  | { name: 'KillIdentity'; params: { target: MultiAddressLike } }
  /**
   * Add the given account to the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'AddSub'; params: { sub: MultiAddressLike; data: Data } }
  /**
   * Alter the associated name of the given sub-account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RenameSub'; params: { sub: MultiAddressLike; data: Data } }
  /**
   * Remove the given account from the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RemoveSub'; params: { sub: MultiAddressLike } }
  /**
   * Remove the sender as a sub-account.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender (*not* the original depositor).
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * super-identity.
   *
   * NOTE: This should not normally be used, but is provided in the case that the non-
   * controller of an account is maliciously registered as a sub-account.
   **/
  | { name: 'QuitSub' }
  /**
   * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
   *
   * The authority can grant up to `allocation` usernames. To top up their allocation, they
   * should just issue (or request via governance) a new `add_username_authority` call.
   **/
  | { name: 'AddUsernameAuthority'; params: { authority: MultiAddressLike; suffix: BytesLike; allocation: number } }
  /**
   * Remove `authority` from the username authorities.
   **/
  | { name: 'RemoveUsernameAuthority'; params: { authority: MultiAddressLike } }
  /**
   * Set the username for `who`. Must be called by a username authority.
   *
   * The authority must have an `allocation`. Users can either pre-sign their usernames or
   * accept them later.
   *
   * Usernames must:
   * - Only contain lowercase ASCII characters or digits.
   * - When combined with the suffix of the issuing authority be _less than_ the
   * `MaxUsernameLength`.
   **/
  | {
      name: 'SetUsernameFor';
      params: { who: MultiAddressLike; username: BytesLike; signature?: SpRuntimeMultiSignature | undefined };
    }
  /**
   * Accept a given username that an `authority` granted. The call must include the full
   * username, as in `username.suffix`.
   **/
  | { name: 'AcceptUsername'; params: { username: BytesLike } }
  /**
   * Remove an expired username approval. The username was approved by an authority but never
   * accepted by the user and must now be beyond its expiration. The call must include the
   * full username, as in `username.suffix`.
   **/
  | { name: 'RemoveExpiredApproval'; params: { username: BytesLike } }
  /**
   * Set a given username as the primary. The username should include the suffix.
   **/
  | { name: 'SetPrimaryUsername'; params: { username: BytesLike } }
  /**
   * Remove a username that corresponds to an account with no identity. Exists when a user
   * gets a username but then calls `clear_identity`.
   **/
  | { name: 'RemoveDanglingUsername'; params: { username: BytesLike } };

export type PalletIdentityLegacyIdentityInfo = {
  additional: Array<[Data, Data]>;
  display: Data;
  legal: Data;
  web: Data;
  riot: Data;
  email: Data;
  pgpFingerprint?: FixedBytes<20> | undefined;
  image: Data;
  twitter: Data;
};

export type PalletIdentityJudgement =
  | { tag: 'Unknown' }
  | { tag: 'FeePaid'; value: bigint }
  | { tag: 'Reasonable' }
  | { tag: 'KnownGood' }
  | { tag: 'OutOfDate' }
  | { tag: 'LowQuality' }
  | { tag: 'Erroneous' };

export type SpRuntimeMultiSignature =
  | { tag: 'Ed25519'; value: SpCoreEd25519Signature }
  | { tag: 'Sr25519'; value: SpCoreSr25519Signature }
  | { tag: 'Ecdsa'; value: SpCoreEcdsaSignature };

export type SpCoreEcdsaSignature = FixedBytes<65>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSocietyCall =
  /**
   * A user outside of the society can make a bid for entry.
   *
   * Payment: The group's Candidate Deposit will be reserved for making a bid. It is returned
   * when the bid becomes a member, or if the bid calls `unbid`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `value`: A one time payment the bid would like to receive when joining the society.
   **/
  | { name: 'Bid'; params: { value: bigint } }
  /**
   * A bidder can remove their bid for entry into society.
   * By doing so, they will have their candidate deposit returned or
   * they will unvouch their voucher.
   *
   * Payment: The bid deposit is unreserved if the user made a bid.
   *
   * The dispatch origin for this call must be _Signed_ and a bidder.
   **/
  | { name: 'Unbid' }
  /**
   * As a member, vouch for someone to join society by placing a bid on their behalf.
   *
   * There is no deposit required to vouch for a new bid, but a member can only vouch for
   * one bid at a time. If the bid becomes a suspended candidate and ultimately rejected by
   * the suspension judgement origin, the member will be banned from vouching again.
   *
   * As a vouching member, you can claim a tip if the candidate is accepted. This tip will
   * be paid as a portion of the reward the member will receive for joining the society.
   *
   * The dispatch origin for this call must be _Signed_ and a member.
   *
   * Parameters:
   * - `who`: The user who you would like to vouch for.
   * - `value`: The total reward to be paid between you and the candidate if they become
   * a member in the society.
   * - `tip`: Your cut of the total `value` payout when the candidate is inducted into
   * the society. Tips larger than `value` will be saturated upon payout.
   **/
  | { name: 'Vouch'; params: { who: MultiAddress; value: bigint; tip: bigint } }
  /**
   * As a vouching member, unvouch a bid. This only works while vouched user is
   * only a bidder (and not a candidate).
   *
   * The dispatch origin for this call must be _Signed_ and a vouching member.
   *
   * Parameters:
   * - `pos`: Position in the `Bids` vector of the bid who should be unvouched.
   **/
  | { name: 'Unvouch' }
  /**
   * As a member, vote on a candidate.
   *
   * The dispatch origin for this call must be _Signed_ and a member.
   *
   * Parameters:
   * - `candidate`: The candidate that the member would like to bid on.
   * - `approve`: A boolean which says if the candidate should be approved (`true`) or
   * rejected (`false`).
   **/
  | { name: 'Vote'; params: { candidate: MultiAddress; approve: boolean } }
  /**
   * As a member, vote on the defender.
   *
   * The dispatch origin for this call must be _Signed_ and a member.
   *
   * Parameters:
   * - `approve`: A boolean which says if the candidate should be
   * approved (`true`) or rejected (`false`).
   **/
  | { name: 'DefenderVote'; params: { approve: boolean } }
  /**
   * Transfer the first matured payout for the sender and remove it from the records.
   *
   * NOTE: This extrinsic needs to be called multiple times to claim multiple matured
   * payouts.
   *
   * Payment: The member will receive a payment equal to their first matured
   * payout to their free balance.
   *
   * The dispatch origin for this call must be _Signed_ and a member with
   * payouts remaining.
   **/
  | { name: 'Payout' }
  /**
   * Repay the payment previously given to the member with the signed origin, remove any
   * pending payments, and elevate them from rank 0 to rank 1.
   **/
  | { name: 'WaiveRepay'; params: { amount: bigint } }
  /**
   * Found the society.
   *
   * This is done as a discrete action in order to allow for the
   * pallet to be included into a running chain and can only be done once.
   *
   * The dispatch origin for this call must be from the _FounderSetOrigin_.
   *
   * Parameters:
   * - `founder` - The first member and head of the newly founded society.
   * - `max_members` - The initial max number of members for the society.
   * - `max_intake` - The maximum number of candidates per intake period.
   * - `max_strikes`: The maximum number of strikes a member may get before they become
   * suspended and may only be reinstated by the founder.
   * - `candidate_deposit`: The deposit required to make a bid for membership of the group.
   * - `rules` - The rules of this society concerning membership.
   *
   * Complexity: O(1)
   **/
  | {
      name: 'FoundSociety';
      params: {
        founder: MultiAddress;
        maxMembers: number;
        maxIntake: number;
        maxStrikes: number;
        candidateDeposit: bigint;
        rules: Bytes;
      };
    }
  /**
   * Dissolve the society and remove all members.
   *
   * The dispatch origin for this call must be Signed, and the signing account must be both
   * the `Founder` and the `Head`. This implies that it may only be done when there is one
   * member.
   **/
  | { name: 'Dissolve' }
  /**
   * Allow suspension judgement origin to make judgement on a suspended member.
   *
   * If a suspended member is forgiven, we simply add them back as a member, not affecting
   * any of the existing storage items for that member.
   *
   * If a suspended member is rejected, remove all associated storage items, including
   * their payouts, and remove any vouched bids they currently have.
   *
   * The dispatch origin for this call must be Signed from the Founder.
   *
   * Parameters:
   * - `who` - The suspended member to be judged.
   * - `forgive` - A boolean representing whether the suspension judgement origin forgives
   * (`true`) or rejects (`false`) a suspended member.
   **/
  | { name: 'JudgeSuspendedMember'; params: { who: MultiAddress; forgive: boolean } }
  /**
   * Change the maximum number of members in society and the maximum number of new candidates
   * in a single intake period.
   *
   * The dispatch origin for this call must be Signed by the Founder.
   *
   * Parameters:
   * - `max_members` - The maximum number of members for the society. This must be no less
   * than the current number of members.
   * - `max_intake` - The maximum number of candidates per intake period.
   * - `max_strikes`: The maximum number of strikes a member may get before they become
   * suspended and may only be reinstated by the founder.
   * - `candidate_deposit`: The deposit required to make a bid for membership of the group.
   **/
  | {
      name: 'SetParameters';
      params: { maxMembers: number; maxIntake: number; maxStrikes: number; candidateDeposit: bigint };
    }
  /**
   * Punish the skeptic with a strike if they did not vote on a candidate. Callable by the
   * candidate.
   **/
  | { name: 'PunishSkeptic' }
  /**
   * Transform an approved candidate into a member. Callable only by the
   * the candidate, and only after the period for voting has ended.
   **/
  | { name: 'ClaimMembership' }
  /**
   * Transform an approved candidate into a member. Callable only by the Signed origin of the
   * Founder, only after the period for voting has ended and only when the candidate is not
   * clearly rejected.
   **/
  | { name: 'BestowMembership'; params: { candidate: AccountId32 } }
  /**
   * Remove the candidate's application from the society. Callable only by the Signed origin
   * of the Founder, only after the period for voting has ended, and only when they do not
   * have a clear approval.
   *
   * Any bid deposit is lost and voucher is banned.
   **/
  | { name: 'KickCandidate'; params: { candidate: AccountId32 } }
  /**
   * Remove the candidate's application from the society. Callable only by the candidate.
   *
   * Any bid deposit is lost and voucher is banned.
   **/
  | { name: 'ResignCandidacy' }
  /**
   * Remove a `candidate`'s failed application from the society. Callable by any
   * signed origin but only at the end of the subsequent round and only for
   * a candidate with more rejections than approvals.
   *
   * The bid deposit is lost and the voucher is banned.
   **/
  | { name: 'DropCandidate'; params: { candidate: AccountId32 } }
  /**
   * Remove up to `max` stale votes for the given `candidate`.
   *
   * May be called by any Signed origin, but only after the candidate's candidacy is ended.
   **/
  | { name: 'CleanupCandidacy'; params: { candidate: AccountId32; max: number } }
  /**
   * Remove up to `max` stale votes for the defender in the given `challenge_round`.
   *
   * May be called by any Signed origin, but only after the challenge round is ended.
   **/
  | { name: 'CleanupChallenge'; params: { challengeRound: number; max: number } };

export type PalletSocietyCallLike =
  /**
   * A user outside of the society can make a bid for entry.
   *
   * Payment: The group's Candidate Deposit will be reserved for making a bid. It is returned
   * when the bid becomes a member, or if the bid calls `unbid`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `value`: A one time payment the bid would like to receive when joining the society.
   **/
  | { name: 'Bid'; params: { value: bigint } }
  /**
   * A bidder can remove their bid for entry into society.
   * By doing so, they will have their candidate deposit returned or
   * they will unvouch their voucher.
   *
   * Payment: The bid deposit is unreserved if the user made a bid.
   *
   * The dispatch origin for this call must be _Signed_ and a bidder.
   **/
  | { name: 'Unbid' }
  /**
   * As a member, vouch for someone to join society by placing a bid on their behalf.
   *
   * There is no deposit required to vouch for a new bid, but a member can only vouch for
   * one bid at a time. If the bid becomes a suspended candidate and ultimately rejected by
   * the suspension judgement origin, the member will be banned from vouching again.
   *
   * As a vouching member, you can claim a tip if the candidate is accepted. This tip will
   * be paid as a portion of the reward the member will receive for joining the society.
   *
   * The dispatch origin for this call must be _Signed_ and a member.
   *
   * Parameters:
   * - `who`: The user who you would like to vouch for.
   * - `value`: The total reward to be paid between you and the candidate if they become
   * a member in the society.
   * - `tip`: Your cut of the total `value` payout when the candidate is inducted into
   * the society. Tips larger than `value` will be saturated upon payout.
   **/
  | { name: 'Vouch'; params: { who: MultiAddressLike; value: bigint; tip: bigint } }
  /**
   * As a vouching member, unvouch a bid. This only works while vouched user is
   * only a bidder (and not a candidate).
   *
   * The dispatch origin for this call must be _Signed_ and a vouching member.
   *
   * Parameters:
   * - `pos`: Position in the `Bids` vector of the bid who should be unvouched.
   **/
  | { name: 'Unvouch' }
  /**
   * As a member, vote on a candidate.
   *
   * The dispatch origin for this call must be _Signed_ and a member.
   *
   * Parameters:
   * - `candidate`: The candidate that the member would like to bid on.
   * - `approve`: A boolean which says if the candidate should be approved (`true`) or
   * rejected (`false`).
   **/
  | { name: 'Vote'; params: { candidate: MultiAddressLike; approve: boolean } }
  /**
   * As a member, vote on the defender.
   *
   * The dispatch origin for this call must be _Signed_ and a member.
   *
   * Parameters:
   * - `approve`: A boolean which says if the candidate should be
   * approved (`true`) or rejected (`false`).
   **/
  | { name: 'DefenderVote'; params: { approve: boolean } }
  /**
   * Transfer the first matured payout for the sender and remove it from the records.
   *
   * NOTE: This extrinsic needs to be called multiple times to claim multiple matured
   * payouts.
   *
   * Payment: The member will receive a payment equal to their first matured
   * payout to their free balance.
   *
   * The dispatch origin for this call must be _Signed_ and a member with
   * payouts remaining.
   **/
  | { name: 'Payout' }
  /**
   * Repay the payment previously given to the member with the signed origin, remove any
   * pending payments, and elevate them from rank 0 to rank 1.
   **/
  | { name: 'WaiveRepay'; params: { amount: bigint } }
  /**
   * Found the society.
   *
   * This is done as a discrete action in order to allow for the
   * pallet to be included into a running chain and can only be done once.
   *
   * The dispatch origin for this call must be from the _FounderSetOrigin_.
   *
   * Parameters:
   * - `founder` - The first member and head of the newly founded society.
   * - `max_members` - The initial max number of members for the society.
   * - `max_intake` - The maximum number of candidates per intake period.
   * - `max_strikes`: The maximum number of strikes a member may get before they become
   * suspended and may only be reinstated by the founder.
   * - `candidate_deposit`: The deposit required to make a bid for membership of the group.
   * - `rules` - The rules of this society concerning membership.
   *
   * Complexity: O(1)
   **/
  | {
      name: 'FoundSociety';
      params: {
        founder: MultiAddressLike;
        maxMembers: number;
        maxIntake: number;
        maxStrikes: number;
        candidateDeposit: bigint;
        rules: BytesLike;
      };
    }
  /**
   * Dissolve the society and remove all members.
   *
   * The dispatch origin for this call must be Signed, and the signing account must be both
   * the `Founder` and the `Head`. This implies that it may only be done when there is one
   * member.
   **/
  | { name: 'Dissolve' }
  /**
   * Allow suspension judgement origin to make judgement on a suspended member.
   *
   * If a suspended member is forgiven, we simply add them back as a member, not affecting
   * any of the existing storage items for that member.
   *
   * If a suspended member is rejected, remove all associated storage items, including
   * their payouts, and remove any vouched bids they currently have.
   *
   * The dispatch origin for this call must be Signed from the Founder.
   *
   * Parameters:
   * - `who` - The suspended member to be judged.
   * - `forgive` - A boolean representing whether the suspension judgement origin forgives
   * (`true`) or rejects (`false`) a suspended member.
   **/
  | { name: 'JudgeSuspendedMember'; params: { who: MultiAddressLike; forgive: boolean } }
  /**
   * Change the maximum number of members in society and the maximum number of new candidates
   * in a single intake period.
   *
   * The dispatch origin for this call must be Signed by the Founder.
   *
   * Parameters:
   * - `max_members` - The maximum number of members for the society. This must be no less
   * than the current number of members.
   * - `max_intake` - The maximum number of candidates per intake period.
   * - `max_strikes`: The maximum number of strikes a member may get before they become
   * suspended and may only be reinstated by the founder.
   * - `candidate_deposit`: The deposit required to make a bid for membership of the group.
   **/
  | {
      name: 'SetParameters';
      params: { maxMembers: number; maxIntake: number; maxStrikes: number; candidateDeposit: bigint };
    }
  /**
   * Punish the skeptic with a strike if they did not vote on a candidate. Callable by the
   * candidate.
   **/
  | { name: 'PunishSkeptic' }
  /**
   * Transform an approved candidate into a member. Callable only by the
   * the candidate, and only after the period for voting has ended.
   **/
  | { name: 'ClaimMembership' }
  /**
   * Transform an approved candidate into a member. Callable only by the Signed origin of the
   * Founder, only after the period for voting has ended and only when the candidate is not
   * clearly rejected.
   **/
  | { name: 'BestowMembership'; params: { candidate: AccountId32Like } }
  /**
   * Remove the candidate's application from the society. Callable only by the Signed origin
   * of the Founder, only after the period for voting has ended, and only when they do not
   * have a clear approval.
   *
   * Any bid deposit is lost and voucher is banned.
   **/
  | { name: 'KickCandidate'; params: { candidate: AccountId32Like } }
  /**
   * Remove the candidate's application from the society. Callable only by the candidate.
   *
   * Any bid deposit is lost and voucher is banned.
   **/
  | { name: 'ResignCandidacy' }
  /**
   * Remove a `candidate`'s failed application from the society. Callable by any
   * signed origin but only at the end of the subsequent round and only for
   * a candidate with more rejections than approvals.
   *
   * The bid deposit is lost and the voucher is banned.
   **/
  | { name: 'DropCandidate'; params: { candidate: AccountId32Like } }
  /**
   * Remove up to `max` stale votes for the given `candidate`.
   *
   * May be called by any Signed origin, but only after the candidate's candidacy is ended.
   **/
  | { name: 'CleanupCandidacy'; params: { candidate: AccountId32Like; max: number } }
  /**
   * Remove up to `max` stale votes for the defender in the given `challenge_round`.
   *
   * May be called by any Signed origin, but only after the challenge round is ended.
   **/
  | { name: 'CleanupChallenge'; params: { challengeRound: number; max: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRecoveryCall =
  /**
   * Send a call through a recovered account.
   *
   * The dispatch origin for this call must be _Signed_ and registered to
   * be able to make calls on behalf of the recovered account.
   *
   * Parameters:
   * - `account`: The recovered account you want to make a call on-behalf-of.
   * - `call`: The call you want to make with the recovered account.
   **/
  | { name: 'AsRecovered'; params: { account: MultiAddress; call: KitchensinkRuntimeRuntimeCall } }
  /**
   * Allow ROOT to bypass the recovery process and set an a rescuer account
   * for a lost account directly.
   *
   * The dispatch origin for this call must be _ROOT_.
   *
   * Parameters:
   * - `lost`: The "lost account" to be recovered.
   * - `rescuer`: The "rescuer account" which can call as the lost account.
   **/
  | { name: 'SetRecovered'; params: { lost: MultiAddress; rescuer: MultiAddress } }
  /**
   * Create a recovery configuration for your account. This makes your account recoverable.
   *
   * Payment: `ConfigDepositBase` + `FriendDepositFactor` * #_of_friends balance
   * will be reserved for storing the recovery configuration. This deposit is returned
   * in full when the user calls `remove_recovery`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `friends`: A list of friends you trust to vouch for recovery attempts. Should be
   * ordered and contain no duplicate values.
   * - `threshold`: The number of friends that must vouch for a recovery attempt before the
   * account can be recovered. Should be less than or equal to the length of the list of
   * friends.
   * - `delay_period`: The number of blocks after a recovery attempt is initialized that
   * needs to pass before the account can be recovered.
   **/
  | { name: 'CreateRecovery'; params: { friends: Array<AccountId32>; threshold: number; delayPeriod: number } }
  /**
   * Initiate the process for recovering a recoverable account.
   *
   * Payment: `RecoveryDeposit` balance will be reserved for initiating the
   * recovery process. This deposit will always be repatriated to the account
   * trying to be recovered. See `close_recovery`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `account`: The lost account that you want to recover. This account needs to be
   * recoverable (i.e. have a recovery configuration).
   **/
  | { name: 'InitiateRecovery'; params: { account: MultiAddress } }
  /**
   * Allow a "friend" of a recoverable account to vouch for an active recovery
   * process for that account.
   *
   * The dispatch origin for this call must be _Signed_ and must be a "friend"
   * for the recoverable account.
   *
   * Parameters:
   * - `lost`: The lost account that you want to recover.
   * - `rescuer`: The account trying to rescue the lost account that you want to vouch for.
   *
   * The combination of these two parameters must point to an active recovery
   * process.
   **/
  | { name: 'VouchRecovery'; params: { lost: MultiAddress; rescuer: MultiAddress } }
  /**
   * Allow a successful rescuer to claim their recovered account.
   *
   * The dispatch origin for this call must be _Signed_ and must be a "rescuer"
   * who has successfully completed the account recovery process: collected
   * `threshold` or more vouches, waited `delay_period` blocks since initiation.
   *
   * Parameters:
   * - `account`: The lost account that you want to claim has been successfully recovered by
   * you.
   **/
  | { name: 'ClaimRecovery'; params: { account: MultiAddress } }
  /**
   * As the controller of a recoverable account, close an active recovery
   * process for your account.
   *
   * Payment: By calling this function, the recoverable account will receive
   * the recovery deposit `RecoveryDeposit` placed by the rescuer.
   *
   * The dispatch origin for this call must be _Signed_ and must be a
   * recoverable account with an active recovery process for it.
   *
   * Parameters:
   * - `rescuer`: The account trying to rescue this recoverable account.
   **/
  | { name: 'CloseRecovery'; params: { rescuer: MultiAddress } }
  /**
   * Remove the recovery process for your account. Recovered accounts are still accessible.
   *
   * NOTE: The user must make sure to call `close_recovery` on all active
   * recovery attempts before calling this function else it will fail.
   *
   * Payment: By calling this function the recoverable account will unreserve
   * their recovery configuration deposit.
   * (`ConfigDepositBase` + `FriendDepositFactor` * #_of_friends)
   *
   * The dispatch origin for this call must be _Signed_ and must be a
   * recoverable account (i.e. has a recovery configuration).
   **/
  | { name: 'RemoveRecovery' }
  /**
   * Cancel the ability to use `as_recovered` for `account`.
   *
   * The dispatch origin for this call must be _Signed_ and registered to
   * be able to make calls on behalf of the recovered account.
   *
   * Parameters:
   * - `account`: The recovered account you are able to call on-behalf-of.
   **/
  | { name: 'CancelRecovered'; params: { account: MultiAddress } };

export type PalletRecoveryCallLike =
  /**
   * Send a call through a recovered account.
   *
   * The dispatch origin for this call must be _Signed_ and registered to
   * be able to make calls on behalf of the recovered account.
   *
   * Parameters:
   * - `account`: The recovered account you want to make a call on-behalf-of.
   * - `call`: The call you want to make with the recovered account.
   **/
  | { name: 'AsRecovered'; params: { account: MultiAddressLike; call: KitchensinkRuntimeRuntimeCallLike } }
  /**
   * Allow ROOT to bypass the recovery process and set an a rescuer account
   * for a lost account directly.
   *
   * The dispatch origin for this call must be _ROOT_.
   *
   * Parameters:
   * - `lost`: The "lost account" to be recovered.
   * - `rescuer`: The "rescuer account" which can call as the lost account.
   **/
  | { name: 'SetRecovered'; params: { lost: MultiAddressLike; rescuer: MultiAddressLike } }
  /**
   * Create a recovery configuration for your account. This makes your account recoverable.
   *
   * Payment: `ConfigDepositBase` + `FriendDepositFactor` * #_of_friends balance
   * will be reserved for storing the recovery configuration. This deposit is returned
   * in full when the user calls `remove_recovery`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `friends`: A list of friends you trust to vouch for recovery attempts. Should be
   * ordered and contain no duplicate values.
   * - `threshold`: The number of friends that must vouch for a recovery attempt before the
   * account can be recovered. Should be less than or equal to the length of the list of
   * friends.
   * - `delay_period`: The number of blocks after a recovery attempt is initialized that
   * needs to pass before the account can be recovered.
   **/
  | { name: 'CreateRecovery'; params: { friends: Array<AccountId32Like>; threshold: number; delayPeriod: number } }
  /**
   * Initiate the process for recovering a recoverable account.
   *
   * Payment: `RecoveryDeposit` balance will be reserved for initiating the
   * recovery process. This deposit will always be repatriated to the account
   * trying to be recovered. See `close_recovery`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `account`: The lost account that you want to recover. This account needs to be
   * recoverable (i.e. have a recovery configuration).
   **/
  | { name: 'InitiateRecovery'; params: { account: MultiAddressLike } }
  /**
   * Allow a "friend" of a recoverable account to vouch for an active recovery
   * process for that account.
   *
   * The dispatch origin for this call must be _Signed_ and must be a "friend"
   * for the recoverable account.
   *
   * Parameters:
   * - `lost`: The lost account that you want to recover.
   * - `rescuer`: The account trying to rescue the lost account that you want to vouch for.
   *
   * The combination of these two parameters must point to an active recovery
   * process.
   **/
  | { name: 'VouchRecovery'; params: { lost: MultiAddressLike; rescuer: MultiAddressLike } }
  /**
   * Allow a successful rescuer to claim their recovered account.
   *
   * The dispatch origin for this call must be _Signed_ and must be a "rescuer"
   * who has successfully completed the account recovery process: collected
   * `threshold` or more vouches, waited `delay_period` blocks since initiation.
   *
   * Parameters:
   * - `account`: The lost account that you want to claim has been successfully recovered by
   * you.
   **/
  | { name: 'ClaimRecovery'; params: { account: MultiAddressLike } }
  /**
   * As the controller of a recoverable account, close an active recovery
   * process for your account.
   *
   * Payment: By calling this function, the recoverable account will receive
   * the recovery deposit `RecoveryDeposit` placed by the rescuer.
   *
   * The dispatch origin for this call must be _Signed_ and must be a
   * recoverable account with an active recovery process for it.
   *
   * Parameters:
   * - `rescuer`: The account trying to rescue this recoverable account.
   **/
  | { name: 'CloseRecovery'; params: { rescuer: MultiAddressLike } }
  /**
   * Remove the recovery process for your account. Recovered accounts are still accessible.
   *
   * NOTE: The user must make sure to call `close_recovery` on all active
   * recovery attempts before calling this function else it will fail.
   *
   * Payment: By calling this function the recoverable account will unreserve
   * their recovery configuration deposit.
   * (`ConfigDepositBase` + `FriendDepositFactor` * #_of_friends)
   *
   * The dispatch origin for this call must be _Signed_ and must be a
   * recoverable account (i.e. has a recovery configuration).
   **/
  | { name: 'RemoveRecovery' }
  /**
   * Cancel the ability to use `as_recovered` for `account`.
   *
   * The dispatch origin for this call must be _Signed_ and registered to
   * be able to make calls on behalf of the recovered account.
   *
   * Parameters:
   * - `account`: The recovered account you are able to call on-behalf-of.
   **/
  | { name: 'CancelRecovered'; params: { account: MultiAddressLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletVestingCall =
  /**
   * Unlock any vested funds of the sender account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Vest' }
  /**
   * Unlock any vested funds of a `target` account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account whose vested funds should be unlocked. Must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'VestOther'; params: { target: MultiAddress } }
  /**
   * Create a vested transfer.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account receiving the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'VestedTransfer'; params: { target: MultiAddress; schedule: PalletVestingVestingInfo } }
  /**
   * Force a vested transfer.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `source`: The account whose funds should be transferred.
   * - `target`: The account that should be transferred the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | {
      name: 'ForceVestedTransfer';
      params: { source: MultiAddress; target: MultiAddress; schedule: PalletVestingVestingInfo };
    }
  /**
   * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
   * the highest possible start and end blocks. If both schedules have already started the
   * current block will be used as the schedule start; with the caveat that if one schedule
   * is finished by the current block, the other will be treated as the new merged schedule,
   * unmodified.
   *
   * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
   * NOTE: This will unlock all schedules through the current block prior to merging.
   * NOTE: If both schedules have ended by the current block, no new schedule will be created
   * and both will be removed.
   *
   * Merged schedule attributes:
   * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
   * current_block)`.
   * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
   * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `schedule1_index`: index of the first schedule to merge.
   * - `schedule2_index`: index of the second schedule to merge.
   **/
  | { name: 'MergeSchedules'; params: { schedule1Index: number; schedule2Index: number } }
  /**
   * Force remove a vesting schedule
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `target`: An account that has a vesting schedule
   * - `schedule_index`: The vesting schedule index that should be removed
   **/
  | { name: 'ForceRemoveVestingSchedule'; params: { target: MultiAddress; scheduleIndex: number } };

export type PalletVestingCallLike =
  /**
   * Unlock any vested funds of the sender account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Vest' }
  /**
   * Unlock any vested funds of a `target` account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account whose vested funds should be unlocked. Must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'VestOther'; params: { target: MultiAddressLike } }
  /**
   * Create a vested transfer.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account receiving the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'VestedTransfer'; params: { target: MultiAddressLike; schedule: PalletVestingVestingInfo } }
  /**
   * Force a vested transfer.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `source`: The account whose funds should be transferred.
   * - `target`: The account that should be transferred the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | {
      name: 'ForceVestedTransfer';
      params: { source: MultiAddressLike; target: MultiAddressLike; schedule: PalletVestingVestingInfo };
    }
  /**
   * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
   * the highest possible start and end blocks. If both schedules have already started the
   * current block will be used as the schedule start; with the caveat that if one schedule
   * is finished by the current block, the other will be treated as the new merged schedule,
   * unmodified.
   *
   * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
   * NOTE: This will unlock all schedules through the current block prior to merging.
   * NOTE: If both schedules have ended by the current block, no new schedule will be created
   * and both will be removed.
   *
   * Merged schedule attributes:
   * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
   * current_block)`.
   * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
   * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `schedule1_index`: index of the first schedule to merge.
   * - `schedule2_index`: index of the second schedule to merge.
   **/
  | { name: 'MergeSchedules'; params: { schedule1Index: number; schedule2Index: number } }
  /**
   * Force remove a vesting schedule
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `target`: An account that has a vesting schedule
   * - `schedule_index`: The vesting schedule index that should be removed
   **/
  | { name: 'ForceRemoveVestingSchedule'; params: { target: MultiAddressLike; scheduleIndex: number } };

export type PalletVestingVestingInfo = { locked: bigint; perBlock: bigint; startingBlock: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSchedulerCall =
  /**
   * Anonymously schedule a task.
   **/
  | {
      name: 'Schedule';
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: KitchensinkRuntimeRuntimeCall;
      };
    }
  /**
   * Cancel an anonymously scheduled task.
   **/
  | { name: 'Cancel'; params: { when: number; index: number } }
  /**
   * Schedule a named task.
   **/
  | {
      name: 'ScheduleNamed';
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: KitchensinkRuntimeRuntimeCall;
      };
    }
  /**
   * Cancel a named scheduled task.
   **/
  | { name: 'CancelNamed'; params: { id: FixedBytes<32> } }
  /**
   * Anonymously schedule a task after a delay.
   **/
  | {
      name: 'ScheduleAfter';
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: KitchensinkRuntimeRuntimeCall;
      };
    }
  /**
   * Schedule a named task after a delay.
   **/
  | {
      name: 'ScheduleNamedAfter';
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: KitchensinkRuntimeRuntimeCall;
      };
    }
  /**
   * Set a retry configuration for a task so that, in case its scheduled run fails, it will
   * be retried after `period` blocks, for a total amount of `retries` retries or until it
   * succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetry'; params: { task: [number, number]; retries: number; period: number } }
  /**
   * Set a retry configuration for a named task so that, in case its scheduled run fails, it
   * will be retried after `period` blocks, for a total amount of `retries` retries or until
   * it succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetryNamed'; params: { id: FixedBytes<32>; retries: number; period: number } }
  /**
   * Removes the retry configuration of a task.
   **/
  | { name: 'CancelRetry'; params: { task: [number, number] } }
  /**
   * Cancel the retry configuration of a named task.
   **/
  | { name: 'CancelRetryNamed'; params: { id: FixedBytes<32> } };

export type PalletSchedulerCallLike =
  /**
   * Anonymously schedule a task.
   **/
  | {
      name: 'Schedule';
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: KitchensinkRuntimeRuntimeCallLike;
      };
    }
  /**
   * Cancel an anonymously scheduled task.
   **/
  | { name: 'Cancel'; params: { when: number; index: number } }
  /**
   * Schedule a named task.
   **/
  | {
      name: 'ScheduleNamed';
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: KitchensinkRuntimeRuntimeCallLike;
      };
    }
  /**
   * Cancel a named scheduled task.
   **/
  | { name: 'CancelNamed'; params: { id: FixedBytes<32> } }
  /**
   * Anonymously schedule a task after a delay.
   **/
  | {
      name: 'ScheduleAfter';
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: KitchensinkRuntimeRuntimeCallLike;
      };
    }
  /**
   * Schedule a named task after a delay.
   **/
  | {
      name: 'ScheduleNamedAfter';
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: KitchensinkRuntimeRuntimeCallLike;
      };
    }
  /**
   * Set a retry configuration for a task so that, in case its scheduled run fails, it will
   * be retried after `period` blocks, for a total amount of `retries` retries or until it
   * succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetry'; params: { task: [number, number]; retries: number; period: number } }
  /**
   * Set a retry configuration for a named task so that, in case its scheduled run fails, it
   * will be retried after `period` blocks, for a total amount of `retries` retries or until
   * it succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetryNamed'; params: { id: FixedBytes<32>; retries: number; period: number } }
  /**
   * Removes the retry configuration of a task.
   **/
  | { name: 'CancelRetry'; params: { task: [number, number] } }
  /**
   * Cancel the retry configuration of a named task.
   **/
  | { name: 'CancelRetryNamed'; params: { id: FixedBytes<32> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletGluttonCall =
  /**
   * Initialize the pallet. Should be called once, if no genesis state was provided.
   *
   * `current_count` is the current number of elements in `TrashData`. This can be set to
   * `None` when the pallet is first initialized.
   *
   * Only callable by Root or `AdminOrigin`. A good default for `new_count` is `5_000`.
   **/
  | { name: 'InitializePallet'; params: { newCount: number; witnessCount?: number | undefined } }
  /**
   * Set how much of the remaining `ref_time` weight should be consumed by `on_idle`.
   *
   * Only callable by Root or `AdminOrigin`.
   **/
  | { name: 'SetCompute'; params: { compute: FixedU64 } }
  /**
   * Set how much of the remaining `proof_size` weight should be consumed by `on_idle`.
   *
   * `1.0` means that all remaining `proof_size` will be consumed. The PoV benchmarking
   * results that are used here are likely an over-estimation. 100% intended consumption will
   * therefore translate to less than 100% actual consumption.
   *
   * Only callable by Root or `AdminOrigin`.
   **/
  | { name: 'SetStorage'; params: { storage: FixedU64 } };

export type PalletGluttonCallLike =
  /**
   * Initialize the pallet. Should be called once, if no genesis state was provided.
   *
   * `current_count` is the current number of elements in `TrashData`. This can be set to
   * `None` when the pallet is first initialized.
   *
   * Only callable by Root or `AdminOrigin`. A good default for `new_count` is `5_000`.
   **/
  | { name: 'InitializePallet'; params: { newCount: number; witnessCount?: number | undefined } }
  /**
   * Set how much of the remaining `ref_time` weight should be consumed by `on_idle`.
   *
   * Only callable by Root or `AdminOrigin`.
   **/
  | { name: 'SetCompute'; params: { compute: FixedU64 } }
  /**
   * Set how much of the remaining `proof_size` weight should be consumed by `on_idle`.
   *
   * `1.0` means that all remaining `proof_size` will be consumed. The PoV benchmarking
   * results that are used here are likely an over-estimation. 100% intended consumption will
   * therefore translate to less than 100% actual consumption.
   *
   * Only callable by Root or `AdminOrigin`.
   **/
  | { name: 'SetStorage'; params: { storage: FixedU64 } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletPreimageCall =
  /**
   * Register a preimage on-chain.
   *
   * If the preimage was previously requested, no fees or deposits are taken for providing
   * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
   **/
  | { name: 'NotePreimage'; params: { bytes: Bytes } }
  /**
   * Clear an unrequested preimage from the runtime storage.
   *
   * If `len` is provided, then it will be a much cheaper operation.
   *
   * - `hash`: The hash of the preimage to be removed from the store.
   * - `len`: The length of the preimage of `hash`.
   **/
  | { name: 'UnnotePreimage'; params: { hash: H256 } }
  /**
   * Request a preimage be uploaded to the chain without paying any fees or deposits.
   *
   * If the preimage requests has already been provided on-chain, we unreserve any deposit
   * a user may have paid, and take the control of the preimage out of their hands.
   **/
  | { name: 'RequestPreimage'; params: { hash: H256 } }
  /**
   * Clear a previously made request for a preimage.
   *
   * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
   **/
  | { name: 'UnrequestPreimage'; params: { hash: H256 } }
  /**
   * Ensure that the a bulk of pre-images is upgraded.
   *
   * The caller pays no fee if at least 90% of pre-images were successfully updated.
   **/
  | { name: 'EnsureUpdated'; params: { hashes: Array<H256> } };

export type PalletPreimageCallLike =
  /**
   * Register a preimage on-chain.
   *
   * If the preimage was previously requested, no fees or deposits are taken for providing
   * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
   **/
  | { name: 'NotePreimage'; params: { bytes: BytesLike } }
  /**
   * Clear an unrequested preimage from the runtime storage.
   *
   * If `len` is provided, then it will be a much cheaper operation.
   *
   * - `hash`: The hash of the preimage to be removed from the store.
   * - `len`: The length of the preimage of `hash`.
   **/
  | { name: 'UnnotePreimage'; params: { hash: H256 } }
  /**
   * Request a preimage be uploaded to the chain without paying any fees or deposits.
   *
   * If the preimage requests has already been provided on-chain, we unreserve any deposit
   * a user may have paid, and take the control of the preimage out of their hands.
   **/
  | { name: 'RequestPreimage'; params: { hash: H256 } }
  /**
   * Clear a previously made request for a preimage.
   *
   * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
   **/
  | { name: 'UnrequestPreimage'; params: { hash: H256 } }
  /**
   * Ensure that the a bulk of pre-images is upgraded.
   *
   * The caller pays no fee if at least 90% of pre-images were successfully updated.
   **/
  | { name: 'EnsureUpdated'; params: { hashes: Array<H256> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletProxyCall =
  /**
   * Dispatch the given `call` from an account that the sender is authorised for through
   * `add_proxy`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'Proxy';
      params: {
        real: MultiAddress;
        forceProxyType?: KitchensinkRuntimeProxyType | undefined;
        call: KitchensinkRuntimeRuntimeCall;
      };
    }
  /**
   * Register a proxy account for the sender that is able to make calls on its behalf.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to make a proxy.
   * - `proxy_type`: The permissions allowed for this proxy account.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   **/
  | { name: 'AddProxy'; params: { delegate: MultiAddress; proxyType: KitchensinkRuntimeProxyType; delay: number } }
  /**
   * Unregister a proxy account for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to remove as a proxy.
   * - `proxy_type`: The permissions currently enabled for the removed proxy account.
   **/
  | { name: 'RemoveProxy'; params: { delegate: MultiAddress; proxyType: KitchensinkRuntimeProxyType; delay: number } }
  /**
   * Unregister all proxy accounts for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * WARNING: This may be called on accounts created by `pure`, however if done, then
   * the unreserved fees will be inaccessible. **All access to this account will be lost.**
   **/
  | { name: 'RemoveProxies' }
  /**
   * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
   * initialize it with a proxy of `proxy_type` for `origin` sender.
   *
   * Requires a `Signed` origin.
   *
   * - `proxy_type`: The type of the proxy that the sender will be registered as over the
   * new account. This will almost always be the most permissive `ProxyType` possible to
   * allow for maximum flexibility.
   * - `index`: A disambiguation index, in case this is called multiple times in the same
   * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
   * want to use `0`.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   *
   * Fails with `Duplicate` if this has already been called in this transaction, from the
   * same sender, with the same parameters.
   *
   * Fails if there are insufficient funds to pay for deposit.
   **/
  | { name: 'CreatePure'; params: { proxyType: KitchensinkRuntimeProxyType; delay: number; index: number } }
  /**
   * Removes a previously spawned pure proxy.
   *
   * WARNING: **All access to this account will be lost.** Any funds held in it will be
   * inaccessible.
   *
   * Requires a `Signed` origin, and the sender account must have been created by a call to
   * `pure` with corresponding parameters.
   *
   * - `spawner`: The account that originally called `pure` to create this account.
   * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
   * - `proxy_type`: The proxy type originally passed to `pure`.
   * - `height`: The height of the chain when the call to `pure` was processed.
   * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
   *
   * Fails with `NoPermission` in case the caller is not a previously created pure
   * account whose `pure` call has corresponding parameters.
   **/
  | {
      name: 'KillPure';
      params: {
        spawner: MultiAddress;
        proxyType: KitchensinkRuntimeProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * Publish the hash of a proxy-call that will be made in the future.
   *
   * This must be called some number of blocks before the corresponding `proxy` is attempted
   * if the delay associated with the proxy relationship is greater than zero.
   *
   * No more than `MaxPending` announcements may be made at any one time.
   *
   * This will take a deposit of `AnnouncementDepositFactor` as well as
   * `AnnouncementDepositBase` if there are no other pending announcements.
   *
   * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'Announce'; params: { real: MultiAddress; callHash: H256 } }
  /**
   * Remove a given announcement.
   *
   * May be called by a proxy account to remove a call they previously announced and return
   * the deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'RemoveAnnouncement'; params: { real: MultiAddress; callHash: H256 } }
  /**
   * Remove the given announcement of a delegate.
   *
   * May be called by a target (proxied) account to remove a call that one of their delegates
   * (`delegate`) has announced they want to execute. The deposit is returned.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `delegate`: The account that previously announced the call.
   * - `call_hash`: The hash of the call to be made.
   **/
  | { name: 'RejectAnnouncement'; params: { delegate: MultiAddress; callHash: H256 } }
  /**
   * Dispatch the given `call` from an account that the sender is authorized for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'ProxyAnnounced';
      params: {
        delegate: MultiAddress;
        real: MultiAddress;
        forceProxyType?: KitchensinkRuntimeProxyType | undefined;
        call: KitchensinkRuntimeRuntimeCall;
      };
    };

export type PalletProxyCallLike =
  /**
   * Dispatch the given `call` from an account that the sender is authorised for through
   * `add_proxy`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'Proxy';
      params: {
        real: MultiAddressLike;
        forceProxyType?: KitchensinkRuntimeProxyType | undefined;
        call: KitchensinkRuntimeRuntimeCallLike;
      };
    }
  /**
   * Register a proxy account for the sender that is able to make calls on its behalf.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to make a proxy.
   * - `proxy_type`: The permissions allowed for this proxy account.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   **/
  | { name: 'AddProxy'; params: { delegate: MultiAddressLike; proxyType: KitchensinkRuntimeProxyType; delay: number } }
  /**
   * Unregister a proxy account for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to remove as a proxy.
   * - `proxy_type`: The permissions currently enabled for the removed proxy account.
   **/
  | {
      name: 'RemoveProxy';
      params: { delegate: MultiAddressLike; proxyType: KitchensinkRuntimeProxyType; delay: number };
    }
  /**
   * Unregister all proxy accounts for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * WARNING: This may be called on accounts created by `pure`, however if done, then
   * the unreserved fees will be inaccessible. **All access to this account will be lost.**
   **/
  | { name: 'RemoveProxies' }
  /**
   * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
   * initialize it with a proxy of `proxy_type` for `origin` sender.
   *
   * Requires a `Signed` origin.
   *
   * - `proxy_type`: The type of the proxy that the sender will be registered as over the
   * new account. This will almost always be the most permissive `ProxyType` possible to
   * allow for maximum flexibility.
   * - `index`: A disambiguation index, in case this is called multiple times in the same
   * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
   * want to use `0`.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   *
   * Fails with `Duplicate` if this has already been called in this transaction, from the
   * same sender, with the same parameters.
   *
   * Fails if there are insufficient funds to pay for deposit.
   **/
  | { name: 'CreatePure'; params: { proxyType: KitchensinkRuntimeProxyType; delay: number; index: number } }
  /**
   * Removes a previously spawned pure proxy.
   *
   * WARNING: **All access to this account will be lost.** Any funds held in it will be
   * inaccessible.
   *
   * Requires a `Signed` origin, and the sender account must have been created by a call to
   * `pure` with corresponding parameters.
   *
   * - `spawner`: The account that originally called `pure` to create this account.
   * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
   * - `proxy_type`: The proxy type originally passed to `pure`.
   * - `height`: The height of the chain when the call to `pure` was processed.
   * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
   *
   * Fails with `NoPermission` in case the caller is not a previously created pure
   * account whose `pure` call has corresponding parameters.
   **/
  | {
      name: 'KillPure';
      params: {
        spawner: MultiAddressLike;
        proxyType: KitchensinkRuntimeProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * Publish the hash of a proxy-call that will be made in the future.
   *
   * This must be called some number of blocks before the corresponding `proxy` is attempted
   * if the delay associated with the proxy relationship is greater than zero.
   *
   * No more than `MaxPending` announcements may be made at any one time.
   *
   * This will take a deposit of `AnnouncementDepositFactor` as well as
   * `AnnouncementDepositBase` if there are no other pending announcements.
   *
   * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'Announce'; params: { real: MultiAddressLike; callHash: H256 } }
  /**
   * Remove a given announcement.
   *
   * May be called by a proxy account to remove a call they previously announced and return
   * the deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'RemoveAnnouncement'; params: { real: MultiAddressLike; callHash: H256 } }
  /**
   * Remove the given announcement of a delegate.
   *
   * May be called by a target (proxied) account to remove a call that one of their delegates
   * (`delegate`) has announced they want to execute. The deposit is returned.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `delegate`: The account that previously announced the call.
   * - `call_hash`: The hash of the call to be made.
   **/
  | { name: 'RejectAnnouncement'; params: { delegate: MultiAddressLike; callHash: H256 } }
  /**
   * Dispatch the given `call` from an account that the sender is authorized for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'ProxyAnnounced';
      params: {
        delegate: MultiAddressLike;
        real: MultiAddressLike;
        forceProxyType?: KitchensinkRuntimeProxyType | undefined;
        call: KitchensinkRuntimeRuntimeCallLike;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMultisigCall =
  /**
   * Immediately dispatch a multi-signature call using a single approval from the caller.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `other_signatories`: The accounts (other than the sender) who are part of the
   * multi-signature, but do not participate in the approval process.
   * - `call`: The call to be executed.
   *
   * Result is equivalent to the dispatched result.
   *
   * ## Complexity
   * O(Z + C) where Z is the length of the call and C its execution weight.
   **/
  | { name: 'AsMultiThreshold1'; params: { otherSignatories: Array<AccountId32>; call: KitchensinkRuntimeRuntimeCall } }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * If there are enough, then dispatch the call.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call`: The call to be executed.
   *
   * NOTE: Unless this is the final approval, you will generally want to use
   * `approve_as_multi` instead, since it only requires a hash of the call.
   *
   * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
   * on success, result is `Ok` and the result from the interior call, if it was executed,
   * may be found in the deposited `MultisigExecuted` event.
   *
   * ## Complexity
   * - `O(S + Z + Call)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - The weight of the `call`.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: KitchensinkRuntimeRuntimeCall;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call_hash`: The hash of the call to be executed.
   *
   * NOTE: If this is the final approval, you will want to use `as_multi` instead.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
   * for this operation will be unreserved on success.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `timepoint`: The timepoint (block number and transaction index) of the first approval
   * transaction for this dispatch.
   * - `call_hash`: The hash of the call to be executed.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - One event.
   * - I/O: 1 read `O(S)`, one remove.
   * - Storage: removes one item.
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigCallLike =
  /**
   * Immediately dispatch a multi-signature call using a single approval from the caller.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `other_signatories`: The accounts (other than the sender) who are part of the
   * multi-signature, but do not participate in the approval process.
   * - `call`: The call to be executed.
   *
   * Result is equivalent to the dispatched result.
   *
   * ## Complexity
   * O(Z + C) where Z is the length of the call and C its execution weight.
   **/
  | {
      name: 'AsMultiThreshold1';
      params: { otherSignatories: Array<AccountId32Like>; call: KitchensinkRuntimeRuntimeCallLike };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * If there are enough, then dispatch the call.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call`: The call to be executed.
   *
   * NOTE: Unless this is the final approval, you will generally want to use
   * `approve_as_multi` instead, since it only requires a hash of the call.
   *
   * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
   * on success, result is `Ok` and the result from the interior call, if it was executed,
   * may be found in the deposited `MultisigExecuted` event.
   *
   * ## Complexity
   * - `O(S + Z + Call)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - The weight of the `call`.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: KitchensinkRuntimeRuntimeCallLike;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call_hash`: The hash of the call to be executed.
   *
   * NOTE: If this is the final approval, you will want to use `as_multi` instead.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
   * for this operation will be unreserved on success.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `timepoint`: The timepoint (block number and transaction index) of the first approval
   * transaction for this dispatch.
   * - `call_hash`: The hash of the call to be executed.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - One event.
   * - I/O: 1 read `O(S)`, one remove.
   * - Storage: removes one item.
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBountiesCall =
  /**
   * Propose a new bounty.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
   * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
   * or slashed when rejected.
   *
   * - `curator`: The curator account whom will manage this bounty.
   * - `fee`: The curator fee.
   * - `value`: The total payment amount of this bounty, curator fee included.
   * - `description`: The description of this bounty.
   **/
  | { name: 'ProposeBounty'; params: { value: bigint; description: Bytes } }
  /**
   * Approve a bounty proposal. At a later time, the bounty will be funded and become active
   * and the original deposit will be returned.
   *
   * May only be called from `T::SpendOrigin`.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ApproveBounty'; params: { bountyId: number } }
  /**
   * Propose a curator to a funded bounty.
   *
   * May only be called from `T::SpendOrigin`.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ProposeCurator'; params: { bountyId: number; curator: MultiAddress; fee: bigint } }
  /**
   * Unassign curator from a bounty.
   *
   * This function can only be called by the `RejectOrigin` a signed origin.
   *
   * If this function is called by the `RejectOrigin`, we assume that the curator is
   * malicious or inactive. As a result, we will slash the curator when possible.
   *
   * If the origin is the curator, we take this as a sign they are unable to do their job and
   * they willingly give up. We could slash them, but for now we allow them to recover their
   * deposit and exit without issue. (We may want to change this if it is abused.)
   *
   * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
   * anyone in the community to call out that a curator is not doing their due diligence, and
   * we should pick a new curator. In this case the curator should also be slashed.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'UnassignCurator'; params: { bountyId: number } }
  /**
   * Accept the curator role for a bounty.
   * A deposit will be reserved from curator and refund upon successful payout.
   *
   * May only be called from the curator.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'AcceptCurator'; params: { bountyId: number } }
  /**
   * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
   * after a delay.
   *
   * The dispatch origin for this call must be the curator of this bounty.
   *
   * - `bounty_id`: Bounty ID to award.
   * - `beneficiary`: The beneficiary account whom will receive the payout.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'AwardBounty'; params: { bountyId: number; beneficiary: MultiAddress } }
  /**
   * Claim the payout from an awarded bounty after payout delay.
   *
   * The dispatch origin for this call must be the beneficiary of this bounty.
   *
   * - `bounty_id`: Bounty ID to claim.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ClaimBounty'; params: { bountyId: number } }
  /**
   * Cancel a proposed or active bounty. All the funds will be sent to treasury and
   * the curator deposit will be unreserved if possible.
   *
   * Only `T::RejectOrigin` is able to cancel a bounty.
   *
   * - `bounty_id`: Bounty ID to cancel.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'CloseBounty'; params: { bountyId: number } }
  /**
   * Extend the expiry time of an active bounty.
   *
   * The dispatch origin for this call must be the curator of this bounty.
   *
   * - `bounty_id`: Bounty ID to extend.
   * - `remark`: additional information.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ExtendBountyExpiry'; params: { bountyId: number; remark: Bytes } };

export type PalletBountiesCallLike =
  /**
   * Propose a new bounty.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
   * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
   * or slashed when rejected.
   *
   * - `curator`: The curator account whom will manage this bounty.
   * - `fee`: The curator fee.
   * - `value`: The total payment amount of this bounty, curator fee included.
   * - `description`: The description of this bounty.
   **/
  | { name: 'ProposeBounty'; params: { value: bigint; description: BytesLike } }
  /**
   * Approve a bounty proposal. At a later time, the bounty will be funded and become active
   * and the original deposit will be returned.
   *
   * May only be called from `T::SpendOrigin`.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ApproveBounty'; params: { bountyId: number } }
  /**
   * Propose a curator to a funded bounty.
   *
   * May only be called from `T::SpendOrigin`.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ProposeCurator'; params: { bountyId: number; curator: MultiAddressLike; fee: bigint } }
  /**
   * Unassign curator from a bounty.
   *
   * This function can only be called by the `RejectOrigin` a signed origin.
   *
   * If this function is called by the `RejectOrigin`, we assume that the curator is
   * malicious or inactive. As a result, we will slash the curator when possible.
   *
   * If the origin is the curator, we take this as a sign they are unable to do their job and
   * they willingly give up. We could slash them, but for now we allow them to recover their
   * deposit and exit without issue. (We may want to change this if it is abused.)
   *
   * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
   * anyone in the community to call out that a curator is not doing their due diligence, and
   * we should pick a new curator. In this case the curator should also be slashed.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'UnassignCurator'; params: { bountyId: number } }
  /**
   * Accept the curator role for a bounty.
   * A deposit will be reserved from curator and refund upon successful payout.
   *
   * May only be called from the curator.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'AcceptCurator'; params: { bountyId: number } }
  /**
   * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
   * after a delay.
   *
   * The dispatch origin for this call must be the curator of this bounty.
   *
   * - `bounty_id`: Bounty ID to award.
   * - `beneficiary`: The beneficiary account whom will receive the payout.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'AwardBounty'; params: { bountyId: number; beneficiary: MultiAddressLike } }
  /**
   * Claim the payout from an awarded bounty after payout delay.
   *
   * The dispatch origin for this call must be the beneficiary of this bounty.
   *
   * - `bounty_id`: Bounty ID to claim.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ClaimBounty'; params: { bountyId: number } }
  /**
   * Cancel a proposed or active bounty. All the funds will be sent to treasury and
   * the curator deposit will be unreserved if possible.
   *
   * Only `T::RejectOrigin` is able to cancel a bounty.
   *
   * - `bounty_id`: Bounty ID to cancel.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'CloseBounty'; params: { bountyId: number } }
  /**
   * Extend the expiry time of an active bounty.
   *
   * The dispatch origin for this call must be the curator of this bounty.
   *
   * - `bounty_id`: Bounty ID to extend.
   * - `remark`: additional information.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ExtendBountyExpiry'; params: { bountyId: number; remark: BytesLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTipsCall =
  /**
   * Report something `reason` that deserves a tip and claim any eventual the finder's fee.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
   * `DataDepositPerByte` for each byte in `reason`.
   *
   * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
   * a UTF-8-encoded URL.
   * - `who`: The account which should be credited for the tip.
   *
   * Emits `NewTip` if successful.
   *
   * ## Complexity
   * - `O(R)` where `R` length of `reason`.
   * - encoding and hashing of 'reason'
   **/
  | { name: 'ReportAwesome'; params: { reason: Bytes; who: MultiAddress } }
  /**
   * Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.
   *
   * If successful, the original deposit will be unreserved.
   *
   * The dispatch origin for this call must be _Signed_ and the tip identified by `hash`
   * must have been reported by the signing account through `report_awesome` (and not
   * through `tip_new`).
   *
   * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
   * as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
   *
   * Emits `TipRetracted` if successful.
   *
   * ## Complexity
   * - `O(1)`
   * - Depends on the length of `T::Hash` which is fixed.
   **/
  | { name: 'RetractTip'; params: { hash: H256 } }
  /**
   * Give a tip for something new; no finder's fee will be taken.
   *
   * The dispatch origin for this call must be _Signed_ and the signing account must be a
   * member of the `Tippers` set.
   *
   * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
   * a UTF-8-encoded URL.
   * - `who`: The account which should be credited for the tip.
   * - `tip_value`: The amount of tip that the sender would like to give. The median tip
   * value of active tippers will be given to the `who`.
   *
   * Emits `NewTip` if successful.
   *
   * ## Complexity
   * - `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
   * - `O(T)`: decoding `Tipper` vec of length `T`. `T` is charged as upper bound given by
   * `ContainsLengthBound`. The actual cost depends on the implementation of
   * `T::Tippers`.
   * - `O(R)`: hashing and encoding of reason of length `R`
   **/
  | { name: 'TipNew'; params: { reason: Bytes; who: MultiAddress; tipValue: bigint } }
  /**
   * Declare a tip value for an already-open tip.
   *
   * The dispatch origin for this call must be _Signed_ and the signing account must be a
   * member of the `Tippers` set.
   *
   * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
   * as the hash of the tuple of the hash of the original tip `reason` and the beneficiary
   * account ID.
   * - `tip_value`: The amount of tip that the sender would like to give. The median tip
   * value of active tippers will be given to the `who`.
   *
   * Emits `TipClosing` if the threshold of tippers has been reached and the countdown period
   * has started.
   *
   * ## Complexity
   * - `O(T)` where `T` is the number of tippers. decoding `Tipper` vec of length `T`, insert
   * tip and check closing, `T` is charged as upper bound given by `ContainsLengthBound`.
   * The actual cost depends on the implementation of `T::Tippers`.
   *
   * Actually weight could be lower as it depends on how many tips are in `OpenTip` but it
   * is weighted as if almost full i.e of length `T-1`.
   **/
  | { name: 'Tip'; params: { hash: H256; tipValue: bigint } }
  /**
   * Close and payout a tip.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * The tip identified by `hash` must have finished its countdown period.
   *
   * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
   * as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
   *
   * ## Complexity
   * - : `O(T)` where `T` is the number of tippers. decoding `Tipper` vec of length `T`. `T`
   * is charged as upper bound given by `ContainsLengthBound`. The actual cost depends on
   * the implementation of `T::Tippers`.
   **/
  | { name: 'CloseTip'; params: { hash: H256 } }
  /**
   * Remove and slash an already-open tip.
   *
   * May only be called from `T::RejectOrigin`.
   *
   * As a result, the finder is slashed and the deposits are lost.
   *
   * Emits `TipSlashed` if successful.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'SlashTip'; params: { hash: H256 } };

export type PalletTipsCallLike =
  /**
   * Report something `reason` that deserves a tip and claim any eventual the finder's fee.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
   * `DataDepositPerByte` for each byte in `reason`.
   *
   * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
   * a UTF-8-encoded URL.
   * - `who`: The account which should be credited for the tip.
   *
   * Emits `NewTip` if successful.
   *
   * ## Complexity
   * - `O(R)` where `R` length of `reason`.
   * - encoding and hashing of 'reason'
   **/
  | { name: 'ReportAwesome'; params: { reason: BytesLike; who: MultiAddressLike } }
  /**
   * Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.
   *
   * If successful, the original deposit will be unreserved.
   *
   * The dispatch origin for this call must be _Signed_ and the tip identified by `hash`
   * must have been reported by the signing account through `report_awesome` (and not
   * through `tip_new`).
   *
   * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
   * as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
   *
   * Emits `TipRetracted` if successful.
   *
   * ## Complexity
   * - `O(1)`
   * - Depends on the length of `T::Hash` which is fixed.
   **/
  | { name: 'RetractTip'; params: { hash: H256 } }
  /**
   * Give a tip for something new; no finder's fee will be taken.
   *
   * The dispatch origin for this call must be _Signed_ and the signing account must be a
   * member of the `Tippers` set.
   *
   * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
   * a UTF-8-encoded URL.
   * - `who`: The account which should be credited for the tip.
   * - `tip_value`: The amount of tip that the sender would like to give. The median tip
   * value of active tippers will be given to the `who`.
   *
   * Emits `NewTip` if successful.
   *
   * ## Complexity
   * - `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
   * - `O(T)`: decoding `Tipper` vec of length `T`. `T` is charged as upper bound given by
   * `ContainsLengthBound`. The actual cost depends on the implementation of
   * `T::Tippers`.
   * - `O(R)`: hashing and encoding of reason of length `R`
   **/
  | { name: 'TipNew'; params: { reason: BytesLike; who: MultiAddressLike; tipValue: bigint } }
  /**
   * Declare a tip value for an already-open tip.
   *
   * The dispatch origin for this call must be _Signed_ and the signing account must be a
   * member of the `Tippers` set.
   *
   * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
   * as the hash of the tuple of the hash of the original tip `reason` and the beneficiary
   * account ID.
   * - `tip_value`: The amount of tip that the sender would like to give. The median tip
   * value of active tippers will be given to the `who`.
   *
   * Emits `TipClosing` if the threshold of tippers has been reached and the countdown period
   * has started.
   *
   * ## Complexity
   * - `O(T)` where `T` is the number of tippers. decoding `Tipper` vec of length `T`, insert
   * tip and check closing, `T` is charged as upper bound given by `ContainsLengthBound`.
   * The actual cost depends on the implementation of `T::Tippers`.
   *
   * Actually weight could be lower as it depends on how many tips are in `OpenTip` but it
   * is weighted as if almost full i.e of length `T-1`.
   **/
  | { name: 'Tip'; params: { hash: H256; tipValue: bigint } }
  /**
   * Close and payout a tip.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * The tip identified by `hash` must have finished its countdown period.
   *
   * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
   * as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
   *
   * ## Complexity
   * - : `O(T)` where `T` is the number of tippers. decoding `Tipper` vec of length `T`. `T`
   * is charged as upper bound given by `ContainsLengthBound`. The actual cost depends on
   * the implementation of `T::Tippers`.
   **/
  | { name: 'CloseTip'; params: { hash: H256 } }
  /**
   * Remove and slash an already-open tip.
   *
   * May only be called from `T::RejectOrigin`.
   *
   * As a result, the finder is slashed and the deposits are lost.
   *
   * Emits `TipSlashed` if successful.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'SlashTip'; params: { hash: H256 } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAssetsCall =
  /**
   * Issue a new class of fungible assets from a public origin.
   *
   * This new asset class has no assets initially and its owner is the origin.
   *
   * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
   *
   * Funds of sender are reserved by `AssetDeposit`.
   *
   * Parameters:
   * - `id`: The identifier of the new asset. This must not be currently in use to identify
   * an existing asset.
   * - `admin`: The admin of this class of assets. The admin is the initial address of each
   * member of the asset class's admin team.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   *
   * Emits `Created` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Create'; params: { id: number; admin: MultiAddress; minBalance: bigint } }
  /**
   * Issue a new class of fungible assets from a privileged origin.
   *
   * This new asset class has no assets initially.
   *
   * The origin must conform to `ForceOrigin`.
   *
   * Unlike `create`, no funds are reserved.
   *
   * - `id`: The identifier of the new asset. This must not be currently in use to identify
   * an existing asset.
   * - `owner`: The owner of this class of assets. The owner has full superuser permissions
   * over this asset, but may later change and configure the permissions using
   * `transfer_ownership` and `set_team`.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   *
   * Emits `ForceCreated` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCreate'; params: { id: number; owner: MultiAddress; isSufficient: boolean; minBalance: bigint } }
  /**
   * Start the process of destroying a fungible asset class.
   *
   * `start_destroy` is the first in a series of extrinsics that should be called, to allow
   * destruction of an asset class.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * The asset class must be frozen before calling `start_destroy`.
   **/
  | { name: 'StartDestroy'; params: { id: number } }
  /**
   * Destroy all accounts associated with a given asset.
   *
   * `destroy_accounts` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state.
   *
   * Due to weight restrictions, this function may need to be called multiple times to fully
   * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each call emits the `Event::DestroyedAccounts` event.
   **/
  | { name: 'DestroyAccounts'; params: { id: number } }
  /**
   * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
   *
   * `destroy_approvals` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state.
   *
   * Due to weight restrictions, this function may need to be called multiple times to fully
   * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each call emits the `Event::DestroyedApprovals` event.
   **/
  | { name: 'DestroyApprovals'; params: { id: number } }
  /**
   * Complete destroying asset and unreserve currency.
   *
   * `finish_destroy` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
   * hand.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each successful call emits the `Event::Destroyed` event.
   **/
  | { name: 'FinishDestroy'; params: { id: number } }
  /**
   * Mint assets of a particular class.
   *
   * The origin must be Signed and the sender must be the Issuer of the asset `id`.
   *
   * - `id`: The identifier of the asset to have some amount minted.
   * - `beneficiary`: The account to be credited with the minted assets.
   * - `amount`: The amount of the asset to be minted.
   *
   * Emits `Issued` event when successful.
   *
   * Weight: `O(1)`
   * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
   **/
  | { name: 'Mint'; params: { id: number; beneficiary: MultiAddress; amount: bigint } }
  /**
   * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
   *
   * Origin must be Signed and the sender should be the Manager of the asset `id`.
   *
   * Bails with `NoAccount` if the `who` is already dead.
   *
   * - `id`: The identifier of the asset to have some amount burned.
   * - `who`: The account to be debited from.
   * - `amount`: The maximum amount by which `who`'s balance should be reduced.
   *
   * Emits `Burned` with the actual amount burned. If this takes the balance to below the
   * minimum for the asset, then the amount burned is increased to take it to zero.
   *
   * Weight: `O(1)`
   * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
   **/
  | { name: 'Burn'; params: { id: number; who: MultiAddress; amount: bigint } }
  /**
   * Move some assets from the sender account to another.
   *
   * Origin must be Signed.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `target`: The account to be credited.
   * - `amount`: The amount by which the sender's balance of assets should be reduced and
   * `target`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the sender balance above zero but below
   * the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
   * `target`.
   **/
  | { name: 'Transfer'; params: { id: number; target: MultiAddress; amount: bigint } }
  /**
   * Move some assets from the sender account to another, keeping the sender account alive.
   *
   * Origin must be Signed.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `target`: The account to be credited.
   * - `amount`: The amount by which the sender's balance of assets should be reduced and
   * `target`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the sender balance above zero but below
   * the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
   * `target`.
   **/
  | { name: 'TransferKeepAlive'; params: { id: number; target: MultiAddress; amount: bigint } }
  /**
   * Move some assets from one account to another.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `source`: The account to be debited.
   * - `dest`: The account to be credited.
   * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
   * `dest`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the `source` balance above zero but
   * below the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
   * `dest`.
   **/
  | { name: 'ForceTransfer'; params: { id: number; source: MultiAddress; dest: MultiAddress; amount: bigint } }
  /**
   * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
   * must already exist as an entry in `Account`s of the asset. If you want to freeze an
   * account that does not have an entry, use `touch_other` first.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `who`: The account to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Freeze'; params: { id: number; who: MultiAddress } }
  /**
   * Allow unprivileged transfers to and from an account again.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `who`: The account to be unfrozen.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Thaw'; params: { id: number; who: MultiAddress } }
  /**
   * Disallow further unprivileged transfers for the asset class.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'FreezeAsset'; params: { id: number } }
  /**
   * Allow unprivileged transfers for the asset again.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to be thawed.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ThawAsset'; params: { id: number } }
  /**
   * Change the Owner of an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The new Owner of this asset.
   *
   * Emits `OwnerChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'TransferOwnership'; params: { id: number; owner: MultiAddress } }
  /**
   * Change the Issuer, Admin and Freezer of an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `issuer`: The new Issuer of this asset.
   * - `admin`: The new Admin of this asset.
   * - `freezer`: The new Freezer of this asset.
   *
   * Emits `TeamChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetTeam'; params: { id: number; issuer: MultiAddress; admin: MultiAddress; freezer: MultiAddress } }
  /**
   * Set the metadata for an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * Funds of sender are reserved according to the formula:
   * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
   * account any already reserved funds.
   *
   * - `id`: The identifier of the asset to update.
   * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
   * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
   * - `decimals`: The number of decimals this asset uses to represent one unit.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetMetadata'; params: { id: number; name: Bytes; symbol: Bytes; decimals: number } }
  /**
   * Clear the metadata for an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * Any deposit is freed for the asset owner.
   *
   * - `id`: The identifier of the asset to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearMetadata'; params: { id: number } }
  /**
   * Force the metadata for an asset to some value.
   *
   * Origin must be ForceOrigin.
   *
   * Any deposit is left alone.
   *
   * - `id`: The identifier of the asset to update.
   * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
   * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
   * - `decimals`: The number of decimals this asset uses to represent one unit.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
   **/
  | {
      name: 'ForceSetMetadata';
      params: { id: number; name: Bytes; symbol: Bytes; decimals: number; isFrozen: boolean };
    }
  /**
   * Clear the metadata for an asset.
   *
   * Origin must be ForceOrigin.
   *
   * Any deposit is returned.
   *
   * - `id`: The identifier of the asset to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceClearMetadata'; params: { id: number } }
  /**
   * Alter the attributes of a given asset.
   *
   * Origin must be `ForceOrigin`.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The new Owner of this asset.
   * - `issuer`: The new Issuer of this asset.
   * - `admin`: The new Admin of this asset.
   * - `freezer`: The new Freezer of this asset.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
   * value to account for the state bloat associated with its balance storage. If set to
   * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
   * an ED in the Balances pallet or whatever else is used to control user-account state
   * growth).
   * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
   * instructions.
   *
   * Emits `AssetStatusChanged` with the identity of the asset.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'ForceAssetStatus';
      params: {
        id: number;
        owner: MultiAddress;
        issuer: MultiAddress;
        admin: MultiAddress;
        freezer: MultiAddress;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * Approve an amount of asset for transfer by a delegated third-party account.
   *
   * Origin must be Signed.
   *
   * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
   * for the purpose of holding the approval. If some non-zero amount of assets is already
   * approved from signing account to `delegate`, then it is topped up or unreserved to
   * meet the right value.
   *
   * NOTE: The signing account does not need to own `amount` of assets at the point of
   * making this call.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account to delegate permission to transfer asset.
   * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
   * already an approval in place, then this acts additively.
   *
   * Emits `ApprovedTransfer` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ApproveTransfer'; params: { id: number; delegate: MultiAddress; amount: bigint } }
  /**
   * Cancel all of some asset approved for delegated transfer by a third-party account.
   *
   * Origin must be Signed and there must be an approval in place between signer and
   * `delegate`.
   *
   * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account delegated permission to transfer asset.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'CancelApproval'; params: { id: number; delegate: MultiAddress } }
  /**
   * Cancel all of some asset approved for delegated transfer by a third-party account.
   *
   * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
   * account of the asset `id`.
   *
   * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account delegated permission to transfer asset.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCancelApproval'; params: { id: number; owner: MultiAddress; delegate: MultiAddress } }
  /**
   * Transfer some asset balance from a previously delegated account to some third-party
   * account.
   *
   * Origin must be Signed and there must be an approval in place by the `owner` to the
   * signer.
   *
   * If the entire amount approved for transfer is transferred, then any deposit previously
   * reserved by `approve_transfer` is unreserved.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The account which previously approved for a transfer of at least `amount` and
   * from which the asset balance will be withdrawn.
   * - `destination`: The account to which the asset balance of `amount` will be transferred.
   * - `amount`: The amount of assets to transfer.
   *
   * Emits `TransferredApproved` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'TransferApproved'; params: { id: number; owner: MultiAddress; destination: MultiAddress; amount: bigint } }
  /**
   * Create an asset account for non-provider assets.
   *
   * A deposit will be taken from the signer account.
   *
   * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
   * to be taken.
   * - `id`: The identifier of the asset for the account to be created.
   *
   * Emits `Touched` event when successful.
   **/
  | { name: 'Touch'; params: { id: number } }
  /**
   * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
   * account.
   *
   * The origin must be Signed.
   *
   * - `id`: The identifier of the asset for which the caller would like the deposit
   * refunded.
   * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
   *
   * Emits `Refunded` event when successful.
   **/
  | { name: 'Refund'; params: { id: number; allowBurn: boolean } }
  /**
   * Sets the minimum balance of an asset.
   *
   * Only works if there aren't any accounts that are holding the asset or if
   * the new value of `min_balance` is less than the old one.
   *
   * Origin must be Signed and the sender has to be the Owner of the
   * asset `id`.
   *
   * - `id`: The identifier of the asset.
   * - `min_balance`: The new value of `min_balance`.
   *
   * Emits `AssetMinBalanceChanged` event when successful.
   **/
  | { name: 'SetMinBalance'; params: { id: number; minBalance: bigint } }
  /**
   * Create an asset account for `who`.
   *
   * A deposit will be taken from the signer account.
   *
   * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
   * must have sufficient funds for a deposit to be taken.
   * - `id`: The identifier of the asset for the account to be created.
   * - `who`: The account to be created.
   *
   * Emits `Touched` event when successful.
   **/
  | { name: 'TouchOther'; params: { id: number; who: MultiAddress } }
  /**
   * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
   *
   * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
   * order to burn a non-zero balance of the asset, the caller must be the account and should
   * use `refund`.
   *
   * - `id`: The identifier of the asset for the account holding a deposit.
   * - `who`: The account to refund.
   *
   * Emits `Refunded` event when successful.
   **/
  | { name: 'RefundOther'; params: { id: number; who: MultiAddress } }
  /**
   * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the account's asset.
   * - `who`: The account to be unblocked.
   *
   * Emits `Blocked`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Block'; params: { id: number; who: MultiAddress } };

export type PalletAssetsCallLike =
  /**
   * Issue a new class of fungible assets from a public origin.
   *
   * This new asset class has no assets initially and its owner is the origin.
   *
   * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
   *
   * Funds of sender are reserved by `AssetDeposit`.
   *
   * Parameters:
   * - `id`: The identifier of the new asset. This must not be currently in use to identify
   * an existing asset.
   * - `admin`: The admin of this class of assets. The admin is the initial address of each
   * member of the asset class's admin team.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   *
   * Emits `Created` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Create'; params: { id: number; admin: MultiAddressLike; minBalance: bigint } }
  /**
   * Issue a new class of fungible assets from a privileged origin.
   *
   * This new asset class has no assets initially.
   *
   * The origin must conform to `ForceOrigin`.
   *
   * Unlike `create`, no funds are reserved.
   *
   * - `id`: The identifier of the new asset. This must not be currently in use to identify
   * an existing asset.
   * - `owner`: The owner of this class of assets. The owner has full superuser permissions
   * over this asset, but may later change and configure the permissions using
   * `transfer_ownership` and `set_team`.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   *
   * Emits `ForceCreated` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCreate'; params: { id: number; owner: MultiAddressLike; isSufficient: boolean; minBalance: bigint } }
  /**
   * Start the process of destroying a fungible asset class.
   *
   * `start_destroy` is the first in a series of extrinsics that should be called, to allow
   * destruction of an asset class.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * The asset class must be frozen before calling `start_destroy`.
   **/
  | { name: 'StartDestroy'; params: { id: number } }
  /**
   * Destroy all accounts associated with a given asset.
   *
   * `destroy_accounts` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state.
   *
   * Due to weight restrictions, this function may need to be called multiple times to fully
   * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each call emits the `Event::DestroyedAccounts` event.
   **/
  | { name: 'DestroyAccounts'; params: { id: number } }
  /**
   * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
   *
   * `destroy_approvals` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state.
   *
   * Due to weight restrictions, this function may need to be called multiple times to fully
   * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each call emits the `Event::DestroyedApprovals` event.
   **/
  | { name: 'DestroyApprovals'; params: { id: number } }
  /**
   * Complete destroying asset and unreserve currency.
   *
   * `finish_destroy` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
   * hand.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each successful call emits the `Event::Destroyed` event.
   **/
  | { name: 'FinishDestroy'; params: { id: number } }
  /**
   * Mint assets of a particular class.
   *
   * The origin must be Signed and the sender must be the Issuer of the asset `id`.
   *
   * - `id`: The identifier of the asset to have some amount minted.
   * - `beneficiary`: The account to be credited with the minted assets.
   * - `amount`: The amount of the asset to be minted.
   *
   * Emits `Issued` event when successful.
   *
   * Weight: `O(1)`
   * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
   **/
  | { name: 'Mint'; params: { id: number; beneficiary: MultiAddressLike; amount: bigint } }
  /**
   * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
   *
   * Origin must be Signed and the sender should be the Manager of the asset `id`.
   *
   * Bails with `NoAccount` if the `who` is already dead.
   *
   * - `id`: The identifier of the asset to have some amount burned.
   * - `who`: The account to be debited from.
   * - `amount`: The maximum amount by which `who`'s balance should be reduced.
   *
   * Emits `Burned` with the actual amount burned. If this takes the balance to below the
   * minimum for the asset, then the amount burned is increased to take it to zero.
   *
   * Weight: `O(1)`
   * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
   **/
  | { name: 'Burn'; params: { id: number; who: MultiAddressLike; amount: bigint } }
  /**
   * Move some assets from the sender account to another.
   *
   * Origin must be Signed.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `target`: The account to be credited.
   * - `amount`: The amount by which the sender's balance of assets should be reduced and
   * `target`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the sender balance above zero but below
   * the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
   * `target`.
   **/
  | { name: 'Transfer'; params: { id: number; target: MultiAddressLike; amount: bigint } }
  /**
   * Move some assets from the sender account to another, keeping the sender account alive.
   *
   * Origin must be Signed.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `target`: The account to be credited.
   * - `amount`: The amount by which the sender's balance of assets should be reduced and
   * `target`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the sender balance above zero but below
   * the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
   * `target`.
   **/
  | { name: 'TransferKeepAlive'; params: { id: number; target: MultiAddressLike; amount: bigint } }
  /**
   * Move some assets from one account to another.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `source`: The account to be debited.
   * - `dest`: The account to be credited.
   * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
   * `dest`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the `source` balance above zero but
   * below the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
   * `dest`.
   **/
  | { name: 'ForceTransfer'; params: { id: number; source: MultiAddressLike; dest: MultiAddressLike; amount: bigint } }
  /**
   * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
   * must already exist as an entry in `Account`s of the asset. If you want to freeze an
   * account that does not have an entry, use `touch_other` first.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `who`: The account to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Freeze'; params: { id: number; who: MultiAddressLike } }
  /**
   * Allow unprivileged transfers to and from an account again.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `who`: The account to be unfrozen.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Thaw'; params: { id: number; who: MultiAddressLike } }
  /**
   * Disallow further unprivileged transfers for the asset class.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'FreezeAsset'; params: { id: number } }
  /**
   * Allow unprivileged transfers for the asset again.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to be thawed.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ThawAsset'; params: { id: number } }
  /**
   * Change the Owner of an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The new Owner of this asset.
   *
   * Emits `OwnerChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'TransferOwnership'; params: { id: number; owner: MultiAddressLike } }
  /**
   * Change the Issuer, Admin and Freezer of an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `issuer`: The new Issuer of this asset.
   * - `admin`: The new Admin of this asset.
   * - `freezer`: The new Freezer of this asset.
   *
   * Emits `TeamChanged`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'SetTeam';
      params: { id: number; issuer: MultiAddressLike; admin: MultiAddressLike; freezer: MultiAddressLike };
    }
  /**
   * Set the metadata for an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * Funds of sender are reserved according to the formula:
   * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
   * account any already reserved funds.
   *
   * - `id`: The identifier of the asset to update.
   * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
   * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
   * - `decimals`: The number of decimals this asset uses to represent one unit.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetMetadata'; params: { id: number; name: BytesLike; symbol: BytesLike; decimals: number } }
  /**
   * Clear the metadata for an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * Any deposit is freed for the asset owner.
   *
   * - `id`: The identifier of the asset to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearMetadata'; params: { id: number } }
  /**
   * Force the metadata for an asset to some value.
   *
   * Origin must be ForceOrigin.
   *
   * Any deposit is left alone.
   *
   * - `id`: The identifier of the asset to update.
   * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
   * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
   * - `decimals`: The number of decimals this asset uses to represent one unit.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
   **/
  | {
      name: 'ForceSetMetadata';
      params: { id: number; name: BytesLike; symbol: BytesLike; decimals: number; isFrozen: boolean };
    }
  /**
   * Clear the metadata for an asset.
   *
   * Origin must be ForceOrigin.
   *
   * Any deposit is returned.
   *
   * - `id`: The identifier of the asset to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceClearMetadata'; params: { id: number } }
  /**
   * Alter the attributes of a given asset.
   *
   * Origin must be `ForceOrigin`.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The new Owner of this asset.
   * - `issuer`: The new Issuer of this asset.
   * - `admin`: The new Admin of this asset.
   * - `freezer`: The new Freezer of this asset.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
   * value to account for the state bloat associated with its balance storage. If set to
   * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
   * an ED in the Balances pallet or whatever else is used to control user-account state
   * growth).
   * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
   * instructions.
   *
   * Emits `AssetStatusChanged` with the identity of the asset.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'ForceAssetStatus';
      params: {
        id: number;
        owner: MultiAddressLike;
        issuer: MultiAddressLike;
        admin: MultiAddressLike;
        freezer: MultiAddressLike;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * Approve an amount of asset for transfer by a delegated third-party account.
   *
   * Origin must be Signed.
   *
   * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
   * for the purpose of holding the approval. If some non-zero amount of assets is already
   * approved from signing account to `delegate`, then it is topped up or unreserved to
   * meet the right value.
   *
   * NOTE: The signing account does not need to own `amount` of assets at the point of
   * making this call.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account to delegate permission to transfer asset.
   * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
   * already an approval in place, then this acts additively.
   *
   * Emits `ApprovedTransfer` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ApproveTransfer'; params: { id: number; delegate: MultiAddressLike; amount: bigint } }
  /**
   * Cancel all of some asset approved for delegated transfer by a third-party account.
   *
   * Origin must be Signed and there must be an approval in place between signer and
   * `delegate`.
   *
   * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account delegated permission to transfer asset.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'CancelApproval'; params: { id: number; delegate: MultiAddressLike } }
  /**
   * Cancel all of some asset approved for delegated transfer by a third-party account.
   *
   * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
   * account of the asset `id`.
   *
   * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account delegated permission to transfer asset.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCancelApproval'; params: { id: number; owner: MultiAddressLike; delegate: MultiAddressLike } }
  /**
   * Transfer some asset balance from a previously delegated account to some third-party
   * account.
   *
   * Origin must be Signed and there must be an approval in place by the `owner` to the
   * signer.
   *
   * If the entire amount approved for transfer is transferred, then any deposit previously
   * reserved by `approve_transfer` is unreserved.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The account which previously approved for a transfer of at least `amount` and
   * from which the asset balance will be withdrawn.
   * - `destination`: The account to which the asset balance of `amount` will be transferred.
   * - `amount`: The amount of assets to transfer.
   *
   * Emits `TransferredApproved` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'TransferApproved';
      params: { id: number; owner: MultiAddressLike; destination: MultiAddressLike; amount: bigint };
    }
  /**
   * Create an asset account for non-provider assets.
   *
   * A deposit will be taken from the signer account.
   *
   * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
   * to be taken.
   * - `id`: The identifier of the asset for the account to be created.
   *
   * Emits `Touched` event when successful.
   **/
  | { name: 'Touch'; params: { id: number } }
  /**
   * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
   * account.
   *
   * The origin must be Signed.
   *
   * - `id`: The identifier of the asset for which the caller would like the deposit
   * refunded.
   * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
   *
   * Emits `Refunded` event when successful.
   **/
  | { name: 'Refund'; params: { id: number; allowBurn: boolean } }
  /**
   * Sets the minimum balance of an asset.
   *
   * Only works if there aren't any accounts that are holding the asset or if
   * the new value of `min_balance` is less than the old one.
   *
   * Origin must be Signed and the sender has to be the Owner of the
   * asset `id`.
   *
   * - `id`: The identifier of the asset.
   * - `min_balance`: The new value of `min_balance`.
   *
   * Emits `AssetMinBalanceChanged` event when successful.
   **/
  | { name: 'SetMinBalance'; params: { id: number; minBalance: bigint } }
  /**
   * Create an asset account for `who`.
   *
   * A deposit will be taken from the signer account.
   *
   * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
   * must have sufficient funds for a deposit to be taken.
   * - `id`: The identifier of the asset for the account to be created.
   * - `who`: The account to be created.
   *
   * Emits `Touched` event when successful.
   **/
  | { name: 'TouchOther'; params: { id: number; who: MultiAddressLike } }
  /**
   * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
   *
   * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
   * order to burn a non-zero balance of the asset, the caller must be the account and should
   * use `refund`.
   *
   * - `id`: The identifier of the asset for the account holding a deposit.
   * - `who`: The account to refund.
   *
   * Emits `Refunded` event when successful.
   **/
  | { name: 'RefundOther'; params: { id: number; who: MultiAddressLike } }
  /**
   * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the account's asset.
   * - `who`: The account to be unblocked.
   *
   * Emits `Blocked`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Block'; params: { id: number; who: MultiAddressLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBeefyCall =
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: { equivocationProof: SpConsensusBeefyEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   *
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: { equivocationProof: SpConsensusBeefyEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Reset BEEFY consensus by setting a new BEEFY genesis at `delay_in_blocks` blocks in the
   * future.
   *
   * Note: `delay_in_blocks` has to be at least 1.
   **/
  | { name: 'SetNewGenesis'; params: { delayInBlocks: number } };

export type PalletBeefyCallLike =
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: { equivocationProof: SpConsensusBeefyEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   *
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: { equivocationProof: SpConsensusBeefyEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Reset BEEFY consensus by setting a new BEEFY genesis at `delay_in_blocks` blocks in the
   * future.
   *
   * Note: `delay_in_blocks` has to be at least 1.
   **/
  | { name: 'SetNewGenesis'; params: { delayInBlocks: number } };

export type SpConsensusBeefyEquivocationProof = {
  first: SpConsensusBeefyVoteMessage;
  second: SpConsensusBeefyVoteMessage;
};

export type SpConsensusBeefyEcdsaCryptoSignature = SpCoreEcdsaSignature;

export type SpConsensusBeefyVoteMessage = {
  commitment: SpConsensusBeefyCommitment;
  id: SpConsensusBeefyEcdsaCryptoPublic;
  signature: SpConsensusBeefyEcdsaCryptoSignature;
};

export type SpConsensusBeefyCommitment = {
  payload: SpConsensusBeefyPayload;
  blockNumber: number;
  validatorSetId: bigint;
};

export type SpConsensusBeefyPayload = Array<[FixedBytes<2>, Bytes]>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletLotteryCall =
  /**
   * Buy a ticket to enter the lottery.
   *
   * This extrinsic acts as a passthrough function for `call`. In all
   * situations where `call` alone would succeed, this extrinsic should
   * succeed.
   *
   * If `call` is successful, then we will attempt to purchase a ticket,
   * which may fail silently. To detect success of a ticket purchase, you
   * should listen for the `TicketBought` event.
   *
   * This extrinsic must be called by a signed origin.
   **/
  | { name: 'BuyTicket'; params: { call: KitchensinkRuntimeRuntimeCall } }
  /**
   * Set calls in storage which can be used to purchase a lottery ticket.
   *
   * This function only matters if you use the `ValidateCall` implementation
   * provided by this pallet, which uses storage to determine the valid calls.
   *
   * This extrinsic must be called by the Manager origin.
   **/
  | { name: 'SetCalls'; params: { calls: Array<KitchensinkRuntimeRuntimeCall> } }
  /**
   * Start a lottery using the provided configuration.
   *
   * This extrinsic must be called by the `ManagerOrigin`.
   *
   * Parameters:
   *
   * * `price`: The cost of a single ticket.
   * * `length`: How long the lottery should run for starting at the current block.
   * * `delay`: How long after the lottery end we should wait before picking a winner.
   * * `repeat`: If the lottery should repeat when completed.
   **/
  | { name: 'StartLottery'; params: { price: bigint; length: number; delay: number; repeat: boolean } }
  /**
   * If a lottery is repeating, you can use this to stop the repeat.
   * The lottery will continue to run to completion.
   *
   * This extrinsic must be called by the `ManagerOrigin`.
   **/
  | { name: 'StopRepeat' };

export type PalletLotteryCallLike =
  /**
   * Buy a ticket to enter the lottery.
   *
   * This extrinsic acts as a passthrough function for `call`. In all
   * situations where `call` alone would succeed, this extrinsic should
   * succeed.
   *
   * If `call` is successful, then we will attempt to purchase a ticket,
   * which may fail silently. To detect success of a ticket purchase, you
   * should listen for the `TicketBought` event.
   *
   * This extrinsic must be called by a signed origin.
   **/
  | { name: 'BuyTicket'; params: { call: KitchensinkRuntimeRuntimeCallLike } }
  /**
   * Set calls in storage which can be used to purchase a lottery ticket.
   *
   * This function only matters if you use the `ValidateCall` implementation
   * provided by this pallet, which uses storage to determine the valid calls.
   *
   * This extrinsic must be called by the Manager origin.
   **/
  | { name: 'SetCalls'; params: { calls: Array<KitchensinkRuntimeRuntimeCallLike> } }
  /**
   * Start a lottery using the provided configuration.
   *
   * This extrinsic must be called by the `ManagerOrigin`.
   *
   * Parameters:
   *
   * * `price`: The cost of a single ticket.
   * * `length`: How long the lottery should run for starting at the current block.
   * * `delay`: How long after the lottery end we should wait before picking a winner.
   * * `repeat`: If the lottery should repeat when completed.
   **/
  | { name: 'StartLottery'; params: { price: bigint; length: number; delay: number; repeat: boolean } }
  /**
   * If a lottery is repeating, you can use this to stop the repeat.
   * The lottery will continue to run to completion.
   *
   * This extrinsic must be called by the `ManagerOrigin`.
   **/
  | { name: 'StopRepeat' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletNisCall =
  /**
   * Place a bid.
   *
   * Origin must be Signed, and account must have at least `amount` in free balance.
   *
   * - `amount`: The amount of the bid; these funds will be reserved, and if/when
   * consolidated, removed. Must be at least `MinBid`.
   * - `duration`: The number of periods before which the newly consolidated bid may be
   * thawed. Must be greater than 1 and no more than `QueueCount`.
   *
   * Complexities:
   * - `Queues[duration].len()` (just take max).
   **/
  | { name: 'PlaceBid'; params: { amount: bigint; duration: number } }
  /**
   * Retract a previously placed bid.
   *
   * Origin must be Signed, and the account should have previously issued a still-active bid
   * of `amount` for `duration`.
   *
   * - `amount`: The amount of the previous bid.
   * - `duration`: The duration of the previous bid.
   **/
  | { name: 'RetractBid'; params: { amount: bigint; duration: number } }
  /**
   * Ensure we have sufficient funding for all potential payouts.
   *
   * - `origin`: Must be accepted by `FundOrigin`.
   **/
  | { name: 'FundDeficit' }
  /**
   * Reduce or remove an outstanding receipt, placing the according proportion of funds into
   * the account of the owner.
   *
   * - `origin`: Must be Signed and the account must be the owner of the receipt `index` as
   * well as any fungible counterpart.
   * - `index`: The index of the receipt.
   * - `portion`: If `Some`, then only the given portion of the receipt should be thawed. If
   * `None`, then all of it should be.
   **/
  | { name: 'ThawPrivate'; params: { index: number; maybeProportion?: Perquintill | undefined } }
  /**
   * Reduce or remove an outstanding receipt, placing the according proportion of funds into
   * the account of the owner.
   *
   * - `origin`: Must be Signed and the account must be the owner of the fungible counterpart
   * for receipt `index`.
   * - `index`: The index of the receipt.
   **/
  | { name: 'ThawCommunal'; params: { index: number } }
  /**
   * Make a private receipt communal and create fungible counterparts for its owner.
   **/
  | { name: 'Communify'; params: { index: number } }
  /**
   * Make a communal receipt private and burn fungible counterparts from its owner.
   **/
  | { name: 'Privatize'; params: { index: number } };

export type PalletNisCallLike =
  /**
   * Place a bid.
   *
   * Origin must be Signed, and account must have at least `amount` in free balance.
   *
   * - `amount`: The amount of the bid; these funds will be reserved, and if/when
   * consolidated, removed. Must be at least `MinBid`.
   * - `duration`: The number of periods before which the newly consolidated bid may be
   * thawed. Must be greater than 1 and no more than `QueueCount`.
   *
   * Complexities:
   * - `Queues[duration].len()` (just take max).
   **/
  | { name: 'PlaceBid'; params: { amount: bigint; duration: number } }
  /**
   * Retract a previously placed bid.
   *
   * Origin must be Signed, and the account should have previously issued a still-active bid
   * of `amount` for `duration`.
   *
   * - `amount`: The amount of the previous bid.
   * - `duration`: The duration of the previous bid.
   **/
  | { name: 'RetractBid'; params: { amount: bigint; duration: number } }
  /**
   * Ensure we have sufficient funding for all potential payouts.
   *
   * - `origin`: Must be accepted by `FundOrigin`.
   **/
  | { name: 'FundDeficit' }
  /**
   * Reduce or remove an outstanding receipt, placing the according proportion of funds into
   * the account of the owner.
   *
   * - `origin`: Must be Signed and the account must be the owner of the receipt `index` as
   * well as any fungible counterpart.
   * - `index`: The index of the receipt.
   * - `portion`: If `Some`, then only the given portion of the receipt should be thawed. If
   * `None`, then all of it should be.
   **/
  | { name: 'ThawPrivate'; params: { index: number; maybeProportion?: Perquintill | undefined } }
  /**
   * Reduce or remove an outstanding receipt, placing the according proportion of funds into
   * the account of the owner.
   *
   * - `origin`: Must be Signed and the account must be the owner of the fungible counterpart
   * for receipt `index`.
   * - `index`: The index of the receipt.
   **/
  | { name: 'ThawCommunal'; params: { index: number } }
  /**
   * Make a private receipt communal and create fungible counterparts for its owner.
   **/
  | { name: 'Communify'; params: { index: number } }
  /**
   * Make a communal receipt private and burn fungible counterparts from its owner.
   **/
  | { name: 'Privatize'; params: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUniquesCall =
  /**
   * Issue a new collection of non-fungible items from a public origin.
   *
   * This new collection has no items initially and its owner is the origin.
   *
   * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
   *
   * `ItemDeposit` funds of sender are reserved.
   *
   * Parameters:
   * - `collection`: The identifier of the new collection. This must not be currently in use.
   * - `admin`: The admin of this collection. The admin is the initial address of each
   * member of the collection's admin team.
   *
   * Emits `Created` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Create'; params: { collection: number; admin: MultiAddress } }
  /**
   * Issue a new collection of non-fungible items from a privileged origin.
   *
   * This new collection has no items initially.
   *
   * The origin must conform to `ForceOrigin`.
   *
   * Unlike `create`, no funds are reserved.
   *
   * - `collection`: The identifier of the new item. This must not be currently in use.
   * - `owner`: The owner of this collection of items. The owner has full superuser
   * permissions
   * over this item, but may later change and configure the permissions using
   * `transfer_ownership` and `set_team`.
   *
   * Emits `ForceCreated` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCreate'; params: { collection: number; owner: MultiAddress; freeHolding: boolean } }
  /**
   * Destroy a collection of fungible items.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be the
   * owner of the `collection`.
   *
   * - `collection`: The identifier of the collection to be destroyed.
   * - `witness`: Information on the items minted in the collection. This must be
   * correct.
   *
   * Emits `Destroyed` event when successful.
   *
   * Weight: `O(n + m)` where:
   * - `n = witness.items`
   * - `m = witness.item_metadatas`
   * - `a = witness.attributes`
   **/
  | { name: 'Destroy'; params: { collection: number; witness: PalletUniquesDestroyWitness } }
  /**
   * Mint an item of a particular collection.
   *
   * The origin must be Signed and the sender must be the Issuer of the `collection`.
   *
   * - `collection`: The collection of the item to be minted.
   * - `item`: The item value of the item to be minted.
   * - `beneficiary`: The initial owner of the minted item.
   *
   * Emits `Issued` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Mint'; params: { collection: number; item: number; owner: MultiAddress } }
  /**
   * Destroy a single item.
   *
   * Origin must be Signed and the signing account must be either:
   * - the Admin of the `collection`;
   * - the Owner of the `item`;
   *
   * - `collection`: The collection of the item to be burned.
   * - `item`: The item of the item to be burned.
   * - `check_owner`: If `Some` then the operation will fail with `WrongOwner` unless the
   * item is owned by this value.
   *
   * Emits `Burned` with the actual amount burned.
   *
   * Weight: `O(1)`
   * Modes: `check_owner.is_some()`.
   **/
  | { name: 'Burn'; params: { collection: number; item: number; checkOwner?: MultiAddress | undefined } }
  /**
   * Move an item from the sender account to another.
   *
   * This resets the approved account of the item.
   *
   * Origin must be Signed and the signing account must be either:
   * - the Admin of the `collection`;
   * - the Owner of the `item`;
   * - the approved delegate for the `item` (in this case, the approval is reset).
   *
   * Arguments:
   * - `collection`: The collection of the item to be transferred.
   * - `item`: The item of the item to be transferred.
   * - `dest`: The account to receive ownership of the item.
   *
   * Emits `Transferred`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Transfer'; params: { collection: number; item: number; dest: MultiAddress } }
  /**
   * Reevaluate the deposits on some items.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection to be frozen.
   * - `items`: The items of the collection whose deposits will be reevaluated.
   *
   * NOTE: This exists as a best-effort function. Any items which are unknown or
   * in the case that the owner account does not have reservable funds to pay for a
   * deposit increase are ignored. Generally the owner isn't going to call this on items
   * whose existing deposit is less than the refreshed deposit as it would only cost them,
   * so it's of little consequence.
   *
   * It will still return an error in the case that the collection is unknown of the signer
   * is not permitted to call it.
   *
   * Weight: `O(items.len())`
   **/
  | { name: 'Redeposit'; params: { collection: number; items: Array<number> } }
  /**
   * Disallow further unprivileged transfer of an item.
   *
   * Origin must be Signed and the sender should be the Freezer of the `collection`.
   *
   * - `collection`: The collection of the item to be frozen.
   * - `item`: The item of the item to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Freeze'; params: { collection: number; item: number } }
  /**
   * Re-allow unprivileged transfer of an item.
   *
   * Origin must be Signed and the sender should be the Freezer of the `collection`.
   *
   * - `collection`: The collection of the item to be thawed.
   * - `item`: The item of the item to be thawed.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Thaw'; params: { collection: number; item: number } }
  /**
   * Disallow further unprivileged transfers for a whole collection.
   *
   * Origin must be Signed and the sender should be the Freezer of the `collection`.
   *
   * - `collection`: The collection to be frozen.
   *
   * Emits `CollectionFrozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'FreezeCollection'; params: { collection: number } }
  /**
   * Re-allow unprivileged transfers for a whole collection.
   *
   * Origin must be Signed and the sender should be the Admin of the `collection`.
   *
   * - `collection`: The collection to be thawed.
   *
   * Emits `CollectionThawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ThawCollection'; params: { collection: number } }
  /**
   * Change the Owner of a collection.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection whose owner should be changed.
   * - `owner`: The new Owner of this collection. They must have called
   * `set_accept_ownership` with `collection` in order for this operation to succeed.
   *
   * Emits `OwnerChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'TransferOwnership'; params: { collection: number; newOwner: MultiAddress } }
  /**
   * Change the Issuer, Admin and Freezer of a collection.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection whose team should be changed.
   * - `issuer`: The new Issuer of this collection.
   * - `admin`: The new Admin of this collection.
   * - `freezer`: The new Freezer of this collection.
   *
   * Emits `TeamChanged`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'SetTeam';
      params: { collection: number; issuer: MultiAddress; admin: MultiAddress; freezer: MultiAddress };
    }
  /**
   * Approve an item to be transferred by a delegated third-party account.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be
   * either the owner of the `item` or the admin of the collection.
   *
   * - `collection`: The collection of the item to be approved for delegated transfer.
   * - `item`: The item of the item to be approved for delegated transfer.
   * - `delegate`: The account to delegate permission to transfer the item.
   *
   * Important NOTE: The `approved` account gets reset after each transfer.
   *
   * Emits `ApprovedTransfer` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ApproveTransfer'; params: { collection: number; item: number; delegate: MultiAddress } }
  /**
   * Cancel the prior approval for the transfer of an item by a delegate.
   *
   * Origin must be either:
   * - the `Force` origin;
   * - `Signed` with the signer being the Admin of the `collection`;
   * - `Signed` with the signer being the Owner of the `item`;
   *
   * Arguments:
   * - `collection`: The collection of the item of whose approval will be cancelled.
   * - `item`: The item of the item of whose approval will be cancelled.
   * - `maybe_check_delegate`: If `Some` will ensure that the given account is the one to
   * which permission of transfer is delegated.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'CancelApproval';
      params: { collection: number; item: number; maybeCheckDelegate?: MultiAddress | undefined };
    }
  /**
   * Alter the attributes of a given item.
   *
   * Origin must be `ForceOrigin`.
   *
   * - `collection`: The identifier of the item.
   * - `owner`: The new Owner of this item.
   * - `issuer`: The new Issuer of this item.
   * - `admin`: The new Admin of this item.
   * - `freezer`: The new Freezer of this item.
   * - `free_holding`: Whether a deposit is taken for holding an item of this collection.
   * - `is_frozen`: Whether this collection is frozen except for permissioned/admin
   * instructions.
   *
   * Emits `ItemStatusChanged` with the identity of the item.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'ForceItemStatus';
      params: {
        collection: number;
        owner: MultiAddress;
        issuer: MultiAddress;
        admin: MultiAddress;
        freezer: MultiAddress;
        freeHolding: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * Set an attribute for a collection or item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `collection`.
   *
   * If the origin is Signed, then funds of signer are reserved according to the formula:
   * `MetadataDepositBase + DepositPerByte * (key.len + value.len)` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the collection whose item's metadata to set.
   * - `maybe_item`: The identifier of the item whose metadata to set.
   * - `key`: The key of the attribute.
   * - `value`: The value to which to set the attribute.
   *
   * Emits `AttributeSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetAttribute'; params: { collection: number; maybeItem?: number | undefined; key: Bytes; value: Bytes } }
  /**
   * Clear an attribute for a collection or item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `collection`.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose item's metadata to clear.
   * - `maybe_item`: The identifier of the item whose metadata to clear.
   * - `key`: The key of the attribute.
   *
   * Emits `AttributeCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearAttribute'; params: { collection: number; maybeItem?: number | undefined; key: Bytes } }
  /**
   * Set the metadata for an item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `collection`.
   *
   * If the origin is Signed, then funds of signer are reserved according to the formula:
   * `MetadataDepositBase + DepositPerByte * data.len` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the collection whose item's metadata to set.
   * - `item`: The identifier of the item whose metadata to set.
   * - `data`: The general information of this item. Limited in length by `StringLimit`.
   * - `is_frozen`: Whether the metadata should be frozen against further changes.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetMetadata'; params: { collection: number; item: number; data: Bytes; isFrozen: boolean } }
  /**
   * Clear the metadata for an item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `item`.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose item's metadata to clear.
   * - `item`: The identifier of the item whose metadata to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearMetadata'; params: { collection: number; item: number } }
  /**
   * Set the metadata for a collection.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
   * the `collection`.
   *
   * If the origin is `Signed`, then funds of signer are reserved according to the formula:
   * `MetadataDepositBase + DepositPerByte * data.len` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the item whose metadata to update.
   * - `data`: The general information of this item. Limited in length by `StringLimit`.
   * - `is_frozen`: Whether the metadata should be frozen against further changes.
   *
   * Emits `CollectionMetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetCollectionMetadata'; params: { collection: number; data: Bytes; isFrozen: boolean } }
  /**
   * Clear the metadata for a collection.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
   * the `collection`.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose metadata to clear.
   *
   * Emits `CollectionMetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearCollectionMetadata'; params: { collection: number } }
  /**
   * Set (or reset) the acceptance of ownership for a particular account.
   *
   * Origin must be `Signed` and if `maybe_collection` is `Some`, then the signer must have a
   * provider reference.
   *
   * - `maybe_collection`: The identifier of the collection whose ownership the signer is
   * willing to accept, or if `None`, an indication that the signer is willing to accept no
   * ownership transferal.
   *
   * Emits `OwnershipAcceptanceChanged`.
   **/
  | { name: 'SetAcceptOwnership'; params: { maybeCollection?: number | undefined } }
  /**
   * Set the maximum amount of items a collection could have.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
   * the `collection`.
   *
   * Note: This function can only succeed once per collection.
   *
   * - `collection`: The identifier of the collection to change.
   * - `max_supply`: The maximum amount of items a collection could have.
   *
   * Emits `CollectionMaxSupplySet` event when successful.
   **/
  | { name: 'SetCollectionMaxSupply'; params: { collection: number; maxSupply: number } }
  /**
   * Set (or reset) the price for an item.
   *
   * Origin must be Signed and must be the owner of the asset `item`.
   *
   * - `collection`: The collection of the item.
   * - `item`: The item to set the price for.
   * - `price`: The price for the item. Pass `None`, to reset the price.
   * - `buyer`: Restricts the buy operation to a specific account.
   *
   * Emits `ItemPriceSet` on success if the price is not `None`.
   * Emits `ItemPriceRemoved` on success if the price is `None`.
   **/
  | {
      name: 'SetPrice';
      params: {
        collection: number;
        item: number;
        price?: bigint | undefined;
        whitelistedBuyer?: MultiAddress | undefined;
      };
    }
  /**
   * Allows to buy an item if it's up for sale.
   *
   * Origin must be Signed and must not be the owner of the `item`.
   *
   * - `collection`: The collection of the item.
   * - `item`: The item the sender wants to buy.
   * - `bid_price`: The price the sender is willing to pay.
   *
   * Emits `ItemBought` on success.
   **/
  | { name: 'BuyItem'; params: { collection: number; item: number; bidPrice: bigint } };

export type PalletUniquesCallLike =
  /**
   * Issue a new collection of non-fungible items from a public origin.
   *
   * This new collection has no items initially and its owner is the origin.
   *
   * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
   *
   * `ItemDeposit` funds of sender are reserved.
   *
   * Parameters:
   * - `collection`: The identifier of the new collection. This must not be currently in use.
   * - `admin`: The admin of this collection. The admin is the initial address of each
   * member of the collection's admin team.
   *
   * Emits `Created` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Create'; params: { collection: number; admin: MultiAddressLike } }
  /**
   * Issue a new collection of non-fungible items from a privileged origin.
   *
   * This new collection has no items initially.
   *
   * The origin must conform to `ForceOrigin`.
   *
   * Unlike `create`, no funds are reserved.
   *
   * - `collection`: The identifier of the new item. This must not be currently in use.
   * - `owner`: The owner of this collection of items. The owner has full superuser
   * permissions
   * over this item, but may later change and configure the permissions using
   * `transfer_ownership` and `set_team`.
   *
   * Emits `ForceCreated` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCreate'; params: { collection: number; owner: MultiAddressLike; freeHolding: boolean } }
  /**
   * Destroy a collection of fungible items.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be the
   * owner of the `collection`.
   *
   * - `collection`: The identifier of the collection to be destroyed.
   * - `witness`: Information on the items minted in the collection. This must be
   * correct.
   *
   * Emits `Destroyed` event when successful.
   *
   * Weight: `O(n + m)` where:
   * - `n = witness.items`
   * - `m = witness.item_metadatas`
   * - `a = witness.attributes`
   **/
  | { name: 'Destroy'; params: { collection: number; witness: PalletUniquesDestroyWitness } }
  /**
   * Mint an item of a particular collection.
   *
   * The origin must be Signed and the sender must be the Issuer of the `collection`.
   *
   * - `collection`: The collection of the item to be minted.
   * - `item`: The item value of the item to be minted.
   * - `beneficiary`: The initial owner of the minted item.
   *
   * Emits `Issued` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Mint'; params: { collection: number; item: number; owner: MultiAddressLike } }
  /**
   * Destroy a single item.
   *
   * Origin must be Signed and the signing account must be either:
   * - the Admin of the `collection`;
   * - the Owner of the `item`;
   *
   * - `collection`: The collection of the item to be burned.
   * - `item`: The item of the item to be burned.
   * - `check_owner`: If `Some` then the operation will fail with `WrongOwner` unless the
   * item is owned by this value.
   *
   * Emits `Burned` with the actual amount burned.
   *
   * Weight: `O(1)`
   * Modes: `check_owner.is_some()`.
   **/
  | { name: 'Burn'; params: { collection: number; item: number; checkOwner?: MultiAddressLike | undefined } }
  /**
   * Move an item from the sender account to another.
   *
   * This resets the approved account of the item.
   *
   * Origin must be Signed and the signing account must be either:
   * - the Admin of the `collection`;
   * - the Owner of the `item`;
   * - the approved delegate for the `item` (in this case, the approval is reset).
   *
   * Arguments:
   * - `collection`: The collection of the item to be transferred.
   * - `item`: The item of the item to be transferred.
   * - `dest`: The account to receive ownership of the item.
   *
   * Emits `Transferred`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Transfer'; params: { collection: number; item: number; dest: MultiAddressLike } }
  /**
   * Reevaluate the deposits on some items.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection to be frozen.
   * - `items`: The items of the collection whose deposits will be reevaluated.
   *
   * NOTE: This exists as a best-effort function. Any items which are unknown or
   * in the case that the owner account does not have reservable funds to pay for a
   * deposit increase are ignored. Generally the owner isn't going to call this on items
   * whose existing deposit is less than the refreshed deposit as it would only cost them,
   * so it's of little consequence.
   *
   * It will still return an error in the case that the collection is unknown of the signer
   * is not permitted to call it.
   *
   * Weight: `O(items.len())`
   **/
  | { name: 'Redeposit'; params: { collection: number; items: Array<number> } }
  /**
   * Disallow further unprivileged transfer of an item.
   *
   * Origin must be Signed and the sender should be the Freezer of the `collection`.
   *
   * - `collection`: The collection of the item to be frozen.
   * - `item`: The item of the item to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Freeze'; params: { collection: number; item: number } }
  /**
   * Re-allow unprivileged transfer of an item.
   *
   * Origin must be Signed and the sender should be the Freezer of the `collection`.
   *
   * - `collection`: The collection of the item to be thawed.
   * - `item`: The item of the item to be thawed.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Thaw'; params: { collection: number; item: number } }
  /**
   * Disallow further unprivileged transfers for a whole collection.
   *
   * Origin must be Signed and the sender should be the Freezer of the `collection`.
   *
   * - `collection`: The collection to be frozen.
   *
   * Emits `CollectionFrozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'FreezeCollection'; params: { collection: number } }
  /**
   * Re-allow unprivileged transfers for a whole collection.
   *
   * Origin must be Signed and the sender should be the Admin of the `collection`.
   *
   * - `collection`: The collection to be thawed.
   *
   * Emits `CollectionThawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ThawCollection'; params: { collection: number } }
  /**
   * Change the Owner of a collection.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection whose owner should be changed.
   * - `owner`: The new Owner of this collection. They must have called
   * `set_accept_ownership` with `collection` in order for this operation to succeed.
   *
   * Emits `OwnerChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'TransferOwnership'; params: { collection: number; newOwner: MultiAddressLike } }
  /**
   * Change the Issuer, Admin and Freezer of a collection.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection whose team should be changed.
   * - `issuer`: The new Issuer of this collection.
   * - `admin`: The new Admin of this collection.
   * - `freezer`: The new Freezer of this collection.
   *
   * Emits `TeamChanged`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'SetTeam';
      params: { collection: number; issuer: MultiAddressLike; admin: MultiAddressLike; freezer: MultiAddressLike };
    }
  /**
   * Approve an item to be transferred by a delegated third-party account.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be
   * either the owner of the `item` or the admin of the collection.
   *
   * - `collection`: The collection of the item to be approved for delegated transfer.
   * - `item`: The item of the item to be approved for delegated transfer.
   * - `delegate`: The account to delegate permission to transfer the item.
   *
   * Important NOTE: The `approved` account gets reset after each transfer.
   *
   * Emits `ApprovedTransfer` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ApproveTransfer'; params: { collection: number; item: number; delegate: MultiAddressLike } }
  /**
   * Cancel the prior approval for the transfer of an item by a delegate.
   *
   * Origin must be either:
   * - the `Force` origin;
   * - `Signed` with the signer being the Admin of the `collection`;
   * - `Signed` with the signer being the Owner of the `item`;
   *
   * Arguments:
   * - `collection`: The collection of the item of whose approval will be cancelled.
   * - `item`: The item of the item of whose approval will be cancelled.
   * - `maybe_check_delegate`: If `Some` will ensure that the given account is the one to
   * which permission of transfer is delegated.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'CancelApproval';
      params: { collection: number; item: number; maybeCheckDelegate?: MultiAddressLike | undefined };
    }
  /**
   * Alter the attributes of a given item.
   *
   * Origin must be `ForceOrigin`.
   *
   * - `collection`: The identifier of the item.
   * - `owner`: The new Owner of this item.
   * - `issuer`: The new Issuer of this item.
   * - `admin`: The new Admin of this item.
   * - `freezer`: The new Freezer of this item.
   * - `free_holding`: Whether a deposit is taken for holding an item of this collection.
   * - `is_frozen`: Whether this collection is frozen except for permissioned/admin
   * instructions.
   *
   * Emits `ItemStatusChanged` with the identity of the item.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'ForceItemStatus';
      params: {
        collection: number;
        owner: MultiAddressLike;
        issuer: MultiAddressLike;
        admin: MultiAddressLike;
        freezer: MultiAddressLike;
        freeHolding: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * Set an attribute for a collection or item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `collection`.
   *
   * If the origin is Signed, then funds of signer are reserved according to the formula:
   * `MetadataDepositBase + DepositPerByte * (key.len + value.len)` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the collection whose item's metadata to set.
   * - `maybe_item`: The identifier of the item whose metadata to set.
   * - `key`: The key of the attribute.
   * - `value`: The value to which to set the attribute.
   *
   * Emits `AttributeSet`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'SetAttribute';
      params: { collection: number; maybeItem?: number | undefined; key: BytesLike; value: BytesLike };
    }
  /**
   * Clear an attribute for a collection or item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `collection`.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose item's metadata to clear.
   * - `maybe_item`: The identifier of the item whose metadata to clear.
   * - `key`: The key of the attribute.
   *
   * Emits `AttributeCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearAttribute'; params: { collection: number; maybeItem?: number | undefined; key: BytesLike } }
  /**
   * Set the metadata for an item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `collection`.
   *
   * If the origin is Signed, then funds of signer are reserved according to the formula:
   * `MetadataDepositBase + DepositPerByte * data.len` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the collection whose item's metadata to set.
   * - `item`: The identifier of the item whose metadata to set.
   * - `data`: The general information of this item. Limited in length by `StringLimit`.
   * - `is_frozen`: Whether the metadata should be frozen against further changes.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetMetadata'; params: { collection: number; item: number; data: BytesLike; isFrozen: boolean } }
  /**
   * Clear the metadata for an item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `item`.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose item's metadata to clear.
   * - `item`: The identifier of the item whose metadata to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearMetadata'; params: { collection: number; item: number } }
  /**
   * Set the metadata for a collection.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
   * the `collection`.
   *
   * If the origin is `Signed`, then funds of signer are reserved according to the formula:
   * `MetadataDepositBase + DepositPerByte * data.len` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the item whose metadata to update.
   * - `data`: The general information of this item. Limited in length by `StringLimit`.
   * - `is_frozen`: Whether the metadata should be frozen against further changes.
   *
   * Emits `CollectionMetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetCollectionMetadata'; params: { collection: number; data: BytesLike; isFrozen: boolean } }
  /**
   * Clear the metadata for a collection.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
   * the `collection`.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose metadata to clear.
   *
   * Emits `CollectionMetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearCollectionMetadata'; params: { collection: number } }
  /**
   * Set (or reset) the acceptance of ownership for a particular account.
   *
   * Origin must be `Signed` and if `maybe_collection` is `Some`, then the signer must have a
   * provider reference.
   *
   * - `maybe_collection`: The identifier of the collection whose ownership the signer is
   * willing to accept, or if `None`, an indication that the signer is willing to accept no
   * ownership transferal.
   *
   * Emits `OwnershipAcceptanceChanged`.
   **/
  | { name: 'SetAcceptOwnership'; params: { maybeCollection?: number | undefined } }
  /**
   * Set the maximum amount of items a collection could have.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
   * the `collection`.
   *
   * Note: This function can only succeed once per collection.
   *
   * - `collection`: The identifier of the collection to change.
   * - `max_supply`: The maximum amount of items a collection could have.
   *
   * Emits `CollectionMaxSupplySet` event when successful.
   **/
  | { name: 'SetCollectionMaxSupply'; params: { collection: number; maxSupply: number } }
  /**
   * Set (or reset) the price for an item.
   *
   * Origin must be Signed and must be the owner of the asset `item`.
   *
   * - `collection`: The collection of the item.
   * - `item`: The item to set the price for.
   * - `price`: The price for the item. Pass `None`, to reset the price.
   * - `buyer`: Restricts the buy operation to a specific account.
   *
   * Emits `ItemPriceSet` on success if the price is not `None`.
   * Emits `ItemPriceRemoved` on success if the price is `None`.
   **/
  | {
      name: 'SetPrice';
      params: {
        collection: number;
        item: number;
        price?: bigint | undefined;
        whitelistedBuyer?: MultiAddressLike | undefined;
      };
    }
  /**
   * Allows to buy an item if it's up for sale.
   *
   * Origin must be Signed and must not be the owner of the `item`.
   *
   * - `collection`: The collection of the item.
   * - `item`: The item the sender wants to buy.
   * - `bid_price`: The price the sender is willing to pay.
   *
   * Emits `ItemBought` on success.
   **/
  | { name: 'BuyItem'; params: { collection: number; item: number; bidPrice: bigint } };

export type PalletUniquesDestroyWitness = { items: number; itemMetadatas: number; attributes: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletNftsCall =
  /**
   * Issue a new collection of non-fungible items from a public origin.
   *
   * This new collection has no items initially and its owner is the origin.
   *
   * The origin must be Signed and the sender must have sufficient funds free.
   *
   * `CollectionDeposit` funds of sender are reserved.
   *
   * Parameters:
   * - `admin`: The admin of this collection. The admin is the initial address of each
   * member of the collection's admin team.
   *
   * Emits `Created` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Create'; params: { admin: MultiAddress; config: PalletNftsCollectionConfig } }
  /**
   * Issue a new collection of non-fungible items from a privileged origin.
   *
   * This new collection has no items initially.
   *
   * The origin must conform to `ForceOrigin`.
   *
   * Unlike `create`, no funds are reserved.
   *
   * - `owner`: The owner of this collection of items. The owner has full superuser
   * permissions over this item, but may later change and configure the permissions using
   * `transfer_ownership` and `set_team`.
   *
   * Emits `ForceCreated` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCreate'; params: { owner: MultiAddress; config: PalletNftsCollectionConfig } }
  /**
   * Destroy a collection of fungible items.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be the
   * owner of the `collection`.
   *
   * NOTE: The collection must have 0 items to be destroyed.
   *
   * - `collection`: The identifier of the collection to be destroyed.
   * - `witness`: Information on the items minted in the collection. This must be
   * correct.
   *
   * Emits `Destroyed` event when successful.
   *
   * Weight: `O(m + c + a)` where:
   * - `m = witness.item_metadatas`
   * - `c = witness.item_configs`
   * - `a = witness.attributes`
   **/
  | { name: 'Destroy'; params: { collection: number; witness: PalletNftsDestroyWitness } }
  /**
   * Mint an item of a particular collection.
   *
   * The origin must be Signed and the sender must comply with the `mint_settings` rules.
   *
   * - `collection`: The collection of the item to be minted.
   * - `item`: An identifier of the new item.
   * - `mint_to`: Account into which the item will be minted.
   * - `witness_data`: When the mint type is `HolderOf(collection_id)`, then the owned
   * item_id from that collection needs to be provided within the witness data object. If
   * the mint price is set, then it should be additionally confirmed in the `witness_data`.
   *
   * Note: the deposit will be taken from the `origin` and not the `owner` of the `item`.
   *
   * Emits `Issued` event when successful.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'Mint';
      params: {
        collection: number;
        item: number;
        mintTo: MultiAddress;
        witnessData?: PalletNftsMintWitness | undefined;
      };
    }
  /**
   * Mint an item of a particular collection from a privileged origin.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be the
   * Issuer of the `collection`.
   *
   * - `collection`: The collection of the item to be minted.
   * - `item`: An identifier of the new item.
   * - `mint_to`: Account into which the item will be minted.
   * - `item_config`: A config of the new item.
   *
   * Emits `Issued` event when successful.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'ForceMint';
      params: { collection: number; item: number; mintTo: MultiAddress; itemConfig: PalletNftsItemConfig };
    }
  /**
   * Destroy a single item.
   *
   * The origin must conform to `ForceOrigin` or must be Signed and the signing account must
   * be the owner of the `item`.
   *
   * - `collection`: The collection of the item to be burned.
   * - `item`: The item to be burned.
   *
   * Emits `Burned`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Burn'; params: { collection: number; item: number } }
  /**
   * Move an item from the sender account to another.
   *
   * Origin must be Signed and the signing account must be either:
   * - the Owner of the `item`;
   * - the approved delegate for the `item` (in this case, the approval is reset).
   *
   * Arguments:
   * - `collection`: The collection of the item to be transferred.
   * - `item`: The item to be transferred.
   * - `dest`: The account to receive ownership of the item.
   *
   * Emits `Transferred`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Transfer'; params: { collection: number; item: number; dest: MultiAddress } }
  /**
   * Re-evaluate the deposits on some items.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection of the items to be reevaluated.
   * - `items`: The items of the collection whose deposits will be reevaluated.
   *
   * NOTE: This exists as a best-effort function. Any items which are unknown or
   * in the case that the owner account does not have reservable funds to pay for a
   * deposit increase are ignored. Generally the owner isn't going to call this on items
   * whose existing deposit is less than the refreshed deposit as it would only cost them,
   * so it's of little consequence.
   *
   * It will still return an error in the case that the collection is unknown or the signer
   * is not permitted to call it.
   *
   * Weight: `O(items.len())`
   **/
  | { name: 'Redeposit'; params: { collection: number; items: Array<number> } }
  /**
   * Disallow further unprivileged transfer of an item.
   *
   * Origin must be Signed and the sender should be the Freezer of the `collection`.
   *
   * - `collection`: The collection of the item to be changed.
   * - `item`: The item to become non-transferable.
   *
   * Emits `ItemTransferLocked`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'LockItemTransfer'; params: { collection: number; item: number } }
  /**
   * Re-allow unprivileged transfer of an item.
   *
   * Origin must be Signed and the sender should be the Freezer of the `collection`.
   *
   * - `collection`: The collection of the item to be changed.
   * - `item`: The item to become transferable.
   *
   * Emits `ItemTransferUnlocked`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'UnlockItemTransfer'; params: { collection: number; item: number } }
  /**
   * Disallows specified settings for the whole collection.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection to be locked.
   * - `lock_settings`: The settings to be locked.
   *
   * Note: it's possible to only lock(set) the setting, but not to unset it.
   *
   * Emits `CollectionLocked`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'LockCollection'; params: { collection: number; lockSettings: PalletNftsBitFlags } }
  /**
   * Change the Owner of a collection.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection whose owner should be changed.
   * - `owner`: The new Owner of this collection. They must have called
   * `set_accept_ownership` with `collection` in order for this operation to succeed.
   *
   * Emits `OwnerChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'TransferOwnership'; params: { collection: number; newOwner: MultiAddress } }
  /**
   * Change the Issuer, Admin and Freezer of a collection.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `collection`.
   *
   * Note: by setting the role to `None` only the `ForceOrigin` will be able to change it
   * after to `Some(account)`.
   *
   * - `collection`: The collection whose team should be changed.
   * - `issuer`: The new Issuer of this collection.
   * - `admin`: The new Admin of this collection.
   * - `freezer`: The new Freezer of this collection.
   *
   * Emits `TeamChanged`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'SetTeam';
      params: {
        collection: number;
        issuer?: MultiAddress | undefined;
        admin?: MultiAddress | undefined;
        freezer?: MultiAddress | undefined;
      };
    }
  /**
   * Change the Owner of a collection.
   *
   * Origin must be `ForceOrigin`.
   *
   * - `collection`: The identifier of the collection.
   * - `owner`: The new Owner of this collection.
   *
   * Emits `OwnerChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCollectionOwner'; params: { collection: number; owner: MultiAddress } }
  /**
   * Change the config of a collection.
   *
   * Origin must be `ForceOrigin`.
   *
   * - `collection`: The identifier of the collection.
   * - `config`: The new config of this collection.
   *
   * Emits `CollectionConfigChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCollectionConfig'; params: { collection: number; config: PalletNftsCollectionConfig } }
  /**
   * Approve an item to be transferred by a delegated third-party account.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `item`.
   *
   * - `collection`: The collection of the item to be approved for delegated transfer.
   * - `item`: The item to be approved for delegated transfer.
   * - `delegate`: The account to delegate permission to transfer the item.
   * - `maybe_deadline`: Optional deadline for the approval. Specified by providing the
   * number of blocks after which the approval will expire
   *
   * Emits `TransferApproved` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'ApproveTransfer';
      params: { collection: number; item: number; delegate: MultiAddress; maybeDeadline?: number | undefined };
    }
  /**
   * Cancel one of the transfer approvals for a specific item.
   *
   * Origin must be either:
   * - the `Force` origin;
   * - `Signed` with the signer being the Owner of the `item`;
   *
   * Arguments:
   * - `collection`: The collection of the item of whose approval will be cancelled.
   * - `item`: The item of the collection of whose approval will be cancelled.
   * - `delegate`: The account that is going to loose their approval.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'CancelApproval'; params: { collection: number; item: number; delegate: MultiAddress } }
  /**
   * Cancel all the approvals of a specific item.
   *
   * Origin must be either:
   * - the `Force` origin;
   * - `Signed` with the signer being the Owner of the `item`;
   *
   * Arguments:
   * - `collection`: The collection of the item of whose approvals will be cleared.
   * - `item`: The item of the collection of whose approvals will be cleared.
   *
   * Emits `AllApprovalsCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearAllTransferApprovals'; params: { collection: number; item: number } }
  /**
   * Disallows changing the metadata or attributes of the item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Admin
   * of the `collection`.
   *
   * - `collection`: The collection if the `item`.
   * - `item`: An item to be locked.
   * - `lock_metadata`: Specifies whether the metadata should be locked.
   * - `lock_attributes`: Specifies whether the attributes in the `CollectionOwner` namespace
   * should be locked.
   *
   * Note: `lock_attributes` affects the attributes in the `CollectionOwner` namespace only.
   * When the metadata or attributes are locked, it won't be possible the unlock them.
   *
   * Emits `ItemPropertiesLocked`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'LockItemProperties';
      params: { collection: number; item: number; lockMetadata: boolean; lockAttributes: boolean };
    }
  /**
   * Set an attribute for a collection or item.
   *
   * Origin must be Signed and must conform to the namespace ruleset:
   * - `CollectionOwner` namespace could be modified by the `collection` Admin only;
   * - `ItemOwner` namespace could be modified by the `maybe_item` owner only. `maybe_item`
   * should be set in that case;
   * - `Account(AccountId)` namespace could be modified only when the `origin` was given a
   * permission to do so;
   *
   * The funds of `origin` are reserved according to the formula:
   * `AttributeDepositBase + DepositPerByte * (key.len + value.len)` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the collection whose item's metadata to set.
   * - `maybe_item`: The identifier of the item whose metadata to set.
   * - `namespace`: Attribute's namespace.
   * - `key`: The key of the attribute.
   * - `value`: The value to which to set the attribute.
   *
   * Emits `AttributeSet`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'SetAttribute';
      params: {
        collection: number;
        maybeItem?: number | undefined;
        namespace: PalletNftsAttributeNamespace;
        key: Bytes;
        value: Bytes;
      };
    }
  /**
   * Force-set an attribute for a collection or item.
   *
   * Origin must be `ForceOrigin`.
   *
   * If the attribute already exists and it was set by another account, the deposit
   * will be returned to the previous owner.
   *
   * - `set_as`: An optional owner of the attribute.
   * - `collection`: The identifier of the collection whose item's metadata to set.
   * - `maybe_item`: The identifier of the item whose metadata to set.
   * - `namespace`: Attribute's namespace.
   * - `key`: The key of the attribute.
   * - `value`: The value to which to set the attribute.
   *
   * Emits `AttributeSet`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'ForceSetAttribute';
      params: {
        setAs?: AccountId32 | undefined;
        collection: number;
        maybeItem?: number | undefined;
        namespace: PalletNftsAttributeNamespace;
        key: Bytes;
        value: Bytes;
      };
    }
  /**
   * Clear an attribute for a collection or item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * attribute.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose item's metadata to clear.
   * - `maybe_item`: The identifier of the item whose metadata to clear.
   * - `namespace`: Attribute's namespace.
   * - `key`: The key of the attribute.
   *
   * Emits `AttributeCleared`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'ClearAttribute';
      params: {
        collection: number;
        maybeItem?: number | undefined;
        namespace: PalletNftsAttributeNamespace;
        key: Bytes;
      };
    }
  /**
   * Approve item's attributes to be changed by a delegated third-party account.
   *
   * Origin must be Signed and must be an owner of the `item`.
   *
   * - `collection`: A collection of the item.
   * - `item`: The item that holds attributes.
   * - `delegate`: The account to delegate permission to change attributes of the item.
   *
   * Emits `ItemAttributesApprovalAdded` on success.
   **/
  | { name: 'ApproveItemAttributes'; params: { collection: number; item: number; delegate: MultiAddress } }
  /**
   * Cancel the previously provided approval to change item's attributes.
   * All the previously set attributes by the `delegate` will be removed.
   *
   * Origin must be Signed and must be an owner of the `item`.
   *
   * - `collection`: Collection that the item is contained within.
   * - `item`: The item that holds attributes.
   * - `delegate`: The previously approved account to remove.
   *
   * Emits `ItemAttributesApprovalRemoved` on success.
   **/
  | {
      name: 'CancelItemAttributesApproval';
      params: {
        collection: number;
        item: number;
        delegate: MultiAddress;
        witness: PalletNftsCancelAttributesApprovalWitness;
      };
    }
  /**
   * Set the metadata for an item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Admin of the
   * `collection`.
   *
   * If the origin is Signed, then funds of signer are reserved according to the formula:
   * `MetadataDepositBase + DepositPerByte * data.len` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the collection whose item's metadata to set.
   * - `item`: The identifier of the item whose metadata to set.
   * - `data`: The general information of this item. Limited in length by `StringLimit`.
   *
   * Emits `ItemMetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetMetadata'; params: { collection: number; item: number; data: Bytes } }
  /**
   * Clear the metadata for an item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Admin of the
   * `collection`.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose item's metadata to clear.
   * - `item`: The identifier of the item whose metadata to clear.
   *
   * Emits `ItemMetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearMetadata'; params: { collection: number; item: number } }
  /**
   * Set the metadata for a collection.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Admin of
   * the `collection`.
   *
   * If the origin is `Signed`, then funds of signer are reserved according to the formula:
   * `MetadataDepositBase + DepositPerByte * data.len` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the item whose metadata to update.
   * - `data`: The general information of this item. Limited in length by `StringLimit`.
   *
   * Emits `CollectionMetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetCollectionMetadata'; params: { collection: number; data: Bytes } }
  /**
   * Clear the metadata for a collection.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Admin of
   * the `collection`.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose metadata to clear.
   *
   * Emits `CollectionMetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearCollectionMetadata'; params: { collection: number } }
  /**
   * Set (or reset) the acceptance of ownership for a particular account.
   *
   * Origin must be `Signed` and if `maybe_collection` is `Some`, then the signer must have a
   * provider reference.
   *
   * - `maybe_collection`: The identifier of the collection whose ownership the signer is
   * willing to accept, or if `None`, an indication that the signer is willing to accept no
   * ownership transferal.
   *
   * Emits `OwnershipAcceptanceChanged`.
   **/
  | { name: 'SetAcceptOwnership'; params: { maybeCollection?: number | undefined } }
  /**
   * Set the maximum number of items a collection could have.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
   * the `collection`.
   *
   * - `collection`: The identifier of the collection to change.
   * - `max_supply`: The maximum number of items a collection could have.
   *
   * Emits `CollectionMaxSupplySet` event when successful.
   **/
  | { name: 'SetCollectionMaxSupply'; params: { collection: number; maxSupply: number } }
  /**
   * Update mint settings.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Issuer
   * of the `collection`.
   *
   * - `collection`: The identifier of the collection to change.
   * - `mint_settings`: The new mint settings.
   *
   * Emits `CollectionMintSettingsUpdated` event when successful.
   **/
  | { name: 'UpdateMintSettings'; params: { collection: number; mintSettings: PalletNftsMintSettings } }
  /**
   * Set (or reset) the price for an item.
   *
   * Origin must be Signed and must be the owner of the `item`.
   *
   * - `collection`: The collection of the item.
   * - `item`: The item to set the price for.
   * - `price`: The price for the item. Pass `None`, to reset the price.
   * - `buyer`: Restricts the buy operation to a specific account.
   *
   * Emits `ItemPriceSet` on success if the price is not `None`.
   * Emits `ItemPriceRemoved` on success if the price is `None`.
   **/
  | {
      name: 'SetPrice';
      params: {
        collection: number;
        item: number;
        price?: bigint | undefined;
        whitelistedBuyer?: MultiAddress | undefined;
      };
    }
  /**
   * Allows to buy an item if it's up for sale.
   *
   * Origin must be Signed and must not be the owner of the `item`.
   *
   * - `collection`: The collection of the item.
   * - `item`: The item the sender wants to buy.
   * - `bid_price`: The price the sender is willing to pay.
   *
   * Emits `ItemBought` on success.
   **/
  | { name: 'BuyItem'; params: { collection: number; item: number; bidPrice: bigint } }
  /**
   * Allows to pay the tips.
   *
   * Origin must be Signed.
   *
   * - `tips`: Tips array.
   *
   * Emits `TipSent` on every tip transfer.
   **/
  | { name: 'PayTips'; params: { tips: Array<PalletNftsItemTip> } }
  /**
   * Register a new atomic swap, declaring an intention to send an `item` in exchange for
   * `desired_item` from origin to target on the current blockchain.
   * The target can execute the swap during the specified `duration` of blocks (if set).
   * Additionally, the price could be set for the desired `item`.
   *
   * Origin must be Signed and must be an owner of the `item`.
   *
   * - `collection`: The collection of the item.
   * - `item`: The item an owner wants to give.
   * - `desired_collection`: The collection of the desired item.
   * - `desired_item`: The desired item an owner wants to receive.
   * - `maybe_price`: The price an owner is willing to pay or receive for the desired `item`.
   * - `duration`: A deadline for the swap. Specified by providing the number of blocks
   * after which the swap will expire.
   *
   * Emits `SwapCreated` on success.
   **/
  | {
      name: 'CreateSwap';
      params: {
        offeredCollection: number;
        offeredItem: number;
        desiredCollection: number;
        maybeDesiredItem?: number | undefined;
        maybePrice?: PalletNftsPriceWithDirection | undefined;
        duration: number;
      };
    }
  /**
   * Cancel an atomic swap.
   *
   * Origin must be Signed.
   * Origin must be an owner of the `item` if the deadline hasn't expired.
   *
   * - `collection`: The collection of the item.
   * - `item`: The item an owner wants to give.
   *
   * Emits `SwapCancelled` on success.
   **/
  | { name: 'CancelSwap'; params: { offeredCollection: number; offeredItem: number } }
  /**
   * Claim an atomic swap.
   * This method executes a pending swap, that was created by a counterpart before.
   *
   * Origin must be Signed and must be an owner of the `item`.
   *
   * - `send_collection`: The collection of the item to be sent.
   * - `send_item`: The item to be sent.
   * - `receive_collection`: The collection of the item to be received.
   * - `receive_item`: The item to be received.
   * - `witness_price`: A price that was previously agreed on.
   *
   * Emits `SwapClaimed` on success.
   **/
  | {
      name: 'ClaimSwap';
      params: {
        sendCollection: number;
        sendItem: number;
        receiveCollection: number;
        receiveItem: number;
        witnessPrice?: PalletNftsPriceWithDirection | undefined;
      };
    }
  /**
   * Mint an item by providing the pre-signed approval.
   *
   * Origin must be Signed.
   *
   * - `mint_data`: The pre-signed approval that consists of the information about the item,
   * its metadata, attributes, who can mint it (`None` for anyone) and until what block
   * number.
   * - `signature`: The signature of the `data` object.
   * - `signer`: The `data` object's signer. Should be an Issuer of the collection.
   *
   * Emits `Issued` on success.
   * Emits `AttributeSet` if the attributes were provided.
   * Emits `ItemMetadataSet` if the metadata was not empty.
   **/
  | {
      name: 'MintPreSigned';
      params: { mintData: PalletNftsPreSignedMint; signature: SpRuntimeMultiSignature; signer: AccountId32 };
    }
  /**
   * Set attributes for an item by providing the pre-signed approval.
   *
   * Origin must be Signed and must be an owner of the `data.item`.
   *
   * - `data`: The pre-signed approval that consists of the information about the item,
   * attributes to update and until what block number.
   * - `signature`: The signature of the `data` object.
   * - `signer`: The `data` object's signer. Should be an Admin of the collection for the
   * `CollectionOwner` namespace.
   *
   * Emits `AttributeSet` for each provided attribute.
   * Emits `ItemAttributesApprovalAdded` if the approval wasn't set before.
   * Emits `PreSignedAttributesSet` on success.
   **/
  | {
      name: 'SetAttributesPreSigned';
      params: { data: PalletNftsPreSignedAttributes; signature: SpRuntimeMultiSignature; signer: AccountId32 };
    };

export type PalletNftsCallLike =
  /**
   * Issue a new collection of non-fungible items from a public origin.
   *
   * This new collection has no items initially and its owner is the origin.
   *
   * The origin must be Signed and the sender must have sufficient funds free.
   *
   * `CollectionDeposit` funds of sender are reserved.
   *
   * Parameters:
   * - `admin`: The admin of this collection. The admin is the initial address of each
   * member of the collection's admin team.
   *
   * Emits `Created` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Create'; params: { admin: MultiAddressLike; config: PalletNftsCollectionConfig } }
  /**
   * Issue a new collection of non-fungible items from a privileged origin.
   *
   * This new collection has no items initially.
   *
   * The origin must conform to `ForceOrigin`.
   *
   * Unlike `create`, no funds are reserved.
   *
   * - `owner`: The owner of this collection of items. The owner has full superuser
   * permissions over this item, but may later change and configure the permissions using
   * `transfer_ownership` and `set_team`.
   *
   * Emits `ForceCreated` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCreate'; params: { owner: MultiAddressLike; config: PalletNftsCollectionConfig } }
  /**
   * Destroy a collection of fungible items.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be the
   * owner of the `collection`.
   *
   * NOTE: The collection must have 0 items to be destroyed.
   *
   * - `collection`: The identifier of the collection to be destroyed.
   * - `witness`: Information on the items minted in the collection. This must be
   * correct.
   *
   * Emits `Destroyed` event when successful.
   *
   * Weight: `O(m + c + a)` where:
   * - `m = witness.item_metadatas`
   * - `c = witness.item_configs`
   * - `a = witness.attributes`
   **/
  | { name: 'Destroy'; params: { collection: number; witness: PalletNftsDestroyWitness } }
  /**
   * Mint an item of a particular collection.
   *
   * The origin must be Signed and the sender must comply with the `mint_settings` rules.
   *
   * - `collection`: The collection of the item to be minted.
   * - `item`: An identifier of the new item.
   * - `mint_to`: Account into which the item will be minted.
   * - `witness_data`: When the mint type is `HolderOf(collection_id)`, then the owned
   * item_id from that collection needs to be provided within the witness data object. If
   * the mint price is set, then it should be additionally confirmed in the `witness_data`.
   *
   * Note: the deposit will be taken from the `origin` and not the `owner` of the `item`.
   *
   * Emits `Issued` event when successful.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'Mint';
      params: {
        collection: number;
        item: number;
        mintTo: MultiAddressLike;
        witnessData?: PalletNftsMintWitness | undefined;
      };
    }
  /**
   * Mint an item of a particular collection from a privileged origin.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be the
   * Issuer of the `collection`.
   *
   * - `collection`: The collection of the item to be minted.
   * - `item`: An identifier of the new item.
   * - `mint_to`: Account into which the item will be minted.
   * - `item_config`: A config of the new item.
   *
   * Emits `Issued` event when successful.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'ForceMint';
      params: { collection: number; item: number; mintTo: MultiAddressLike; itemConfig: PalletNftsItemConfig };
    }
  /**
   * Destroy a single item.
   *
   * The origin must conform to `ForceOrigin` or must be Signed and the signing account must
   * be the owner of the `item`.
   *
   * - `collection`: The collection of the item to be burned.
   * - `item`: The item to be burned.
   *
   * Emits `Burned`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Burn'; params: { collection: number; item: number } }
  /**
   * Move an item from the sender account to another.
   *
   * Origin must be Signed and the signing account must be either:
   * - the Owner of the `item`;
   * - the approved delegate for the `item` (in this case, the approval is reset).
   *
   * Arguments:
   * - `collection`: The collection of the item to be transferred.
   * - `item`: The item to be transferred.
   * - `dest`: The account to receive ownership of the item.
   *
   * Emits `Transferred`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Transfer'; params: { collection: number; item: number; dest: MultiAddressLike } }
  /**
   * Re-evaluate the deposits on some items.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection of the items to be reevaluated.
   * - `items`: The items of the collection whose deposits will be reevaluated.
   *
   * NOTE: This exists as a best-effort function. Any items which are unknown or
   * in the case that the owner account does not have reservable funds to pay for a
   * deposit increase are ignored. Generally the owner isn't going to call this on items
   * whose existing deposit is less than the refreshed deposit as it would only cost them,
   * so it's of little consequence.
   *
   * It will still return an error in the case that the collection is unknown or the signer
   * is not permitted to call it.
   *
   * Weight: `O(items.len())`
   **/
  | { name: 'Redeposit'; params: { collection: number; items: Array<number> } }
  /**
   * Disallow further unprivileged transfer of an item.
   *
   * Origin must be Signed and the sender should be the Freezer of the `collection`.
   *
   * - `collection`: The collection of the item to be changed.
   * - `item`: The item to become non-transferable.
   *
   * Emits `ItemTransferLocked`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'LockItemTransfer'; params: { collection: number; item: number } }
  /**
   * Re-allow unprivileged transfer of an item.
   *
   * Origin must be Signed and the sender should be the Freezer of the `collection`.
   *
   * - `collection`: The collection of the item to be changed.
   * - `item`: The item to become transferable.
   *
   * Emits `ItemTransferUnlocked`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'UnlockItemTransfer'; params: { collection: number; item: number } }
  /**
   * Disallows specified settings for the whole collection.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection to be locked.
   * - `lock_settings`: The settings to be locked.
   *
   * Note: it's possible to only lock(set) the setting, but not to unset it.
   *
   * Emits `CollectionLocked`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'LockCollection'; params: { collection: number; lockSettings: PalletNftsBitFlags } }
  /**
   * Change the Owner of a collection.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection whose owner should be changed.
   * - `owner`: The new Owner of this collection. They must have called
   * `set_accept_ownership` with `collection` in order for this operation to succeed.
   *
   * Emits `OwnerChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'TransferOwnership'; params: { collection: number; newOwner: MultiAddressLike } }
  /**
   * Change the Issuer, Admin and Freezer of a collection.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `collection`.
   *
   * Note: by setting the role to `None` only the `ForceOrigin` will be able to change it
   * after to `Some(account)`.
   *
   * - `collection`: The collection whose team should be changed.
   * - `issuer`: The new Issuer of this collection.
   * - `admin`: The new Admin of this collection.
   * - `freezer`: The new Freezer of this collection.
   *
   * Emits `TeamChanged`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'SetTeam';
      params: {
        collection: number;
        issuer?: MultiAddressLike | undefined;
        admin?: MultiAddressLike | undefined;
        freezer?: MultiAddressLike | undefined;
      };
    }
  /**
   * Change the Owner of a collection.
   *
   * Origin must be `ForceOrigin`.
   *
   * - `collection`: The identifier of the collection.
   * - `owner`: The new Owner of this collection.
   *
   * Emits `OwnerChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCollectionOwner'; params: { collection: number; owner: MultiAddressLike } }
  /**
   * Change the config of a collection.
   *
   * Origin must be `ForceOrigin`.
   *
   * - `collection`: The identifier of the collection.
   * - `config`: The new config of this collection.
   *
   * Emits `CollectionConfigChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCollectionConfig'; params: { collection: number; config: PalletNftsCollectionConfig } }
  /**
   * Approve an item to be transferred by a delegated third-party account.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `item`.
   *
   * - `collection`: The collection of the item to be approved for delegated transfer.
   * - `item`: The item to be approved for delegated transfer.
   * - `delegate`: The account to delegate permission to transfer the item.
   * - `maybe_deadline`: Optional deadline for the approval. Specified by providing the
   * number of blocks after which the approval will expire
   *
   * Emits `TransferApproved` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'ApproveTransfer';
      params: { collection: number; item: number; delegate: MultiAddressLike; maybeDeadline?: number | undefined };
    }
  /**
   * Cancel one of the transfer approvals for a specific item.
   *
   * Origin must be either:
   * - the `Force` origin;
   * - `Signed` with the signer being the Owner of the `item`;
   *
   * Arguments:
   * - `collection`: The collection of the item of whose approval will be cancelled.
   * - `item`: The item of the collection of whose approval will be cancelled.
   * - `delegate`: The account that is going to loose their approval.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'CancelApproval'; params: { collection: number; item: number; delegate: MultiAddressLike } }
  /**
   * Cancel all the approvals of a specific item.
   *
   * Origin must be either:
   * - the `Force` origin;
   * - `Signed` with the signer being the Owner of the `item`;
   *
   * Arguments:
   * - `collection`: The collection of the item of whose approvals will be cleared.
   * - `item`: The item of the collection of whose approvals will be cleared.
   *
   * Emits `AllApprovalsCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearAllTransferApprovals'; params: { collection: number; item: number } }
  /**
   * Disallows changing the metadata or attributes of the item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Admin
   * of the `collection`.
   *
   * - `collection`: The collection if the `item`.
   * - `item`: An item to be locked.
   * - `lock_metadata`: Specifies whether the metadata should be locked.
   * - `lock_attributes`: Specifies whether the attributes in the `CollectionOwner` namespace
   * should be locked.
   *
   * Note: `lock_attributes` affects the attributes in the `CollectionOwner` namespace only.
   * When the metadata or attributes are locked, it won't be possible the unlock them.
   *
   * Emits `ItemPropertiesLocked`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'LockItemProperties';
      params: { collection: number; item: number; lockMetadata: boolean; lockAttributes: boolean };
    }
  /**
   * Set an attribute for a collection or item.
   *
   * Origin must be Signed and must conform to the namespace ruleset:
   * - `CollectionOwner` namespace could be modified by the `collection` Admin only;
   * - `ItemOwner` namespace could be modified by the `maybe_item` owner only. `maybe_item`
   * should be set in that case;
   * - `Account(AccountId)` namespace could be modified only when the `origin` was given a
   * permission to do so;
   *
   * The funds of `origin` are reserved according to the formula:
   * `AttributeDepositBase + DepositPerByte * (key.len + value.len)` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the collection whose item's metadata to set.
   * - `maybe_item`: The identifier of the item whose metadata to set.
   * - `namespace`: Attribute's namespace.
   * - `key`: The key of the attribute.
   * - `value`: The value to which to set the attribute.
   *
   * Emits `AttributeSet`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'SetAttribute';
      params: {
        collection: number;
        maybeItem?: number | undefined;
        namespace: PalletNftsAttributeNamespace;
        key: BytesLike;
        value: BytesLike;
      };
    }
  /**
   * Force-set an attribute for a collection or item.
   *
   * Origin must be `ForceOrigin`.
   *
   * If the attribute already exists and it was set by another account, the deposit
   * will be returned to the previous owner.
   *
   * - `set_as`: An optional owner of the attribute.
   * - `collection`: The identifier of the collection whose item's metadata to set.
   * - `maybe_item`: The identifier of the item whose metadata to set.
   * - `namespace`: Attribute's namespace.
   * - `key`: The key of the attribute.
   * - `value`: The value to which to set the attribute.
   *
   * Emits `AttributeSet`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'ForceSetAttribute';
      params: {
        setAs?: AccountId32Like | undefined;
        collection: number;
        maybeItem?: number | undefined;
        namespace: PalletNftsAttributeNamespace;
        key: BytesLike;
        value: BytesLike;
      };
    }
  /**
   * Clear an attribute for a collection or item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * attribute.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose item's metadata to clear.
   * - `maybe_item`: The identifier of the item whose metadata to clear.
   * - `namespace`: Attribute's namespace.
   * - `key`: The key of the attribute.
   *
   * Emits `AttributeCleared`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'ClearAttribute';
      params: {
        collection: number;
        maybeItem?: number | undefined;
        namespace: PalletNftsAttributeNamespace;
        key: BytesLike;
      };
    }
  /**
   * Approve item's attributes to be changed by a delegated third-party account.
   *
   * Origin must be Signed and must be an owner of the `item`.
   *
   * - `collection`: A collection of the item.
   * - `item`: The item that holds attributes.
   * - `delegate`: The account to delegate permission to change attributes of the item.
   *
   * Emits `ItemAttributesApprovalAdded` on success.
   **/
  | { name: 'ApproveItemAttributes'; params: { collection: number; item: number; delegate: MultiAddressLike } }
  /**
   * Cancel the previously provided approval to change item's attributes.
   * All the previously set attributes by the `delegate` will be removed.
   *
   * Origin must be Signed and must be an owner of the `item`.
   *
   * - `collection`: Collection that the item is contained within.
   * - `item`: The item that holds attributes.
   * - `delegate`: The previously approved account to remove.
   *
   * Emits `ItemAttributesApprovalRemoved` on success.
   **/
  | {
      name: 'CancelItemAttributesApproval';
      params: {
        collection: number;
        item: number;
        delegate: MultiAddressLike;
        witness: PalletNftsCancelAttributesApprovalWitness;
      };
    }
  /**
   * Set the metadata for an item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Admin of the
   * `collection`.
   *
   * If the origin is Signed, then funds of signer are reserved according to the formula:
   * `MetadataDepositBase + DepositPerByte * data.len` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the collection whose item's metadata to set.
   * - `item`: The identifier of the item whose metadata to set.
   * - `data`: The general information of this item. Limited in length by `StringLimit`.
   *
   * Emits `ItemMetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetMetadata'; params: { collection: number; item: number; data: BytesLike } }
  /**
   * Clear the metadata for an item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Admin of the
   * `collection`.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose item's metadata to clear.
   * - `item`: The identifier of the item whose metadata to clear.
   *
   * Emits `ItemMetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearMetadata'; params: { collection: number; item: number } }
  /**
   * Set the metadata for a collection.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Admin of
   * the `collection`.
   *
   * If the origin is `Signed`, then funds of signer are reserved according to the formula:
   * `MetadataDepositBase + DepositPerByte * data.len` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the item whose metadata to update.
   * - `data`: The general information of this item. Limited in length by `StringLimit`.
   *
   * Emits `CollectionMetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetCollectionMetadata'; params: { collection: number; data: BytesLike } }
  /**
   * Clear the metadata for a collection.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Admin of
   * the `collection`.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose metadata to clear.
   *
   * Emits `CollectionMetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearCollectionMetadata'; params: { collection: number } }
  /**
   * Set (or reset) the acceptance of ownership for a particular account.
   *
   * Origin must be `Signed` and if `maybe_collection` is `Some`, then the signer must have a
   * provider reference.
   *
   * - `maybe_collection`: The identifier of the collection whose ownership the signer is
   * willing to accept, or if `None`, an indication that the signer is willing to accept no
   * ownership transferal.
   *
   * Emits `OwnershipAcceptanceChanged`.
   **/
  | { name: 'SetAcceptOwnership'; params: { maybeCollection?: number | undefined } }
  /**
   * Set the maximum number of items a collection could have.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
   * the `collection`.
   *
   * - `collection`: The identifier of the collection to change.
   * - `max_supply`: The maximum number of items a collection could have.
   *
   * Emits `CollectionMaxSupplySet` event when successful.
   **/
  | { name: 'SetCollectionMaxSupply'; params: { collection: number; maxSupply: number } }
  /**
   * Update mint settings.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Issuer
   * of the `collection`.
   *
   * - `collection`: The identifier of the collection to change.
   * - `mint_settings`: The new mint settings.
   *
   * Emits `CollectionMintSettingsUpdated` event when successful.
   **/
  | { name: 'UpdateMintSettings'; params: { collection: number; mintSettings: PalletNftsMintSettings } }
  /**
   * Set (or reset) the price for an item.
   *
   * Origin must be Signed and must be the owner of the `item`.
   *
   * - `collection`: The collection of the item.
   * - `item`: The item to set the price for.
   * - `price`: The price for the item. Pass `None`, to reset the price.
   * - `buyer`: Restricts the buy operation to a specific account.
   *
   * Emits `ItemPriceSet` on success if the price is not `None`.
   * Emits `ItemPriceRemoved` on success if the price is `None`.
   **/
  | {
      name: 'SetPrice';
      params: {
        collection: number;
        item: number;
        price?: bigint | undefined;
        whitelistedBuyer?: MultiAddressLike | undefined;
      };
    }
  /**
   * Allows to buy an item if it's up for sale.
   *
   * Origin must be Signed and must not be the owner of the `item`.
   *
   * - `collection`: The collection of the item.
   * - `item`: The item the sender wants to buy.
   * - `bid_price`: The price the sender is willing to pay.
   *
   * Emits `ItemBought` on success.
   **/
  | { name: 'BuyItem'; params: { collection: number; item: number; bidPrice: bigint } }
  /**
   * Allows to pay the tips.
   *
   * Origin must be Signed.
   *
   * - `tips`: Tips array.
   *
   * Emits `TipSent` on every tip transfer.
   **/
  | { name: 'PayTips'; params: { tips: Array<PalletNftsItemTip> } }
  /**
   * Register a new atomic swap, declaring an intention to send an `item` in exchange for
   * `desired_item` from origin to target on the current blockchain.
   * The target can execute the swap during the specified `duration` of blocks (if set).
   * Additionally, the price could be set for the desired `item`.
   *
   * Origin must be Signed and must be an owner of the `item`.
   *
   * - `collection`: The collection of the item.
   * - `item`: The item an owner wants to give.
   * - `desired_collection`: The collection of the desired item.
   * - `desired_item`: The desired item an owner wants to receive.
   * - `maybe_price`: The price an owner is willing to pay or receive for the desired `item`.
   * - `duration`: A deadline for the swap. Specified by providing the number of blocks
   * after which the swap will expire.
   *
   * Emits `SwapCreated` on success.
   **/
  | {
      name: 'CreateSwap';
      params: {
        offeredCollection: number;
        offeredItem: number;
        desiredCollection: number;
        maybeDesiredItem?: number | undefined;
        maybePrice?: PalletNftsPriceWithDirection | undefined;
        duration: number;
      };
    }
  /**
   * Cancel an atomic swap.
   *
   * Origin must be Signed.
   * Origin must be an owner of the `item` if the deadline hasn't expired.
   *
   * - `collection`: The collection of the item.
   * - `item`: The item an owner wants to give.
   *
   * Emits `SwapCancelled` on success.
   **/
  | { name: 'CancelSwap'; params: { offeredCollection: number; offeredItem: number } }
  /**
   * Claim an atomic swap.
   * This method executes a pending swap, that was created by a counterpart before.
   *
   * Origin must be Signed and must be an owner of the `item`.
   *
   * - `send_collection`: The collection of the item to be sent.
   * - `send_item`: The item to be sent.
   * - `receive_collection`: The collection of the item to be received.
   * - `receive_item`: The item to be received.
   * - `witness_price`: A price that was previously agreed on.
   *
   * Emits `SwapClaimed` on success.
   **/
  | {
      name: 'ClaimSwap';
      params: {
        sendCollection: number;
        sendItem: number;
        receiveCollection: number;
        receiveItem: number;
        witnessPrice?: PalletNftsPriceWithDirection | undefined;
      };
    }
  /**
   * Mint an item by providing the pre-signed approval.
   *
   * Origin must be Signed.
   *
   * - `mint_data`: The pre-signed approval that consists of the information about the item,
   * its metadata, attributes, who can mint it (`None` for anyone) and until what block
   * number.
   * - `signature`: The signature of the `data` object.
   * - `signer`: The `data` object's signer. Should be an Issuer of the collection.
   *
   * Emits `Issued` on success.
   * Emits `AttributeSet` if the attributes were provided.
   * Emits `ItemMetadataSet` if the metadata was not empty.
   **/
  | {
      name: 'MintPreSigned';
      params: { mintData: PalletNftsPreSignedMint; signature: SpRuntimeMultiSignature; signer: AccountId32Like };
    }
  /**
   * Set attributes for an item by providing the pre-signed approval.
   *
   * Origin must be Signed and must be an owner of the `data.item`.
   *
   * - `data`: The pre-signed approval that consists of the information about the item,
   * attributes to update and until what block number.
   * - `signature`: The signature of the `data` object.
   * - `signer`: The `data` object's signer. Should be an Admin of the collection for the
   * `CollectionOwner` namespace.
   *
   * Emits `AttributeSet` for each provided attribute.
   * Emits `ItemAttributesApprovalAdded` if the approval wasn't set before.
   * Emits `PreSignedAttributesSet` on success.
   **/
  | {
      name: 'SetAttributesPreSigned';
      params: { data: PalletNftsPreSignedAttributes; signature: SpRuntimeMultiSignature; signer: AccountId32Like };
    };

export type PalletNftsCollectionConfig = {
  settings: PalletNftsBitFlags;
  maxSupply?: number | undefined;
  mintSettings: PalletNftsMintSettings;
};

export type PalletNftsBitFlags = bigint;

export type PalletNftsCollectionSetting =
  | 'TransferableItems'
  | 'UnlockedMetadata'
  | 'UnlockedAttributes'
  | 'UnlockedMaxSupply'
  | 'DepositRequired';

export type PalletNftsMintSettings = {
  mintType: PalletNftsMintType;
  price?: bigint | undefined;
  startBlock?: number | undefined;
  endBlock?: number | undefined;
  defaultItemSettings: PalletNftsBitFlagsItemSetting;
};

export type PalletNftsMintType = { tag: 'Issuer' } | { tag: 'Public' } | { tag: 'HolderOf'; value: number };

export type PalletNftsBitFlagsItemSetting = bigint;

export type PalletNftsItemSetting = 'Transferable' | 'UnlockedMetadata' | 'UnlockedAttributes';

export type PalletNftsDestroyWitness = { itemMetadatas: number; itemConfigs: number; attributes: number };

export type PalletNftsMintWitness = { ownedItem?: number | undefined; mintPrice?: bigint | undefined };

export type PalletNftsItemConfig = { settings: PalletNftsBitFlagsItemSetting };

export type PalletNftsCancelAttributesApprovalWitness = { accountAttributes: number };

export type PalletNftsItemTip = { collection: number; item: number; receiver: AccountId32; amount: bigint };

export type PalletNftsPreSignedMint = {
  collection: number;
  item: number;
  attributes: Array<[Bytes, Bytes]>;
  metadata: Bytes;
  onlyAccount?: AccountId32 | undefined;
  deadline: number;
  mintPrice?: bigint | undefined;
};

export type PalletNftsPreSignedAttributes = {
  collection: number;
  item: number;
  attributes: Array<[Bytes, Bytes]>;
  namespace: PalletNftsAttributeNamespace;
  deadline: number;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletNftFractionalizationCall =
  /**
   * Lock the NFT and mint a new fungible asset.
   *
   * The dispatch origin for this call must be Signed.
   * The origin must be the owner of the NFT they are trying to lock.
   *
   * `Deposit` funds of sender are reserved.
   *
   * - `nft_collection_id`: The ID used to identify the collection of the NFT.
   * Is used within the context of `pallet_nfts`.
   * - `nft_id`: The ID used to identify the NFT within the given collection.
   * Is used within the context of `pallet_nfts`.
   * - `asset_id`: The ID of the new asset. It must not exist.
   * Is used within the context of `pallet_assets`.
   * - `beneficiary`: The account that will receive the newly created asset.
   * - `fractions`: The total issuance of the newly created asset class.
   *
   * Emits `NftFractionalized` event when successful.
   **/
  | {
      name: 'Fractionalize';
      params: { nftCollectionId: number; nftId: number; assetId: number; beneficiary: MultiAddress; fractions: bigint };
    }
  /**
   * Burn the total issuance of the fungible asset and return (unlock) the locked NFT.
   *
   * The dispatch origin for this call must be Signed.
   *
   * `Deposit` funds will be returned to `asset_creator`.
   *
   * - `nft_collection_id`: The ID used to identify the collection of the NFT.
   * Is used within the context of `pallet_nfts`.
   * - `nft_id`: The ID used to identify the NFT within the given collection.
   * Is used within the context of `pallet_nfts`.
   * - `asset_id`: The ID of the asset being returned and destroyed. Must match
   * the original ID of the created asset, corresponding to the NFT.
   * Is used within the context of `pallet_assets`.
   * - `beneficiary`: The account that will receive the unified NFT.
   *
   * Emits `NftUnified` event when successful.
   **/
  | { name: 'Unify'; params: { nftCollectionId: number; nftId: number; assetId: number; beneficiary: MultiAddress } };

export type PalletNftFractionalizationCallLike =
  /**
   * Lock the NFT and mint a new fungible asset.
   *
   * The dispatch origin for this call must be Signed.
   * The origin must be the owner of the NFT they are trying to lock.
   *
   * `Deposit` funds of sender are reserved.
   *
   * - `nft_collection_id`: The ID used to identify the collection of the NFT.
   * Is used within the context of `pallet_nfts`.
   * - `nft_id`: The ID used to identify the NFT within the given collection.
   * Is used within the context of `pallet_nfts`.
   * - `asset_id`: The ID of the new asset. It must not exist.
   * Is used within the context of `pallet_assets`.
   * - `beneficiary`: The account that will receive the newly created asset.
   * - `fractions`: The total issuance of the newly created asset class.
   *
   * Emits `NftFractionalized` event when successful.
   **/
  | {
      name: 'Fractionalize';
      params: {
        nftCollectionId: number;
        nftId: number;
        assetId: number;
        beneficiary: MultiAddressLike;
        fractions: bigint;
      };
    }
  /**
   * Burn the total issuance of the fungible asset and return (unlock) the locked NFT.
   *
   * The dispatch origin for this call must be Signed.
   *
   * `Deposit` funds will be returned to `asset_creator`.
   *
   * - `nft_collection_id`: The ID used to identify the collection of the NFT.
   * Is used within the context of `pallet_nfts`.
   * - `nft_id`: The ID used to identify the NFT within the given collection.
   * Is used within the context of `pallet_nfts`.
   * - `asset_id`: The ID of the asset being returned and destroyed. Must match
   * the original ID of the created asset, corresponding to the NFT.
   * Is used within the context of `pallet_assets`.
   * - `beneficiary`: The account that will receive the unified NFT.
   *
   * Emits `NftUnified` event when successful.
   **/
  | {
      name: 'Unify';
      params: { nftCollectionId: number; nftId: number; assetId: number; beneficiary: MultiAddressLike };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSalaryCall =
  /**
   * Start the first payout cycle.
   *
   * - `origin`: A `Signed` origin of an account.
   **/
  | { name: 'Init' }
  /**
   * Move to next payout cycle, assuming that the present block is now within that cycle.
   *
   * - `origin`: A `Signed` origin of an account.
   **/
  | { name: 'Bump' }
  /**
   * Induct oneself into the payout system.
   **/
  | { name: 'Induct' }
  /**
   * Register for a payout.
   *
   * Will only work if we are in the first `RegistrationPeriod` blocks since the cycle
   * started.
   *
   * - `origin`: A `Signed` origin of an account which is a member of `Members`.
   **/
  | { name: 'Register' }
  /**
   * Request a payout.
   *
   * Will only work if we are after the first `RegistrationPeriod` blocks since the cycle
   * started but by no more than `PayoutPeriod` blocks.
   *
   * - `origin`: A `Signed` origin of an account which is a member of `Members`.
   **/
  | { name: 'Payout' }
  /**
   * Request a payout to a secondary account.
   *
   * Will only work if we are after the first `RegistrationPeriod` blocks since the cycle
   * started but by no more than `PayoutPeriod` blocks.
   *
   * - `origin`: A `Signed` origin of an account which is a member of `Members`.
   * - `beneficiary`: The account to receive payment.
   **/
  | { name: 'PayoutOther'; params: { beneficiary: AccountId32 } }
  /**
   * Update a payment's status; if it failed, alter the state so the payment can be retried.
   *
   * This must be called within the same cycle as the failed payment. It will fail with
   * `Event::NotCurrent` otherwise.
   *
   * - `origin`: A `Signed` origin of an account which is a member of `Members` who has
   * received a payment this cycle.
   **/
  | { name: 'CheckPayment' };

export type PalletSalaryCallLike =
  /**
   * Start the first payout cycle.
   *
   * - `origin`: A `Signed` origin of an account.
   **/
  | { name: 'Init' }
  /**
   * Move to next payout cycle, assuming that the present block is now within that cycle.
   *
   * - `origin`: A `Signed` origin of an account.
   **/
  | { name: 'Bump' }
  /**
   * Induct oneself into the payout system.
   **/
  | { name: 'Induct' }
  /**
   * Register for a payout.
   *
   * Will only work if we are in the first `RegistrationPeriod` blocks since the cycle
   * started.
   *
   * - `origin`: A `Signed` origin of an account which is a member of `Members`.
   **/
  | { name: 'Register' }
  /**
   * Request a payout.
   *
   * Will only work if we are after the first `RegistrationPeriod` blocks since the cycle
   * started but by no more than `PayoutPeriod` blocks.
   *
   * - `origin`: A `Signed` origin of an account which is a member of `Members`.
   **/
  | { name: 'Payout' }
  /**
   * Request a payout to a secondary account.
   *
   * Will only work if we are after the first `RegistrationPeriod` blocks since the cycle
   * started but by no more than `PayoutPeriod` blocks.
   *
   * - `origin`: A `Signed` origin of an account which is a member of `Members`.
   * - `beneficiary`: The account to receive payment.
   **/
  | { name: 'PayoutOther'; params: { beneficiary: AccountId32Like } }
  /**
   * Update a payment's status; if it failed, alter the state so the payment can be retried.
   *
   * This must be called within the same cycle as the failed payment. It will fail with
   * `Event::NotCurrent` otherwise.
   *
   * - `origin`: A `Signed` origin of an account which is a member of `Members` who has
   * received a payment this cycle.
   **/
  | { name: 'CheckPayment' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCoreFellowshipCall =
  /**
   * Bump the state of a member.
   *
   * This will demote a member whose `last_proof` is now beyond their rank's
   * `demotion_period`.
   *
   * - `origin`: A `Signed` origin of an account.
   * - `who`: A member account whose state is to be updated.
   **/
  | { name: 'Bump'; params: { who: AccountId32 } }
  /**
   * Set the parameters.
   *
   * - `origin`: An origin complying with `ParamsOrigin` or root.
   * - `params`: The new parameters for the pallet.
   **/
  | { name: 'SetParams'; params: { params: PalletCoreFellowshipParamsType } }
  /**
   * Set whether a member is active or not.
   *
   * - `origin`: A `Signed` origin of a member's account.
   * - `is_active`: `true` iff the member is active.
   **/
  | { name: 'SetActive'; params: { isActive: boolean } }
  /**
   * Approve a member to continue at their rank.
   *
   * This resets `last_proof` to the current block, thereby delaying any automatic demotion.
   *
   * `who` must already be tracked by this pallet for this to have an effect.
   *
   * - `origin`: An origin which satisfies `ApproveOrigin` or root.
   * - `who`: A member (i.e. of non-zero rank).
   * - `at_rank`: The rank of member.
   **/
  | { name: 'Approve'; params: { who: AccountId32; atRank: number } }
  /**
   * Introduce a new and unranked candidate (rank zero).
   *
   * - `origin`: An origin which satisfies `InductOrigin` or root.
   * - `who`: The account ID of the candidate to be inducted and become a member.
   **/
  | { name: 'Induct'; params: { who: AccountId32 } }
  /**
   * Increment the rank of a ranked and tracked account.
   *
   * - `origin`: An origin which satisfies `PromoteOrigin` with a `Success` result of
   * `to_rank` or more or root.
   * - `who`: The account ID of the member to be promoted to `to_rank`.
   * - `to_rank`: One more than the current rank of `who`.
   **/
  | { name: 'Promote'; params: { who: AccountId32; toRank: number } }
  /**
   * Stop tracking a prior member who is now not a ranked member of the collective.
   *
   * - `origin`: A `Signed` origin of an account.
   * - `who`: The ID of an account which was tracked in this pallet but which is now not a
   * ranked member of the collective.
   **/
  | { name: 'Offboard'; params: { who: AccountId32 } }
  /**
   * Provide evidence that a rank is deserved.
   *
   * This is free as long as no evidence for the forthcoming judgement is already submitted.
   * Evidence is cleared after an outcome (either demotion, promotion of approval).
   *
   * - `origin`: A `Signed` origin of an inducted and ranked account.
   * - `wish`: The stated desire of the member.
   * - `evidence`: A dump of evidence to be considered. This should generally be either a
   * Markdown-encoded document or a series of 32-byte hashes which can be found on a
   * decentralised content-based-indexing system such as IPFS.
   **/
  | { name: 'SubmitEvidence'; params: { wish: PalletCoreFellowshipWish; evidence: Bytes } }
  /**
   * Introduce an already-ranked individual of the collective into this pallet. The rank may
   * still be zero.
   *
   * This resets `last_proof` to the current block and `last_promotion` will be set to zero,
   * thereby delaying any automatic demotion but allowing immediate promotion.
   *
   * - `origin`: A signed origin of a ranked, but not tracked, account.
   **/
  | { name: 'Import' };

export type PalletCoreFellowshipCallLike =
  /**
   * Bump the state of a member.
   *
   * This will demote a member whose `last_proof` is now beyond their rank's
   * `demotion_period`.
   *
   * - `origin`: A `Signed` origin of an account.
   * - `who`: A member account whose state is to be updated.
   **/
  | { name: 'Bump'; params: { who: AccountId32Like } }
  /**
   * Set the parameters.
   *
   * - `origin`: An origin complying with `ParamsOrigin` or root.
   * - `params`: The new parameters for the pallet.
   **/
  | { name: 'SetParams'; params: { params: PalletCoreFellowshipParamsType } }
  /**
   * Set whether a member is active or not.
   *
   * - `origin`: A `Signed` origin of a member's account.
   * - `is_active`: `true` iff the member is active.
   **/
  | { name: 'SetActive'; params: { isActive: boolean } }
  /**
   * Approve a member to continue at their rank.
   *
   * This resets `last_proof` to the current block, thereby delaying any automatic demotion.
   *
   * `who` must already be tracked by this pallet for this to have an effect.
   *
   * - `origin`: An origin which satisfies `ApproveOrigin` or root.
   * - `who`: A member (i.e. of non-zero rank).
   * - `at_rank`: The rank of member.
   **/
  | { name: 'Approve'; params: { who: AccountId32Like; atRank: number } }
  /**
   * Introduce a new and unranked candidate (rank zero).
   *
   * - `origin`: An origin which satisfies `InductOrigin` or root.
   * - `who`: The account ID of the candidate to be inducted and become a member.
   **/
  | { name: 'Induct'; params: { who: AccountId32Like } }
  /**
   * Increment the rank of a ranked and tracked account.
   *
   * - `origin`: An origin which satisfies `PromoteOrigin` with a `Success` result of
   * `to_rank` or more or root.
   * - `who`: The account ID of the member to be promoted to `to_rank`.
   * - `to_rank`: One more than the current rank of `who`.
   **/
  | { name: 'Promote'; params: { who: AccountId32Like; toRank: number } }
  /**
   * Stop tracking a prior member who is now not a ranked member of the collective.
   *
   * - `origin`: A `Signed` origin of an account.
   * - `who`: The ID of an account which was tracked in this pallet but which is now not a
   * ranked member of the collective.
   **/
  | { name: 'Offboard'; params: { who: AccountId32Like } }
  /**
   * Provide evidence that a rank is deserved.
   *
   * This is free as long as no evidence for the forthcoming judgement is already submitted.
   * Evidence is cleared after an outcome (either demotion, promotion of approval).
   *
   * - `origin`: A `Signed` origin of an inducted and ranked account.
   * - `wish`: The stated desire of the member.
   * - `evidence`: A dump of evidence to be considered. This should generally be either a
   * Markdown-encoded document or a series of 32-byte hashes which can be found on a
   * decentralised content-based-indexing system such as IPFS.
   **/
  | { name: 'SubmitEvidence'; params: { wish: PalletCoreFellowshipWish; evidence: BytesLike } }
  /**
   * Introduce an already-ranked individual of the collective into this pallet. The rank may
   * still be zero.
   *
   * This resets `last_proof` to the current block and `last_promotion` will be set to zero,
   * thereby delaying any automatic demotion but allowing immediate promotion.
   *
   * - `origin`: A signed origin of a ranked, but not tracked, account.
   **/
  | { name: 'Import' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTransactionStorageCall =
  /**
   * Index and store data off chain. Minimum data size is 1 bytes, maximum is
   * `MaxTransactionSize`. Data will be removed after `STORAGE_PERIOD` blocks, unless `renew`
   * is called.
   * ## Complexity
   * - O(n*log(n)) of data size, as all data is pushed to an in-memory trie.
   **/
  | { name: 'Store'; params: { data: Bytes } }
  /**
   * Renew previously stored data. Parameters are the block number that contains
   * previous `store` or `renew` call and transaction index within that block.
   * Transaction index is emitted in the `Stored` or `Renewed` event.
   * Applies same fees as `store`.
   * ## Complexity
   * - O(1).
   **/
  | { name: 'Renew'; params: { block: number; index: number } }
  /**
   * Check storage proof for block number `block_number() - StoragePeriod`.
   * If such block does not exist the proof is expected to be `None`.
   * ## Complexity
   * - Linear w.r.t the number of indexed transactions in the proved block for random
   * probing.
   * There's a DB read for each transaction.
   **/
  | { name: 'CheckProof'; params: { proof: SpTransactionStorageProofTransactionStorageProof } };

export type PalletTransactionStorageCallLike =
  /**
   * Index and store data off chain. Minimum data size is 1 bytes, maximum is
   * `MaxTransactionSize`. Data will be removed after `STORAGE_PERIOD` blocks, unless `renew`
   * is called.
   * ## Complexity
   * - O(n*log(n)) of data size, as all data is pushed to an in-memory trie.
   **/
  | { name: 'Store'; params: { data: BytesLike } }
  /**
   * Renew previously stored data. Parameters are the block number that contains
   * previous `store` or `renew` call and transaction index within that block.
   * Transaction index is emitted in the `Stored` or `Renewed` event.
   * Applies same fees as `store`.
   * ## Complexity
   * - O(1).
   **/
  | { name: 'Renew'; params: { block: number; index: number } }
  /**
   * Check storage proof for block number `block_number() - StoragePeriod`.
   * If such block does not exist the proof is expected to be `None`.
   * ## Complexity
   * - Linear w.r.t the number of indexed transactions in the proved block for random
   * probing.
   * There's a DB read for each transaction.
   **/
  | { name: 'CheckProof'; params: { proof: SpTransactionStorageProofTransactionStorageProof } };

export type SpTransactionStorageProofTransactionStorageProof = { chunk: Bytes; proof: Array<Bytes> };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBagsListCall =
  /**
   * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
   * changed its score that it should properly fall into a different bag than its current
   * one.
   *
   * Anyone can call this function about any potentially dislocated account.
   *
   * Will always update the stored score of `dislocated` to the correct score, based on
   * `ScoreProvider`.
   *
   * If `dislocated` does not exists, it returns an error.
   **/
  | { name: 'Rebag'; params: { dislocated: MultiAddress } }
  /**
   * Move the caller's Id directly in front of `lighter`.
   *
   * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
   * the account going in front of `lighter`. Fee is payed by the origin under all
   * circumstances.
   *
   * Only works if:
   *
   * - both nodes are within the same bag,
   * - and `origin` has a greater `Score` than `lighter`.
   **/
  | { name: 'PutInFrontOf'; params: { lighter: MultiAddress } }
  /**
   * Same as [`Pallet::put_in_front_of`], but it can be called by anyone.
   *
   * Fee is paid by the origin under all circumstances.
   **/
  | { name: 'PutInFrontOfOther'; params: { heavier: MultiAddress; lighter: MultiAddress } };

export type PalletBagsListCallLike =
  /**
   * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
   * changed its score that it should properly fall into a different bag than its current
   * one.
   *
   * Anyone can call this function about any potentially dislocated account.
   *
   * Will always update the stored score of `dislocated` to the correct score, based on
   * `ScoreProvider`.
   *
   * If `dislocated` does not exists, it returns an error.
   **/
  | { name: 'Rebag'; params: { dislocated: MultiAddressLike } }
  /**
   * Move the caller's Id directly in front of `lighter`.
   *
   * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
   * the account going in front of `lighter`. Fee is payed by the origin under all
   * circumstances.
   *
   * Only works if:
   *
   * - both nodes are within the same bag,
   * - and `origin` has a greater `Score` than `lighter`.
   **/
  | { name: 'PutInFrontOf'; params: { lighter: MultiAddressLike } }
  /**
   * Same as [`Pallet::put_in_front_of`], but it can be called by anyone.
   *
   * Fee is paid by the origin under all circumstances.
   **/
  | { name: 'PutInFrontOfOther'; params: { heavier: MultiAddressLike; lighter: MultiAddressLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletStateTrieMigrationCall =
  /**
   * Control the automatic migration.
   *
   * The dispatch origin of this call must be [`Config::ControlOrigin`].
   **/
  | { name: 'ControlAutoMigration'; params: { maybeConfig?: PalletStateTrieMigrationMigrationLimits | undefined } }
  /**
   * Continue the migration for the given `limits`.
   *
   * The dispatch origin of this call can be any signed account.
   *
   * This transaction has NO MONETARY INCENTIVES. calling it will not reward anyone. Albeit,
   * Upon successful execution, the transaction fee is returned.
   *
   * The (potentially over-estimated) of the byte length of all the data read must be
   * provided for up-front fee-payment and weighing. In essence, the caller is guaranteeing
   * that executing the current `MigrationTask` with the given `limits` will not exceed
   * `real_size_upper` bytes of read data.
   *
   * The `witness_task` is merely a helper to prevent the caller from being slashed or
   * generally trigger a migration that they do not intend. This parameter is just a message
   * from caller, saying that they believed `witness_task` was the last state of the
   * migration, and they only wish for their transaction to do anything, if this assumption
   * holds. In case `witness_task` does not match, the transaction fails.
   *
   * Based on the documentation of [`MigrationTask::migrate_until_exhaustion`], the
   * recommended way of doing this is to pass a `limit` that only bounds `count`, as the
   * `size` limit can always be overwritten.
   **/
  | {
      name: 'ContinueMigrate';
      params: {
        limits: PalletStateTrieMigrationMigrationLimits;
        realSizeUpper: number;
        witnessTask: PalletStateTrieMigrationMigrationTask;
      };
    }
  /**
   * Migrate the list of top keys by iterating each of them one by one.
   *
   * This does not affect the global migration process tracker ([`MigrationProcess`]), and
   * should only be used in case any keys are leftover due to a bug.
   **/
  | { name: 'MigrateCustomTop'; params: { keys: Array<Bytes>; witnessSize: number } }
  /**
   * Migrate the list of child keys by iterating each of them one by one.
   *
   * All of the given child keys must be present under one `child_root`.
   *
   * This does not affect the global migration process tracker ([`MigrationProcess`]), and
   * should only be used in case any keys are leftover due to a bug.
   **/
  | { name: 'MigrateCustomChild'; params: { root: Bytes; childKeys: Array<Bytes>; totalSize: number } }
  /**
   * Set the maximum limit of the signed migration.
   **/
  | { name: 'SetSignedMaxLimits'; params: { limits: PalletStateTrieMigrationMigrationLimits } }
  /**
   * Forcefully set the progress the running migration.
   *
   * This is only useful in one case: the next key to migrate is too big to be migrated with
   * a signed account, in a parachain context, and we simply want to skip it. A reasonable
   * example of this would be `:code:`, which is both very expensive to migrate, and commonly
   * used, so probably it is already migrated.
   *
   * In case you mess things up, you can also, in principle, use this to reset the migration
   * process.
   **/
  | {
      name: 'ForceSetProgress';
      params: { progressTop: PalletStateTrieMigrationProgress; progressChild: PalletStateTrieMigrationProgress };
    };

export type PalletStateTrieMigrationCallLike =
  /**
   * Control the automatic migration.
   *
   * The dispatch origin of this call must be [`Config::ControlOrigin`].
   **/
  | { name: 'ControlAutoMigration'; params: { maybeConfig?: PalletStateTrieMigrationMigrationLimits | undefined } }
  /**
   * Continue the migration for the given `limits`.
   *
   * The dispatch origin of this call can be any signed account.
   *
   * This transaction has NO MONETARY INCENTIVES. calling it will not reward anyone. Albeit,
   * Upon successful execution, the transaction fee is returned.
   *
   * The (potentially over-estimated) of the byte length of all the data read must be
   * provided for up-front fee-payment and weighing. In essence, the caller is guaranteeing
   * that executing the current `MigrationTask` with the given `limits` will not exceed
   * `real_size_upper` bytes of read data.
   *
   * The `witness_task` is merely a helper to prevent the caller from being slashed or
   * generally trigger a migration that they do not intend. This parameter is just a message
   * from caller, saying that they believed `witness_task` was the last state of the
   * migration, and they only wish for their transaction to do anything, if this assumption
   * holds. In case `witness_task` does not match, the transaction fails.
   *
   * Based on the documentation of [`MigrationTask::migrate_until_exhaustion`], the
   * recommended way of doing this is to pass a `limit` that only bounds `count`, as the
   * `size` limit can always be overwritten.
   **/
  | {
      name: 'ContinueMigrate';
      params: {
        limits: PalletStateTrieMigrationMigrationLimits;
        realSizeUpper: number;
        witnessTask: PalletStateTrieMigrationMigrationTask;
      };
    }
  /**
   * Migrate the list of top keys by iterating each of them one by one.
   *
   * This does not affect the global migration process tracker ([`MigrationProcess`]), and
   * should only be used in case any keys are leftover due to a bug.
   **/
  | { name: 'MigrateCustomTop'; params: { keys: Array<BytesLike>; witnessSize: number } }
  /**
   * Migrate the list of child keys by iterating each of them one by one.
   *
   * All of the given child keys must be present under one `child_root`.
   *
   * This does not affect the global migration process tracker ([`MigrationProcess`]), and
   * should only be used in case any keys are leftover due to a bug.
   **/
  | { name: 'MigrateCustomChild'; params: { root: BytesLike; childKeys: Array<BytesLike>; totalSize: number } }
  /**
   * Set the maximum limit of the signed migration.
   **/
  | { name: 'SetSignedMaxLimits'; params: { limits: PalletStateTrieMigrationMigrationLimits } }
  /**
   * Forcefully set the progress the running migration.
   *
   * This is only useful in one case: the next key to migrate is too big to be migrated with
   * a signed account, in a parachain context, and we simply want to skip it. A reasonable
   * example of this would be `:code:`, which is both very expensive to migrate, and commonly
   * used, so probably it is already migrated.
   *
   * In case you mess things up, you can also, in principle, use this to reset the migration
   * process.
   **/
  | {
      name: 'ForceSetProgress';
      params: { progressTop: PalletStateTrieMigrationProgress; progressChild: PalletStateTrieMigrationProgress };
    };

export type PalletStateTrieMigrationMigrationLimits = { size: number; item: number };

export type PalletStateTrieMigrationMigrationTask = {
  progressTop: PalletStateTrieMigrationProgress;
  progressChild: PalletStateTrieMigrationProgress;
  size: number;
  topItems: number;
  childItems: number;
};

export type PalletStateTrieMigrationProgress =
  | { tag: 'ToStart' }
  | { tag: 'LastKey'; value: Bytes }
  | { tag: 'Complete' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletChildBountiesCall =
  /**
   * Add a new child-bounty.
   *
   * The dispatch origin for this call must be the curator of parent
   * bounty and the parent bounty must be in "active" state.
   *
   * Child-bounty gets added successfully & fund gets transferred from
   * parent bounty to child-bounty account, if parent bounty has enough
   * funds, else the call fails.
   *
   * Upper bound to maximum number of active child bounties that can be
   * added are managed via runtime trait config
   * [`Config::MaxActiveChildBountyCount`].
   *
   * If the call is success, the status of child-bounty is updated to
   * "Added".
   *
   * - `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
   * - `value`: Value for executing the proposal.
   * - `description`: Text description for the child-bounty.
   **/
  | { name: 'AddChildBounty'; params: { parentBountyId: number; value: bigint; description: Bytes } }
  /**
   * Propose curator for funded child-bounty.
   *
   * The dispatch origin for this call must be curator of parent bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in "Added" state, for processing the call. And
   * state of child-bounty is moved to "CuratorProposed" on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   * - `curator`: Address of child-bounty curator.
   * - `fee`: payment fee to child-bounty curator for execution.
   **/
  | {
      name: 'ProposeCurator';
      params: { parentBountyId: number; childBountyId: number; curator: MultiAddress; fee: bigint };
    }
  /**
   * Accept the curator role for the child-bounty.
   *
   * The dispatch origin for this call must be the curator of this
   * child-bounty.
   *
   * A deposit will be reserved from the curator and refund upon
   * successful payout or cancellation.
   *
   * Fee for curator is deducted from curator fee of parent bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in "CuratorProposed" state, for processing the
   * call. And state of child-bounty is moved to "Active" on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'AcceptCurator'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Unassign curator from a child-bounty.
   *
   * The dispatch origin for this call can be either `RejectOrigin`, or
   * the curator of the parent bounty, or any signed origin.
   *
   * For the origin other than T::RejectOrigin and the child-bounty
   * curator, parent bounty must be in active state, for this call to
   * work. We allow child-bounty curator and T::RejectOrigin to execute
   * this call irrespective of the parent bounty state.
   *
   * If this function is called by the `RejectOrigin` or the
   * parent bounty curator, we assume that the child-bounty curator is
   * malicious or inactive. As a result, child-bounty curator deposit is
   * slashed.
   *
   * If the origin is the child-bounty curator, we take this as a sign
   * that they are unable to do their job, and are willingly giving up.
   * We could slash the deposit, but for now we allow them to unreserve
   * their deposit and exit without issue. (We may want to change this if
   * it is abused.)
   *
   * Finally, the origin can be anyone iff the child-bounty curator is
   * "inactive". Expiry update due of parent bounty is used to estimate
   * inactive state of child-bounty curator.
   *
   * This allows anyone in the community to call out that a child-bounty
   * curator is not doing their due diligence, and we should pick a new
   * one. In this case the child-bounty curator deposit is slashed.
   *
   * State of child-bounty is moved to Added state on successful call
   * completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'UnassignCurator'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Award child-bounty to a beneficiary.
   *
   * The beneficiary will be able to claim the funds after a delay.
   *
   * The dispatch origin for this call must be the parent curator or
   * curator of this child-bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in active state, for processing the call. And
   * state of child-bounty is moved to "PendingPayout" on successful call
   * completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   * - `beneficiary`: Beneficiary account.
   **/
  | { name: 'AwardChildBounty'; params: { parentBountyId: number; childBountyId: number; beneficiary: MultiAddress } }
  /**
   * Claim the payout from an awarded child-bounty after payout delay.
   *
   * The dispatch origin for this call may be any signed origin.
   *
   * Call works independent of parent bounty state, No need for parent
   * bounty to be in active state.
   *
   * The Beneficiary is paid out with agreed bounty value. Curator fee is
   * paid & curator deposit is unreserved.
   *
   * Child-bounty must be in "PendingPayout" state, for processing the
   * call. And instance of child-bounty is removed from the state on
   * successful call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'ClaimChildBounty'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Cancel a proposed or active child-bounty. Child-bounty account funds
   * are transferred to parent bounty account. The child-bounty curator
   * deposit may be unreserved if possible.
   *
   * The dispatch origin for this call must be either parent curator or
   * `T::RejectOrigin`.
   *
   * If the state of child-bounty is `Active`, curator deposit is
   * unreserved.
   *
   * If the state of child-bounty is `PendingPayout`, call fails &
   * returns `PendingPayout` error.
   *
   * For the origin other than T::RejectOrigin, parent bounty must be in
   * active state, for this child-bounty call to work. For origin
   * T::RejectOrigin execution is forced.
   *
   * Instance of child-bounty is removed from the state on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'CloseChildBounty'; params: { parentBountyId: number; childBountyId: number } };

export type PalletChildBountiesCallLike =
  /**
   * Add a new child-bounty.
   *
   * The dispatch origin for this call must be the curator of parent
   * bounty and the parent bounty must be in "active" state.
   *
   * Child-bounty gets added successfully & fund gets transferred from
   * parent bounty to child-bounty account, if parent bounty has enough
   * funds, else the call fails.
   *
   * Upper bound to maximum number of active child bounties that can be
   * added are managed via runtime trait config
   * [`Config::MaxActiveChildBountyCount`].
   *
   * If the call is success, the status of child-bounty is updated to
   * "Added".
   *
   * - `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
   * - `value`: Value for executing the proposal.
   * - `description`: Text description for the child-bounty.
   **/
  | { name: 'AddChildBounty'; params: { parentBountyId: number; value: bigint; description: BytesLike } }
  /**
   * Propose curator for funded child-bounty.
   *
   * The dispatch origin for this call must be curator of parent bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in "Added" state, for processing the call. And
   * state of child-bounty is moved to "CuratorProposed" on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   * - `curator`: Address of child-bounty curator.
   * - `fee`: payment fee to child-bounty curator for execution.
   **/
  | {
      name: 'ProposeCurator';
      params: { parentBountyId: number; childBountyId: number; curator: MultiAddressLike; fee: bigint };
    }
  /**
   * Accept the curator role for the child-bounty.
   *
   * The dispatch origin for this call must be the curator of this
   * child-bounty.
   *
   * A deposit will be reserved from the curator and refund upon
   * successful payout or cancellation.
   *
   * Fee for curator is deducted from curator fee of parent bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in "CuratorProposed" state, for processing the
   * call. And state of child-bounty is moved to "Active" on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'AcceptCurator'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Unassign curator from a child-bounty.
   *
   * The dispatch origin for this call can be either `RejectOrigin`, or
   * the curator of the parent bounty, or any signed origin.
   *
   * For the origin other than T::RejectOrigin and the child-bounty
   * curator, parent bounty must be in active state, for this call to
   * work. We allow child-bounty curator and T::RejectOrigin to execute
   * this call irrespective of the parent bounty state.
   *
   * If this function is called by the `RejectOrigin` or the
   * parent bounty curator, we assume that the child-bounty curator is
   * malicious or inactive. As a result, child-bounty curator deposit is
   * slashed.
   *
   * If the origin is the child-bounty curator, we take this as a sign
   * that they are unable to do their job, and are willingly giving up.
   * We could slash the deposit, but for now we allow them to unreserve
   * their deposit and exit without issue. (We may want to change this if
   * it is abused.)
   *
   * Finally, the origin can be anyone iff the child-bounty curator is
   * "inactive". Expiry update due of parent bounty is used to estimate
   * inactive state of child-bounty curator.
   *
   * This allows anyone in the community to call out that a child-bounty
   * curator is not doing their due diligence, and we should pick a new
   * one. In this case the child-bounty curator deposit is slashed.
   *
   * State of child-bounty is moved to Added state on successful call
   * completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'UnassignCurator'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Award child-bounty to a beneficiary.
   *
   * The beneficiary will be able to claim the funds after a delay.
   *
   * The dispatch origin for this call must be the parent curator or
   * curator of this child-bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in active state, for processing the call. And
   * state of child-bounty is moved to "PendingPayout" on successful call
   * completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   * - `beneficiary`: Beneficiary account.
   **/
  | {
      name: 'AwardChildBounty';
      params: { parentBountyId: number; childBountyId: number; beneficiary: MultiAddressLike };
    }
  /**
   * Claim the payout from an awarded child-bounty after payout delay.
   *
   * The dispatch origin for this call may be any signed origin.
   *
   * Call works independent of parent bounty state, No need for parent
   * bounty to be in active state.
   *
   * The Beneficiary is paid out with agreed bounty value. Curator fee is
   * paid & curator deposit is unreserved.
   *
   * Child-bounty must be in "PendingPayout" state, for processing the
   * call. And instance of child-bounty is removed from the state on
   * successful call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'ClaimChildBounty'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Cancel a proposed or active child-bounty. Child-bounty account funds
   * are transferred to parent bounty account. The child-bounty curator
   * deposit may be unreserved if possible.
   *
   * The dispatch origin for this call must be either parent curator or
   * `T::RejectOrigin`.
   *
   * If the state of child-bounty is `Active`, curator deposit is
   * unreserved.
   *
   * If the state of child-bounty is `PendingPayout`, call fails &
   * returns `PendingPayout` error.
   *
   * For the origin other than T::RejectOrigin, parent bounty must be in
   * active state, for this child-bounty call to work. For origin
   * T::RejectOrigin execution is forced.
   *
   * Instance of child-bounty is removed from the state on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'CloseChildBounty'; params: { parentBountyId: number; childBountyId: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletReferendaCall =
  /**
   * Propose a referendum on a privileged action.
   *
   * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
   * available.
   * - `proposal_origin`: The origin from which the proposal should be executed.
   * - `proposal`: The proposal.
   * - `enactment_moment`: The moment that the proposal should be enacted.
   *
   * Emits `Submitted`.
   **/
  | {
      name: 'Submit';
      params: {
        proposalOrigin: KitchensinkRuntimeOriginCaller;
        proposal: FrameSupportPreimagesBounded;
        enactmentMoment: FrameSupportScheduleDispatchTime;
      };
    }
  /**
   * Post the Decision Deposit for a referendum.
   *
   * - `origin`: must be `Signed` and the account must have funds available for the
   * referendum's track's Decision Deposit.
   * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
   * posted.
   *
   * Emits `DecisionDepositPlaced`.
   **/
  | { name: 'PlaceDecisionDeposit'; params: { index: number } }
  /**
   * Refund the Decision Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
   * refunded.
   *
   * Emits `DecisionDepositRefunded`.
   **/
  | { name: 'RefundDecisionDeposit'; params: { index: number } }
  /**
   * Cancel an ongoing referendum.
   *
   * - `origin`: must be the `CancelOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Cancelled`.
   **/
  | { name: 'Cancel'; params: { index: number } }
  /**
   * Cancel an ongoing referendum and slash the deposits.
   *
   * - `origin`: must be the `KillOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Killed` and `DepositSlashed`.
   **/
  | { name: 'Kill'; params: { index: number } }
  /**
   * Advance a referendum onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `index`: the referendum to be advanced.
   **/
  | { name: 'NudgeReferendum'; params: { index: number } }
  /**
   * Advance a track onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `track`: the track to be advanced.
   *
   * Action item for when there is now one fewer referendum in the deciding phase and the
   * `DecidingCount` is not yet updated. This means that we should either:
   * - begin deciding another referendum (and leave `DecidingCount` alone); or
   * - decrement `DecidingCount`.
   **/
  | { name: 'OneFewerDeciding'; params: { track: number } }
  /**
   * Refund the Submission Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
   * refunded.
   *
   * Emits `SubmissionDepositRefunded`.
   **/
  | { name: 'RefundSubmissionDeposit'; params: { index: number } }
  /**
   * Set or clear metadata of a referendum.
   *
   * Parameters:
   * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
   * metadata of a finished referendum.
   * - `index`: The index of a referendum to set or clear metadata for.
   * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
   **/
  | { name: 'SetMetadata'; params: { index: number; maybeHash?: H256 | undefined } };

export type PalletReferendaCallLike =
  /**
   * Propose a referendum on a privileged action.
   *
   * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
   * available.
   * - `proposal_origin`: The origin from which the proposal should be executed.
   * - `proposal`: The proposal.
   * - `enactment_moment`: The moment that the proposal should be enacted.
   *
   * Emits `Submitted`.
   **/
  | {
      name: 'Submit';
      params: {
        proposalOrigin: KitchensinkRuntimeOriginCaller;
        proposal: FrameSupportPreimagesBounded;
        enactmentMoment: FrameSupportScheduleDispatchTime;
      };
    }
  /**
   * Post the Decision Deposit for a referendum.
   *
   * - `origin`: must be `Signed` and the account must have funds available for the
   * referendum's track's Decision Deposit.
   * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
   * posted.
   *
   * Emits `DecisionDepositPlaced`.
   **/
  | { name: 'PlaceDecisionDeposit'; params: { index: number } }
  /**
   * Refund the Decision Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
   * refunded.
   *
   * Emits `DecisionDepositRefunded`.
   **/
  | { name: 'RefundDecisionDeposit'; params: { index: number } }
  /**
   * Cancel an ongoing referendum.
   *
   * - `origin`: must be the `CancelOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Cancelled`.
   **/
  | { name: 'Cancel'; params: { index: number } }
  /**
   * Cancel an ongoing referendum and slash the deposits.
   *
   * - `origin`: must be the `KillOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Killed` and `DepositSlashed`.
   **/
  | { name: 'Kill'; params: { index: number } }
  /**
   * Advance a referendum onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `index`: the referendum to be advanced.
   **/
  | { name: 'NudgeReferendum'; params: { index: number } }
  /**
   * Advance a track onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `track`: the track to be advanced.
   *
   * Action item for when there is now one fewer referendum in the deciding phase and the
   * `DecidingCount` is not yet updated. This means that we should either:
   * - begin deciding another referendum (and leave `DecidingCount` alone); or
   * - decrement `DecidingCount`.
   **/
  | { name: 'OneFewerDeciding'; params: { track: number } }
  /**
   * Refund the Submission Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
   * refunded.
   *
   * Emits `SubmissionDepositRefunded`.
   **/
  | { name: 'RefundSubmissionDeposit'; params: { index: number } }
  /**
   * Set or clear metadata of a referendum.
   *
   * Parameters:
   * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
   * metadata of a finished referendum.
   * - `index`: The index of a referendum to set or clear metadata for.
   * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
   **/
  | { name: 'SetMetadata'; params: { index: number; maybeHash?: H256 | undefined } };

export type FrameSupportScheduleDispatchTime = { tag: 'At'; value: number } | { tag: 'After'; value: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRemarkCall =
  /**
   * Index and store data off chain.
   **/
  { name: 'Store'; params: { remark: Bytes } };

export type PalletRemarkCallLike =
  /**
   * Index and store data off chain.
   **/
  { name: 'Store'; params: { remark: BytesLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRootTestingCall =
  /**
   * A dispatch that will fill the block weight up to the given ratio.
   **/
  { name: 'FillBlock'; params: { ratio: Perbill } } | { name: 'TriggerDefensive' };

export type PalletRootTestingCallLike =
  /**
   * A dispatch that will fill the block weight up to the given ratio.
   **/
  { name: 'FillBlock'; params: { ratio: Perbill } } | { name: 'TriggerDefensive' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletConvictionVotingCall =
  /**
   * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `poll_index`: The index of the poll to vote for.
   * - `vote`: The vote configuration.
   *
   * Weight: `O(R)` where R is the number of polls the voter has voted on.
   **/
  | { name: 'Vote'; params: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote } }
  /**
   * Delegate the voting power (with some given conviction) of the sending account for a
   * particular class of polls.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   * - be delegating already; or
   * - have no voting activity (if there is, then it will need to be removed through
   * `remove_vote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
   * to this function are required.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   * account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   * be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | {
      name: 'Delegate';
      params: { class: number; to: MultiAddress; conviction: PalletConvictionVotingConviction; balance: bigint };
    }
  /**
   * Undelegate the voting power of the sending account for a particular class of polls.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued has passed.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * - `class`: The class of polls to remove the delegation from.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | { name: 'Undelegate'; params: { class: number } }
  /**
   * Remove the lock caused by prior voting/delegating which has expired within a particular
   * class.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `class`: The class of polls to unlock.
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   **/
  | { name: 'Unlock'; params: { class: number; target: MultiAddress } }
  /**
   * Remove a vote for a poll.
   *
   * If:
   * - the poll was cancelled, or
   * - the poll is ongoing, or
   * - the poll has ended such that
   * - the vote of the account was in opposition to the result; or
   * - there was no conviction to the account's vote; or
   * - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the poll has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for poll `index`.
   *
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
   * which have finished or are cancelled, this must be `Some`.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveVote'; params: { class?: number | undefined; index: number } }
  /**
   * Remove a vote for a poll.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the poll was cancelled, because the voter lost the poll or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for poll
   * `index`.
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: The class of the poll.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveOtherVote'; params: { target: MultiAddress; class: number; index: number } };

export type PalletConvictionVotingCallLike =
  /**
   * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `poll_index`: The index of the poll to vote for.
   * - `vote`: The vote configuration.
   *
   * Weight: `O(R)` where R is the number of polls the voter has voted on.
   **/
  | { name: 'Vote'; params: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote } }
  /**
   * Delegate the voting power (with some given conviction) of the sending account for a
   * particular class of polls.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   * - be delegating already; or
   * - have no voting activity (if there is, then it will need to be removed through
   * `remove_vote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
   * to this function are required.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   * account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   * be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | {
      name: 'Delegate';
      params: { class: number; to: MultiAddressLike; conviction: PalletConvictionVotingConviction; balance: bigint };
    }
  /**
   * Undelegate the voting power of the sending account for a particular class of polls.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued has passed.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * - `class`: The class of polls to remove the delegation from.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | { name: 'Undelegate'; params: { class: number } }
  /**
   * Remove the lock caused by prior voting/delegating which has expired within a particular
   * class.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `class`: The class of polls to unlock.
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   **/
  | { name: 'Unlock'; params: { class: number; target: MultiAddressLike } }
  /**
   * Remove a vote for a poll.
   *
   * If:
   * - the poll was cancelled, or
   * - the poll is ongoing, or
   * - the poll has ended such that
   * - the vote of the account was in opposition to the result; or
   * - there was no conviction to the account's vote; or
   * - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the poll has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for poll `index`.
   *
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
   * which have finished or are cancelled, this must be `Some`.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveVote'; params: { class?: number | undefined; index: number } }
  /**
   * Remove a vote for a poll.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the poll was cancelled, because the voter lost the poll or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for poll
   * `index`.
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: The class of the poll.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveOtherVote'; params: { target: MultiAddressLike; class: number; index: number } };

export type PalletConvictionVotingVoteAccountVote =
  | { tag: 'Standard'; value: { vote: PalletConvictionVotingVote; balance: bigint } }
  | { tag: 'Split'; value: { aye: bigint; nay: bigint } }
  | { tag: 'SplitAbstain'; value: { aye: bigint; nay: bigint; abstain: bigint } };

export type PalletConvictionVotingVote = number;

export type PalletConvictionVotingConviction =
  | 'None'
  | 'Locked1x'
  | 'Locked2x'
  | 'Locked3x'
  | 'Locked4x'
  | 'Locked5x'
  | 'Locked6x';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletWhitelistCall =
  | { name: 'WhitelistCall'; params: { callHash: H256 } }
  | { name: 'RemoveWhitelistedCall'; params: { callHash: H256 } }
  | {
      name: 'DispatchWhitelistedCall';
      params: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
    }
  | { name: 'DispatchWhitelistedCallWithPreimage'; params: { call: KitchensinkRuntimeRuntimeCall } };

export type PalletWhitelistCallLike =
  | { name: 'WhitelistCall'; params: { callHash: H256 } }
  | { name: 'RemoveWhitelistedCall'; params: { callHash: H256 } }
  | {
      name: 'DispatchWhitelistedCall';
      params: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
    }
  | { name: 'DispatchWhitelistedCallWithPreimage'; params: { call: KitchensinkRuntimeRuntimeCallLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAllianceCall =
  /**
   * Add a new proposal to be voted on.
   *
   * Must be called by a Fellow.
   **/
  | { name: 'Propose'; params: { threshold: number; proposal: KitchensinkRuntimeRuntimeCall; lengthBound: number } }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * Must be called by a Fellow.
   **/
  | { name: 'Vote'; params: { proposal: H256; index: number; approve: boolean } }
  /**
   * Initialize the Alliance, onboard fellows and allies.
   *
   * The Alliance must be empty, and the call must provide some founding members.
   *
   * Must be called by the Root origin.
   **/
  | { name: 'InitMembers'; params: { fellows: Array<AccountId32>; allies: Array<AccountId32> } }
  /**
   * Disband the Alliance, remove all active members and unreserve deposits.
   *
   * Witness data must be set.
   **/
  | { name: 'Disband'; params: { witness: PalletAllianceDisbandWitness } }
  /**
   * Set a new IPFS CID to the alliance rule.
   **/
  | { name: 'SetRule'; params: { rule: PalletAllianceCid } }
  /**
   * Make an announcement of a new IPFS CID about alliance issues.
   **/
  | { name: 'Announce'; params: { announcement: PalletAllianceCid } }
  /**
   * Remove an announcement.
   **/
  | { name: 'RemoveAnnouncement'; params: { announcement: PalletAllianceCid } }
  /**
   * Submit oneself for candidacy. A fixed deposit is reserved.
   **/
  | { name: 'JoinAlliance' }
  /**
   * A Fellow can nominate someone to join the alliance as an Ally. There is no deposit
   * required from the nominator or nominee.
   **/
  | { name: 'NominateAlly'; params: { who: MultiAddress } }
  /**
   * Elevate an Ally to Fellow.
   **/
  | { name: 'ElevateAlly'; params: { ally: MultiAddress } }
  /**
   * As a member, give a retirement notice and start a retirement period required to pass in
   * order to retire.
   **/
  | { name: 'GiveRetirementNotice' }
  /**
   * As a member, retire from the Alliance and unreserve the deposit.
   *
   * This can only be done once you have called `give_retirement_notice` and the
   * `RetirementPeriod` has passed.
   **/
  | { name: 'Retire' }
  /**
   * Kick a member from the Alliance and slash its deposit.
   **/
  | { name: 'KickMember'; params: { who: MultiAddress } }
  /**
   * Add accounts or websites to the list of unscrupulous items.
   **/
  | { name: 'AddUnscrupulousItems'; params: { items: Array<PalletAllianceUnscrupulousItem> } }
  /**
   * Deem some items no longer unscrupulous.
   **/
  | { name: 'RemoveUnscrupulousItems'; params: { items: Array<PalletAllianceUnscrupulousItem> } }
  /**
   * Close a vote that is either approved, disapproved, or whose voting period has ended.
   *
   * Must be called by a Fellow.
   **/
  | {
      name: 'Close';
      params: { proposalHash: H256; index: number; proposalWeightBound: SpWeightsWeightV2Weight; lengthBound: number };
    }
  /**
   * Abdicate one's position as a voting member and just be an Ally. May be used by Fellows
   * who do not want to leave the Alliance but do not have the capacity to participate
   * operationally for some time.
   **/
  | { name: 'AbdicateFellowStatus' };

export type PalletAllianceCallLike =
  /**
   * Add a new proposal to be voted on.
   *
   * Must be called by a Fellow.
   **/
  | { name: 'Propose'; params: { threshold: number; proposal: KitchensinkRuntimeRuntimeCallLike; lengthBound: number } }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * Must be called by a Fellow.
   **/
  | { name: 'Vote'; params: { proposal: H256; index: number; approve: boolean } }
  /**
   * Initialize the Alliance, onboard fellows and allies.
   *
   * The Alliance must be empty, and the call must provide some founding members.
   *
   * Must be called by the Root origin.
   **/
  | { name: 'InitMembers'; params: { fellows: Array<AccountId32Like>; allies: Array<AccountId32Like> } }
  /**
   * Disband the Alliance, remove all active members and unreserve deposits.
   *
   * Witness data must be set.
   **/
  | { name: 'Disband'; params: { witness: PalletAllianceDisbandWitness } }
  /**
   * Set a new IPFS CID to the alliance rule.
   **/
  | { name: 'SetRule'; params: { rule: PalletAllianceCid } }
  /**
   * Make an announcement of a new IPFS CID about alliance issues.
   **/
  | { name: 'Announce'; params: { announcement: PalletAllianceCid } }
  /**
   * Remove an announcement.
   **/
  | { name: 'RemoveAnnouncement'; params: { announcement: PalletAllianceCid } }
  /**
   * Submit oneself for candidacy. A fixed deposit is reserved.
   **/
  | { name: 'JoinAlliance' }
  /**
   * A Fellow can nominate someone to join the alliance as an Ally. There is no deposit
   * required from the nominator or nominee.
   **/
  | { name: 'NominateAlly'; params: { who: MultiAddressLike } }
  /**
   * Elevate an Ally to Fellow.
   **/
  | { name: 'ElevateAlly'; params: { ally: MultiAddressLike } }
  /**
   * As a member, give a retirement notice and start a retirement period required to pass in
   * order to retire.
   **/
  | { name: 'GiveRetirementNotice' }
  /**
   * As a member, retire from the Alliance and unreserve the deposit.
   *
   * This can only be done once you have called `give_retirement_notice` and the
   * `RetirementPeriod` has passed.
   **/
  | { name: 'Retire' }
  /**
   * Kick a member from the Alliance and slash its deposit.
   **/
  | { name: 'KickMember'; params: { who: MultiAddressLike } }
  /**
   * Add accounts or websites to the list of unscrupulous items.
   **/
  | { name: 'AddUnscrupulousItems'; params: { items: Array<PalletAllianceUnscrupulousItem> } }
  /**
   * Deem some items no longer unscrupulous.
   **/
  | { name: 'RemoveUnscrupulousItems'; params: { items: Array<PalletAllianceUnscrupulousItem> } }
  /**
   * Close a vote that is either approved, disapproved, or whose voting period has ended.
   *
   * Must be called by a Fellow.
   **/
  | {
      name: 'Close';
      params: { proposalHash: H256; index: number; proposalWeightBound: SpWeightsWeightV2Weight; lengthBound: number };
    }
  /**
   * Abdicate one's position as a voting member and just be an Ally. May be used by Fellows
   * who do not want to leave the Alliance but do not have the capacity to participate
   * operationally for some time.
   **/
  | { name: 'AbdicateFellowStatus' };

export type PalletAllianceDisbandWitness = { fellowMembers: number; allyMembers: number };

export type PalletAllianceCid = { version: PalletAllianceVersion; codec: bigint; hash: PalletAllianceMultihash };

export type PalletAllianceVersion = 'V0' | 'V1';

export type PalletAllianceMultihash = { code: bigint; digest: Bytes };

export type PalletAllianceUnscrupulousItem =
  | { tag: 'AccountId'; value: AccountId32 }
  | { tag: 'Website'; value: Bytes };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletNominationPoolsCall =
  /**
   * Stake funds with a pool. The amount to bond is transferred from the member to the
   * pools account and immediately increases the pools bond.
   *
   * # Note
   *
   * * An account can only be a member of a single pool.
   * * An account cannot join the same pool multiple times.
   * * This call will *not* dust the member account, so the member must have at least
   * `existential deposit + amount` in their account.
   * * Only a pool with [`PoolState::Open`] can be joined
   **/
  | { name: 'Join'; params: { amount: bigint; poolId: number } }
  /**
   * Bond `extra` more funds from `origin` into the pool to which they already belong.
   *
   * Additional funds can come from either the free balance of the account, of from the
   * accumulated rewards, see [`BondExtra`].
   *
   * Bonding extra funds implies an automatic payout of all pending rewards as well.
   * See `bond_extra_other` to bond pending rewards of `other` members.
   **/
  | { name: 'BondExtra'; params: { extra: PalletNominationPoolsBondExtra } }
  /**
   * A bonded member can use this to claim their payout based on the rewards that the pool
   * has accumulated since their last claimed payout (OR since joining if this is their first
   * time claiming rewards). The payout will be transferred to the member's account.
   *
   * The member will earn rewards pro rata based on the members stake vs the sum of the
   * members in the pools stake. Rewards do not "expire".
   *
   * See `claim_payout_other` to caim rewards on bahalf of some `other` pool member.
   **/
  | { name: 'ClaimPayout' }
  /**
   * Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
   * implicitly collects the rewards one last time, since not doing so would mean some
   * rewards would be forfeited.
   *
   * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
   * account).
   *
   * # Conditions for a permissionless dispatch.
   *
   * * The pool is blocked and the caller is either the root or bouncer. This is refereed to
   * as a kick.
   * * The pool is destroying and the member is not the depositor.
   * * The pool is destroying, the member is the depositor and no other members are in the
   * pool.
   *
   * ## Conditions for permissioned dispatch (i.e. the caller is also the
   * `member_account`):
   *
   * * The caller is not the depositor.
   * * The caller is the depositor, the pool is destroying and no other members are in the
   * pool.
   *
   * # Note
   *
   * If there are too many unlocking chunks to unbond with the pool account,
   * [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks.
   * The [`StakingInterface::unbond`] will implicitly call [`Call::pool_withdraw_unbonded`]
   * to try to free chunks if necessary (ie. if unbound was called and no unlocking chunks
   * are available). However, it may not be possible to release the current unlocking chunks,
   * in which case, the result of this call will likely be the `NoMoreChunks` error from the
   * staking system.
   **/
  | { name: 'Unbond'; params: { memberAccount: MultiAddress; unbondingPoints: bigint } }
  /**
   * Call `withdraw_unbonded` for the pools account. This call can be made by any account.
   *
   * This is useful if there are too many unlocking chunks to call `unbond`, and some
   * can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
   * would probably see an error like `NoMoreChunks` emitted from the staking system when
   * they attempt to unbond.
   **/
  | { name: 'PoolWithdrawUnbonded'; params: { poolId: number; numSlashingSpans: number } }
  /**
   * Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
   * error is returned.
   *
   * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
   * account).
   *
   * # Conditions for a permissionless dispatch
   *
   * * The pool is in destroy mode and the target is not the depositor.
   * * The target is the depositor and they are the only member in the sub pools.
   * * The pool is blocked and the caller is either the root or bouncer.
   *
   * # Conditions for permissioned dispatch
   *
   * * The caller is the target and they are not the depositor.
   *
   * # Note
   *
   * If the target is the depositor, the pool will be destroyed.
   **/
  | { name: 'WithdrawUnbonded'; params: { memberAccount: MultiAddress; numSlashingSpans: number } }
  /**
   * Create a new delegation pool.
   *
   * # Arguments
   *
   * * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
   * deposit since the pools creator cannot fully unbond funds until the pool is being
   * destroyed.
   * * `index` - A disambiguation index for creating the account. Likely only useful when
   * creating multiple pools in the same extrinsic.
   * * `root` - The account to set as [`PoolRoles::root`].
   * * `nominator` - The account to set as the [`PoolRoles::nominator`].
   * * `bouncer` - The account to set as the [`PoolRoles::bouncer`].
   *
   * # Note
   *
   * In addition to `amount`, the caller will transfer the existential deposit; so the caller
   * needs at have at least `amount + existential_deposit` transferable.
   **/
  | { name: 'Create'; params: { amount: bigint; root: MultiAddress; nominator: MultiAddress; bouncer: MultiAddress } }
  /**
   * Create a new delegation pool with a previously used pool id
   *
   * # Arguments
   *
   * same as `create` with the inclusion of
   * * `pool_id` - `A valid PoolId.
   **/
  | {
      name: 'CreateWithPoolId';
      params: { amount: bigint; root: MultiAddress; nominator: MultiAddress; bouncer: MultiAddress; poolId: number };
    }
  /**
   * Nominate on behalf of the pool.
   *
   * The dispatch origin of this call must be signed by the pool nominator or the pool
   * root role.
   *
   * This directly forward the call to the staking pallet, on behalf of the pool bonded
   * account.
   *
   * # Note
   *
   * In addition to a `root` or `nominator` role of `origin`, pool's depositor needs to have
   * at least `depositor_min_bond` in the pool to start nominating.
   **/
  | { name: 'Nominate'; params: { poolId: number; validators: Array<AccountId32> } }
  /**
   * Set a new state for the pool.
   *
   * If a pool is already in the `Destroying` state, then under no condition can its state
   * change again.
   *
   * The dispatch origin of this call must be either:
   *
   * 1. signed by the bouncer, or the root role of the pool,
   * 2. if the pool conditions to be open are NOT met (as described by `ok_to_be_open`), and
   * then the state of the pool can be permissionlessly changed to `Destroying`.
   **/
  | { name: 'SetState'; params: { poolId: number; state: PalletNominationPoolsPoolState } }
  /**
   * Set a new metadata for the pool.
   *
   * The dispatch origin of this call must be signed by the bouncer, or the root role of the
   * pool.
   **/
  | { name: 'SetMetadata'; params: { poolId: number; metadata: Bytes } }
  /**
   * Update configurations for the nomination pools. The origin for this call must be
   * Root.
   *
   * # Arguments
   *
   * * `min_join_bond` - Set [`MinJoinBond`].
   * * `min_create_bond` - Set [`MinCreateBond`].
   * * `max_pools` - Set [`MaxPools`].
   * * `max_members` - Set [`MaxPoolMembers`].
   * * `max_members_per_pool` - Set [`MaxPoolMembersPerPool`].
   * * `global_max_commission` - Set [`GlobalMaxCommission`].
   **/
  | {
      name: 'SetConfigs';
      params: {
        minJoinBond: PalletNominationPoolsConfigOp;
        minCreateBond: PalletNominationPoolsConfigOp;
        maxPools: PalletNominationPoolsConfigOpU32;
        maxMembers: PalletNominationPoolsConfigOpU32;
        maxMembersPerPool: PalletNominationPoolsConfigOpU32;
        globalMaxCommission: PalletNominationPoolsConfigOpPerbill;
      };
    }
  /**
   * Update the roles of the pool.
   *
   * The root is the only entity that can change any of the roles, including itself,
   * excluding the depositor, who can never change.
   *
   * It emits an event, notifying UIs of the role change. This event is quite relevant to
   * most pool members and they should be informed of changes to pool roles.
   **/
  | {
      name: 'UpdateRoles';
      params: {
        poolId: number;
        newRoot: PalletNominationPoolsConfigOp004;
        newNominator: PalletNominationPoolsConfigOp004;
        newBouncer: PalletNominationPoolsConfigOp004;
      };
    }
  /**
   * Chill on behalf of the pool.
   *
   * The dispatch origin of this call can be signed by the pool nominator or the pool
   * root role, same as [`Pallet::nominate`].
   *
   * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
   * account).
   *
   * # Conditions for a permissionless dispatch:
   * * When pool depositor has less than `MinNominatorBond` staked, otherwise pool members
   * are unable to unbond.
   *
   * # Conditions for permissioned dispatch:
   * * The caller has a nominator or root role of the pool.
   * This directly forward the call to the staking pallet, on behalf of the pool bonded
   * account.
   **/
  | { name: 'Chill'; params: { poolId: number } }
  /**
   * `origin` bonds funds from `extra` for some pool member `member` into their respective
   * pools.
   *
   * `origin` can bond extra funds from free balance or pending rewards when `origin ==
   * other`.
   *
   * In the case of `origin != other`, `origin` can only bond extra pending rewards of
   * `other` members assuming set_claim_permission for the given member is
   * `PermissionlessAll` or `PermissionlessCompound`.
   **/
  | { name: 'BondExtraOther'; params: { member: MultiAddress; extra: PalletNominationPoolsBondExtra } }
  /**
   * Allows a pool member to set a claim permission to allow or disallow permissionless
   * bonding and withdrawing.
   *
   * By default, this is `Permissioned`, which implies only the pool member themselves can
   * claim their pending rewards. If a pool member wishes so, they can set this to
   * `PermissionlessAll` to allow any account to claim their rewards and bond extra to the
   * pool.
   *
   * # Arguments
   *
   * * `origin` - Member of a pool.
   * * `actor` - Account to claim reward. // improve this
   **/
  | { name: 'SetClaimPermission'; params: { permission: PalletNominationPoolsClaimPermission } }
  /**
   * `origin` can claim payouts on some pool member `other`'s behalf.
   *
   * Pool member `other` must have a `PermissionlessAll` or `PermissionlessWithdraw` in order
   * for this call to be successful.
   **/
  | { name: 'ClaimPayoutOther'; params: { other: AccountId32 } }
  /**
   * Set the commission of a pool.
   * Both a commission percentage and a commission payee must be provided in the `current`
   * tuple. Where a `current` of `None` is provided, any current commission will be removed.
   *
   * - If a `None` is supplied to `new_commission`, existing commission will be removed.
   **/
  | { name: 'SetCommission'; params: { poolId: number; newCommission?: [Perbill, AccountId32] | undefined } }
  /**
   * Set the maximum commission of a pool.
   *
   * - Initial max can be set to any `Perbill`, and only smaller values thereafter.
   * - Current commission will be lowered in the event it is higher than a new max
   * commission.
   **/
  | { name: 'SetCommissionMax'; params: { poolId: number; maxCommission: Perbill } }
  /**
   * Set the commission change rate for a pool.
   *
   * Initial change rate is not bounded, whereas subsequent updates can only be more
   * restrictive than the current.
   **/
  | {
      name: 'SetCommissionChangeRate';
      params: { poolId: number; changeRate: PalletNominationPoolsCommissionChangeRate };
    }
  /**
   * Claim pending commission.
   *
   * The dispatch origin of this call must be signed by the `root` role of the pool. Pending
   * commission is paid out and added to total claimed commission`. Total pending commission
   * is reset to zero. the current.
   **/
  | { name: 'ClaimCommission'; params: { poolId: number } }
  /**
   * Top up the deficit or withdraw the excess ED from the pool.
   *
   * When a pool is created, the pool depositor transfers ED to the reward account of the
   * pool. ED is subject to change and over time, the deposit in the reward account may be
   * insufficient to cover the ED deficit of the pool or vice-versa where there is excess
   * deposit to the pool. This call allows anyone to adjust the ED deposit of the
   * pool by either topping up the deficit or claiming the excess.
   **/
  | { name: 'AdjustPoolDeposit'; params: { poolId: number } }
  /**
   * Set or remove a pool's commission claim permission.
   *
   * Determines who can claim the pool's pending commission. Only the `Root` role of the pool
   * is able to conifigure commission claim permissions.
   **/
  | {
      name: 'SetCommissionClaimPermission';
      params: { poolId: number; permission?: PalletNominationPoolsCommissionClaimPermission | undefined };
    };

export type PalletNominationPoolsCallLike =
  /**
   * Stake funds with a pool. The amount to bond is transferred from the member to the
   * pools account and immediately increases the pools bond.
   *
   * # Note
   *
   * * An account can only be a member of a single pool.
   * * An account cannot join the same pool multiple times.
   * * This call will *not* dust the member account, so the member must have at least
   * `existential deposit + amount` in their account.
   * * Only a pool with [`PoolState::Open`] can be joined
   **/
  | { name: 'Join'; params: { amount: bigint; poolId: number } }
  /**
   * Bond `extra` more funds from `origin` into the pool to which they already belong.
   *
   * Additional funds can come from either the free balance of the account, of from the
   * accumulated rewards, see [`BondExtra`].
   *
   * Bonding extra funds implies an automatic payout of all pending rewards as well.
   * See `bond_extra_other` to bond pending rewards of `other` members.
   **/
  | { name: 'BondExtra'; params: { extra: PalletNominationPoolsBondExtra } }
  /**
   * A bonded member can use this to claim their payout based on the rewards that the pool
   * has accumulated since their last claimed payout (OR since joining if this is their first
   * time claiming rewards). The payout will be transferred to the member's account.
   *
   * The member will earn rewards pro rata based on the members stake vs the sum of the
   * members in the pools stake. Rewards do not "expire".
   *
   * See `claim_payout_other` to caim rewards on bahalf of some `other` pool member.
   **/
  | { name: 'ClaimPayout' }
  /**
   * Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
   * implicitly collects the rewards one last time, since not doing so would mean some
   * rewards would be forfeited.
   *
   * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
   * account).
   *
   * # Conditions for a permissionless dispatch.
   *
   * * The pool is blocked and the caller is either the root or bouncer. This is refereed to
   * as a kick.
   * * The pool is destroying and the member is not the depositor.
   * * The pool is destroying, the member is the depositor and no other members are in the
   * pool.
   *
   * ## Conditions for permissioned dispatch (i.e. the caller is also the
   * `member_account`):
   *
   * * The caller is not the depositor.
   * * The caller is the depositor, the pool is destroying and no other members are in the
   * pool.
   *
   * # Note
   *
   * If there are too many unlocking chunks to unbond with the pool account,
   * [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks.
   * The [`StakingInterface::unbond`] will implicitly call [`Call::pool_withdraw_unbonded`]
   * to try to free chunks if necessary (ie. if unbound was called and no unlocking chunks
   * are available). However, it may not be possible to release the current unlocking chunks,
   * in which case, the result of this call will likely be the `NoMoreChunks` error from the
   * staking system.
   **/
  | { name: 'Unbond'; params: { memberAccount: MultiAddressLike; unbondingPoints: bigint } }
  /**
   * Call `withdraw_unbonded` for the pools account. This call can be made by any account.
   *
   * This is useful if there are too many unlocking chunks to call `unbond`, and some
   * can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
   * would probably see an error like `NoMoreChunks` emitted from the staking system when
   * they attempt to unbond.
   **/
  | { name: 'PoolWithdrawUnbonded'; params: { poolId: number; numSlashingSpans: number } }
  /**
   * Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
   * error is returned.
   *
   * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
   * account).
   *
   * # Conditions for a permissionless dispatch
   *
   * * The pool is in destroy mode and the target is not the depositor.
   * * The target is the depositor and they are the only member in the sub pools.
   * * The pool is blocked and the caller is either the root or bouncer.
   *
   * # Conditions for permissioned dispatch
   *
   * * The caller is the target and they are not the depositor.
   *
   * # Note
   *
   * If the target is the depositor, the pool will be destroyed.
   **/
  | { name: 'WithdrawUnbonded'; params: { memberAccount: MultiAddressLike; numSlashingSpans: number } }
  /**
   * Create a new delegation pool.
   *
   * # Arguments
   *
   * * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
   * deposit since the pools creator cannot fully unbond funds until the pool is being
   * destroyed.
   * * `index` - A disambiguation index for creating the account. Likely only useful when
   * creating multiple pools in the same extrinsic.
   * * `root` - The account to set as [`PoolRoles::root`].
   * * `nominator` - The account to set as the [`PoolRoles::nominator`].
   * * `bouncer` - The account to set as the [`PoolRoles::bouncer`].
   *
   * # Note
   *
   * In addition to `amount`, the caller will transfer the existential deposit; so the caller
   * needs at have at least `amount + existential_deposit` transferable.
   **/
  | {
      name: 'Create';
      params: { amount: bigint; root: MultiAddressLike; nominator: MultiAddressLike; bouncer: MultiAddressLike };
    }
  /**
   * Create a new delegation pool with a previously used pool id
   *
   * # Arguments
   *
   * same as `create` with the inclusion of
   * * `pool_id` - `A valid PoolId.
   **/
  | {
      name: 'CreateWithPoolId';
      params: {
        amount: bigint;
        root: MultiAddressLike;
        nominator: MultiAddressLike;
        bouncer: MultiAddressLike;
        poolId: number;
      };
    }
  /**
   * Nominate on behalf of the pool.
   *
   * The dispatch origin of this call must be signed by the pool nominator or the pool
   * root role.
   *
   * This directly forward the call to the staking pallet, on behalf of the pool bonded
   * account.
   *
   * # Note
   *
   * In addition to a `root` or `nominator` role of `origin`, pool's depositor needs to have
   * at least `depositor_min_bond` in the pool to start nominating.
   **/
  | { name: 'Nominate'; params: { poolId: number; validators: Array<AccountId32Like> } }
  /**
   * Set a new state for the pool.
   *
   * If a pool is already in the `Destroying` state, then under no condition can its state
   * change again.
   *
   * The dispatch origin of this call must be either:
   *
   * 1. signed by the bouncer, or the root role of the pool,
   * 2. if the pool conditions to be open are NOT met (as described by `ok_to_be_open`), and
   * then the state of the pool can be permissionlessly changed to `Destroying`.
   **/
  | { name: 'SetState'; params: { poolId: number; state: PalletNominationPoolsPoolState } }
  /**
   * Set a new metadata for the pool.
   *
   * The dispatch origin of this call must be signed by the bouncer, or the root role of the
   * pool.
   **/
  | { name: 'SetMetadata'; params: { poolId: number; metadata: BytesLike } }
  /**
   * Update configurations for the nomination pools. The origin for this call must be
   * Root.
   *
   * # Arguments
   *
   * * `min_join_bond` - Set [`MinJoinBond`].
   * * `min_create_bond` - Set [`MinCreateBond`].
   * * `max_pools` - Set [`MaxPools`].
   * * `max_members` - Set [`MaxPoolMembers`].
   * * `max_members_per_pool` - Set [`MaxPoolMembersPerPool`].
   * * `global_max_commission` - Set [`GlobalMaxCommission`].
   **/
  | {
      name: 'SetConfigs';
      params: {
        minJoinBond: PalletNominationPoolsConfigOp;
        minCreateBond: PalletNominationPoolsConfigOp;
        maxPools: PalletNominationPoolsConfigOpU32;
        maxMembers: PalletNominationPoolsConfigOpU32;
        maxMembersPerPool: PalletNominationPoolsConfigOpU32;
        globalMaxCommission: PalletNominationPoolsConfigOpPerbill;
      };
    }
  /**
   * Update the roles of the pool.
   *
   * The root is the only entity that can change any of the roles, including itself,
   * excluding the depositor, who can never change.
   *
   * It emits an event, notifying UIs of the role change. This event is quite relevant to
   * most pool members and they should be informed of changes to pool roles.
   **/
  | {
      name: 'UpdateRoles';
      params: {
        poolId: number;
        newRoot: PalletNominationPoolsConfigOp004;
        newNominator: PalletNominationPoolsConfigOp004;
        newBouncer: PalletNominationPoolsConfigOp004;
      };
    }
  /**
   * Chill on behalf of the pool.
   *
   * The dispatch origin of this call can be signed by the pool nominator or the pool
   * root role, same as [`Pallet::nominate`].
   *
   * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
   * account).
   *
   * # Conditions for a permissionless dispatch:
   * * When pool depositor has less than `MinNominatorBond` staked, otherwise pool members
   * are unable to unbond.
   *
   * # Conditions for permissioned dispatch:
   * * The caller has a nominator or root role of the pool.
   * This directly forward the call to the staking pallet, on behalf of the pool bonded
   * account.
   **/
  | { name: 'Chill'; params: { poolId: number } }
  /**
   * `origin` bonds funds from `extra` for some pool member `member` into their respective
   * pools.
   *
   * `origin` can bond extra funds from free balance or pending rewards when `origin ==
   * other`.
   *
   * In the case of `origin != other`, `origin` can only bond extra pending rewards of
   * `other` members assuming set_claim_permission for the given member is
   * `PermissionlessAll` or `PermissionlessCompound`.
   **/
  | { name: 'BondExtraOther'; params: { member: MultiAddressLike; extra: PalletNominationPoolsBondExtra } }
  /**
   * Allows a pool member to set a claim permission to allow or disallow permissionless
   * bonding and withdrawing.
   *
   * By default, this is `Permissioned`, which implies only the pool member themselves can
   * claim their pending rewards. If a pool member wishes so, they can set this to
   * `PermissionlessAll` to allow any account to claim their rewards and bond extra to the
   * pool.
   *
   * # Arguments
   *
   * * `origin` - Member of a pool.
   * * `actor` - Account to claim reward. // improve this
   **/
  | { name: 'SetClaimPermission'; params: { permission: PalletNominationPoolsClaimPermission } }
  /**
   * `origin` can claim payouts on some pool member `other`'s behalf.
   *
   * Pool member `other` must have a `PermissionlessAll` or `PermissionlessWithdraw` in order
   * for this call to be successful.
   **/
  | { name: 'ClaimPayoutOther'; params: { other: AccountId32Like } }
  /**
   * Set the commission of a pool.
   * Both a commission percentage and a commission payee must be provided in the `current`
   * tuple. Where a `current` of `None` is provided, any current commission will be removed.
   *
   * - If a `None` is supplied to `new_commission`, existing commission will be removed.
   **/
  | { name: 'SetCommission'; params: { poolId: number; newCommission?: [Perbill, AccountId32Like] | undefined } }
  /**
   * Set the maximum commission of a pool.
   *
   * - Initial max can be set to any `Perbill`, and only smaller values thereafter.
   * - Current commission will be lowered in the event it is higher than a new max
   * commission.
   **/
  | { name: 'SetCommissionMax'; params: { poolId: number; maxCommission: Perbill } }
  /**
   * Set the commission change rate for a pool.
   *
   * Initial change rate is not bounded, whereas subsequent updates can only be more
   * restrictive than the current.
   **/
  | {
      name: 'SetCommissionChangeRate';
      params: { poolId: number; changeRate: PalletNominationPoolsCommissionChangeRate };
    }
  /**
   * Claim pending commission.
   *
   * The dispatch origin of this call must be signed by the `root` role of the pool. Pending
   * commission is paid out and added to total claimed commission`. Total pending commission
   * is reset to zero. the current.
   **/
  | { name: 'ClaimCommission'; params: { poolId: number } }
  /**
   * Top up the deficit or withdraw the excess ED from the pool.
   *
   * When a pool is created, the pool depositor transfers ED to the reward account of the
   * pool. ED is subject to change and over time, the deposit in the reward account may be
   * insufficient to cover the ED deficit of the pool or vice-versa where there is excess
   * deposit to the pool. This call allows anyone to adjust the ED deposit of the
   * pool by either topping up the deficit or claiming the excess.
   **/
  | { name: 'AdjustPoolDeposit'; params: { poolId: number } }
  /**
   * Set or remove a pool's commission claim permission.
   *
   * Determines who can claim the pool's pending commission. Only the `Root` role of the pool
   * is able to conifigure commission claim permissions.
   **/
  | {
      name: 'SetCommissionClaimPermission';
      params: { poolId: number; permission?: PalletNominationPoolsCommissionClaimPermission | undefined };
    };

export type PalletNominationPoolsBondExtra = { tag: 'FreeBalance'; value: bigint } | { tag: 'Rewards' };

export type PalletNominationPoolsPoolState = 'Open' | 'Blocked' | 'Destroying';

export type PalletNominationPoolsConfigOp = { tag: 'Noop' } | { tag: 'Set'; value: bigint } | { tag: 'Remove' };

export type PalletNominationPoolsConfigOpU32 = { tag: 'Noop' } | { tag: 'Set'; value: number } | { tag: 'Remove' };

export type PalletNominationPoolsConfigOpPerbill = { tag: 'Noop' } | { tag: 'Set'; value: Perbill } | { tag: 'Remove' };

export type PalletNominationPoolsConfigOp004 = { tag: 'Noop' } | { tag: 'Set'; value: AccountId32 } | { tag: 'Remove' };

export type PalletNominationPoolsClaimPermission =
  | 'Permissioned'
  | 'PermissionlessCompound'
  | 'PermissionlessWithdraw'
  | 'PermissionlessAll';

export type PalletNominationPoolsCommissionChangeRate = { maxIncrease: Perbill; minDelay: number };

export type PalletNominationPoolsCommissionClaimPermission =
  | { tag: 'Permissionless' }
  | { tag: 'Account'; value: AccountId32 };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRankedCollectiveCall =
  /**
   * Introduce a new member.
   *
   * - `origin`: Must be the `AddOrigin`.
   * - `who`: Account of non-member which will become a member.
   *
   * Weight: `O(1)`
   **/
  | { name: 'AddMember'; params: { who: MultiAddress } }
  /**
   * Increment the rank of an existing member by one.
   *
   * - `origin`: Must be the `PromoteOrigin`.
   * - `who`: Account of existing member.
   *
   * Weight: `O(1)`
   **/
  | { name: 'PromoteMember'; params: { who: MultiAddress } }
  /**
   * Decrement the rank of an existing member by one. If the member is already at rank zero,
   * then they are removed entirely.
   *
   * - `origin`: Must be the `DemoteOrigin`.
   * - `who`: Account of existing member of rank greater than zero.
   *
   * Weight: `O(1)`, less if the member's index is highest in its rank.
   **/
  | { name: 'DemoteMember'; params: { who: MultiAddress } }
  /**
   * Remove the member entirely.
   *
   * - `origin`: Must be the `RemoveOrigin`.
   * - `who`: Account of existing member of rank greater than zero.
   * - `min_rank`: The rank of the member or greater.
   *
   * Weight: `O(min_rank)`.
   **/
  | { name: 'RemoveMember'; params: { who: MultiAddress; minRank: number } }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * - `origin`: Must be `Signed` by a member account.
   * - `poll`: Index of a poll which is ongoing.
   * - `aye`: `true` if the vote is to approve the proposal, `false` otherwise.
   *
   * Transaction fees are be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   *
   * Weight: `O(1)`, less if there was no previous vote on the poll by the member.
   **/
  | { name: 'Vote'; params: { poll: number; aye: boolean } }
  /**
   * Remove votes from the given poll. It must have ended.
   *
   * - `origin`: Must be `Signed` by any account.
   * - `poll_index`: Index of a poll which is completed and for which votes continue to
   * exist.
   * - `max`: Maximum number of vote items from remove in this call.
   *
   * Transaction fees are waived if the operation is successful.
   *
   * Weight `O(max)` (less if there are fewer items to remove than `max`).
   **/
  | { name: 'CleanupPoll'; params: { pollIndex: number; max: number } }
  /**
   * Exchanges a member with a new account and the same existing rank.
   *
   * - `origin`: Must be the `ExchangeOrigin`.
   * - `who`: Account of existing member of rank greater than zero to be exchanged.
   * - `new_who`: New Account of existing member of rank greater than zero to exchanged to.
   **/
  | { name: 'ExchangeMember'; params: { who: MultiAddress; newWho: MultiAddress } };

export type PalletRankedCollectiveCallLike =
  /**
   * Introduce a new member.
   *
   * - `origin`: Must be the `AddOrigin`.
   * - `who`: Account of non-member which will become a member.
   *
   * Weight: `O(1)`
   **/
  | { name: 'AddMember'; params: { who: MultiAddressLike } }
  /**
   * Increment the rank of an existing member by one.
   *
   * - `origin`: Must be the `PromoteOrigin`.
   * - `who`: Account of existing member.
   *
   * Weight: `O(1)`
   **/
  | { name: 'PromoteMember'; params: { who: MultiAddressLike } }
  /**
   * Decrement the rank of an existing member by one. If the member is already at rank zero,
   * then they are removed entirely.
   *
   * - `origin`: Must be the `DemoteOrigin`.
   * - `who`: Account of existing member of rank greater than zero.
   *
   * Weight: `O(1)`, less if the member's index is highest in its rank.
   **/
  | { name: 'DemoteMember'; params: { who: MultiAddressLike } }
  /**
   * Remove the member entirely.
   *
   * - `origin`: Must be the `RemoveOrigin`.
   * - `who`: Account of existing member of rank greater than zero.
   * - `min_rank`: The rank of the member or greater.
   *
   * Weight: `O(min_rank)`.
   **/
  | { name: 'RemoveMember'; params: { who: MultiAddressLike; minRank: number } }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * - `origin`: Must be `Signed` by a member account.
   * - `poll`: Index of a poll which is ongoing.
   * - `aye`: `true` if the vote is to approve the proposal, `false` otherwise.
   *
   * Transaction fees are be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   *
   * Weight: `O(1)`, less if there was no previous vote on the poll by the member.
   **/
  | { name: 'Vote'; params: { poll: number; aye: boolean } }
  /**
   * Remove votes from the given poll. It must have ended.
   *
   * - `origin`: Must be `Signed` by any account.
   * - `poll_index`: Index of a poll which is completed and for which votes continue to
   * exist.
   * - `max`: Maximum number of vote items from remove in this call.
   *
   * Transaction fees are waived if the operation is successful.
   *
   * Weight `O(max)` (less if there are fewer items to remove than `max`).
   **/
  | { name: 'CleanupPoll'; params: { pollIndex: number; max: number } }
  /**
   * Exchanges a member with a new account and the same existing rank.
   *
   * - `origin`: Must be the `ExchangeOrigin`.
   * - `who`: Account of existing member of rank greater than zero to be exchanged.
   * - `new_who`: New Account of existing member of rank greater than zero to exchanged to.
   **/
  | { name: 'ExchangeMember'; params: { who: MultiAddressLike; newWho: MultiAddressLike } };

/**
 * Pallet's callable functions.
 **/
export type PalletAssetConversionCall =
  /**
   * Creates an empty liquidity pool and an associated new `lp_token` asset
   * (the id of which is returned in the `Event::PoolCreated` event).
   *
   * Once a pool is created, someone may [`Pallet::add_liquidity`] to it.
   **/
  | {
      name: 'CreatePool';
      params: {
        asset1: FrameSupportTokensFungibleUnionOfNativeOrWithId;
        asset2: FrameSupportTokensFungibleUnionOfNativeOrWithId;
      };
    }
  /**
   * Provide liquidity into the pool of `asset1` and `asset2`.
   * NOTE: an optimal amount of asset1 and asset2 will be calculated and
   * might be different than the provided `amount1_desired`/`amount2_desired`
   * thus you should provide the min amount you're happy to provide.
   * Params `amount1_min`/`amount2_min` represent that.
   * `mint_to` will be sent the liquidity tokens that represent this share of the pool.
   *
   * NOTE: when encountering an incorrect exchange rate and non-withdrawable pool liquidity,
   * batch an atomic call with [`Pallet::add_liquidity`] and
   * [`Pallet::swap_exact_tokens_for_tokens`] or [`Pallet::swap_tokens_for_exact_tokens`]
   * calls to render the liquidity withdrawable and rectify the exchange rate.
   *
   * Once liquidity is added, someone may successfully call
   * [`Pallet::swap_exact_tokens_for_tokens`] successfully.
   **/
  | {
      name: 'AddLiquidity';
      params: {
        asset1: FrameSupportTokensFungibleUnionOfNativeOrWithId;
        asset2: FrameSupportTokensFungibleUnionOfNativeOrWithId;
        amount1Desired: bigint;
        amount2Desired: bigint;
        amount1Min: bigint;
        amount2Min: bigint;
        mintTo: AccountId32;
      };
    }
  /**
   * Allows you to remove liquidity by providing the `lp_token_burn` tokens that will be
   * burned in the process. With the usage of `amount1_min_receive`/`amount2_min_receive`
   * it's possible to control the min amount of returned tokens you're happy with.
   **/
  | {
      name: 'RemoveLiquidity';
      params: {
        asset1: FrameSupportTokensFungibleUnionOfNativeOrWithId;
        asset2: FrameSupportTokensFungibleUnionOfNativeOrWithId;
        lpTokenBurn: bigint;
        amount1MinReceive: bigint;
        amount2MinReceive: bigint;
        withdrawTo: AccountId32;
      };
    }
  /**
   * Swap the exact amount of `asset1` into `asset2`.
   * `amount_out_min` param allows you to specify the min amount of the `asset2`
   * you're happy to receive.
   *
   * [`AssetConversionApi::quote_price_exact_tokens_for_tokens`] runtime call can be called
   * for a quote.
   **/
  | {
      name: 'SwapExactTokensForTokens';
      params: {
        path: Array<FrameSupportTokensFungibleUnionOfNativeOrWithId>;
        amountIn: bigint;
        amountOutMin: bigint;
        sendTo: AccountId32;
        keepAlive: boolean;
      };
    }
  /**
   * Swap any amount of `asset1` to get the exact amount of `asset2`.
   * `amount_in_max` param allows to specify the max amount of the `asset1`
   * you're happy to provide.
   *
   * [`AssetConversionApi::quote_price_tokens_for_exact_tokens`] runtime call can be called
   * for a quote.
   **/
  | {
      name: 'SwapTokensForExactTokens';
      params: {
        path: Array<FrameSupportTokensFungibleUnionOfNativeOrWithId>;
        amountOut: bigint;
        amountInMax: bigint;
        sendTo: AccountId32;
        keepAlive: boolean;
      };
    };

export type PalletAssetConversionCallLike =
  /**
   * Creates an empty liquidity pool and an associated new `lp_token` asset
   * (the id of which is returned in the `Event::PoolCreated` event).
   *
   * Once a pool is created, someone may [`Pallet::add_liquidity`] to it.
   **/
  | {
      name: 'CreatePool';
      params: {
        asset1: FrameSupportTokensFungibleUnionOfNativeOrWithId;
        asset2: FrameSupportTokensFungibleUnionOfNativeOrWithId;
      };
    }
  /**
   * Provide liquidity into the pool of `asset1` and `asset2`.
   * NOTE: an optimal amount of asset1 and asset2 will be calculated and
   * might be different than the provided `amount1_desired`/`amount2_desired`
   * thus you should provide the min amount you're happy to provide.
   * Params `amount1_min`/`amount2_min` represent that.
   * `mint_to` will be sent the liquidity tokens that represent this share of the pool.
   *
   * NOTE: when encountering an incorrect exchange rate and non-withdrawable pool liquidity,
   * batch an atomic call with [`Pallet::add_liquidity`] and
   * [`Pallet::swap_exact_tokens_for_tokens`] or [`Pallet::swap_tokens_for_exact_tokens`]
   * calls to render the liquidity withdrawable and rectify the exchange rate.
   *
   * Once liquidity is added, someone may successfully call
   * [`Pallet::swap_exact_tokens_for_tokens`] successfully.
   **/
  | {
      name: 'AddLiquidity';
      params: {
        asset1: FrameSupportTokensFungibleUnionOfNativeOrWithId;
        asset2: FrameSupportTokensFungibleUnionOfNativeOrWithId;
        amount1Desired: bigint;
        amount2Desired: bigint;
        amount1Min: bigint;
        amount2Min: bigint;
        mintTo: AccountId32Like;
      };
    }
  /**
   * Allows you to remove liquidity by providing the `lp_token_burn` tokens that will be
   * burned in the process. With the usage of `amount1_min_receive`/`amount2_min_receive`
   * it's possible to control the min amount of returned tokens you're happy with.
   **/
  | {
      name: 'RemoveLiquidity';
      params: {
        asset1: FrameSupportTokensFungibleUnionOfNativeOrWithId;
        asset2: FrameSupportTokensFungibleUnionOfNativeOrWithId;
        lpTokenBurn: bigint;
        amount1MinReceive: bigint;
        amount2MinReceive: bigint;
        withdrawTo: AccountId32Like;
      };
    }
  /**
   * Swap the exact amount of `asset1` into `asset2`.
   * `amount_out_min` param allows you to specify the min amount of the `asset2`
   * you're happy to receive.
   *
   * [`AssetConversionApi::quote_price_exact_tokens_for_tokens`] runtime call can be called
   * for a quote.
   **/
  | {
      name: 'SwapExactTokensForTokens';
      params: {
        path: Array<FrameSupportTokensFungibleUnionOfNativeOrWithId>;
        amountIn: bigint;
        amountOutMin: bigint;
        sendTo: AccountId32Like;
        keepAlive: boolean;
      };
    }
  /**
   * Swap any amount of `asset1` to get the exact amount of `asset2`.
   * `amount_in_max` param allows to specify the max amount of the `asset1`
   * you're happy to provide.
   *
   * [`AssetConversionApi::quote_price_tokens_for_exact_tokens`] runtime call can be called
   * for a quote.
   **/
  | {
      name: 'SwapTokensForExactTokens';
      params: {
        path: Array<FrameSupportTokensFungibleUnionOfNativeOrWithId>;
        amountOut: bigint;
        amountInMax: bigint;
        sendTo: AccountId32Like;
        keepAlive: boolean;
      };
    };

export type FrameSupportTokensFungibleUnionOfNativeOrWithId = { tag: 'Native' } | { tag: 'WithId'; value: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletFastUnstakeCall =
  /**
   * Register oneself for fast-unstake.
   *
   * ## Dispatch Origin
   *
   * The dispatch origin of this call must be *signed* by whoever is permitted to call
   * unbond funds by the staking system. See [`Config::Staking`].
   *
   * ## Details
   *
   * The stash associated with the origin must have no ongoing unlocking chunks. If
   * successful, this will fully unbond and chill the stash. Then, it will enqueue the stash
   * to be checked in further blocks.
   *
   * If by the time this is called, the stash is actually eligible for fast-unstake, then
   * they are guaranteed to remain eligible, because the call will chill them as well.
   *
   * If the check works, the entire staking data is removed, i.e. the stash is fully
   * unstaked.
   *
   * If the check fails, the stash remains chilled and waiting for being unbonded as in with
   * the normal staking system, but they lose part of their unbonding chunks due to consuming
   * the chain's resources.
   *
   * ## Events
   *
   * Some events from the staking and currency system might be emitted.
   **/
  | { name: 'RegisterFastUnstake' }
  /**
   * Deregister oneself from the fast-unstake.
   *
   * ## Dispatch Origin
   *
   * The dispatch origin of this call must be *signed* by whoever is permitted to call
   * unbond funds by the staking system. See [`Config::Staking`].
   *
   * ## Details
   *
   * This is useful if one is registered, they are still waiting, and they change their mind.
   *
   * Note that the associated stash is still fully unbonded and chilled as a consequence of
   * calling [`Pallet::register_fast_unstake`]. Therefore, this should probably be followed
   * by a call to `rebond` in the staking system.
   *
   * ## Events
   *
   * Some events from the staking and currency system might be emitted.
   **/
  | { name: 'Deregister' }
  /**
   * Control the operation of this pallet.
   *
   * ## Dispatch Origin
   *
   * The dispatch origin of this call must be [`Config::ControlOrigin`].
   *
   * ## Details
   *
   * Can set the number of eras to check per block, and potentially other admin work.
   *
   * ## Events
   *
   * No events are emitted from this dispatch.
   **/
  | { name: 'Control'; params: { erasToCheck: number } };

export type PalletFastUnstakeCallLike =
  /**
   * Register oneself for fast-unstake.
   *
   * ## Dispatch Origin
   *
   * The dispatch origin of this call must be *signed* by whoever is permitted to call
   * unbond funds by the staking system. See [`Config::Staking`].
   *
   * ## Details
   *
   * The stash associated with the origin must have no ongoing unlocking chunks. If
   * successful, this will fully unbond and chill the stash. Then, it will enqueue the stash
   * to be checked in further blocks.
   *
   * If by the time this is called, the stash is actually eligible for fast-unstake, then
   * they are guaranteed to remain eligible, because the call will chill them as well.
   *
   * If the check works, the entire staking data is removed, i.e. the stash is fully
   * unstaked.
   *
   * If the check fails, the stash remains chilled and waiting for being unbonded as in with
   * the normal staking system, but they lose part of their unbonding chunks due to consuming
   * the chain's resources.
   *
   * ## Events
   *
   * Some events from the staking and currency system might be emitted.
   **/
  | { name: 'RegisterFastUnstake' }
  /**
   * Deregister oneself from the fast-unstake.
   *
   * ## Dispatch Origin
   *
   * The dispatch origin of this call must be *signed* by whoever is permitted to call
   * unbond funds by the staking system. See [`Config::Staking`].
   *
   * ## Details
   *
   * This is useful if one is registered, they are still waiting, and they change their mind.
   *
   * Note that the associated stash is still fully unbonded and chilled as a consequence of
   * calling [`Pallet::register_fast_unstake`]. Therefore, this should probably be followed
   * by a call to `rebond` in the staking system.
   *
   * ## Events
   *
   * Some events from the staking and currency system might be emitted.
   **/
  | { name: 'Deregister' }
  /**
   * Control the operation of this pallet.
   *
   * ## Dispatch Origin
   *
   * The dispatch origin of this call must be [`Config::ControlOrigin`].
   *
   * ## Details
   *
   * Can set the number of eras to check per block, and potentially other admin work.
   *
   * ## Events
   *
   * No events are emitted from this dispatch.
   **/
  | { name: 'Control'; params: { erasToCheck: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMessageQueueCall =
  /**
   * Remove a page which has no more messages remaining to be processed or is stale.
   **/
  | { name: 'ReapPage'; params: { messageOrigin: number; pageIndex: number } }
  /**
   * Execute an overweight message.
   *
   * Temporary processing errors will be propagated whereas permanent errors are treated
   * as success condition.
   *
   * - `origin`: Must be `Signed`.
   * - `message_origin`: The origin from which the message to be executed arrived.
   * - `page`: The page in the queue in which the message to be executed is sitting.
   * - `index`: The index into the queue of the message to be executed.
   * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
   * of the message.
   *
   * Benchmark complexity considerations: O(index + weight_limit).
   **/
  | {
      name: 'ExecuteOverweight';
      params: { messageOrigin: number; page: number; index: number; weightLimit: SpWeightsWeightV2Weight };
    };

export type PalletMessageQueueCallLike =
  /**
   * Remove a page which has no more messages remaining to be processed or is stale.
   **/
  | { name: 'ReapPage'; params: { messageOrigin: number; pageIndex: number } }
  /**
   * Execute an overweight message.
   *
   * Temporary processing errors will be propagated whereas permanent errors are treated
   * as success condition.
   *
   * - `origin`: Must be `Signed`.
   * - `message_origin`: The origin from which the message to be executed arrived.
   * - `page`: The page in the queue in which the message to be executed is sitting.
   * - `index`: The index into the queue of the message to be executed.
   * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
   * of the message.
   *
   * Benchmark complexity considerations: O(index + weight_limit).
   **/
  | {
      name: 'ExecuteOverweight';
      params: { messageOrigin: number; page: number; index: number; weightLimit: SpWeightsWeightV2Weight };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type FrameBenchmarkingPalletPovCall = 'EmitEvent' | 'Noop';

export type FrameBenchmarkingPalletPovCallLike = 'EmitEvent' | 'Noop';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTxPauseCall =
  /**
   * Pause a call.
   *
   * Can only be called by [`Config::PauseOrigin`].
   * Emits an [`Event::CallPaused`] event on success.
   **/
  | { name: 'Pause'; params: { fullName: [Bytes, Bytes] } }
  /**
   * Un-pause a call.
   *
   * Can only be called by [`Config::UnpauseOrigin`].
   * Emits an [`Event::CallUnpaused`] event on success.
   **/
  | { name: 'Unpause'; params: { ident: [Bytes, Bytes] } };

export type PalletTxPauseCallLike =
  /**
   * Pause a call.
   *
   * Can only be called by [`Config::PauseOrigin`].
   * Emits an [`Event::CallPaused`] event on success.
   **/
  | { name: 'Pause'; params: { fullName: [BytesLike, BytesLike] } }
  /**
   * Un-pause a call.
   *
   * Can only be called by [`Config::UnpauseOrigin`].
   * Emits an [`Event::CallUnpaused`] event on success.
   **/
  | { name: 'Unpause'; params: { ident: [BytesLike, BytesLike] } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSafeModeCall =
  /**
   * Enter safe-mode permissionlessly for [`Config::EnterDuration`] blocks.
   *
   * Reserves [`Config::EnterDepositAmount`] from the caller's account.
   * Emits an [`Event::Entered`] event on success.
   * Errors with [`Error::Entered`] if the safe-mode is already entered.
   * Errors with [`Error::NotConfigured`] if the deposit amount is `None`.
   **/
  | { name: 'Enter' }
  /**
   * Enter safe-mode by force for a per-origin configured number of blocks.
   *
   * Emits an [`Event::Entered`] event on success.
   * Errors with [`Error::Entered`] if the safe-mode is already entered.
   *
   * Can only be called by the [`Config::ForceEnterOrigin`] origin.
   **/
  | { name: 'ForceEnter' }
  /**
   * Extend the safe-mode permissionlessly for [`Config::ExtendDuration`] blocks.
   *
   * This accumulates on top of the current remaining duration.
   * Reserves [`Config::ExtendDepositAmount`] from the caller's account.
   * Emits an [`Event::Extended`] event on success.
   * Errors with [`Error::Exited`] if the safe-mode is entered.
   * Errors with [`Error::NotConfigured`] if the deposit amount is `None`.
   *
   * This may be called by any signed origin with [`Config::ExtendDepositAmount`] free
   * currency to reserve. This call can be disabled for all origins by configuring
   * [`Config::ExtendDepositAmount`] to `None`.
   **/
  | { name: 'Extend' }
  /**
   * Extend the safe-mode by force for a per-origin configured number of blocks.
   *
   * Emits an [`Event::Extended`] event on success.
   * Errors with [`Error::Exited`] if the safe-mode is inactive.
   *
   * Can only be called by the [`Config::ForceExtendOrigin`] origin.
   **/
  | { name: 'ForceExtend' }
  /**
   * Exit safe-mode by force.
   *
   * Emits an [`Event::Exited`] with [`ExitReason::Force`] event on success.
   * Errors with [`Error::Exited`] if the safe-mode is inactive.
   *
   * Note: `safe-mode` will be automatically deactivated by [`Pallet::on_initialize`] hook
   * after the block height is greater than the [`EnteredUntil`] storage item.
   * Emits an [`Event::Exited`] with [`ExitReason::Timeout`] event when deactivated in the
   * hook.
   **/
  | { name: 'ForceExit' }
  /**
   * Slash a deposit for an account that entered or extended safe-mode at a given
   * historical block.
   *
   * This can only be called while safe-mode is entered.
   *
   * Emits a [`Event::DepositSlashed`] event on success.
   * Errors with [`Error::Entered`] if safe-mode is entered.
   *
   * Can only be called by the [`Config::ForceDepositOrigin`] origin.
   **/
  | { name: 'ForceSlashDeposit'; params: { account: AccountId32; block: number } }
  /**
   * Permissionlessly release a deposit for an account that entered safe-mode at a
   * given historical block.
   *
   * The call can be completely disabled by setting [`Config::ReleaseDelay`] to `None`.
   * This cannot be called while safe-mode is entered and not until
   * [`Config::ReleaseDelay`] blocks have passed since safe-mode was entered.
   *
   * Emits a [`Event::DepositReleased`] event on success.
   * Errors with [`Error::Entered`] if the safe-mode is entered.
   * Errors with [`Error::CannotReleaseYet`] if [`Config::ReleaseDelay`] block have not
   * passed since safe-mode was entered. Errors with [`Error::NoDeposit`] if the payee has no
   * reserved currency at the block specified.
   **/
  | { name: 'ReleaseDeposit'; params: { account: AccountId32; block: number } }
  /**
   * Force to release a deposit for an account that entered safe-mode at a given
   * historical block.
   *
   * This can be called while safe-mode is still entered.
   *
   * Emits a [`Event::DepositReleased`] event on success.
   * Errors with [`Error::Entered`] if safe-mode is entered.
   * Errors with [`Error::NoDeposit`] if the payee has no reserved currency at the
   * specified block.
   *
   * Can only be called by the [`Config::ForceDepositOrigin`] origin.
   **/
  | { name: 'ForceReleaseDeposit'; params: { account: AccountId32; block: number } };

export type PalletSafeModeCallLike =
  /**
   * Enter safe-mode permissionlessly for [`Config::EnterDuration`] blocks.
   *
   * Reserves [`Config::EnterDepositAmount`] from the caller's account.
   * Emits an [`Event::Entered`] event on success.
   * Errors with [`Error::Entered`] if the safe-mode is already entered.
   * Errors with [`Error::NotConfigured`] if the deposit amount is `None`.
   **/
  | { name: 'Enter' }
  /**
   * Enter safe-mode by force for a per-origin configured number of blocks.
   *
   * Emits an [`Event::Entered`] event on success.
   * Errors with [`Error::Entered`] if the safe-mode is already entered.
   *
   * Can only be called by the [`Config::ForceEnterOrigin`] origin.
   **/
  | { name: 'ForceEnter' }
  /**
   * Extend the safe-mode permissionlessly for [`Config::ExtendDuration`] blocks.
   *
   * This accumulates on top of the current remaining duration.
   * Reserves [`Config::ExtendDepositAmount`] from the caller's account.
   * Emits an [`Event::Extended`] event on success.
   * Errors with [`Error::Exited`] if the safe-mode is entered.
   * Errors with [`Error::NotConfigured`] if the deposit amount is `None`.
   *
   * This may be called by any signed origin with [`Config::ExtendDepositAmount`] free
   * currency to reserve. This call can be disabled for all origins by configuring
   * [`Config::ExtendDepositAmount`] to `None`.
   **/
  | { name: 'Extend' }
  /**
   * Extend the safe-mode by force for a per-origin configured number of blocks.
   *
   * Emits an [`Event::Extended`] event on success.
   * Errors with [`Error::Exited`] if the safe-mode is inactive.
   *
   * Can only be called by the [`Config::ForceExtendOrigin`] origin.
   **/
  | { name: 'ForceExtend' }
  /**
   * Exit safe-mode by force.
   *
   * Emits an [`Event::Exited`] with [`ExitReason::Force`] event on success.
   * Errors with [`Error::Exited`] if the safe-mode is inactive.
   *
   * Note: `safe-mode` will be automatically deactivated by [`Pallet::on_initialize`] hook
   * after the block height is greater than the [`EnteredUntil`] storage item.
   * Emits an [`Event::Exited`] with [`ExitReason::Timeout`] event when deactivated in the
   * hook.
   **/
  | { name: 'ForceExit' }
  /**
   * Slash a deposit for an account that entered or extended safe-mode at a given
   * historical block.
   *
   * This can only be called while safe-mode is entered.
   *
   * Emits a [`Event::DepositSlashed`] event on success.
   * Errors with [`Error::Entered`] if safe-mode is entered.
   *
   * Can only be called by the [`Config::ForceDepositOrigin`] origin.
   **/
  | { name: 'ForceSlashDeposit'; params: { account: AccountId32Like; block: number } }
  /**
   * Permissionlessly release a deposit for an account that entered safe-mode at a
   * given historical block.
   *
   * The call can be completely disabled by setting [`Config::ReleaseDelay`] to `None`.
   * This cannot be called while safe-mode is entered and not until
   * [`Config::ReleaseDelay`] blocks have passed since safe-mode was entered.
   *
   * Emits a [`Event::DepositReleased`] event on success.
   * Errors with [`Error::Entered`] if the safe-mode is entered.
   * Errors with [`Error::CannotReleaseYet`] if [`Config::ReleaseDelay`] block have not
   * passed since safe-mode was entered. Errors with [`Error::NoDeposit`] if the payee has no
   * reserved currency at the block specified.
   **/
  | { name: 'ReleaseDeposit'; params: { account: AccountId32Like; block: number } }
  /**
   * Force to release a deposit for an account that entered safe-mode at a given
   * historical block.
   *
   * This can be called while safe-mode is still entered.
   *
   * Emits a [`Event::DepositReleased`] event on success.
   * Errors with [`Error::Entered`] if safe-mode is entered.
   * Errors with [`Error::NoDeposit`] if the payee has no reserved currency at the
   * specified block.
   *
   * Can only be called by the [`Config::ForceDepositOrigin`] origin.
   **/
  | { name: 'ForceReleaseDeposit'; params: { account: AccountId32Like; block: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMigrationsCall =
  /**
   * Allows root to set a cursor to forcefully start, stop or forward the migration process.
   *
   * Should normally not be needed and is only in place as emergency measure. Note that
   * restarting the migration process in this manner will not call the
   * [`MigrationStatusHandler::started`] hook or emit an `UpgradeStarted` event.
   **/
  | { name: 'ForceSetCursor'; params: { cursor?: PalletMigrationsMigrationCursor | undefined } }
  /**
   * Allows root to set an active cursor to forcefully start/forward the migration process.
   *
   * This is an edge-case version of [`Self::force_set_cursor`] that allows to set the
   * `started_at` value to the next block number. Otherwise this would not be possible, since
   * `force_set_cursor` takes an absolute block number. Setting `started_at` to `None`
   * indicates that the current block number plus one should be used.
   **/
  | {
      name: 'ForceSetActiveCursor';
      params: { index: number; innerCursor?: Bytes | undefined; startedAt?: number | undefined };
    }
  /**
   * Forces the onboarding of the migrations.
   *
   * This process happens automatically on a runtime upgrade. It is in place as an emergency
   * measurement. The cursor needs to be `None` for this to succeed.
   **/
  | { name: 'ForceOnboardMbms' }
  /**
   * Clears the `Historic` set.
   *
   * `map_cursor` must be set to the last value that was returned by the
   * `HistoricCleared` event. The first time `None` can be used. `limit` must be chosen in a
   * way that will result in a sensible weight.
   **/
  | { name: 'ClearHistoric'; params: { selector: PalletMigrationsHistoricCleanupSelector } };

export type PalletMigrationsCallLike =
  /**
   * Allows root to set a cursor to forcefully start, stop or forward the migration process.
   *
   * Should normally not be needed and is only in place as emergency measure. Note that
   * restarting the migration process in this manner will not call the
   * [`MigrationStatusHandler::started`] hook or emit an `UpgradeStarted` event.
   **/
  | { name: 'ForceSetCursor'; params: { cursor?: PalletMigrationsMigrationCursor | undefined } }
  /**
   * Allows root to set an active cursor to forcefully start/forward the migration process.
   *
   * This is an edge-case version of [`Self::force_set_cursor`] that allows to set the
   * `started_at` value to the next block number. Otherwise this would not be possible, since
   * `force_set_cursor` takes an absolute block number. Setting `started_at` to `None`
   * indicates that the current block number plus one should be used.
   **/
  | {
      name: 'ForceSetActiveCursor';
      params: { index: number; innerCursor?: BytesLike | undefined; startedAt?: number | undefined };
    }
  /**
   * Forces the onboarding of the migrations.
   *
   * This process happens automatically on a runtime upgrade. It is in place as an emergency
   * measurement. The cursor needs to be `None` for this to succeed.
   **/
  | { name: 'ForceOnboardMbms' }
  /**
   * Clears the `Historic` set.
   *
   * `map_cursor` must be set to the last value that was returned by the
   * `HistoricCleared` event. The first time `None` can be used. `limit` must be chosen in a
   * way that will result in a sensible weight.
   **/
  | { name: 'ClearHistoric'; params: { selector: PalletMigrationsHistoricCleanupSelector } };

export type PalletMigrationsMigrationCursor = { tag: 'Active'; value: PalletMigrationsActiveCursor } | { tag: 'Stuck' };

export type PalletMigrationsActiveCursor = { index: number; innerCursor?: Bytes | undefined; startedAt: number };

export type PalletMigrationsHistoricCleanupSelector =
  | { tag: 'Specific'; value: Array<Bytes> }
  | { tag: 'Wildcard'; value: { limit?: number | undefined; previousCursor?: Bytes | undefined } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBrokerCall =
  /**
   * Configure the pallet.
   *
   * - `origin`: Must be Root or pass `AdminOrigin`.
   * - `config`: The configuration for this pallet.
   **/
  | { name: 'Configure'; params: { config: PalletBrokerConfigRecord } }
  /**
   * Reserve a core for a workload.
   *
   * - `origin`: Must be Root or pass `AdminOrigin`.
   * - `workload`: The workload which should be permanently placed on a core.
   **/
  | { name: 'Reserve'; params: { workload: Array<PalletBrokerScheduleItem> } }
  /**
   * Cancel a reservation for a workload.
   *
   * - `origin`: Must be Root or pass `AdminOrigin`.
   * - `item_index`: The index of the reservation. Usually this will also be the index of the
   * core on which the reservation has been scheduled. However, it is possible that if
   * other cores are reserved or unreserved in the same sale rotation that they won't
   * correspond, so it's better to look up the core properly in the `Reservations` storage.
   **/
  | { name: 'Unreserve'; params: { itemIndex: number } }
  /**
   * Reserve a core for a single task workload for a limited period.
   *
   * In the interlude and sale period where Bulk Coretime is sold for the period immediately
   * after `until`, then the same workload may be renewed.
   *
   * - `origin`: Must be Root or pass `AdminOrigin`.
   * - `task`: The workload which should be placed on a core.
   * - `until`: The timeslice now earlier than which `task` should be placed as a workload on
   * a core.
   **/
  | { name: 'SetLease'; params: { task: number; until: number } }
  /**
   * Begin the Bulk Coretime sales rotation.
   *
   * - `origin`: Must be Root or pass `AdminOrigin`.
   * - `initial_price`: The price of Bulk Coretime in the first sale.
   * - `core_count`: The number of cores which can be allocated.
   **/
  | { name: 'StartSales'; params: { initialPrice: bigint; coreCount: number } }
  /**
   * Purchase Bulk Coretime in the ongoing Sale.
   *
   * - `origin`: Must be a Signed origin with at least enough funds to pay the current price
   * of Bulk Coretime.
   * - `price_limit`: An amount no more than which should be paid.
   **/
  | { name: 'Purchase'; params: { priceLimit: bigint } }
  /**
   * Renew Bulk Coretime in the ongoing Sale or its prior Interlude Period.
   *
   * - `origin`: Must be a Signed origin with at least enough funds to pay the renewal price
   * of the core.
   * - `core`: The core which should be renewed.
   **/
  | { name: 'Renew'; params: { core: number } }
  /**
   * Transfer a Bulk Coretime Region to a new owner.
   *
   * - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
   * - `region_id`: The Region whose ownership should change.
   * - `new_owner`: The new owner for the Region.
   **/
  | { name: 'Transfer'; params: { regionId: PalletBrokerRegionId; newOwner: AccountId32 } }
  /**
   * Split a Bulk Coretime Region into two non-overlapping Regions at a particular time into
   * the region.
   *
   * - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
   * - `region_id`: The Region which should be partitioned into two non-overlapping Regions.
   * - `pivot`: The offset in time into the Region at which to make the split.
   **/
  | { name: 'Partition'; params: { regionId: PalletBrokerRegionId; pivot: number } }
  /**
   * Split a Bulk Coretime Region into two wholly-overlapping Regions with complementary
   * interlace masks which together make up the original Region's interlace mask.
   *
   * - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
   * - `region_id`: The Region which should become two interlaced Regions of incomplete
   * regularity.
   * - `pivot`: The interlace mask of one of the two new regions (the other is its partial
   * complement).
   **/
  | { name: 'Interlace'; params: { regionId: PalletBrokerRegionId; pivot: PalletBrokerCoreMask } }
  /**
   * Assign a Bulk Coretime Region to a task.
   *
   * - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
   * - `region_id`: The Region which should be assigned to the task.
   * - `task`: The task to assign.
   * - `finality`: Indication of whether this assignment is final (in which case it may be
   * eligible for renewal) or provisional (in which case it may be manipulated and/or
   * reassigned at a later stage).
   **/
  | { name: 'Assign'; params: { regionId: PalletBrokerRegionId; task: number; finality: PalletBrokerFinality } }
  /**
   * Place a Bulk Coretime Region into the Instantaneous Coretime Pool.
   *
   * - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
   * - `region_id`: The Region which should be assigned to the Pool.
   * - `payee`: The account which is able to collect any revenue due for the usage of this
   * Coretime.
   **/
  | { name: 'Pool'; params: { regionId: PalletBrokerRegionId; payee: AccountId32; finality: PalletBrokerFinality } }
  /**
   * Claim the revenue owed from inclusion in the Instantaneous Coretime Pool.
   *
   * - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
   * - `region_id`: The Region which was assigned to the Pool.
   * - `max_timeslices`: The maximum number of timeslices which should be processed. This may
   * effect the weight of the call but should be ideally made equivalant to the length of
   * the Region `region_id`. If it is less than this, then further dispatches will be
   * required with the `region_id` which makes up any remainders of the region to be
   * collected.
   **/
  | { name: 'ClaimRevenue'; params: { regionId: PalletBrokerRegionId; maxTimeslices: number } }
  /**
   * Purchase credit for use in the Instantaneous Coretime Pool.
   *
   * - `origin`: Must be a Signed origin able to pay at least `amount`.
   * - `amount`: The amount of credit to purchase.
   * - `beneficiary`: The account on the Relay-chain which controls the credit (generally
   * this will be the collator's hot wallet).
   **/
  | { name: 'PurchaseCredit'; params: { amount: bigint; beneficiary: AccountId32 } }
  /**
   * Drop an expired Region from the chain.
   *
   * - `origin`: Can be any kind of origin.
   * - `region_id`: The Region which has expired.
   **/
  | { name: 'DropRegion'; params: { regionId: PalletBrokerRegionId } }
  /**
   * Drop an expired Instantaneous Pool Contribution record from the chain.
   *
   * - `origin`: Can be any kind of origin.
   * - `region_id`: The Region identifying the Pool Contribution which has expired.
   **/
  | { name: 'DropContribution'; params: { regionId: PalletBrokerRegionId } }
  /**
   * Drop an expired Instantaneous Pool History record from the chain.
   *
   * - `origin`: Can be any kind of origin.
   * - `region_id`: The time of the Pool History record which has expired.
   **/
  | { name: 'DropHistory'; params: { when: number } }
  /**
   * Drop an expired Allowed Renewal record from the chain.
   *
   * - `origin`: Can be any kind of origin.
   * - `core`: The core to which the expired renewal refers.
   * - `when`: The timeslice to which the expired renewal refers. This must have passed.
   **/
  | { name: 'DropRenewal'; params: { core: number; when: number } }
  /**
   * Request a change to the number of cores available for scheduling work.
   *
   * - `origin`: Must be Root or pass `AdminOrigin`.
   * - `core_count`: The desired number of cores to be made available.
   **/
  | { name: 'RequestCoreCount'; params: { coreCount: number } }
  | { name: 'NotifyCoreCount'; params: { coreCount: number } };

export type PalletBrokerCallLike =
  /**
   * Configure the pallet.
   *
   * - `origin`: Must be Root or pass `AdminOrigin`.
   * - `config`: The configuration for this pallet.
   **/
  | { name: 'Configure'; params: { config: PalletBrokerConfigRecord } }
  /**
   * Reserve a core for a workload.
   *
   * - `origin`: Must be Root or pass `AdminOrigin`.
   * - `workload`: The workload which should be permanently placed on a core.
   **/
  | { name: 'Reserve'; params: { workload: Array<PalletBrokerScheduleItem> } }
  /**
   * Cancel a reservation for a workload.
   *
   * - `origin`: Must be Root or pass `AdminOrigin`.
   * - `item_index`: The index of the reservation. Usually this will also be the index of the
   * core on which the reservation has been scheduled. However, it is possible that if
   * other cores are reserved or unreserved in the same sale rotation that they won't
   * correspond, so it's better to look up the core properly in the `Reservations` storage.
   **/
  | { name: 'Unreserve'; params: { itemIndex: number } }
  /**
   * Reserve a core for a single task workload for a limited period.
   *
   * In the interlude and sale period where Bulk Coretime is sold for the period immediately
   * after `until`, then the same workload may be renewed.
   *
   * - `origin`: Must be Root or pass `AdminOrigin`.
   * - `task`: The workload which should be placed on a core.
   * - `until`: The timeslice now earlier than which `task` should be placed as a workload on
   * a core.
   **/
  | { name: 'SetLease'; params: { task: number; until: number } }
  /**
   * Begin the Bulk Coretime sales rotation.
   *
   * - `origin`: Must be Root or pass `AdminOrigin`.
   * - `initial_price`: The price of Bulk Coretime in the first sale.
   * - `core_count`: The number of cores which can be allocated.
   **/
  | { name: 'StartSales'; params: { initialPrice: bigint; coreCount: number } }
  /**
   * Purchase Bulk Coretime in the ongoing Sale.
   *
   * - `origin`: Must be a Signed origin with at least enough funds to pay the current price
   * of Bulk Coretime.
   * - `price_limit`: An amount no more than which should be paid.
   **/
  | { name: 'Purchase'; params: { priceLimit: bigint } }
  /**
   * Renew Bulk Coretime in the ongoing Sale or its prior Interlude Period.
   *
   * - `origin`: Must be a Signed origin with at least enough funds to pay the renewal price
   * of the core.
   * - `core`: The core which should be renewed.
   **/
  | { name: 'Renew'; params: { core: number } }
  /**
   * Transfer a Bulk Coretime Region to a new owner.
   *
   * - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
   * - `region_id`: The Region whose ownership should change.
   * - `new_owner`: The new owner for the Region.
   **/
  | { name: 'Transfer'; params: { regionId: PalletBrokerRegionId; newOwner: AccountId32Like } }
  /**
   * Split a Bulk Coretime Region into two non-overlapping Regions at a particular time into
   * the region.
   *
   * - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
   * - `region_id`: The Region which should be partitioned into two non-overlapping Regions.
   * - `pivot`: The offset in time into the Region at which to make the split.
   **/
  | { name: 'Partition'; params: { regionId: PalletBrokerRegionId; pivot: number } }
  /**
   * Split a Bulk Coretime Region into two wholly-overlapping Regions with complementary
   * interlace masks which together make up the original Region's interlace mask.
   *
   * - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
   * - `region_id`: The Region which should become two interlaced Regions of incomplete
   * regularity.
   * - `pivot`: The interlace mask of one of the two new regions (the other is its partial
   * complement).
   **/
  | { name: 'Interlace'; params: { regionId: PalletBrokerRegionId; pivot: PalletBrokerCoreMask } }
  /**
   * Assign a Bulk Coretime Region to a task.
   *
   * - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
   * - `region_id`: The Region which should be assigned to the task.
   * - `task`: The task to assign.
   * - `finality`: Indication of whether this assignment is final (in which case it may be
   * eligible for renewal) or provisional (in which case it may be manipulated and/or
   * reassigned at a later stage).
   **/
  | { name: 'Assign'; params: { regionId: PalletBrokerRegionId; task: number; finality: PalletBrokerFinality } }
  /**
   * Place a Bulk Coretime Region into the Instantaneous Coretime Pool.
   *
   * - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
   * - `region_id`: The Region which should be assigned to the Pool.
   * - `payee`: The account which is able to collect any revenue due for the usage of this
   * Coretime.
   **/
  | { name: 'Pool'; params: { regionId: PalletBrokerRegionId; payee: AccountId32Like; finality: PalletBrokerFinality } }
  /**
   * Claim the revenue owed from inclusion in the Instantaneous Coretime Pool.
   *
   * - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
   * - `region_id`: The Region which was assigned to the Pool.
   * - `max_timeslices`: The maximum number of timeslices which should be processed. This may
   * effect the weight of the call but should be ideally made equivalant to the length of
   * the Region `region_id`. If it is less than this, then further dispatches will be
   * required with the `region_id` which makes up any remainders of the region to be
   * collected.
   **/
  | { name: 'ClaimRevenue'; params: { regionId: PalletBrokerRegionId; maxTimeslices: number } }
  /**
   * Purchase credit for use in the Instantaneous Coretime Pool.
   *
   * - `origin`: Must be a Signed origin able to pay at least `amount`.
   * - `amount`: The amount of credit to purchase.
   * - `beneficiary`: The account on the Relay-chain which controls the credit (generally
   * this will be the collator's hot wallet).
   **/
  | { name: 'PurchaseCredit'; params: { amount: bigint; beneficiary: AccountId32Like } }
  /**
   * Drop an expired Region from the chain.
   *
   * - `origin`: Can be any kind of origin.
   * - `region_id`: The Region which has expired.
   **/
  | { name: 'DropRegion'; params: { regionId: PalletBrokerRegionId } }
  /**
   * Drop an expired Instantaneous Pool Contribution record from the chain.
   *
   * - `origin`: Can be any kind of origin.
   * - `region_id`: The Region identifying the Pool Contribution which has expired.
   **/
  | { name: 'DropContribution'; params: { regionId: PalletBrokerRegionId } }
  /**
   * Drop an expired Instantaneous Pool History record from the chain.
   *
   * - `origin`: Can be any kind of origin.
   * - `region_id`: The time of the Pool History record which has expired.
   **/
  | { name: 'DropHistory'; params: { when: number } }
  /**
   * Drop an expired Allowed Renewal record from the chain.
   *
   * - `origin`: Can be any kind of origin.
   * - `core`: The core to which the expired renewal refers.
   * - `when`: The timeslice to which the expired renewal refers. This must have passed.
   **/
  | { name: 'DropRenewal'; params: { core: number; when: number } }
  /**
   * Request a change to the number of cores available for scheduling work.
   *
   * - `origin`: Must be Root or pass `AdminOrigin`.
   * - `core_count`: The desired number of cores to be made available.
   **/
  | { name: 'RequestCoreCount'; params: { coreCount: number } }
  | { name: 'NotifyCoreCount'; params: { coreCount: number } };

export type PalletBrokerConfigRecord = {
  advanceNotice: number;
  interludeLength: number;
  leadinLength: number;
  regionLength: number;
  idealBulkProportion: Perbill;
  limitCoresOffered?: number | undefined;
  renewalBump: Perbill;
  contributionTimeout: number;
};

export type PalletBrokerScheduleItem = {
  mask: PalletBrokerCoreMask;
  assignment: PalletBrokerCoretimeInterfaceCoreAssignment;
};

export type PalletBrokerCoreMask = FixedBytes<10>;

export type PalletBrokerCoretimeInterfaceCoreAssignment =
  | { tag: 'Idle' }
  | { tag: 'Pool' }
  | { tag: 'Task'; value: number };

export type PalletBrokerRegionId = { begin: number; core: number; mask: PalletBrokerCoreMask };

export type PalletBrokerFinality = 'Provisional' | 'Final';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMixnetCall =
  /**
   * Register a mixnode for the following session.
   **/
  { name: 'Register'; params: { registration: PalletMixnetRegistration; signature: SpMixnetAppSignature } };

export type PalletMixnetCallLike =
  /**
   * Register a mixnode for the following session.
   **/
  { name: 'Register'; params: { registration: PalletMixnetRegistration; signature: SpMixnetAppSignature } };

export type PalletMixnetRegistration = {
  blockNumber: number;
  sessionIndex: number;
  authorityIndex: number;
  mixnode: PalletMixnetBoundedMixnode;
};

export type PalletMixnetBoundedMixnode = {
  kxPublic: FixedBytes<32>;
  peerId: FixedBytes<32>;
  externalAddresses: Array<Bytes>;
};

export type SpMixnetAppSignature = SpCoreSr25519Signature;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletParametersCall =
  /**
   * Set the value of a parameter.
   *
   * The dispatch origin of this call must be `AdminOrigin` for the given `key`. Values be
   * deleted by setting them to `None`.
   **/
  { name: 'SetParameter'; params: { keyValue: KitchensinkRuntimeRuntimeParameters } };

export type PalletParametersCallLike =
  /**
   * Set the value of a parameter.
   *
   * The dispatch origin of this call must be `AdminOrigin` for the given `key`. Values be
   * deleted by setting them to `None`.
   **/
  { name: 'SetParameter'; params: { keyValue: KitchensinkRuntimeRuntimeParameters } };

export type KitchensinkRuntimeRuntimeParameters =
  | { tag: 'Storage'; value: KitchensinkRuntimeDynamicParamsStorageParameters }
  | { tag: 'Contract'; value: KitchensinkRuntimeDynamicParamsContractsParameters };

export type KitchensinkRuntimeDynamicParamsStorageParameters =
  | { tag: 'BaseDeposit'; value: [KitchensinkRuntimeDynamicParamsStorageBaseDeposit, bigint | undefined] }
  | { tag: 'ByteDeposit'; value: [KitchensinkRuntimeDynamicParamsStorageByteDeposit, bigint | undefined] };

export type KitchensinkRuntimeDynamicParamsStorageBaseDeposit = {};

export type KitchensinkRuntimeDynamicParamsStorageByteDeposit = {};

export type KitchensinkRuntimeDynamicParamsContractsParameters =
  | { tag: 'DepositPerItem'; value: [KitchensinkRuntimeDynamicParamsContractsDepositPerItem, bigint | undefined] }
  | { tag: 'DepositPerByte'; value: [KitchensinkRuntimeDynamicParamsContractsDepositPerByte, bigint | undefined] }
  | {
      tag: 'DefaultDepositLimit';
      value: [KitchensinkRuntimeDynamicParamsContractsDefaultDepositLimit, bigint | undefined];
    };

export type KitchensinkRuntimeDynamicParamsContractsDepositPerItem = {};

export type KitchensinkRuntimeDynamicParamsContractsDepositPerByte = {};

export type KitchensinkRuntimeDynamicParamsContractsDefaultDepositLimit = {};

export type SpRuntimeBlakeTwo256 = {};

export type PalletConvictionVotingTally = { ayes: bigint; nays: bigint; support: bigint };

/**
 * The `Event` enum of this pallet
 **/
export type PalletRemarkEvent =
  /**
   * Stored data off chain.
   **/
  { name: 'Stored'; data: { sender: AccountId32; contentHash: H256 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletRootTestingEvent =
  /**
   * Event dispatched when the trigger_defensive extrinsic is called.
   **/
  'DefensiveTestCall';

/**
 * The `Event` enum of this pallet
 **/
export type PalletConvictionVotingEvent =
  /**
   * An account has delegated their vote to another account. \[who, target\]
   **/
  | { name: 'Delegated'; data: [AccountId32, AccountId32] }
  /**
   * An \[account\] has cancelled a previous delegation operation.
   **/
  | { name: 'Undelegated'; data: AccountId32 };

/**
 * The `Event` enum of this pallet
 **/
export type PalletWhitelistEvent =
  | { name: 'CallWhitelisted'; data: { callHash: H256 } }
  | { name: 'WhitelistedCallRemoved'; data: { callHash: H256 } }
  | {
      name: 'WhitelistedCallDispatched';
      data: {
        callHash: H256;
        result: Result<FrameSupportDispatchPostDispatchInfo, SpRuntimeDispatchErrorWithPostInfo>;
      };
    };

export type FrameSupportDispatchPostDispatchInfo = {
  actualWeight?: SpWeightsWeightV2Weight | undefined;
  paysFee: FrameSupportDispatchPays;
};

export type SpRuntimeDispatchErrorWithPostInfo = {
  postInfo: FrameSupportDispatchPostDispatchInfo;
  error: DispatchError;
};

/**
 * The `Event` enum of this pallet
 **/
export type PalletAllianceEvent =
  /**
   * A new rule has been set.
   **/
  | { name: 'NewRuleSet'; data: { rule: PalletAllianceCid } }
  /**
   * A new announcement has been proposed.
   **/
  | { name: 'Announced'; data: { announcement: PalletAllianceCid } }
  /**
   * An on-chain announcement has been removed.
   **/
  | { name: 'AnnouncementRemoved'; data: { announcement: PalletAllianceCid } }
  /**
   * Some accounts have been initialized as members (fellows/allies).
   **/
  | { name: 'MembersInitialized'; data: { fellows: Array<AccountId32>; allies: Array<AccountId32> } }
  /**
   * An account has been added as an Ally and reserved its deposit.
   **/
  | {
      name: 'NewAllyJoined';
      data: { ally: AccountId32; nominator?: AccountId32 | undefined; reserved?: bigint | undefined };
    }
  /**
   * An ally has been elevated to Fellow.
   **/
  | { name: 'AllyElevated'; data: { ally: AccountId32 } }
  /**
   * A member gave retirement notice and their retirement period started.
   **/
  | { name: 'MemberRetirementPeriodStarted'; data: { member: AccountId32 } }
  /**
   * A member has retired with its deposit unreserved.
   **/
  | { name: 'MemberRetired'; data: { member: AccountId32; unreserved?: bigint | undefined } }
  /**
   * A member has been kicked out with its deposit slashed.
   **/
  | { name: 'MemberKicked'; data: { member: AccountId32; slashed?: bigint | undefined } }
  /**
   * Accounts or websites have been added into the list of unscrupulous items.
   **/
  | { name: 'UnscrupulousItemAdded'; data: { items: Array<PalletAllianceUnscrupulousItem> } }
  /**
   * Accounts or websites have been removed from the list of unscrupulous items.
   **/
  | { name: 'UnscrupulousItemRemoved'; data: { items: Array<PalletAllianceUnscrupulousItem> } }
  /**
   * Alliance disbanded. Includes number deleted members and unreserved deposits.
   **/
  | { name: 'AllianceDisbanded'; data: { fellowMembers: number; allyMembers: number; unreserved: number } }
  /**
   * A Fellow abdicated their voting rights. They are now an Ally.
   **/
  | { name: 'FellowAbdicated'; data: { fellow: AccountId32 } };

/**
 * Events of this pallet.
 **/
export type PalletNominationPoolsEvent =
  /**
   * A pool has been created.
   **/
  | { name: 'Created'; data: { depositor: AccountId32; poolId: number } }
  /**
   * A member has became bonded in a pool.
   **/
  | { name: 'Bonded'; data: { member: AccountId32; poolId: number; bonded: bigint; joined: boolean } }
  /**
   * A payout has been made to a member.
   **/
  | { name: 'PaidOut'; data: { member: AccountId32; poolId: number; payout: bigint } }
  /**
   * A member has unbonded from their pool.
   *
   * - `balance` is the corresponding balance of the number of points that has been
   * requested to be unbonded (the argument of the `unbond` transaction) from the bonded
   * pool.
   * - `points` is the number of points that are issued as a result of `balance` being
   * dissolved into the corresponding unbonding pool.
   * - `era` is the era in which the balance will be unbonded.
   * In the absence of slashing, these values will match. In the presence of slashing, the
   * number of points that are issued in the unbonding pool will be less than the amount
   * requested to be unbonded.
   **/
  | { name: 'Unbonded'; data: { member: AccountId32; poolId: number; balance: bigint; points: bigint; era: number } }
  /**
   * A member has withdrawn from their pool.
   *
   * The given number of `points` have been dissolved in return of `balance`.
   *
   * Similar to `Unbonded` event, in the absence of slashing, the ratio of point to balance
   * will be 1.
   **/
  | { name: 'Withdrawn'; data: { member: AccountId32; poolId: number; balance: bigint; points: bigint } }
  /**
   * A pool has been destroyed.
   **/
  | { name: 'Destroyed'; data: { poolId: number } }
  /**
   * The state of a pool has changed
   **/
  | { name: 'StateChanged'; data: { poolId: number; newState: PalletNominationPoolsPoolState } }
  /**
   * A member has been removed from a pool.
   *
   * The removal can be voluntary (withdrawn all unbonded funds) or involuntary (kicked).
   **/
  | { name: 'MemberRemoved'; data: { poolId: number; member: AccountId32 } }
  /**
   * The roles of a pool have been updated to the given new roles. Note that the depositor
   * can never change.
   **/
  | {
      name: 'RolesUpdated';
      data: { root?: AccountId32 | undefined; bouncer?: AccountId32 | undefined; nominator?: AccountId32 | undefined };
    }
  /**
   * The active balance of pool `pool_id` has been slashed to `balance`.
   **/
  | { name: 'PoolSlashed'; data: { poolId: number; balance: bigint } }
  /**
   * The unbond pool at `era` of pool `pool_id` has been slashed to `balance`.
   **/
  | { name: 'UnbondingPoolSlashed'; data: { poolId: number; era: number; balance: bigint } }
  /**
   * A pool's commission setting has been changed.
   **/
  | { name: 'PoolCommissionUpdated'; data: { poolId: number; current?: [Perbill, AccountId32] | undefined } }
  /**
   * A pool's maximum commission setting has been changed.
   **/
  | { name: 'PoolMaxCommissionUpdated'; data: { poolId: number; maxCommission: Perbill } }
  /**
   * A pool's commission `change_rate` has been changed.
   **/
  | {
      name: 'PoolCommissionChangeRateUpdated';
      data: { poolId: number; changeRate: PalletNominationPoolsCommissionChangeRate };
    }
  /**
   * Pool commission claim permission has been updated.
   **/
  | {
      name: 'PoolCommissionClaimPermissionUpdated';
      data: { poolId: number; permission?: PalletNominationPoolsCommissionClaimPermission | undefined };
    }
  /**
   * Pool commission has been claimed.
   **/
  | { name: 'PoolCommissionClaimed'; data: { poolId: number; commission: bigint } }
  /**
   * Topped up deficit in frozen ED of the reward pool.
   **/
  | { name: 'MinBalanceDeficitAdjusted'; data: { poolId: number; amount: bigint } }
  /**
   * Claimed excess frozen ED of af the reward pool.
   **/
  | { name: 'MinBalanceExcessAdjusted'; data: { poolId: number; amount: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletReferendaEvent002 =
  /**
   * A referendum has been submitted.
   **/
  | {
      name: 'Submitted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;
      };
    }
  /**
   * The decision deposit has been placed.
   **/
  | {
      name: 'DecisionDepositPlaced';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * The decision deposit has been refunded.
   **/
  | {
      name: 'DecisionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A deposit has been slashed.
   **/
  | {
      name: 'DepositSlashed';
      data: {
        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A referendum has moved into the deciding phase.
   **/
  | {
      name: 'DecisionStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;

        /**
         * The current tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  | {
      name: 'ConfirmStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  | {
      name: 'ConfirmAborted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A referendum has ended its confirmation phase and is ready for approval.
   **/
  | {
      name: 'Confirmed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * A referendum has been approved and its proposal has been scheduled.
   **/
  | {
      name: 'Approved';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A proposal has been rejected by referendum.
   **/
  | {
      name: 'Rejected';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * A referendum has been timed out without being decided.
   **/
  | {
      name: 'TimedOut';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * A referendum has been cancelled.
   **/
  | {
      name: 'Cancelled';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * A referendum has been killed.
   **/
  | {
      name: 'Killed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * The submission deposit has been refunded.
   **/
  | {
      name: 'SubmissionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * Metadata for a referendum has been set.
   **/
  | {
      name: 'MetadataSet';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  /**
   * Metadata for a referendum has been cleared.
   **/
  | {
      name: 'MetadataCleared';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    };

export type PalletRankedCollectiveTally = { bareAyes: number; ayes: number; nays: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletRankedCollectiveEvent =
  /**
   * A member `who` has been added.
   **/
  | { name: 'MemberAdded'; data: { who: AccountId32 } }
  /**
   * The member `who`se rank has been changed to the given `rank`.
   **/
  | { name: 'RankChanged'; data: { who: AccountId32; rank: number } }
  /**
   * The member `who` of given `rank` has been removed from the collective.
   **/
  | { name: 'MemberRemoved'; data: { who: AccountId32; rank: number } }
  /**
   * The member `who` has voted for the `poll` with the given `vote` leading to an updated
   * `tally`.
   **/
  | {
      name: 'Voted';
      data: {
        who: AccountId32;
        poll: number;
        vote: PalletRankedCollectiveVoteRecord;
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * The member `who` had their `AccountId` changed to `new_who`.
   **/
  | { name: 'MemberExchanged'; data: { who: AccountId32; newWho: AccountId32 } };

export type PalletRankedCollectiveVoteRecord = { tag: 'Aye'; value: number } | { tag: 'Nay'; value: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetConversionEvent =
  /**
   * A successful call of the `CretaPool` extrinsic will create this event.
   **/
  | {
      name: 'PoolCreated';
      data: {
        /**
         * The account that created the pool.
         **/
        creator: AccountId32;

        /**
         * The pool id associated with the pool. Note that the order of the assets may not be
         * the same as the order specified in the create pool extrinsic.
         **/
        poolId: [FrameSupportTokensFungibleUnionOfNativeOrWithId, FrameSupportTokensFungibleUnionOfNativeOrWithId];

        /**
         * The account ID of the pool.
         **/
        poolAccount: AccountId32;

        /**
         * The id of the liquidity tokens that will be minted when assets are added to this
         * pool.
         **/
        lpToken: number;
      };
    }
  /**
   * A successful call of the `AddLiquidity` extrinsic will create this event.
   **/
  | {
      name: 'LiquidityAdded';
      data: {
        /**
         * The account that the liquidity was taken from.
         **/
        who: AccountId32;

        /**
         * The account that the liquidity tokens were minted to.
         **/
        mintTo: AccountId32;

        /**
         * The pool id of the pool that the liquidity was added to.
         **/
        poolId: [FrameSupportTokensFungibleUnionOfNativeOrWithId, FrameSupportTokensFungibleUnionOfNativeOrWithId];

        /**
         * The amount of the first asset that was added to the pool.
         **/
        amount1Provided: bigint;

        /**
         * The amount of the second asset that was added to the pool.
         **/
        amount2Provided: bigint;

        /**
         * The id of the lp token that was minted.
         **/
        lpToken: number;

        /**
         * The amount of lp tokens that were minted of that id.
         **/
        lpTokenMinted: bigint;
      };
    }
  /**
   * A successful call of the `RemoveLiquidity` extrinsic will create this event.
   **/
  | {
      name: 'LiquidityRemoved';
      data: {
        /**
         * The account that the liquidity tokens were burned from.
         **/
        who: AccountId32;

        /**
         * The account that the assets were transferred to.
         **/
        withdrawTo: AccountId32;

        /**
         * The pool id that the liquidity was removed from.
         **/
        poolId: [FrameSupportTokensFungibleUnionOfNativeOrWithId, FrameSupportTokensFungibleUnionOfNativeOrWithId];

        /**
         * The amount of the first asset that was removed from the pool.
         **/
        amount1: bigint;

        /**
         * The amount of the second asset that was removed from the pool.
         **/
        amount2: bigint;

        /**
         * The id of the lp token that was burned.
         **/
        lpToken: number;

        /**
         * The amount of lp tokens that were burned of that id.
         **/
        lpTokenBurned: bigint;

        /**
         * Liquidity withdrawal fee (%).
         **/
        withdrawalFee: Permill;
      };
    }
  /**
   * Assets have been converted from one to another. Both `SwapExactTokenForToken`
   * and `SwapTokenForExactToken` will generate this event.
   **/
  | {
      name: 'SwapExecuted';
      data: {
        /**
         * Which account was the instigator of the swap.
         **/
        who: AccountId32;

        /**
         * The account that the assets were transferred to.
         **/
        sendTo: AccountId32;

        /**
         * The amount of the first asset that was swapped.
         **/
        amountIn: bigint;

        /**
         * The amount of the second asset that was received.
         **/
        amountOut: bigint;

        /**
         * The route of asset IDs with amounts that the swap went through.
         * E.g. (A, amount_in) -> (Dot, amount_out) -> (B, amount_out)
         **/
        path: Array<[FrameSupportTokensFungibleUnionOfNativeOrWithId, bigint]>;
      };
    }
  /**
   * Assets have been converted from one to another.
   **/
  | {
      name: 'SwapCreditExecuted';
      data: {
        /**
         * The amount of the first asset that was swapped.
         **/
        amountIn: bigint;

        /**
         * The amount of the second asset that was received.
         **/
        amountOut: bigint;

        /**
         * The route of asset IDs with amounts that the swap went through.
         * E.g. (A, amount_in) -> (Dot, amount_out) -> (B, amount_out)
         **/
        path: Array<[FrameSupportTokensFungibleUnionOfNativeOrWithId, bigint]>;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletFastUnstakeEvent =
  /**
   * A staker was unstaked.
   **/
  | { name: 'Unstaked'; data: { stash: AccountId32; result: Result<[], DispatchError> } }
  /**
   * A staker was slashed for requesting fast-unstake whilst being exposed.
   **/
  | { name: 'Slashed'; data: { stash: AccountId32; amount: bigint } }
  /**
   * A batch was partially checked for the given eras, but the process did not finish.
   **/
  | { name: 'BatchChecked'; data: { eras: Array<number> } }
  /**
   * A batch of a given size was terminated.
   *
   * This is always follows by a number of `Unstaked` or `Slashed` events, marking the end
   * of the batch. A new batch will be created upon next block.
   **/
  | { name: 'BatchFinished'; data: { size: number } }
  /**
   * An internal error happened. Operations will be paused now.
   **/
  | { name: 'InternalError' };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMessageQueueEvent =
  /**
   * Message discarded due to an error in the `MessageProcessor` (usually a format error).
   **/
  | {
      name: 'ProcessingFailed';
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: H256;

        /**
         * The queue of the message.
         **/
        origin: number;

        /**
         * The error that occurred.
         *
         * This error is pretty opaque. More fine-grained errors need to be emitted as events
         * by the `MessageProcessor`.
         **/
        error: FrameSupportMessagesProcessMessageError;
      };
    }
  /**
   * Message is processed.
   **/
  | {
      name: 'Processed';
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: H256;

        /**
         * The queue of the message.
         **/
        origin: number;

        /**
         * How much weight was used to process the message.
         **/
        weightUsed: SpWeightsWeightV2Weight;

        /**
         * Whether the message was processed.
         *
         * Note that this does not mean that the underlying `MessageProcessor` was internally
         * successful. It *solely* means that the MQ pallet will treat this as a success
         * condition and discard the message. Any internal error needs to be emitted as events
         * by the `MessageProcessor`.
         **/
        success: boolean;
      };
    }
  /**
   * Message placed in overweight queue.
   **/
  | {
      name: 'OverweightEnqueued';
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: FixedBytes<32>;

        /**
         * The queue of the message.
         **/
        origin: number;

        /**
         * The page of the message.
         **/
        pageIndex: number;

        /**
         * The index of the message within the page.
         **/
        messageIndex: number;
      };
    }
  /**
   * This page was reaped.
   **/
  | {
      name: 'PageReaped';
      data: {
        /**
         * The queue of the page.
         **/
        origin: number;

        /**
         * The index of the page.
         **/
        index: number;
      };
    };

export type FrameSupportMessagesProcessMessageError =
  | { tag: 'BadFormat' }
  | { tag: 'Corrupt' }
  | { tag: 'Unsupported' }
  | { tag: 'Overweight'; value: SpWeightsWeightV2Weight }
  | { tag: 'Yield' };

/**
 * The `Event` enum of this pallet
 **/
export type FrameBenchmarkingPalletPovEvent = 'TestEvent';

/**
 * The `Event` enum of this pallet
 **/
export type PalletTxPauseEvent =
  /**
   * This pallet, or a specific call is now paused.
   **/
  | { name: 'CallPaused'; data: { fullName: [Bytes, Bytes] } }
  /**
   * This pallet, or a specific call is now unpaused.
   **/
  | { name: 'CallUnpaused'; data: { fullName: [Bytes, Bytes] } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSafeModeEvent =
  /**
   * The safe-mode was entered until inclusively this block.
   **/
  | { name: 'Entered'; data: { until: number } }
  /**
   * The safe-mode was extended until inclusively this block.
   **/
  | { name: 'Extended'; data: { until: number } }
  /**
   * Exited the safe-mode for a specific reason.
   **/
  | { name: 'Exited'; data: { reason: PalletSafeModeExitReason } }
  /**
   * An account reserved funds for either entering or extending the safe-mode.
   **/
  | { name: 'DepositPlaced'; data: { account: AccountId32; amount: bigint } }
  /**
   * An account had a reserve released that was reserved.
   **/
  | { name: 'DepositReleased'; data: { account: AccountId32; amount: bigint } }
  /**
   * An account had reserve slashed that was reserved.
   **/
  | { name: 'DepositSlashed'; data: { account: AccountId32; amount: bigint } }
  /**
   * Could not hold funds for entering or extending the safe-mode.
   *
   * This error comes from the underlying `Currency`.
   **/
  | { name: 'CannotDeposit' }
  /**
   * Could not release funds for entering or extending the safe-mode.
   *
   * This error comes from the underlying `Currency`.
   **/
  | { name: 'CannotRelease' };

export type PalletSafeModeExitReason = 'Timeout' | 'Force';

/**
 * The `Event` enum of this pallet
 **/
export type PalletStatementEvent =
  /**
   * A new statement is submitted
   **/
  { name: 'NewStatement'; data: { account: AccountId32; statement: SpStatementStoreStatement } };

export type SpStatementStoreStatement = {
  proof?: SpStatementStoreProof | undefined;
  decryptionKey?: FixedBytes<32> | undefined;
  channel?: FixedBytes<32> | undefined;
  priority?: number | undefined;
  numTopics: number;
  topics: FixedArray<FixedBytes<32>, 4>;
  data?: Bytes | undefined;
};

export type SpStatementStoreProof =
  | { tag: 'Sr25519'; value: { signature: FixedBytes<64>; signer: FixedBytes<32> } }
  | { tag: 'Ed25519'; value: { signature: FixedBytes<64>; signer: FixedBytes<32> } }
  | { tag: 'Secp256k1Ecdsa'; value: { signature: FixedBytes<65>; signer: FixedBytes<33> } }
  | { tag: 'OnChain'; value: { who: FixedBytes<32>; blockHash: FixedBytes<32>; eventIndex: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMigrationsEvent =
  /**
   * A Runtime upgrade started.
   *
   * Its end is indicated by `UpgradeCompleted` or `UpgradeFailed`.
   **/
  | {
      name: 'UpgradeStarted';
      data: {
        /**
         * The number of migrations that this upgrade contains.
         *
         * This can be used to design a progress indicator in combination with counting the
         * `MigrationCompleted` and `MigrationSkipped` events.
         **/
        migrations: number;
      };
    }
  /**
   * The current runtime upgrade completed.
   *
   * This implies that all of its migrations completed successfully as well.
   **/
  | { name: 'UpgradeCompleted' }
  /**
   * Runtime upgrade failed.
   *
   * This is very bad and will require governance intervention.
   **/
  | { name: 'UpgradeFailed' }
  /**
   * A migration was skipped since it was already executed in the past.
   **/
  | {
      name: 'MigrationSkipped';
      data: {
        /**
         * The index of the skipped migration within the [`Config::Migrations`] list.
         **/
        index: number;
      };
    }
  /**
   * A migration progressed.
   **/
  | {
      name: 'MigrationAdvanced';
      data: {
        /**
         * The index of the migration within the [`Config::Migrations`] list.
         **/
        index: number;

        /**
         * The number of blocks that this migration took so far.
         **/
        took: number;
      };
    }
  /**
   * A Migration completed.
   **/
  | {
      name: 'MigrationCompleted';
      data: {
        /**
         * The index of the migration within the [`Config::Migrations`] list.
         **/
        index: number;

        /**
         * The number of blocks that this migration took so far.
         **/
        took: number;
      };
    }
  /**
   * A Migration failed.
   *
   * This implies that the whole upgrade failed and governance intervention is required.
   **/
  | {
      name: 'MigrationFailed';
      data: {
        /**
         * The index of the migration within the [`Config::Migrations`] list.
         **/
        index: number;

        /**
         * The number of blocks that this migration took so far.
         **/
        took: number;
      };
    }
  /**
   * The set of historical migrations has been cleared.
   **/
  | {
      name: 'HistoricCleared';
      data: {
        /**
         * Should be passed to `clear_historic` in a successive call.
         **/
        nextCursor?: Bytes | undefined;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBrokerEvent =
  /**
   * A Region of Bulk Coretime has been purchased.
   **/
  | {
      name: 'Purchased';
      data: {
        /**
         * The identity of the purchaser.
         **/
        who: AccountId32;

        /**
         * The identity of the Region.
         **/
        regionId: PalletBrokerRegionId;

        /**
         * The price paid for this Region.
         **/
        price: bigint;

        /**
         * The duration of the Region.
         **/
        duration: number;
      };
    }
  /**
   * The workload of a core has become renewable.
   **/
  | {
      name: 'Renewable';
      data: {
        /**
         * The core whose workload can be renewed.
         **/
        core: number;

        /**
         * The price at which the workload can be renewed.
         **/
        price: bigint;

        /**
         * The time at which the workload would recommence of this renewal. The call to renew
         * cannot happen before the beginning of the interlude prior to the sale for regions
         * which begin at this time.
         **/
        begin: number;

        /**
         * The actual workload which can be renewed.
         **/
        workload: Array<PalletBrokerScheduleItem>;
      };
    }
  /**
   * A workload has been renewed.
   **/
  | {
      name: 'Renewed';
      data: {
        /**
         * The identity of the renewer.
         **/
        who: AccountId32;

        /**
         * The price paid for this renewal.
         **/
        price: bigint;

        /**
         * The index of the core on which the `workload` was previously scheduled.
         **/
        oldCore: number;

        /**
         * The index of the core on which the renewed `workload` has been scheduled.
         **/
        core: number;

        /**
         * The time at which the `workload` will begin on the `core`.
         **/
        begin: number;

        /**
         * The number of timeslices for which this `workload` is newly scheduled.
         **/
        duration: number;

        /**
         * The workload which was renewed.
         **/
        workload: Array<PalletBrokerScheduleItem>;
      };
    }
  /**
   * Ownership of a Region has been transferred.
   **/
  | {
      name: 'Transferred';
      data: {
        /**
         * The Region which has been transferred.
         **/
        regionId: PalletBrokerRegionId;

        /**
         * The duration of the Region.
         **/
        duration: number;

        /**
         * The old owner of the Region.
         **/
        oldOwner: AccountId32;

        /**
         * The new owner of the Region.
         **/
        owner: AccountId32;
      };
    }
  /**
   * A Region has been split into two non-overlapping Regions.
   **/
  | {
      name: 'Partitioned';
      data: {
        /**
         * The Region which was split.
         **/
        oldRegionId: PalletBrokerRegionId;

        /**
         * The new Regions into which it became.
         **/
        newRegionIds: [PalletBrokerRegionId, PalletBrokerRegionId];
      };
    }
  /**
   * A Region has been converted into two overlapping Regions each of lesser regularity.
   **/
  | {
      name: 'Interlaced';
      data: {
        /**
         * The Region which was interlaced.
         **/
        oldRegionId: PalletBrokerRegionId;

        /**
         * The new Regions into which it became.
         **/
        newRegionIds: [PalletBrokerRegionId, PalletBrokerRegionId];
      };
    }
  /**
   * A Region has been assigned to a particular task.
   **/
  | {
      name: 'Assigned';
      data: {
        /**
         * The Region which was assigned.
         **/
        regionId: PalletBrokerRegionId;

        /**
         * The duration of the assignment.
         **/
        duration: number;

        /**
         * The task to which the Region was assigned.
         **/
        task: number;
      };
    }
  /**
   * A Region has been added to the Instantaneous Coretime Pool.
   **/
  | {
      name: 'Pooled';
      data: {
        /**
         * The Region which was added to the Instantaneous Coretime Pool.
         **/
        regionId: PalletBrokerRegionId;

        /**
         * The duration of the Region.
         **/
        duration: number;
      };
    }
  /**
   * A new number of cores has been requested.
   **/
  | {
      name: 'CoreCountRequested';
      data: {
        /**
         * The number of cores requested.
         **/
        coreCount: number;
      };
    }
  /**
   * The number of cores available for scheduling has changed.
   **/
  | {
      name: 'CoreCountChanged';
      data: {
        /**
         * The new number of cores available for scheduling.
         **/
        coreCount: number;
      };
    }
  /**
   * There is a new reservation for a workload.
   **/
  | {
      name: 'ReservationMade';
      data: {
        /**
         * The index of the reservation.
         **/
        index: number;

        /**
         * The workload of the reservation.
         **/
        workload: Array<PalletBrokerScheduleItem>;
      };
    }
  /**
   * A reservation for a workload has been cancelled.
   **/
  | {
      name: 'ReservationCancelled';
      data: {
        /**
         * The index of the reservation which was cancelled.
         **/
        index: number;

        /**
         * The workload of the now cancelled reservation.
         **/
        workload: Array<PalletBrokerScheduleItem>;
      };
    }
  /**
   * A new sale has been initialized.
   **/
  | {
      name: 'SaleInitialized';
      data: {
        /**
         * The local block number at which the sale will/did start.
         **/
        saleStart: number;

        /**
         * The length in blocks of the Leadin Period (where the price is decreasing).
         **/
        leadinLength: number;

        /**
         * The price of Bulk Coretime at the beginning of the Leadin Period.
         **/
        startPrice: bigint;

        /**
         * The price of Bulk Coretime after the Leadin Period.
         **/
        regularPrice: bigint;

        /**
         * The first timeslice of the Regions which are being sold in this sale.
         **/
        regionBegin: number;

        /**
         * The timeslice on which the Regions which are being sold in the sale terminate.
         * (i.e. One after the last timeslice which the Regions control.)
         **/
        regionEnd: number;

        /**
         * The number of cores we want to sell, ideally. Selling this amount would result in
         * no change to the price for the next sale.
         **/
        idealCoresSold: number;

        /**
         * Number of cores which are/have been offered for sale.
         **/
        coresOffered: number;
      };
    }
  /**
   * A new lease has been created.
   **/
  | {
      name: 'Leased';
      data: {
        /**
         * The task to which a core will be assigned.
         **/
        task: number;

        /**
         * The timeslice contained in the sale period after which this lease will
         * self-terminate (and therefore the earliest timeslice at which the lease may no
         * longer apply).
         **/
        until: number;
      };
    }
  /**
   * A lease is about to end.
   **/
  | {
      name: 'LeaseEnding';
      data: {
        /**
         * The task to which a core was assigned.
         **/
        task: number;

        /**
         * The timeslice at which the task will no longer be scheduled.
         **/
        when: number;
      };
    }
  /**
   * The sale rotation has been started and a new sale is imminent.
   **/
  | {
      name: 'SalesStarted';
      data: {
        /**
         * The nominal price of an Region of Bulk Coretime.
         **/
        price: bigint;

        /**
         * The maximum number of cores which this pallet will attempt to assign.
         **/
        coreCount: number;
      };
    }
  /**
   * The act of claiming revenue has begun.
   **/
  | {
      name: 'RevenueClaimBegun';
      data: {
        /**
         * The region to be claimed for.
         **/
        region: PalletBrokerRegionId;

        /**
         * The maximum number of timeslices which should be searched for claimed.
         **/
        maxTimeslices: number;
      };
    }
  /**
   * A particular timeslice has a non-zero claim.
   **/
  | {
      name: 'RevenueClaimItem';
      data: {
        /**
         * The timeslice whose claim is being processed.
         **/
        when: number;

        /**
         * The amount which was claimed at this timeslice.
         **/
        amount: bigint;
      };
    }
  /**
   * A revenue claim has (possibly only in part) been paid.
   **/
  | {
      name: 'RevenueClaimPaid';
      data: {
        /**
         * The account to whom revenue has been paid.
         **/
        who: AccountId32;

        /**
         * The total amount of revenue claimed and paid.
         **/
        amount: bigint;

        /**
         * The next region which should be claimed for the continuation of this contribution.
         **/
        next?: PalletBrokerRegionId | undefined;
      };
    }
  /**
   * Some Instantaneous Coretime Pool credit has been purchased.
   **/
  | {
      name: 'CreditPurchased';
      data: {
        /**
         * The account which purchased the credit.
         **/
        who: AccountId32;

        /**
         * The Relay-chain account to which the credit will be made.
         **/
        beneficiary: AccountId32;

        /**
         * The amount of credit purchased.
         **/
        amount: bigint;
      };
    }
  /**
   * A Region has been dropped due to being out of date.
   **/
  | {
      name: 'RegionDropped';
      data: {
        /**
         * The Region which no longer exists.
         **/
        regionId: PalletBrokerRegionId;

        /**
         * The duration of the Region.
         **/
        duration: number;
      };
    }
  /**
   * Some historical Instantaneous Core Pool contribution record has been dropped.
   **/
  | {
      name: 'ContributionDropped';
      data: {
        /**
         * The Region whose contribution is no longer exists.
         **/
        regionId: PalletBrokerRegionId;
      };
    }
  /**
   * Some historical Instantaneous Core Pool payment record has been initialized.
   **/
  | {
      name: 'HistoryInitialized';
      data: {
        /**
         * The timeslice whose history has been initialized.
         **/
        when: number;

        /**
         * The amount of privately contributed Coretime to the Instantaneous Coretime Pool.
         **/
        privatePoolSize: number;

        /**
         * The amount of Coretime contributed to the Instantaneous Coretime Pool by the
         * Polkadot System.
         **/
        systemPoolSize: number;
      };
    }
  /**
   * Some historical Instantaneous Core Pool payment record has been dropped.
   **/
  | {
      name: 'HistoryDropped';
      data: {
        /**
         * The timeslice whose history is no longer available.
         **/
        when: number;

        /**
         * The amount of revenue the system has taken.
         **/
        revenue: bigint;
      };
    }
  /**
   * Some historical Instantaneous Core Pool payment record has been ignored because the
   * timeslice was already known. Governance may need to intervene.
   **/
  | {
      name: 'HistoryIgnored';
      data: {
        /**
         * The timeslice whose history is was ignored.
         **/
        when: number;

        /**
         * The amount of revenue which was ignored.
         **/
        revenue: bigint;
      };
    }
  /**
   * Some historical Instantaneous Core Pool Revenue is ready for payout claims.
   **/
  | {
      name: 'ClaimsReady';
      data: {
        /**
         * The timeslice whose history is available.
         **/
        when: number;

        /**
         * The amount of revenue the Polkadot System has already taken.
         **/
        systemPayout: bigint;

        /**
         * The total amount of revenue remaining to be claimed.
         **/
        privatePayout: bigint;
      };
    }
  /**
   * A Core has been assigned to one or more tasks and/or the Pool on the Relay-chain.
   **/
  | {
      name: 'CoreAssigned';
      data: {
        /**
         * The index of the Core which has been assigned.
         **/
        core: number;

        /**
         * The Relay-chain block at which this assignment should take effect.
         **/
        when: number;

        /**
         * The workload to be done on the Core.
         **/
        assignment: Array<[PalletBrokerCoretimeInterfaceCoreAssignment, number]>;
      };
    }
  /**
   * Some historical Instantaneous Core Pool payment record has been dropped.
   **/
  | {
      name: 'AllowedRenewalDropped';
      data: {
        /**
         * The timeslice whose renewal is no longer available.
         **/
        when: number;

        /**
         * The core whose workload is no longer available to be renewed for `when`.
         **/
        core: number;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletParametersEvent =
  /**
   * A Parameter was set.
   *
   * Is also emitted when the value was not changed.
   **/
  {
    name: 'Updated';
    data: {
      /**
       * The key that was updated.
       **/
      key: KitchensinkRuntimeRuntimeParametersKey;

      /**
       * The old value before this call.
       **/
      oldValue?: KitchensinkRuntimeRuntimeParametersValue | undefined;

      /**
       * The new value after this call.
       **/
      newValue?: KitchensinkRuntimeRuntimeParametersValue | undefined;
    };
  };

export type KitchensinkRuntimeRuntimeParametersKey =
  | { tag: 'Storage'; value: KitchensinkRuntimeDynamicParamsStorageParametersKey }
  | { tag: 'Contract'; value: KitchensinkRuntimeDynamicParamsContractsParametersKey };

export type KitchensinkRuntimeDynamicParamsStorageParametersKey =
  | { tag: 'BaseDeposit'; value: KitchensinkRuntimeDynamicParamsStorageBaseDeposit }
  | { tag: 'ByteDeposit'; value: KitchensinkRuntimeDynamicParamsStorageByteDeposit };

export type KitchensinkRuntimeDynamicParamsContractsParametersKey =
  | { tag: 'DepositPerItem'; value: KitchensinkRuntimeDynamicParamsContractsDepositPerItem }
  | { tag: 'DepositPerByte'; value: KitchensinkRuntimeDynamicParamsContractsDepositPerByte }
  | { tag: 'DefaultDepositLimit'; value: KitchensinkRuntimeDynamicParamsContractsDefaultDepositLimit };

export type KitchensinkRuntimeRuntimeParametersValue =
  | { tag: 'Storage'; value: KitchensinkRuntimeDynamicParamsStorageParametersValue }
  | { tag: 'Contract'; value: KitchensinkRuntimeDynamicParamsContractsParametersValue };

export type KitchensinkRuntimeDynamicParamsStorageParametersValue =
  | { tag: 'BaseDeposit'; value: bigint }
  | { tag: 'ByteDeposit'; value: bigint };

export type KitchensinkRuntimeDynamicParamsContractsParametersValue =
  | { tag: 'DepositPerItem'; value: bigint }
  | { tag: 'DepositPerByte'; value: bigint }
  | { tag: 'DefaultDepositLimit'; value: bigint };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSkipFeelessPaymentEvent =
  /**
   * A transaction fee was skipped.
   **/
  { name: 'FeeSkipped'; data: { who: AccountId32 } };

export type FrameSystemLastRuntimeUpgradeInfo = { specVersion: number; specName: string };

export type FrameSystemCodeUpgradeAuthorization = { codeHash: H256; checkVersion: boolean };

export type FrameSystemLimitsBlockWeights = {
  baseBlock: SpWeightsWeightV2Weight;
  maxBlock: SpWeightsWeightV2Weight;
  perClass: FrameSupportDispatchPerDispatchClassWeightsPerClass;
};

export type FrameSupportDispatchPerDispatchClassWeightsPerClass = {
  normal: FrameSystemLimitsWeightsPerClass;
  operational: FrameSystemLimitsWeightsPerClass;
  mandatory: FrameSystemLimitsWeightsPerClass;
};

export type FrameSystemLimitsWeightsPerClass = {
  baseExtrinsic: SpWeightsWeightV2Weight;
  maxExtrinsic?: SpWeightsWeightV2Weight | undefined;
  maxTotal?: SpWeightsWeightV2Weight | undefined;
  reserved?: SpWeightsWeightV2Weight | undefined;
};

export type FrameSystemLimitsBlockLength = { max: FrameSupportDispatchPerDispatchClassU32 };

export type FrameSupportDispatchPerDispatchClassU32 = { normal: number; operational: number; mandatory: number };

export type SpWeightsRuntimeDbWeight = { read: bigint; write: bigint };

/**
 * Error for the System pallet
 **/
export type FrameSystemError =
  /**
   * The name of specification does not match between the current runtime
   * and the new runtime.
   **/
  | 'InvalidSpecName'
  /**
   * The specification version is not allowed to decrease between the current runtime
   * and the new runtime.
   **/
  | 'SpecVersionNeedsToIncrease'
  /**
   * Failed to extract the runtime version from the new runtime.
   *
   * Either calling `Core_version` or decoding `RuntimeVersion` failed.
   **/
  | 'FailedToExtractRuntimeVersion'
  /**
   * Suicide called when the account has non-default composite data.
   **/
  | 'NonDefaultComposite'
  /**
   * There is a non-zero reference count preventing the account from being purged.
   **/
  | 'NonZeroRefCount'
  /**
   * The origin filter prevent the call to be dispatched.
   **/
  | 'CallFiltered'
  /**
   * A multi-block migration is ongoing and prevents the current code from being replaced.
   **/
  | 'MultiBlockMigrationsOngoing'
  /**
   * No upgrade authorized.
   **/
  | 'NothingAuthorized'
  /**
   * The submitted code is not authorized.
   **/
  | 'Unauthorized';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUtilityError =
  /**
   * Too many calls batched.
   **/
  'TooManyCalls';

export type SpConsensusBabeDigestsPreDigest =
  | { tag: 'Primary'; value: SpConsensusBabeDigestsPrimaryPreDigest }
  | { tag: 'SecondaryPlain'; value: SpConsensusBabeDigestsSecondaryPlainPreDigest }
  | { tag: 'SecondaryVRF'; value: SpConsensusBabeDigestsSecondaryVRFPreDigest };

export type SpConsensusBabeDigestsPrimaryPreDigest = {
  authorityIndex: number;
  slot: SpConsensusSlotsSlot;
  vrfSignature: SpCoreSr25519VrfVrfSignature;
};

export type SpCoreSr25519VrfVrfSignature = { preOutput: FixedBytes<32>; proof: FixedBytes<64> };

export type SpConsensusBabeDigestsSecondaryPlainPreDigest = { authorityIndex: number; slot: SpConsensusSlotsSlot };

export type SpConsensusBabeDigestsSecondaryVRFPreDigest = {
  authorityIndex: number;
  slot: SpConsensusSlotsSlot;
  vrfSignature: SpCoreSr25519VrfVrfSignature;
};

export type SpConsensusBabeBabeEpochConfiguration = { c: [bigint, bigint]; allowedSlots: SpConsensusBabeAllowedSlots };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBabeError =
  /**
   * An equivocation proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidEquivocationProof'
  /**
   * A key ownership proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidKeyOwnershipProof'
  /**
   * A given equivocation report is valid but already previously reported.
   **/
  | 'DuplicateOffenceReport'
  /**
   * Submitted configuration is invalid.
   **/
  | 'InvalidConfiguration';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIndicesError =
  /**
   * The index was not already assigned.
   **/
  | 'NotAssigned'
  /**
   * The index is assigned to another account.
   **/
  | 'NotOwner'
  /**
   * The index was not available.
   **/
  | 'InUse'
  /**
   * The source and destination accounts are identical.
   **/
  | 'NotTransfer'
  /**
   * The index is permanent and may not be freed/changed.
   **/
  | 'Permanent';

export type PalletBalancesBalanceLock = { id: FixedBytes<8>; amount: bigint; reasons: PalletBalancesReasons };

export type PalletBalancesReasons = 'Fee' | 'Misc' | 'All';

export type PalletBalancesReserveData = { id: FixedBytes<8>; amount: bigint };

export type PalletBalancesIdAmount = { id: KitchensinkRuntimeRuntimeHoldReason; amount: bigint };

export type KitchensinkRuntimeRuntimeHoldReason =
  | { tag: 'Contracts'; value: PalletContractsHoldReason }
  | { tag: 'Preimage'; value: PalletPreimageHoldReason }
  | { tag: 'Nis'; value: PalletNisHoldReason }
  | { tag: 'NftFractionalization'; value: PalletNftFractionalizationHoldReason }
  | { tag: 'TransactionStorage'; value: PalletTransactionStorageHoldReason }
  | { tag: 'StateTrieMigration'; value: PalletStateTrieMigrationHoldReason }
  | { tag: 'SafeMode'; value: PalletSafeModeHoldReason };

export type PalletContractsHoldReason = 'CodeUploadDepositReserve' | 'StorageDepositReserve';

export type PalletPreimageHoldReason = 'Preimage';

export type PalletNisHoldReason = 'NftReceipt';

export type PalletNftFractionalizationHoldReason = 'Fractionalized';

export type PalletTransactionStorageHoldReason = 'StorageFeeHold';

export type PalletStateTrieMigrationHoldReason = 'SlashForMigrate';

export type PalletSafeModeHoldReason = 'EnterOrExtend';

export type PalletBalancesIdAmountRuntimeFreezeReason = { id: KitchensinkRuntimeRuntimeFreezeReason; amount: bigint };

export type KitchensinkRuntimeRuntimeFreezeReason = {
  tag: 'NominationPools';
  value: PalletNominationPoolsFreezeReason;
};

export type PalletNominationPoolsFreezeReason = 'PoolMinBalance';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBalancesError =
  /**
   * Vesting balance too high to send value.
   **/
  | 'VestingBalance'
  /**
   * Account liquidity restrictions prevent withdrawal.
   **/
  | 'LiquidityRestrictions'
  /**
   * Balance too low to send value.
   **/
  | 'InsufficientBalance'
  /**
   * Value too low to create account due to existential deposit.
   **/
  | 'ExistentialDeposit'
  /**
   * Transfer/payment would kill account.
   **/
  | 'Expendability'
  /**
   * A vesting schedule already exists for this account.
   **/
  | 'ExistingVestingSchedule'
  /**
   * Beneficiary account must pre-exist.
   **/
  | 'DeadAccount'
  /**
   * Number of named reserves exceed `MaxReserves`.
   **/
  | 'TooManyReserves'
  /**
   * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
   **/
  | 'TooManyHolds'
  /**
   * Number of freezes exceed `MaxFreezes`.
   **/
  | 'TooManyFreezes'
  /**
   * The issuance cannot be modified since it is already deactivated.
   **/
  | 'IssuanceDeactivated'
  /**
   * The delta cannot be zero.
   **/
  | 'DeltaZero';

export type PalletTransactionPaymentReleases = 'V1Ancient' | 'V2';

export type PalletElectionProviderMultiPhaseReadySolution = {
  supports: Array<[AccountId32, SpNposElectionsSupport]>;
  score: SpNposElectionsElectionScore;
  compute: PalletElectionProviderMultiPhaseElectionCompute;
};

export type PalletElectionProviderMultiPhaseRoundSnapshot = {
  voters: Array<[AccountId32, bigint, Array<AccountId32>]>;
  targets: Array<AccountId32>;
};

export type PalletElectionProviderMultiPhaseSignedSignedSubmission = {
  who: AccountId32;
  deposit: bigint;
  rawSolution: PalletElectionProviderMultiPhaseRawSolution;
  callFee: bigint;
};

/**
 * Error of the pallet that can be returned in response to dispatches.
 **/
export type PalletElectionProviderMultiPhaseError =
  /**
   * Submission was too early.
   **/
  | 'PreDispatchEarlySubmission'
  /**
   * Wrong number of winners presented.
   **/
  | 'PreDispatchWrongWinnerCount'
  /**
   * Submission was too weak, score-wise.
   **/
  | 'PreDispatchWeakSubmission'
  /**
   * The queue was full, and the solution was not better than any of the existing ones.
   **/
  | 'SignedQueueFull'
  /**
   * The origin failed to pay the deposit.
   **/
  | 'SignedCannotPayDeposit'
  /**
   * Witness data to dispatchable is invalid.
   **/
  | 'SignedInvalidWitness'
  /**
   * The signed submission consumes too much weight
   **/
  | 'SignedTooMuchWeight'
  /**
   * OCW submitted solution for wrong round
   **/
  | 'OcwCallWrongEra'
  /**
   * Snapshot metadata should exist but didn't.
   **/
  | 'MissingSnapshotMetadata'
  /**
   * `Self::insert_submission` returned an invalid index.
   **/
  | 'InvalidSubmissionIndex'
  /**
   * The call is not allowed at this point.
   **/
  | 'CallNotAllowed'
  /**
   * The fallback failed
   **/
  | 'FallbackFailed'
  /**
   * Some bound not met
   **/
  | 'BoundNotMet'
  /**
   * Submitted solution has too many winners
   **/
  | 'TooManyWinners'
  /**
   * Sumission was prepared for a different round.
   **/
  | 'PreDispatchDifferentRound';

export type PalletStakingStakingLedger = {
  stash: AccountId32;
  total: bigint;
  active: bigint;
  unlocking: Array<PalletStakingUnlockChunk>;
  legacyClaimedRewards: Array<number>;
};

export type PalletStakingUnlockChunk = { value: bigint; era: number };

export type PalletStakingNominations = { targets: Array<AccountId32>; submittedIn: number; suppressed: boolean };

export type PalletStakingActiveEraInfo = { index: number; start?: bigint | undefined };

export type SpStakingPagedExposureMetadata = { total: bigint; own: bigint; nominatorCount: number; pageCount: number };

export type SpStakingExposurePage = { pageTotal: bigint; others: Array<SpStakingIndividualExposure> };

export type PalletStakingEraRewardPoints = { total: number; individual: Array<[AccountId32, number]> };

export type PalletStakingUnappliedSlash = {
  validator: AccountId32;
  own: bigint;
  others: Array<[AccountId32, bigint]>;
  reporters: Array<AccountId32>;
  payout: bigint;
};

export type PalletStakingSlashingSlashingSpans = {
  spanIndex: number;
  lastStart: number;
  lastNonzeroSlash: number;
  prior: Array<number>;
};

export type PalletStakingSlashingSpanRecord = { slashed: bigint; paidOut: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletStakingPalletError =
  /**
   * Not a controller account.
   **/
  | 'NotController'
  /**
   * Not a stash account.
   **/
  | 'NotStash'
  /**
   * Stash is already bonded.
   **/
  | 'AlreadyBonded'
  /**
   * Controller is already paired.
   **/
  | 'AlreadyPaired'
  /**
   * Targets cannot be empty.
   **/
  | 'EmptyTargets'
  /**
   * Duplicate index.
   **/
  | 'DuplicateIndex'
  /**
   * Slash record index out of bounds.
   **/
  | 'InvalidSlashIndex'
  /**
   * Cannot have a validator or nominator role, with value less than the minimum defined by
   * governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
   * intention, `chill` first to remove one's role as validator/nominator.
   **/
  | 'InsufficientBond'
  /**
   * Can not schedule more unlock chunks.
   **/
  | 'NoMoreChunks'
  /**
   * Can not rebond without unlocking chunks.
   **/
  | 'NoUnlockChunk'
  /**
   * Attempting to target a stash that still has funds.
   **/
  | 'FundedTarget'
  /**
   * Invalid era to reward.
   **/
  | 'InvalidEraToReward'
  /**
   * Invalid number of nominations.
   **/
  | 'InvalidNumberOfNominations'
  /**
   * Items are not sorted and unique.
   **/
  | 'NotSortedAndUnique'
  /**
   * Rewards for this era have already been claimed for this validator.
   **/
  | 'AlreadyClaimed'
  /**
   * No nominators exist on this page.
   **/
  | 'InvalidPage'
  /**
   * Incorrect previous history depth input provided.
   **/
  | 'IncorrectHistoryDepth'
  /**
   * Incorrect number of slashing spans provided.
   **/
  | 'IncorrectSlashingSpans'
  /**
   * Internal state has become somehow corrupted and the operation cannot continue.
   **/
  | 'BadState'
  /**
   * Too many nomination targets supplied.
   **/
  | 'TooManyTargets'
  /**
   * A nomination target was supplied that was blocked or otherwise not a validator.
   **/
  | 'BadTarget'
  /**
   * The user has enough bond and thus cannot be chilled forcefully by an external person.
   **/
  | 'CannotChillOther'
  /**
   * There are too many nominators in the system. Governance needs to adjust the staking
   * settings to keep things safe for the runtime.
   **/
  | 'TooManyNominators'
  /**
   * There are too many validator candidates in the system. Governance needs to adjust the
   * staking settings to keep things safe for the runtime.
   **/
  | 'TooManyValidators'
  /**
   * Commission is too low. Must be at least `MinCommission`.
   **/
  | 'CommissionTooLow'
  /**
   * Some bound is not met.
   **/
  | 'BoundNotMet'
  /**
   * Used when attempting to use deprecated controller account logic.
   **/
  | 'ControllerDeprecated';

export type SpCoreCryptoKeyTypeId = FixedBytes<4>;

/**
 * Error for the session pallet.
 **/
export type PalletSessionError =
  /**
   * Invalid ownership proof.
   **/
  | 'InvalidProof'
  /**
   * No associated validator ID for account.
   **/
  | 'NoAssociatedValidatorId'
  /**
   * Registered duplicate key.
   **/
  | 'DuplicatedKey'
  /**
   * No keys are associated with this account.
   **/
  | 'NoKeys'
  /**
   * Key setting account is not live, so it's impossible to associate keys.
   **/
  | 'NoAccount';

export type PalletDemocracyReferendumInfo =
  | { tag: 'Ongoing'; value: PalletDemocracyReferendumStatus }
  | { tag: 'Finished'; value: { approved: boolean; end: number } };

export type PalletDemocracyReferendumStatus = {
  end: number;
  proposal: FrameSupportPreimagesBounded;
  threshold: PalletDemocracyVoteThreshold;
  delay: number;
  tally: PalletDemocracyTally;
};

export type PalletDemocracyTally = { ayes: bigint; nays: bigint; turnout: bigint };

export type PalletDemocracyVoteVoting =
  | {
      tag: 'Direct';
      value: {
        votes: Array<[number, PalletDemocracyVoteAccountVote]>;
        delegations: PalletDemocracyDelegations;
        prior: PalletDemocracyVotePriorLock;
      };
    }
  | {
      tag: 'Delegating';
      value: {
        balance: bigint;
        target: AccountId32;
        conviction: PalletDemocracyConviction;
        delegations: PalletDemocracyDelegations;
        prior: PalletDemocracyVotePriorLock;
      };
    };

export type PalletDemocracyDelegations = { votes: bigint; capital: bigint };

export type PalletDemocracyVotePriorLock = [number, bigint];

/**
 * The `Error` enum of this pallet.
 **/
export type PalletDemocracyError =
  /**
   * Value too low
   **/
  | 'ValueLow'
  /**
   * Proposal does not exist
   **/
  | 'ProposalMissing'
  /**
   * Cannot cancel the same proposal twice
   **/
  | 'AlreadyCanceled'
  /**
   * Proposal already made
   **/
  | 'DuplicateProposal'
  /**
   * Proposal still blacklisted
   **/
  | 'ProposalBlacklisted'
  /**
   * Next external proposal not simple majority
   **/
  | 'NotSimpleMajority'
  /**
   * Invalid hash
   **/
  | 'InvalidHash'
  /**
   * No external proposal
   **/
  | 'NoProposal'
  /**
   * Identity may not veto a proposal twice
   **/
  | 'AlreadyVetoed'
  /**
   * Vote given for invalid referendum
   **/
  | 'ReferendumInvalid'
  /**
   * No proposals waiting
   **/
  | 'NoneWaiting'
  /**
   * The given account did not vote on the referendum.
   **/
  | 'NotVoter'
  /**
   * The actor has no permission to conduct the action.
   **/
  | 'NoPermission'
  /**
   * The account is already delegating.
   **/
  | 'AlreadyDelegating'
  /**
   * Too high a balance was provided that the account cannot afford.
   **/
  | 'InsufficientFunds'
  /**
   * The account is not currently delegating.
   **/
  | 'NotDelegating'
  /**
   * The account currently has votes attached to it and the operation cannot succeed until
   * these are removed, either through `unvote` or `reap_vote`.
   **/
  | 'VotesExist'
  /**
   * The instant referendum origin is currently disallowed.
   **/
  | 'InstantNotAllowed'
  /**
   * Delegation to oneself makes no sense.
   **/
  | 'Nonsense'
  /**
   * Invalid upper bound.
   **/
  | 'WrongUpperBound'
  /**
   * Maximum number of votes reached.
   **/
  | 'MaxVotesReached'
  /**
   * Maximum number of items reached.
   **/
  | 'TooMany'
  /**
   * Voting period too low
   **/
  | 'VotingPeriodLow'
  /**
   * The preimage does not exist.
   **/
  | 'PreimageNotExist';

export type PalletCollectiveVotes = {
  index: number;
  threshold: number;
  ayes: Array<AccountId32>;
  nays: Array<AccountId32>;
  end: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCollectiveError =
  /**
   * Account is not a member
   **/
  | 'NotMember'
  /**
   * Duplicate proposals not allowed
   **/
  | 'DuplicateProposal'
  /**
   * Proposal must exist
   **/
  | 'ProposalMissing'
  /**
   * Mismatched index
   **/
  | 'WrongIndex'
  /**
   * Duplicate vote ignored
   **/
  | 'DuplicateVote'
  /**
   * Members are already initialized!
   **/
  | 'AlreadyInitialized'
  /**
   * The close call was made too early, before the end of the voting.
   **/
  | 'TooEarly'
  /**
   * There can only be a maximum of `MaxProposals` active proposals.
   **/
  | 'TooManyProposals'
  /**
   * The given weight bound for the proposal was too low.
   **/
  | 'WrongProposalWeight'
  /**
   * The given length bound for the proposal was too low.
   **/
  | 'WrongProposalLength'
  /**
   * Prime account is not a member
   **/
  | 'PrimeAccountNotMember';

export type PalletElectionsPhragmenSeatHolder = { who: AccountId32; stake: bigint; deposit: bigint };

export type PalletElectionsPhragmenVoter = { votes: Array<AccountId32>; stake: bigint; deposit: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletElectionsPhragmenError =
  /**
   * Cannot vote when no candidates or members exist.
   **/
  | 'UnableToVote'
  /**
   * Must vote for at least one candidate.
   **/
  | 'NoVotes'
  /**
   * Cannot vote more than candidates.
   **/
  | 'TooManyVotes'
  /**
   * Cannot vote more than maximum allowed.
   **/
  | 'MaximumVotesExceeded'
  /**
   * Cannot vote with stake less than minimum balance.
   **/
  | 'LowBalance'
  /**
   * Voter can not pay voting bond.
   **/
  | 'UnableToPayBond'
  /**
   * Must be a voter.
   **/
  | 'MustBeVoter'
  /**
   * Duplicated candidate submission.
   **/
  | 'DuplicatedCandidate'
  /**
   * Too many candidates have been created.
   **/
  | 'TooManyCandidates'
  /**
   * Member cannot re-submit candidacy.
   **/
  | 'MemberSubmit'
  /**
   * Runner cannot re-submit candidacy.
   **/
  | 'RunnerUpSubmit'
  /**
   * Candidate does not have enough funds.
   **/
  | 'InsufficientCandidateFunds'
  /**
   * Not a member.
   **/
  | 'NotMember'
  /**
   * The provided count of number of candidates is incorrect.
   **/
  | 'InvalidWitnessData'
  /**
   * The provided count of number of votes is incorrect.
   **/
  | 'InvalidVoteCount'
  /**
   * The renouncing origin presented a wrong `Renouncing` parameter.
   **/
  | 'InvalidRenouncing'
  /**
   * Prediction regarding replacement after member removal is wrong.
   **/
  | 'InvalidReplacement';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMembershipError =
  /**
   * Already a member.
   **/
  | 'AlreadyMember'
  /**
   * Not a member.
   **/
  | 'NotMember'
  /**
   * Too many members.
   **/
  | 'TooManyMembers';

export type PalletGrandpaStoredState =
  | { tag: 'Live' }
  | { tag: 'PendingPause'; value: { scheduledAt: number; delay: number } }
  | { tag: 'Paused' }
  | { tag: 'PendingResume'; value: { scheduledAt: number; delay: number } };

export type PalletGrandpaStoredPendingChange = {
  scheduledAt: number;
  delay: number;
  nextAuthorities: Array<[SpConsensusGrandpaAppPublic, bigint]>;
  forced?: number | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletGrandpaError =
  /**
   * Attempt to signal GRANDPA pause when the authority set isn't live
   * (either paused or already pending pause).
   **/
  | 'PauseFailed'
  /**
   * Attempt to signal GRANDPA resume when the authority set isn't paused
   * (either live or already pending resume).
   **/
  | 'ResumeFailed'
  /**
   * Attempt to signal GRANDPA change with one already pending.
   **/
  | 'ChangePending'
  /**
   * Cannot signal forced change so soon after last.
   **/
  | 'TooSoon'
  /**
   * A key ownership proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidKeyOwnershipProof'
  /**
   * An equivocation proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidEquivocationProof'
  /**
   * A given equivocation report is valid but already previously reported.
   **/
  | 'DuplicateOffenceReport';

export type PalletTreasuryProposal = { proposer: AccountId32; value: bigint; beneficiary: AccountId32; bond: bigint };

export type PalletTreasurySpendStatus = {
  assetKind: number;
  amount: bigint;
  beneficiary: AccountId32;
  validFrom: number;
  expireAt: number;
  status: PalletTreasuryPaymentState;
};

export type PalletTreasuryPaymentState =
  | { tag: 'Pending' }
  | { tag: 'Attempted'; value: { id: [] } }
  | { tag: 'Failed' };

export type FrameSupportPalletId = FixedBytes<8>;

/**
 * Error for the treasury pallet.
 **/
export type PalletTreasuryError =
  /**
   * Proposer's balance is too low.
   **/
  | 'InsufficientProposersBalance'
  /**
   * No proposal, bounty or spend at that index.
   **/
  | 'InvalidIndex'
  /**
   * Too many approvals in the queue.
   **/
  | 'TooManyApprovals'
  /**
   * The spend origin is valid but the amount it is allowed to spend is lower than the
   * amount to be spent.
   **/
  | 'InsufficientPermission'
  /**
   * Proposal has not been approved.
   **/
  | 'ProposalNotApproved'
  /**
   * The balance of the asset kind is not convertible to the balance of the native asset.
   **/
  | 'FailedToConvertBalance'
  /**
   * The spend has expired and cannot be claimed.
   **/
  | 'SpendExpired'
  /**
   * The spend is not yet eligible for payout.
   **/
  | 'EarlyPayout'
  /**
   * The payment has already been attempted.
   **/
  | 'AlreadyAttempted'
  /**
   * There was some issue with the mechanism of payment.
   **/
  | 'PayoutError'
  /**
   * The payout was not yet attempted/claimed.
   **/
  | 'NotAttempted'
  /**
   * The payment has neither failed nor succeeded yet.
   **/
  | 'Inconclusive';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAssetRateError =
  /**
   * The given asset ID is unknown.
   **/
  | 'UnknownAssetKind'
  /**
   * The given asset ID already has an assigned conversion rate and cannot be re-created.
   **/
  | 'AlreadyExists'
  /**
   * Overflow ocurred when calculating the inverse rate.
   **/
  | 'Overflow';

export type PalletContractsWasmCodeInfo = {
  owner: AccountId32;
  deposit: bigint;
  refcount: bigint;
  determinism: PalletContractsWasmDeterminism;
  codeLen: number;
};

export type PalletContractsStorageContractInfo = {
  trieId: Bytes;
  codeHash: H256;
  storageBytes: number;
  storageItems: number;
  storageByteDeposit: bigint;
  storageItemDeposit: bigint;
  storageBaseDeposit: bigint;
  delegateDependencies: Array<[H256, bigint]>;
};

export type PalletContractsStorageDeletionQueueManager = { insertCounter: number; deleteCounter: number };

export type PalletContractsSchedule = {
  limits: PalletContractsScheduleLimits;
  instructionWeights: PalletContractsScheduleInstructionWeights;
  hostFnWeights: PalletContractsScheduleHostFnWeights;
};

export type PalletContractsScheduleLimits = {
  eventTopics: number;
  memoryPages: number;
  subjectLen: number;
  payloadLen: number;
  runtimeMemory: number;
};

export type PalletContractsScheduleInstructionWeights = { base: number };

export type PalletContractsScheduleHostFnWeights = {
  caller: SpWeightsWeightV2Weight;
  isContract: SpWeightsWeightV2Weight;
  codeHash: SpWeightsWeightV2Weight;
  ownCodeHash: SpWeightsWeightV2Weight;
  callerIsOrigin: SpWeightsWeightV2Weight;
  callerIsRoot: SpWeightsWeightV2Weight;
  address: SpWeightsWeightV2Weight;
  gasLeft: SpWeightsWeightV2Weight;
  balance: SpWeightsWeightV2Weight;
  valueTransferred: SpWeightsWeightV2Weight;
  minimumBalance: SpWeightsWeightV2Weight;
  blockNumber: SpWeightsWeightV2Weight;
  now: SpWeightsWeightV2Weight;
  weightToFee: SpWeightsWeightV2Weight;
  input: SpWeightsWeightV2Weight;
  inputPerByte: SpWeightsWeightV2Weight;
  rReturn: SpWeightsWeightV2Weight;
  returnPerByte: SpWeightsWeightV2Weight;
  terminate: SpWeightsWeightV2Weight;
  random: SpWeightsWeightV2Weight;
  depositEvent: SpWeightsWeightV2Weight;
  depositEventPerTopic: SpWeightsWeightV2Weight;
  depositEventPerByte: SpWeightsWeightV2Weight;
  debugMessage: SpWeightsWeightV2Weight;
  debugMessagePerByte: SpWeightsWeightV2Weight;
  setStorage: SpWeightsWeightV2Weight;
  setStoragePerNewByte: SpWeightsWeightV2Weight;
  setStoragePerOldByte: SpWeightsWeightV2Weight;
  setCodeHash: SpWeightsWeightV2Weight;
  clearStorage: SpWeightsWeightV2Weight;
  clearStoragePerByte: SpWeightsWeightV2Weight;
  containsStorage: SpWeightsWeightV2Weight;
  containsStoragePerByte: SpWeightsWeightV2Weight;
  getStorage: SpWeightsWeightV2Weight;
  getStoragePerByte: SpWeightsWeightV2Weight;
  takeStorage: SpWeightsWeightV2Weight;
  takeStoragePerByte: SpWeightsWeightV2Weight;
  transfer: SpWeightsWeightV2Weight;
  call: SpWeightsWeightV2Weight;
  delegateCall: SpWeightsWeightV2Weight;
  callTransferSurcharge: SpWeightsWeightV2Weight;
  callPerClonedByte: SpWeightsWeightV2Weight;
  instantiate: SpWeightsWeightV2Weight;
  instantiateTransferSurcharge: SpWeightsWeightV2Weight;
  instantiatePerInputByte: SpWeightsWeightV2Weight;
  instantiatePerSaltByte: SpWeightsWeightV2Weight;
  hashSha2256: SpWeightsWeightV2Weight;
  hashSha2256PerByte: SpWeightsWeightV2Weight;
  hashKeccak256: SpWeightsWeightV2Weight;
  hashKeccak256PerByte: SpWeightsWeightV2Weight;
  hashBlake2256: SpWeightsWeightV2Weight;
  hashBlake2256PerByte: SpWeightsWeightV2Weight;
  hashBlake2128: SpWeightsWeightV2Weight;
  hashBlake2128PerByte: SpWeightsWeightV2Weight;
  ecdsaRecover: SpWeightsWeightV2Weight;
  ecdsaToEthAddress: SpWeightsWeightV2Weight;
  sr25519Verify: SpWeightsWeightV2Weight;
  sr25519VerifyPerByte: SpWeightsWeightV2Weight;
  reentranceCount: SpWeightsWeightV2Weight;
  accountReentranceCount: SpWeightsWeightV2Weight;
  instantiationNonce: SpWeightsWeightV2Weight;
  lockDelegateDependency: SpWeightsWeightV2Weight;
  unlockDelegateDependency: SpWeightsWeightV2Weight;
};

export type PalletContractsEnvironment = {
  accountId: PalletContractsEnvironmentType;
  balance: PalletContractsEnvironmentTypeU128;
  hash: PalletContractsEnvironmentTypeH256;
  hasher: PalletContractsEnvironmentTypeBlakeTwo256;
  timestamp: PalletContractsEnvironmentTypeU64;
  blockNumber: PalletContractsEnvironmentTypeU32;
};

export type PalletContractsEnvironmentType = {};

export type PalletContractsEnvironmentTypeU128 = {};

export type PalletContractsEnvironmentTypeH256 = {};

export type PalletContractsEnvironmentTypeBlakeTwo256 = {};

export type PalletContractsEnvironmentTypeU64 = {};

export type PalletContractsEnvironmentTypeU32 = {};

export type PalletContractsApiVersion = number;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletContractsError =
  /**
   * Invalid schedule supplied, e.g. with zero weight of a basic operation.
   **/
  | 'InvalidSchedule'
  /**
   * Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`.
   **/
  | 'InvalidCallFlags'
  /**
   * The executed contract exhausted its gas limit.
   **/
  | 'OutOfGas'
  /**
   * The output buffer supplied to a contract API call was too small.
   **/
  | 'OutputBufferTooSmall'
  /**
   * Performing the requested transfer failed. Probably because there isn't enough
   * free balance in the sender's account.
   **/
  | 'TransferFailed'
  /**
   * Performing a call was denied because the calling depth reached the limit
   * of what is specified in the schedule.
   **/
  | 'MaxCallDepthReached'
  /**
   * No contract was found at the specified address.
   **/
  | 'ContractNotFound'
  /**
   * The code supplied to `instantiate_with_code` exceeds the limit specified in the
   * current schedule.
   **/
  | 'CodeTooLarge'
  /**
   * No code could be found at the supplied code hash.
   **/
  | 'CodeNotFound'
  /**
   * No code info could be found at the supplied code hash.
   **/
  | 'CodeInfoNotFound'
  /**
   * A buffer outside of sandbox memory was passed to a contract API function.
   **/
  | 'OutOfBounds'
  /**
   * Input passed to a contract API function failed to decode as expected type.
   **/
  | 'DecodingFailed'
  /**
   * Contract trapped during execution.
   **/
  | 'ContractTrapped'
  /**
   * The size defined in `T::MaxValueSize` was exceeded.
   **/
  | 'ValueTooLarge'
  /**
   * Termination of a contract is not allowed while the contract is already
   * on the call stack. Can be triggered by `seal_terminate`.
   **/
  | 'TerminatedWhileReentrant'
  /**
   * `seal_call` forwarded this contracts input. It therefore is no longer available.
   **/
  | 'InputForwarded'
  /**
   * The subject passed to `seal_random` exceeds the limit.
   **/
  | 'RandomSubjectTooLong'
  /**
   * The amount of topics passed to `seal_deposit_events` exceeds the limit.
   **/
  | 'TooManyTopics'
  /**
   * The chain does not provide a chain extension. Calling the chain extension results
   * in this error. Note that this usually shouldn't happen as deploying such contracts
   * is rejected.
   **/
  | 'NoChainExtension'
  /**
   * Failed to decode the XCM program.
   **/
  | 'XcmDecodeFailed'
  /**
   * A contract with the same AccountId already exists.
   **/
  | 'DuplicateContract'
  /**
   * A contract self destructed in its constructor.
   *
   * This can be triggered by a call to `seal_terminate`.
   **/
  | 'TerminatedInConstructor'
  /**
   * A call tried to invoke a contract that is flagged as non-reentrant.
   * The only other cause is that a call from a contract into the runtime tried to call back
   * into `pallet-contracts`. This would make the whole pallet reentrant with regard to
   * contract code execution which is not supported.
   **/
  | 'ReentranceDenied'
  /**
   * Origin doesn't have enough balance to pay the required storage deposits.
   **/
  | 'StorageDepositNotEnoughFunds'
  /**
   * More storage was created than allowed by the storage deposit limit.
   **/
  | 'StorageDepositLimitExhausted'
  /**
   * Code removal was denied because the code is still in use by at least one contract.
   **/
  | 'CodeInUse'
  /**
   * The contract ran to completion but decided to revert its storage changes.
   * Please note that this error is only returned from extrinsics. When called directly
   * or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags
   * to determine whether a reversion has taken place.
   **/
  | 'ContractReverted'
  /**
   * The contract's code was found to be invalid during validation.
   *
   * The most likely cause of this is that an API was used which is not supported by the
   * node. This happens if an older node is used with a new version of ink!. Try updating
   * your node to the newest available version.
   *
   * A more detailed error can be found on the node console if debug messages are enabled
   * by supplying `-lruntime::contracts=debug`.
   **/
  | 'CodeRejected'
  /**
   * An indetermistic code was used in a context where this is not permitted.
   **/
  | 'Indeterministic'
  /**
   * A pending migration needs to complete before the extrinsic can be called.
   **/
  | 'MigrationInProgress'
  /**
   * Migrate dispatch call was attempted but no migration was performed.
   **/
  | 'NoMigrationPerformed'
  /**
   * The contract has reached its maximum number of delegate dependencies.
   **/
  | 'MaxDelegateDependenciesReached'
  /**
   * The dependency was not found in the contract's delegate dependencies.
   **/
  | 'DelegateDependencyNotFound'
  /**
   * The contract already depends on the given delegate dependency.
   **/
  | 'DelegateDependencyAlreadyExists'
  /**
   * Can not add a delegate dependency to the code hash of the contract itself.
   **/
  | 'CannotAddSelfAsDelegateDependency';

/**
 * Error for the Sudo pallet.
 **/
export type PalletSudoError =
  /**
   * Sender must be the Sudo account.
   **/
  'RequireSudo';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletImOnlineError =
  /**
   * Non existent public key.
   **/
  | 'InvalidKey'
  /**
   * Duplicated heartbeat.
   **/
  | 'DuplicatedHeartbeat';

export type SpStakingOffenceOffenceDetails = {
  offender: [AccountId32, SpStakingExposure];
  reporters: Array<AccountId32>;
};

export type PalletIdentityRegistration = {
  judgements: Array<[number, PalletIdentityJudgement]>;
  deposit: bigint;
  info: PalletIdentityLegacyIdentityInfo;
};

export type PalletIdentityRegistrarInfo = { account: AccountId32; fee: bigint; fields: bigint };

export type PalletIdentityAuthorityProperties = { suffix: Bytes; allocation: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIdentityError =
  /**
   * Too many subs-accounts.
   **/
  | 'TooManySubAccounts'
  /**
   * Account isn't found.
   **/
  | 'NotFound'
  /**
   * Account isn't named.
   **/
  | 'NotNamed'
  /**
   * Empty index.
   **/
  | 'EmptyIndex'
  /**
   * Fee is changed.
   **/
  | 'FeeChanged'
  /**
   * No identity found.
   **/
  | 'NoIdentity'
  /**
   * Sticky judgement.
   **/
  | 'StickyJudgement'
  /**
   * Judgement given.
   **/
  | 'JudgementGiven'
  /**
   * Invalid judgement.
   **/
  | 'InvalidJudgement'
  /**
   * The index is invalid.
   **/
  | 'InvalidIndex'
  /**
   * The target is invalid.
   **/
  | 'InvalidTarget'
  /**
   * Maximum amount of registrars reached. Cannot add any more.
   **/
  | 'TooManyRegistrars'
  /**
   * Account ID is already named.
   **/
  | 'AlreadyClaimed'
  /**
   * Sender is not a sub-account.
   **/
  | 'NotSub'
  /**
   * Sub-account isn't owned by sender.
   **/
  | 'NotOwned'
  /**
   * The provided judgement was for a different identity.
   **/
  | 'JudgementForDifferentIdentity'
  /**
   * Error that occurs when there is an issue paying for judgement.
   **/
  | 'JudgementPaymentFailed'
  /**
   * The provided suffix is too long.
   **/
  | 'InvalidSuffix'
  /**
   * The sender does not have permission to issue a username.
   **/
  | 'NotUsernameAuthority'
  /**
   * The authority cannot allocate any more usernames.
   **/
  | 'NoAllocation'
  /**
   * The signature on a username was not valid.
   **/
  | 'InvalidSignature'
  /**
   * Setting this username requires a signature, but none was provided.
   **/
  | 'RequiresSignature'
  /**
   * The username does not meet the requirements.
   **/
  | 'InvalidUsername'
  /**
   * The username is already taken.
   **/
  | 'UsernameTaken'
  /**
   * The requested username does not exist.
   **/
  | 'NoUsername'
  /**
   * The username cannot be forcefully removed because it can still be accepted.
   **/
  | 'NotExpired';

export type PalletSocietyMemberRecord = {
  rank: number;
  strikes: number;
  vouching?: PalletSocietyVouchingStatus | undefined;
  index: number;
};

export type PalletSocietyVouchingStatus = 'Vouching' | 'Banned';

export type PalletSocietyPayoutRecord = { paid: bigint; payouts: Array<[number, bigint]> };

export type PalletSocietyBid = { who: AccountId32; kind: PalletSocietyBidKind; value: bigint };

export type PalletSocietyBidKind = { tag: 'Deposit'; value: bigint } | { tag: 'Vouch'; value: [AccountId32, bigint] };

export type PalletSocietyCandidacy = {
  round: number;
  kind: PalletSocietyBidKind;
  bid: bigint;
  tally: PalletSocietyTally;
  skepticStruck: boolean;
};

export type PalletSocietyTally = { approvals: number; rejections: number };

export type PalletSocietyVote = { approve: boolean; weight: number };

export type PalletSocietyIntakeRecord = { who: AccountId32; bid: bigint; round: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSocietyError =
  /**
   * User is not a member.
   **/
  | 'NotMember'
  /**
   * User is already a member.
   **/
  | 'AlreadyMember'
  /**
   * User is suspended.
   **/
  | 'Suspended'
  /**
   * User is not suspended.
   **/
  | 'NotSuspended'
  /**
   * Nothing to payout.
   **/
  | 'NoPayout'
  /**
   * Society already founded.
   **/
  | 'AlreadyFounded'
  /**
   * Not enough in pot to accept candidate.
   **/
  | 'InsufficientPot'
  /**
   * Member is already vouching or banned from vouching again.
   **/
  | 'AlreadyVouching'
  /**
   * Member is not vouching.
   **/
  | 'NotVouchingOnBidder'
  /**
   * Cannot remove the head of the chain.
   **/
  | 'Head'
  /**
   * Cannot remove the founder.
   **/
  | 'Founder'
  /**
   * User has already made a bid.
   **/
  | 'AlreadyBid'
  /**
   * User is already a candidate.
   **/
  | 'AlreadyCandidate'
  /**
   * User is not a candidate.
   **/
  | 'NotCandidate'
  /**
   * Too many members in the society.
   **/
  | 'MaxMembers'
  /**
   * The caller is not the founder.
   **/
  | 'NotFounder'
  /**
   * The caller is not the head.
   **/
  | 'NotHead'
  /**
   * The membership cannot be claimed as the candidate was not clearly approved.
   **/
  | 'NotApproved'
  /**
   * The candidate cannot be kicked as the candidate was not clearly rejected.
   **/
  | 'NotRejected'
  /**
   * The candidacy cannot be dropped as the candidate was clearly approved.
   **/
  | 'Approved'
  /**
   * The candidacy cannot be bestowed as the candidate was clearly rejected.
   **/
  | 'Rejected'
  /**
   * The candidacy cannot be concluded as the voting is still in progress.
   **/
  | 'InProgress'
  /**
   * The candidacy cannot be pruned until a full additional intake period has passed.
   **/
  | 'TooEarly'
  /**
   * The skeptic already voted.
   **/
  | 'Voted'
  /**
   * The skeptic need not vote on candidates from expired rounds.
   **/
  | 'Expired'
  /**
   * User is not a bidder.
   **/
  | 'NotBidder'
  /**
   * There is no defender currently.
   **/
  | 'NoDefender'
  /**
   * Group doesn't exist.
   **/
  | 'NotGroup'
  /**
   * The member is already elevated to this rank.
   **/
  | 'AlreadyElevated'
  /**
   * The skeptic has already been punished for this offence.
   **/
  | 'AlreadyPunished'
  /**
   * Funds are insufficient to pay off society debts.
   **/
  | 'InsufficientFunds'
  /**
   * The candidate/defender has no stale votes to remove.
   **/
  | 'NoVotes';

export type PalletRecoveryRecoveryConfig = {
  delayPeriod: number;
  deposit: bigint;
  friends: Array<AccountId32>;
  threshold: number;
};

export type PalletRecoveryActiveRecovery = { created: number; deposit: bigint; friends: Array<AccountId32> };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRecoveryError =
  /**
   * User is not allowed to make a call on behalf of this account
   **/
  | 'NotAllowed'
  /**
   * Threshold must be greater than zero
   **/
  | 'ZeroThreshold'
  /**
   * Friends list must be greater than zero and threshold
   **/
  | 'NotEnoughFriends'
  /**
   * Friends list must be less than max friends
   **/
  | 'MaxFriends'
  /**
   * Friends list must be sorted and free of duplicates
   **/
  | 'NotSorted'
  /**
   * This account is not set up for recovery
   **/
  | 'NotRecoverable'
  /**
   * This account is already set up for recovery
   **/
  | 'AlreadyRecoverable'
  /**
   * A recovery process has already started for this account
   **/
  | 'AlreadyStarted'
  /**
   * A recovery process has not started for this rescuer
   **/
  | 'NotStarted'
  /**
   * This account is not a friend who can vouch
   **/
  | 'NotFriend'
  /**
   * The friend must wait until the delay period to vouch for this recovery
   **/
  | 'DelayPeriod'
  /**
   * This user has already vouched for this recovery
   **/
  | 'AlreadyVouched'
  /**
   * The threshold for recovering this account has not been met
   **/
  | 'Threshold'
  /**
   * There are still active recovery attempts that need to be closed
   **/
  | 'StillActive'
  /**
   * This account is already set up for recovery
   **/
  | 'AlreadyProxy'
  /**
   * Some internal state is broken.
   **/
  | 'BadState';

export type PalletVestingReleases = 'V0' | 'V1';

/**
 * Error for the vesting pallet.
 **/
export type PalletVestingError =
  /**
   * The account given is not vesting.
   **/
  | 'NotVesting'
  /**
   * The account already has `MaxVestingSchedules` count of schedules and thus
   * cannot add another one. Consider merging existing schedules in order to add another.
   **/
  | 'AtMaxVestingSchedules'
  /**
   * Amount being transferred is too low to create a vesting schedule.
   **/
  | 'AmountLow'
  /**
   * An index was out of bounds of the vesting schedules.
   **/
  | 'ScheduleIndexOutOfBounds'
  /**
   * Failed to create a new schedule because some parameter was invalid.
   **/
  | 'InvalidScheduleParams';

export type PalletSchedulerScheduled = {
  maybeId?: FixedBytes<32> | undefined;
  priority: number;
  call: FrameSupportPreimagesBounded;
  maybePeriodic?: [number, number] | undefined;
  origin: KitchensinkRuntimeOriginCaller;
};

export type PalletSchedulerRetryConfig = { totalRetries: number; remaining: number; period: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSchedulerError =
  /**
   * Failed to schedule a call
   **/
  | 'FailedToSchedule'
  /**
   * Cannot find the scheduled call.
   **/
  | 'NotFound'
  /**
   * Given target block number is in the past.
   **/
  | 'TargetBlockNumberInPast'
  /**
   * Reschedule failed because it does not change scheduled time.
   **/
  | 'RescheduleNoChange'
  /**
   * Attempt to use a non-named function on a named task.
   **/
  | 'Named';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletGluttonError =
  /**
   * The pallet was already initialized.
   *
   * Set `witness_count` to `Some` to bypass this error.
   **/
  | 'AlreadyInitialized'
  /**
   * The limit was over [`crate::RESOURCE_HARD_LIMIT`].
   **/
  | 'InsaneLimit';

export type PalletPreimageOldRequestStatus =
  | { tag: 'Unrequested'; value: { deposit: [AccountId32, bigint]; len: number } }
  | {
      tag: 'Requested';
      value: { deposit?: [AccountId32, bigint] | undefined; count: number; len?: number | undefined };
    };

export type PalletPreimageRequestStatus =
  | { tag: 'Unrequested'; value: { ticket: [AccountId32, FrameSupportTokensFungibleHoldConsideration]; len: number } }
  | {
      tag: 'Requested';
      value: {
        maybeTicket?: [AccountId32, FrameSupportTokensFungibleHoldConsideration] | undefined;
        count: number;
        maybeLen?: number | undefined;
      };
    };

export type FrameSupportTokensFungibleHoldConsideration = bigint;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletPreimageError =
  /**
   * Preimage is too large to store on-chain.
   **/
  | 'TooBig'
  /**
   * Preimage has already been noted on-chain.
   **/
  | 'AlreadyNoted'
  /**
   * The user is not authorized to perform this action.
   **/
  | 'NotAuthorized'
  /**
   * The preimage cannot be removed since it has not yet been noted.
   **/
  | 'NotNoted'
  /**
   * A preimage may not be removed when there are outstanding requests.
   **/
  | 'Requested'
  /**
   * The preimage request cannot be removed since no outstanding requests exist.
   **/
  | 'NotRequested'
  /**
   * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
   **/
  | 'TooMany'
  /**
   * Too few hashes were requested to be upgraded (i.e. zero).
   **/
  | 'TooFew';

export type PalletProxyProxyDefinition = {
  delegate: AccountId32;
  proxyType: KitchensinkRuntimeProxyType;
  delay: number;
};

export type PalletProxyAnnouncement = { real: AccountId32; callHash: H256; height: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletProxyError =
  /**
   * There are too many proxies registered or too many announcements pending.
   **/
  | 'TooMany'
  /**
   * Proxy registration not found.
   **/
  | 'NotFound'
  /**
   * Sender is not a proxy of the account to be proxied.
   **/
  | 'NotProxy'
  /**
   * A call which is incompatible with the proxy type's filter was attempted.
   **/
  | 'Unproxyable'
  /**
   * Account is already a proxy.
   **/
  | 'Duplicate'
  /**
   * Call may not be made by proxy because it may escalate its privileges.
   **/
  | 'NoPermission'
  /**
   * Announcement, if made at all, was made too recently.
   **/
  | 'Unannounced'
  /**
   * Cannot add self as proxy.
   **/
  | 'NoSelfProxy';

export type PalletMultisigMultisig = {
  when: PalletMultisigTimepoint;
  deposit: bigint;
  depositor: AccountId32;
  approvals: Array<AccountId32>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMultisigError =
  /**
   * Threshold must be 2 or greater.
   **/
  | 'MinimumThreshold'
  /**
   * Call is already approved by this signatory.
   **/
  | 'AlreadyApproved'
  /**
   * Call doesn't need any (more) approvals.
   **/
  | 'NoApprovalsNeeded'
  /**
   * There are too few signatories in the list.
   **/
  | 'TooFewSignatories'
  /**
   * There are too many signatories in the list.
   **/
  | 'TooManySignatories'
  /**
   * The signatories were provided out of order; they should be ordered.
   **/
  | 'SignatoriesOutOfOrder'
  /**
   * The sender was contained in the other signatories; it shouldn't be.
   **/
  | 'SenderInSignatories'
  /**
   * Multisig operation not found when attempting to cancel.
   **/
  | 'NotFound'
  /**
   * Only the account that originally created the multisig is able to cancel it.
   **/
  | 'NotOwner'
  /**
   * No timepoint was given, yet the multisig operation is already underway.
   **/
  | 'NoTimepoint'
  /**
   * A different timepoint was given to the multisig operation that is underway.
   **/
  | 'WrongTimepoint'
  /**
   * A timepoint was given, yet no multisig operation is underway.
   **/
  | 'UnexpectedTimepoint'
  /**
   * The maximum weight information provided was too low.
   **/
  | 'MaxWeightTooLow'
  /**
   * The data to be stored is already stored.
   **/
  | 'AlreadyStored';

export type PalletBountiesBounty = {
  proposer: AccountId32;
  value: bigint;
  fee: bigint;
  curatorDeposit: bigint;
  bond: bigint;
  status: PalletBountiesBountyStatus;
};

export type PalletBountiesBountyStatus =
  | { tag: 'Proposed' }
  | { tag: 'Approved' }
  | { tag: 'Funded' }
  | { tag: 'CuratorProposed'; value: { curator: AccountId32 } }
  | { tag: 'Active'; value: { curator: AccountId32; updateDue: number } }
  | { tag: 'PendingPayout'; value: { curator: AccountId32; beneficiary: AccountId32; unlockAt: number } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBountiesError =
  /**
   * Proposer's balance is too low.
   **/
  | 'InsufficientProposersBalance'
  /**
   * No proposal or bounty at that index.
   **/
  | 'InvalidIndex'
  /**
   * The reason given is just too big.
   **/
  | 'ReasonTooBig'
  /**
   * The bounty status is unexpected.
   **/
  | 'UnexpectedStatus'
  /**
   * Require bounty curator.
   **/
  | 'RequireCurator'
  /**
   * Invalid bounty value.
   **/
  | 'InvalidValue'
  /**
   * Invalid bounty fee.
   **/
  | 'InvalidFee'
  /**
   * A bounty payout is pending.
   * To cancel the bounty, you must unassign and slash the curator.
   **/
  | 'PendingPayout'
  /**
   * The bounties cannot be claimed/closed because it's still in the countdown period.
   **/
  | 'Premature'
  /**
   * The bounty cannot be closed because it has active child bounties.
   **/
  | 'HasActiveChildBounty'
  /**
   * Too many approvals are already queued.
   **/
  | 'TooManyQueued';

export type PalletTipsOpenTip = {
  reason: H256;
  who: AccountId32;
  finder: AccountId32;
  deposit: bigint;
  closes?: number | undefined;
  tips: Array<[AccountId32, bigint]>;
  findersFee: boolean;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletTipsError =
  /**
   * The reason given is just too big.
   **/
  | 'ReasonTooBig'
  /**
   * The tip was already found/started.
   **/
  | 'AlreadyKnown'
  /**
   * The tip hash is unknown.
   **/
  | 'UnknownTip'
  /**
   * The tip given was too generous.
   **/
  | 'MaxTipAmountExceeded'
  /**
   * The account attempting to retract the tip is not the finder of the tip.
   **/
  | 'NotFinder'
  /**
   * The tip cannot be claimed/closed because there are not enough tippers yet.
   **/
  | 'StillOpen'
  /**
   * The tip cannot be claimed/closed because it's still in the countdown period.
   **/
  | 'Premature';

export type PalletAssetsAssetDetails = {
  owner: AccountId32;
  issuer: AccountId32;
  admin: AccountId32;
  freezer: AccountId32;
  supply: bigint;
  deposit: bigint;
  minBalance: bigint;
  isSufficient: boolean;
  accounts: number;
  sufficients: number;
  approvals: number;
  status: PalletAssetsAssetStatus;
};

export type PalletAssetsAssetStatus = 'Live' | 'Frozen' | 'Destroying';

export type PalletAssetsAssetAccount = {
  balance: bigint;
  status: PalletAssetsAccountStatus;
  reason: PalletAssetsExistenceReason;
  extra: [];
};

export type PalletAssetsAccountStatus = 'Liquid' | 'Frozen' | 'Blocked';

export type PalletAssetsExistenceReason =
  | { tag: 'Consumer' }
  | { tag: 'Sufficient' }
  | { tag: 'DepositHeld'; value: bigint }
  | { tag: 'DepositRefunded' }
  | { tag: 'DepositFrom'; value: [AccountId32, bigint] };

export type PalletAssetsApproval = { amount: bigint; deposit: bigint };

export type PalletAssetsAssetMetadata = {
  deposit: bigint;
  name: Bytes;
  symbol: Bytes;
  decimals: number;
  isFrozen: boolean;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAssetsError =
  /**
   * Account balance must be greater than or equal to the transfer amount.
   **/
  | 'BalanceLow'
  /**
   * The account to alter does not exist.
   **/
  | 'NoAccount'
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * The given asset ID is unknown.
   **/
  | 'Unknown'
  /**
   * The origin account is frozen.
   **/
  | 'Frozen'
  /**
   * The asset ID is already taken.
   **/
  | 'InUse'
  /**
   * Invalid witness data given.
   **/
  | 'BadWitness'
  /**
   * Minimum balance should be non-zero.
   **/
  | 'MinBalanceZero'
  /**
   * Unable to increment the consumer reference counters on the account. Either no provider
   * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
   * fewer then the maximum number of consumers has been reached.
   **/
  | 'UnavailableConsumer'
  /**
   * Invalid metadata given.
   **/
  | 'BadMetadata'
  /**
   * No approval exists that would allow the transfer.
   **/
  | 'Unapproved'
  /**
   * The source account would not survive the transfer and it needs to stay alive.
   **/
  | 'WouldDie'
  /**
   * The asset-account already exists.
   **/
  | 'AlreadyExists'
  /**
   * The asset-account doesn't have an associated deposit.
   **/
  | 'NoDeposit'
  /**
   * The operation would result in funds being burned.
   **/
  | 'WouldBurn'
  /**
   * The asset is a live asset and is actively being used. Usually emit for operations such
   * as `start_destroy` which require the asset to be in a destroying state.
   **/
  | 'LiveAsset'
  /**
   * The asset is not live, and likely being destroyed.
   **/
  | 'AssetNotLive'
  /**
   * The asset status is not the expected status.
   **/
  | 'IncorrectStatus'
  /**
   * The asset should be frozen before the given operation.
   **/
  | 'NotFrozen'
  /**
   * Callback action resulted in error
   **/
  | 'CallbackFailed';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBeefyError =
  /**
   * A key ownership proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidKeyOwnershipProof'
  /**
   * An equivocation proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidEquivocationProof'
  /**
   * A given equivocation report is valid but already previously reported.
   **/
  | 'DuplicateOffenceReport'
  /**
   * Submitted configuration is invalid.
   **/
  | 'InvalidConfiguration';

export type SpConsensusBeefyMmrBeefyAuthoritySet = { id: bigint; len: number; keysetCommitment: H256 };

export type PalletLotteryLotteryConfig = {
  price: bigint;
  start: number;
  length: number;
  delay: number;
  repeat: boolean;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletLotteryError =
  /**
   * A lottery has not been configured.
   **/
  | 'NotConfigured'
  /**
   * A lottery is already in progress.
   **/
  | 'InProgress'
  /**
   * A lottery has already ended.
   **/
  | 'AlreadyEnded'
  /**
   * The call is not valid for an open lottery.
   **/
  | 'InvalidCall'
  /**
   * You are already participating in the lottery with this call.
   **/
  | 'AlreadyParticipating'
  /**
   * Too many calls for a single lottery.
   **/
  | 'TooManyCalls'
  /**
   * Failed to encode calls
   **/
  | 'EncodingFailed';

export type PalletNisBid = { amount: bigint; who: AccountId32 };

export type PalletNisSummaryRecord = {
  proportionOwed: Perquintill;
  index: number;
  thawed: Perquintill;
  lastPeriod: number;
  receiptsOnHold: bigint;
};

export type PalletNisReceiptRecord = {
  proportion: Perquintill;
  owner?: [AccountId32, bigint] | undefined;
  expiry: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletNisError =
  /**
   * The duration of the bid is less than one.
   **/
  | 'DurationTooSmall'
  /**
   * The duration is the bid is greater than the number of queues.
   **/
  | 'DurationTooBig'
  /**
   * The amount of the bid is less than the minimum allowed.
   **/
  | 'AmountTooSmall'
  /**
   * The queue for the bid's duration is full and the amount bid is too low to get in
   * through replacing an existing bid.
   **/
  | 'BidTooLow'
  /**
   * Receipt index is unknown.
   **/
  | 'UnknownReceipt'
  /**
   * Not the owner of the receipt.
   **/
  | 'NotOwner'
  /**
   * Bond not yet at expiry date.
   **/
  | 'NotExpired'
  /**
   * The given bid for retraction is not found.
   **/
  | 'UnknownBid'
  /**
   * The portion supplied is beyond the value of the receipt.
   **/
  | 'PortionTooBig'
  /**
   * Not enough funds are held to pay out.
   **/
  | 'Unfunded'
  /**
   * There are enough funds for what is required.
   **/
  | 'AlreadyFunded'
  /**
   * The thaw throttle has been reached for this period.
   **/
  | 'Throttled'
  /**
   * The operation would result in a receipt worth an insignficant value.
   **/
  | 'MakesDust'
  /**
   * The receipt is already communal.
   **/
  | 'AlreadyCommunal'
  /**
   * The receipt is already private.
   **/
  | 'AlreadyPrivate';

export type PalletUniquesCollectionDetails = {
  owner: AccountId32;
  issuer: AccountId32;
  admin: AccountId32;
  freezer: AccountId32;
  totalDeposit: bigint;
  freeHolding: boolean;
  items: number;
  itemMetadatas: number;
  attributes: number;
  isFrozen: boolean;
};

export type PalletUniquesItemDetails = {
  owner: AccountId32;
  approved?: AccountId32 | undefined;
  isFrozen: boolean;
  deposit: bigint;
};

export type PalletUniquesCollectionMetadata = { deposit: bigint; data: Bytes; isFrozen: boolean };

export type PalletUniquesItemMetadata = { deposit: bigint; data: Bytes; isFrozen: boolean };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUniquesError =
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * The given item ID is unknown.
   **/
  | 'UnknownCollection'
  /**
   * The item ID has already been used for an item.
   **/
  | 'AlreadyExists'
  /**
   * The owner turned out to be different to what was expected.
   **/
  | 'WrongOwner'
  /**
   * Invalid witness data given.
   **/
  | 'BadWitness'
  /**
   * The item ID is already taken.
   **/
  | 'InUse'
  /**
   * The item or collection is frozen.
   **/
  | 'Frozen'
  /**
   * The delegate turned out to be different to what was expected.
   **/
  | 'WrongDelegate'
  /**
   * There is no delegate approved.
   **/
  | 'NoDelegate'
  /**
   * No approval exists that would allow the transfer.
   **/
  | 'Unapproved'
  /**
   * The named owner has not signed ownership of the collection is acceptable.
   **/
  | 'Unaccepted'
  /**
   * The item is locked.
   **/
  | 'Locked'
  /**
   * All items have been minted.
   **/
  | 'MaxSupplyReached'
  /**
   * The max supply has already been set.
   **/
  | 'MaxSupplyAlreadySet'
  /**
   * The provided max supply is less to the amount of items a collection already has.
   **/
  | 'MaxSupplyTooSmall'
  /**
   * The given item ID is unknown.
   **/
  | 'UnknownItem'
  /**
   * Item is not for sale.
   **/
  | 'NotForSale'
  /**
   * The provided bid is too low.
   **/
  | 'BidTooLow';

export type PalletNftsCollectionDetails = {
  owner: AccountId32;
  ownerDeposit: bigint;
  items: number;
  itemMetadatas: number;
  itemConfigs: number;
  attributes: number;
};

export type PalletNftsBitFlagsCollectionRole = number;

export type PalletNftsCollectionRole = 'Issuer' | 'Freezer' | 'Admin';

export type PalletNftsItemDetails = {
  owner: AccountId32;
  approvals: Array<[AccountId32, number | undefined]>;
  deposit: PalletNftsItemDeposit;
};

export type PalletNftsItemDeposit = { account: AccountId32; amount: bigint };

export type PalletNftsCollectionMetadata = { deposit: bigint; data: Bytes };

export type PalletNftsItemMetadata = { deposit: PalletNftsItemMetadataDeposit; data: Bytes };

export type PalletNftsItemMetadataDeposit = { account?: AccountId32 | undefined; amount: bigint };

export type PalletNftsAttributeDeposit = { account?: AccountId32 | undefined; amount: bigint };

export type PalletNftsPendingSwap = {
  desiredCollection: number;
  desiredItem?: number | undefined;
  price?: PalletNftsPriceWithDirection | undefined;
  deadline: number;
};

export type PalletNftsBitFlagsPalletFeature = bigint;

export type PalletNftsPalletFeature = 'Trading' | 'Attributes' | 'Approvals' | 'Swaps';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletNftsError =
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * The given item ID is unknown.
   **/
  | 'UnknownCollection'
  /**
   * The item ID has already been used for an item.
   **/
  | 'AlreadyExists'
  /**
   * The approval had a deadline that expired, so the approval isn't valid anymore.
   **/
  | 'ApprovalExpired'
  /**
   * The owner turned out to be different to what was expected.
   **/
  | 'WrongOwner'
  /**
   * The witness data given does not match the current state of the chain.
   **/
  | 'BadWitness'
  /**
   * Collection ID is already taken.
   **/
  | 'CollectionIdInUse'
  /**
   * Items within that collection are non-transferable.
   **/
  | 'ItemsNonTransferable'
  /**
   * The provided account is not a delegate.
   **/
  | 'NotDelegate'
  /**
   * The delegate turned out to be different to what was expected.
   **/
  | 'WrongDelegate'
  /**
   * No approval exists that would allow the transfer.
   **/
  | 'Unapproved'
  /**
   * The named owner has not signed ownership acceptance of the collection.
   **/
  | 'Unaccepted'
  /**
   * The item is locked (non-transferable).
   **/
  | 'ItemLocked'
  /**
   * Item's attributes are locked.
   **/
  | 'LockedItemAttributes'
  /**
   * Collection's attributes are locked.
   **/
  | 'LockedCollectionAttributes'
  /**
   * Item's metadata is locked.
   **/
  | 'LockedItemMetadata'
  /**
   * Collection's metadata is locked.
   **/
  | 'LockedCollectionMetadata'
  /**
   * All items have been minted.
   **/
  | 'MaxSupplyReached'
  /**
   * The max supply is locked and can't be changed.
   **/
  | 'MaxSupplyLocked'
  /**
   * The provided max supply is less than the number of items a collection already has.
   **/
  | 'MaxSupplyTooSmall'
  /**
   * The given item ID is unknown.
   **/
  | 'UnknownItem'
  /**
   * Swap doesn't exist.
   **/
  | 'UnknownSwap'
  /**
   * The given item has no metadata set.
   **/
  | 'MetadataNotFound'
  /**
   * The provided attribute can't be found.
   **/
  | 'AttributeNotFound'
  /**
   * Item is not for sale.
   **/
  | 'NotForSale'
  /**
   * The provided bid is too low.
   **/
  | 'BidTooLow'
  /**
   * The item has reached its approval limit.
   **/
  | 'ReachedApprovalLimit'
  /**
   * The deadline has already expired.
   **/
  | 'DeadlineExpired'
  /**
   * The duration provided should be less than or equal to `MaxDeadlineDuration`.
   **/
  | 'WrongDuration'
  /**
   * The method is disabled by system settings.
   **/
  | 'MethodDisabled'
  /**
   * The provided setting can't be set.
   **/
  | 'WrongSetting'
  /**
   * Item's config already exists and should be equal to the provided one.
   **/
  | 'InconsistentItemConfig'
  /**
   * Config for a collection or an item can't be found.
   **/
  | 'NoConfig'
  /**
   * Some roles were not cleared.
   **/
  | 'RolesNotCleared'
  /**
   * Mint has not started yet.
   **/
  | 'MintNotStarted'
  /**
   * Mint has already ended.
   **/
  | 'MintEnded'
  /**
   * The provided Item was already used for claiming.
   **/
  | 'AlreadyClaimed'
  /**
   * The provided data is incorrect.
   **/
  | 'IncorrectData'
  /**
   * The extrinsic was sent by the wrong origin.
   **/
  | 'WrongOrigin'
  /**
   * The provided signature is incorrect.
   **/
  | 'WrongSignature'
  /**
   * The provided metadata might be too long.
   **/
  | 'IncorrectMetadata'
  /**
   * Can't set more attributes per one call.
   **/
  | 'MaxAttributesLimitReached'
  /**
   * The provided namespace isn't supported in this call.
   **/
  | 'WrongNamespace'
  /**
   * Can't delete non-empty collections.
   **/
  | 'CollectionNotEmpty'
  /**
   * The witness data should be provided.
   **/
  | 'WitnessRequired';

export type PalletNftFractionalizationDetails = {
  asset: number;
  fractions: bigint;
  deposit: bigint;
  assetCreator: AccountId32;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletNftFractionalizationError =
  /**
   * Asset ID does not correspond to locked NFT.
   **/
  | 'IncorrectAssetId'
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * NFT doesn't exist.
   **/
  | 'NftNotFound'
  /**
   * NFT has not yet been fractionalised.
   **/
  | 'NftNotFractionalized';

export type PalletSalaryStatusType = {
  cycleIndex: number;
  cycleStart: number;
  budget: bigint;
  totalRegistrations: bigint;
  totalUnregisteredPaid: bigint;
};

export type PalletSalaryClaimantStatus = { lastActive: number; status: PalletSalaryClaimState };

export type PalletSalaryClaimState =
  | { tag: 'Nothing' }
  | { tag: 'Registered'; value: bigint }
  | { tag: 'Attempted'; value: { registered?: bigint | undefined; id: []; amount: bigint } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSalaryError =
  /**
   * The salary system has already been started.
   **/
  | 'AlreadyStarted'
  /**
   * The account is not a ranked member.
   **/
  | 'NotMember'
  /**
   * The account is already inducted.
   **/
  | 'AlreadyInducted'
  | 'NotInducted'
  /**
   * The member does not have a current valid claim.
   **/
  | 'NoClaim'
  /**
   * The member's claim is zero.
   **/
  | 'ClaimZero'
  /**
   * Current cycle's registration period is over.
   **/
  | 'TooLate'
  /**
   * Current cycle's payment period is not yet begun.
   **/
  | 'TooEarly'
  /**
   * Cycle is not yet over.
   **/
  | 'NotYet'
  /**
   * The payout cycles have not yet started.
   **/
  | 'NotStarted'
  /**
   * There is no budget left for the payout.
   **/
  | 'Bankrupt'
  /**
   * There was some issue with the mechanism of payment.
   **/
  | 'PayError'
  /**
   * The payment has neither failed nor succeeded yet.
   **/
  | 'Inconclusive'
  /**
   * The cycle is after that in which the payment was made.
   **/
  | 'NotCurrent';

export type PalletCoreFellowshipMemberStatus = { isActive: boolean; lastPromotion: number; lastProof: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCoreFellowshipError =
  /**
   * Member's rank is too low.
   **/
  | 'Unranked'
  /**
   * Member's rank is not zero.
   **/
  | 'Ranked'
  /**
   * Member's rank is not as expected - generally means that the rank provided to the call
   * does not agree with the state of the system.
   **/
  | 'UnexpectedRank'
  /**
   * The given rank is invalid - this generally means it's not between 1 and `RANK_COUNT`.
   **/
  | 'InvalidRank'
  /**
   * The origin does not have enough permission to do this operation.
   **/
  | 'NoPermission'
  /**
   * No work needs to be done at present for this member.
   **/
  | 'NothingDoing'
  /**
   * The candidate has already been inducted. This should never happen since it would
   * require a candidate (rank 0) to already be tracked in the pallet.
   **/
  | 'AlreadyInducted'
  /**
   * The candidate has not been inducted, so cannot be offboarded from this pallet.
   **/
  | 'NotTracked'
  /**
   * Operation cannot be done yet since not enough time has passed.
   **/
  | 'TooSoon';

export type PalletTransactionStorageTransactionInfo = {
  chunkRoot: H256;
  contentHash: H256;
  size: number;
  blockChunks: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletTransactionStorageError =
  /**
   * Invalid configuration.
   **/
  | 'NotConfigured'
  /**
   * Renewed extrinsic is not found.
   **/
  | 'RenewedNotFound'
  /**
   * Attempting to store empty transaction
   **/
  | 'EmptyTransaction'
  /**
   * Proof was not expected in this block.
   **/
  | 'UnexpectedProof'
  /**
   * Proof failed verification.
   **/
  | 'InvalidProof'
  /**
   * Missing storage proof.
   **/
  | 'MissingProof'
  /**
   * Unable to verify proof becasue state data is missing.
   **/
  | 'MissingStateData'
  /**
   * Double proof check in the block.
   **/
  | 'DoubleCheck'
  /**
   * Storage proof was not checked in the block.
   **/
  | 'ProofNotChecked'
  /**
   * Transaction is too large.
   **/
  | 'TransactionTooLarge'
  /**
   * Too many transactions in the block.
   **/
  | 'TooManyTransactions'
  /**
   * Attempted to call `store` outside of block execution.
   **/
  | 'BadContext';

export type PalletBagsListListNode = {
  id: AccountId32;
  prev?: AccountId32 | undefined;
  next?: AccountId32 | undefined;
  bagUpper: bigint;
  score: bigint;
};

export type PalletBagsListListBag = { head?: AccountId32 | undefined; tail?: AccountId32 | undefined };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBagsListError =
  /**
   * A error in the list interface implementation.
   **/
  { name: 'List'; data: PalletBagsListListListError };

export type PalletBagsListListListError = 'Duplicate' | 'NotHeavier' | 'NotInSameBag' | 'NodeNotFound';

export type PalletChildBountiesChildBounty = {
  parentBounty: number;
  value: bigint;
  fee: bigint;
  curatorDeposit: bigint;
  status: PalletChildBountiesChildBountyStatus;
};

export type PalletChildBountiesChildBountyStatus =
  | { tag: 'Added' }
  | { tag: 'CuratorProposed'; value: { curator: AccountId32 } }
  | { tag: 'Active'; value: { curator: AccountId32 } }
  | { tag: 'PendingPayout'; value: { curator: AccountId32; beneficiary: AccountId32; unlockAt: number } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletChildBountiesError =
  /**
   * The parent bounty is not in active state.
   **/
  | 'ParentBountyNotActive'
  /**
   * The bounty balance is not enough to add new child-bounty.
   **/
  | 'InsufficientBountyBalance'
  /**
   * Number of child bounties exceeds limit `MaxActiveChildBountyCount`.
   **/
  | 'TooManyChildBounties';

export type PalletReferendaReferendumInfo =
  | { tag: 'Ongoing'; value: PalletReferendaReferendumStatus }
  | { tag: 'Approved'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Rejected'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Cancelled'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'TimedOut'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Killed'; value: number };

export type PalletReferendaReferendumStatus = {
  track: number;
  origin: KitchensinkRuntimeOriginCaller;
  proposal: FrameSupportPreimagesBounded;
  enactment: FrameSupportScheduleDispatchTime;
  submitted: number;
  submissionDeposit: PalletReferendaDeposit;
  decisionDeposit?: PalletReferendaDeposit | undefined;
  deciding?: PalletReferendaDecidingStatus | undefined;
  tally: PalletConvictionVotingTally;
  inQueue: boolean;
  alarm?: [number, [number, number]] | undefined;
};

export type PalletReferendaDeposit = { who: AccountId32; amount: bigint };

export type PalletReferendaDecidingStatus = { since: number; confirming?: number | undefined };

export type PalletReferendaTrackInfo = {
  name: string;
  maxDeciding: number;
  decisionDeposit: bigint;
  preparePeriod: number;
  decisionPeriod: number;
  confirmPeriod: number;
  minEnactmentPeriod: number;
  minApproval: PalletReferendaCurve;
  minSupport: PalletReferendaCurve;
};

export type PalletReferendaCurve =
  | { tag: 'LinearDecreasing'; value: { length: Perbill; floor: Perbill; ceil: Perbill } }
  | { tag: 'SteppedDecreasing'; value: { begin: Perbill; end: Perbill; step: Perbill; period: Perbill } }
  | { tag: 'Reciprocal'; value: { factor: FixedI64; xOffset: FixedI64; yOffset: FixedI64 } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletReferendaError =
  /**
   * Referendum is not ongoing.
   **/
  | 'NotOngoing'
  /**
   * Referendum's decision deposit is already paid.
   **/
  | 'HasDeposit'
  /**
   * The track identifier given was invalid.
   **/
  | 'BadTrack'
  /**
   * There are already a full complement of referenda in progress for this track.
   **/
  | 'Full'
  /**
   * The queue of the track is empty.
   **/
  | 'QueueEmpty'
  /**
   * The referendum index provided is invalid in this context.
   **/
  | 'BadReferendum'
  /**
   * There was nothing to do in the advancement.
   **/
  | 'NothingToDo'
  /**
   * No track exists for the proposal origin.
   **/
  | 'NoTrack'
  /**
   * Any deposit cannot be refunded until after the decision is over.
   **/
  | 'Unfinished'
  /**
   * The deposit refunder is not the depositor.
   **/
  | 'NoPermission'
  /**
   * The deposit cannot be refunded since none was made.
   **/
  | 'NoDeposit'
  /**
   * The referendum status is invalid for this operation.
   **/
  | 'BadStatus'
  /**
   * The preimage does not exist.
   **/
  | 'PreimageNotExist';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRemarkError =
  /**
   * Attempting to store empty data.
   **/
  | 'Empty'
  /**
   * Attempted to call `store` outside of block execution.
   **/
  | 'BadContext';

export type PalletConvictionVotingVoteVoting =
  | { tag: 'Casting'; value: PalletConvictionVotingVoteCasting }
  | { tag: 'Delegating'; value: PalletConvictionVotingVoteDelegating };

export type PalletConvictionVotingVoteCasting = {
  votes: Array<[number, PalletConvictionVotingVoteAccountVote]>;
  delegations: PalletConvictionVotingDelegations;
  prior: PalletConvictionVotingVotePriorLock;
};

export type PalletConvictionVotingDelegations = { votes: bigint; capital: bigint };

export type PalletConvictionVotingVotePriorLock = [number, bigint];

export type PalletConvictionVotingVoteDelegating = {
  balance: bigint;
  target: AccountId32;
  conviction: PalletConvictionVotingConviction;
  delegations: PalletConvictionVotingDelegations;
  prior: PalletConvictionVotingVotePriorLock;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletConvictionVotingError =
  /**
   * Poll is not ongoing.
   **/
  | 'NotOngoing'
  /**
   * The given account did not vote on the poll.
   **/
  | 'NotVoter'
  /**
   * The actor has no permission to conduct the action.
   **/
  | 'NoPermission'
  /**
   * The actor has no permission to conduct the action right now but will do in the future.
   **/
  | 'NoPermissionYet'
  /**
   * The account is already delegating.
   **/
  | 'AlreadyDelegating'
  /**
   * The account currently has votes attached to it and the operation cannot succeed until
   * these are removed through `remove_vote`.
   **/
  | 'AlreadyVoting'
  /**
   * Too high a balance was provided that the account cannot afford.
   **/
  | 'InsufficientFunds'
  /**
   * The account is not currently delegating.
   **/
  | 'NotDelegating'
  /**
   * Delegation to oneself makes no sense.
   **/
  | 'Nonsense'
  /**
   * Maximum number of votes reached.
   **/
  | 'MaxVotesReached'
  /**
   * The class must be supplied since it is not easily determinable from the state.
   **/
  | 'ClassNeeded'
  /**
   * The class ID supplied is invalid.
   **/
  | 'BadClass';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletWhitelistError =
  /**
   * The preimage of the call hash could not be loaded.
   **/
  | 'UnavailablePreImage'
  /**
   * The call could not be decoded.
   **/
  | 'UndecodableCall'
  /**
   * The weight of the decoded call was higher than the witness.
   **/
  | 'InvalidCallWeightWitness'
  /**
   * The call was not whitelisted.
   **/
  | 'CallIsNotWhitelisted'
  /**
   * The call was already whitelisted; No-Op.
   **/
  | 'CallAlreadyWhitelisted';

export type PalletAllianceMemberRole = 'Fellow' | 'Ally' | 'Retiring';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAllianceError =
  /**
   * The Alliance has not been initialized yet, therefore accounts cannot join it.
   **/
  | 'AllianceNotYetInitialized'
  /**
   * The Alliance has been initialized, therefore cannot be initialized again.
   **/
  | 'AllianceAlreadyInitialized'
  /**
   * Account is already a member.
   **/
  | 'AlreadyMember'
  /**
   * Account is not a member.
   **/
  | 'NotMember'
  /**
   * Account is not an ally.
   **/
  | 'NotAlly'
  /**
   * Account does not have voting rights.
   **/
  | 'NoVotingRights'
  /**
   * Account is already an elevated (fellow) member.
   **/
  | 'AlreadyElevated'
  /**
   * Item is already listed as unscrupulous.
   **/
  | 'AlreadyUnscrupulous'
  /**
   * Account has been deemed unscrupulous by the Alliance and is not welcome to join or be
   * nominated.
   **/
  | 'AccountNonGrata'
  /**
   * Item has not been deemed unscrupulous.
   **/
  | 'NotListedAsUnscrupulous'
  /**
   * The number of unscrupulous items exceeds `MaxUnscrupulousItems`.
   **/
  | 'TooManyUnscrupulousItems'
  /**
   * Length of website URL exceeds `MaxWebsiteUrlLength`.
   **/
  | 'TooLongWebsiteUrl'
  /**
   * Balance is insufficient for the required deposit.
   **/
  | 'InsufficientFunds'
  /**
   * The account's identity does not have display field and website field.
   **/
  | 'WithoutRequiredIdentityFields'
  /**
   * The account's identity has no good judgement.
   **/
  | 'WithoutGoodIdentityJudgement'
  /**
   * The proposal hash is not found.
   **/
  | 'MissingProposalHash'
  /**
   * The announcement is not found.
   **/
  | 'MissingAnnouncement'
  /**
   * Number of members exceeds `MaxMembersCount`.
   **/
  | 'TooManyMembers'
  /**
   * Number of announcements exceeds `MaxAnnouncementsCount`.
   **/
  | 'TooManyAnnouncements'
  /**
   * Invalid witness data given.
   **/
  | 'BadWitness'
  /**
   * Account already gave retirement notice
   **/
  | 'AlreadyRetiring'
  /**
   * Account did not give a retirement notice required to retire.
   **/
  | 'RetirementNoticeNotGiven'
  /**
   * Retirement period has not passed.
   **/
  | 'RetirementPeriodNotPassed'
  /**
   * Fellows must be provided to initialize the Alliance.
   **/
  | 'FellowsMissing';

export type PalletNominationPoolsPoolMember = {
  poolId: number;
  points: bigint;
  lastRecordedRewardCounter: FixedU128;
  unbondingEras: Array<[number, bigint]>;
};

export type PalletNominationPoolsBondedPoolInner = {
  commission: PalletNominationPoolsCommission;
  memberCounter: number;
  points: bigint;
  roles: PalletNominationPoolsPoolRoles;
  state: PalletNominationPoolsPoolState;
};

export type PalletNominationPoolsCommission = {
  current?: [Perbill, AccountId32] | undefined;
  max?: Perbill | undefined;
  changeRate?: PalletNominationPoolsCommissionChangeRate | undefined;
  throttleFrom?: number | undefined;
  claimPermission?: PalletNominationPoolsCommissionClaimPermission | undefined;
};

export type PalletNominationPoolsPoolRoles = {
  depositor: AccountId32;
  root?: AccountId32 | undefined;
  nominator?: AccountId32 | undefined;
  bouncer?: AccountId32 | undefined;
};

export type PalletNominationPoolsRewardPool = {
  lastRecordedRewardCounter: FixedU128;
  lastRecordedTotalPayouts: bigint;
  totalRewardsClaimed: bigint;
  totalCommissionPending: bigint;
  totalCommissionClaimed: bigint;
};

export type PalletNominationPoolsSubPools = {
  noEra: PalletNominationPoolsUnbondPool;
  withEra: Array<[number, PalletNominationPoolsUnbondPool]>;
};

export type PalletNominationPoolsUnbondPool = { points: bigint; balance: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletNominationPoolsError =
  /**
   * A (bonded) pool id does not exist.
   **/
  | { name: 'PoolNotFound' }
  /**
   * An account is not a member.
   **/
  | { name: 'PoolMemberNotFound' }
  /**
   * A reward pool does not exist. In all cases this is a system logic error.
   **/
  | { name: 'RewardPoolNotFound' }
  /**
   * A sub pool does not exist.
   **/
  | { name: 'SubPoolsNotFound' }
  /**
   * An account is already delegating in another pool. An account may only belong to one
   * pool at a time.
   **/
  | { name: 'AccountBelongsToOtherPool' }
  /**
   * The member is fully unbonded (and thus cannot access the bonded and reward pool
   * anymore to, for example, collect rewards).
   **/
  | { name: 'FullyUnbonding' }
  /**
   * The member cannot unbond further chunks due to reaching the limit.
   **/
  | { name: 'MaxUnbondingLimit' }
  /**
   * None of the funds can be withdrawn yet because the bonding duration has not passed.
   **/
  | { name: 'CannotWithdrawAny' }
  /**
   * The amount does not meet the minimum bond to either join or create a pool.
   *
   * The depositor can never unbond to a value less than `Pallet::depositor_min_bond`. The
   * caller does not have nominating permissions for the pool. Members can never unbond to a
   * value below `MinJoinBond`.
   **/
  | { name: 'MinimumBondNotMet' }
  /**
   * The transaction could not be executed due to overflow risk for the pool.
   **/
  | { name: 'OverflowRisk' }
  /**
   * A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
   * other members to be permissionlessly unbonded.
   **/
  | { name: 'NotDestroying' }
  /**
   * The caller does not have nominating permissions for the pool.
   **/
  | { name: 'NotNominator' }
  /**
   * Either a) the caller cannot make a valid kick or b) the pool is not destroying.
   **/
  | { name: 'NotKickerOrDestroying' }
  /**
   * The pool is not open to join
   **/
  | { name: 'NotOpen' }
  /**
   * The system is maxed out on pools.
   **/
  | { name: 'MaxPools' }
  /**
   * Too many members in the pool or system.
   **/
  | { name: 'MaxPoolMembers' }
  /**
   * The pools state cannot be changed.
   **/
  | { name: 'CanNotChangeState' }
  /**
   * The caller does not have adequate permissions.
   **/
  | { name: 'DoesNotHavePermission' }
  /**
   * Metadata exceeds [`Config::MaxMetadataLen`]
   **/
  | { name: 'MetadataExceedsMaxLen' }
  /**
   * Some error occurred that should never happen. This should be reported to the
   * maintainers.
   **/
  | { name: 'Defensive'; data: PalletNominationPoolsDefensiveError }
  /**
   * Partial unbonding now allowed permissionlessly.
   **/
  | { name: 'PartialUnbondNotAllowedPermissionlessly' }
  /**
   * The pool's max commission cannot be set higher than the existing value.
   **/
  | { name: 'MaxCommissionRestricted' }
  /**
   * The supplied commission exceeds the max allowed commission.
   **/
  | { name: 'CommissionExceedsMaximum' }
  /**
   * The supplied commission exceeds global maximum commission.
   **/
  | { name: 'CommissionExceedsGlobalMaximum' }
  /**
   * Not enough blocks have surpassed since the last commission update.
   **/
  | { name: 'CommissionChangeThrottled' }
  /**
   * The submitted changes to commission change rate are not allowed.
   **/
  | { name: 'CommissionChangeRateNotAllowed' }
  /**
   * There is no pending commission to claim.
   **/
  | { name: 'NoPendingCommission' }
  /**
   * No commission current has been set.
   **/
  | { name: 'NoCommissionCurrentSet' }
  /**
   * Pool id currently in use.
   **/
  | { name: 'PoolIdInUse' }
  /**
   * Pool id provided is not correct/usable.
   **/
  | { name: 'InvalidPoolId' }
  /**
   * Bonding extra is restricted to the exact pending reward amount.
   **/
  | { name: 'BondExtraRestricted' }
  /**
   * No imbalance in the ED deposit for the pool.
   **/
  | { name: 'NothingToAdjust' };

export type PalletNominationPoolsDefensiveError =
  | 'NotEnoughSpaceInUnbondPool'
  | 'PoolNotFound'
  | 'RewardPoolNotFound'
  | 'SubPoolsNotFound'
  | 'BondedStashKilledPrematurely';

export type PalletReferendaReferendumInfoTally =
  | { tag: 'Ongoing'; value: PalletReferendaReferendumStatusTally }
  | { tag: 'Approved'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Rejected'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Cancelled'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'TimedOut'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Killed'; value: number };

export type PalletReferendaReferendumStatusTally = {
  track: number;
  origin: KitchensinkRuntimeOriginCaller;
  proposal: FrameSupportPreimagesBounded;
  enactment: FrameSupportScheduleDispatchTime;
  submitted: number;
  submissionDeposit: PalletReferendaDeposit;
  decisionDeposit?: PalletReferendaDeposit | undefined;
  deciding?: PalletReferendaDecidingStatus | undefined;
  tally: PalletRankedCollectiveTally;
  inQueue: boolean;
  alarm?: [number, [number, number]] | undefined;
};

export type PalletRankedCollectiveMemberRecord = { rank: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRankedCollectiveError =
  /**
   * Account is already a member.
   **/
  | 'AlreadyMember'
  /**
   * Account is not a member.
   **/
  | 'NotMember'
  /**
   * The given poll index is unknown or has closed.
   **/
  | 'NotPolling'
  /**
   * The given poll is still ongoing.
   **/
  | 'Ongoing'
  /**
   * There are no further records to be removed.
   **/
  | 'NoneRemaining'
  /**
   * Unexpected error in state.
   **/
  | 'Corruption'
  /**
   * The member's rank is too low to vote.
   **/
  | 'RankTooLow'
  /**
   * The information provided is incorrect.
   **/
  | 'InvalidWitness'
  /**
   * The origin is not sufficiently privileged to do the operation.
   **/
  | 'NoPermission'
  /**
   * The new member to exchange is the same as the old member
   **/
  | 'SameMember';

export type PalletAssetConversionPoolInfo = { lpToken: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAssetConversionError =
  /**
   * Provided asset pair is not supported for pool.
   **/
  | 'InvalidAssetPair'
  /**
   * Pool already exists.
   **/
  | 'PoolExists'
  /**
   * Desired amount can't be zero.
   **/
  | 'WrongDesiredAmount'
  /**
   * Provided amount should be greater than or equal to the existential deposit/asset's
   * minimal amount.
   **/
  | 'AmountOneLessThanMinimal'
  /**
   * Provided amount should be greater than or equal to the existential deposit/asset's
   * minimal amount.
   **/
  | 'AmountTwoLessThanMinimal'
  /**
   * Reserve needs to always be greater than or equal to the existential deposit/asset's
   * minimal amount.
   **/
  | 'ReserveLeftLessThanMinimal'
  /**
   * Desired amount can't be equal to the pool reserve.
   **/
  | 'AmountOutTooHigh'
  /**
   * The pool doesn't exist.
   **/
  | 'PoolNotFound'
  /**
   * An overflow happened.
   **/
  | 'Overflow'
  /**
   * The minimal amount requirement for the first token in the pair wasn't met.
   **/
  | 'AssetOneDepositDidNotMeetMinimum'
  /**
   * The minimal amount requirement for the second token in the pair wasn't met.
   **/
  | 'AssetTwoDepositDidNotMeetMinimum'
  /**
   * The minimal amount requirement for the first token in the pair wasn't met.
   **/
  | 'AssetOneWithdrawalDidNotMeetMinimum'
  /**
   * The minimal amount requirement for the second token in the pair wasn't met.
   **/
  | 'AssetTwoWithdrawalDidNotMeetMinimum'
  /**
   * Optimal calculated amount is less than desired.
   **/
  | 'OptimalAmountLessThanDesired'
  /**
   * Insufficient liquidity minted.
   **/
  | 'InsufficientLiquidityMinted'
  /**
   * Requested liquidity can't be zero.
   **/
  | 'ZeroLiquidity'
  /**
   * Amount can't be zero.
   **/
  | 'ZeroAmount'
  /**
   * Calculated amount out is less than provided minimum amount.
   **/
  | 'ProvidedMinimumNotSufficientForSwap'
  /**
   * Provided maximum amount is not sufficient for swap.
   **/
  | 'ProvidedMaximumNotSufficientForSwap'
  /**
   * The provided path must consists of 2 assets at least.
   **/
  | 'InvalidPath'
  /**
   * The provided path must consists of unique assets.
   **/
  | 'NonUniquePath'
  /**
   * It was not possible to get or increment the Id of the pool.
   **/
  | 'IncorrectPoolAssetId'
  /**
   * The destination account cannot exist with the swapped funds.
   **/
  | 'BelowMinimum';

export type PalletFastUnstakeUnstakeRequest = { stashes: Array<[AccountId32, bigint]>; checked: Array<number> };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletFastUnstakeError =
  /**
   * The provided Controller account was not found.
   *
   * This means that the given account is not bonded.
   **/
  | 'NotController'
  /**
   * The bonded account has already been queued.
   **/
  | 'AlreadyQueued'
  /**
   * The bonded account has active unlocking chunks.
   **/
  | 'NotFullyBonded'
  /**
   * The provided un-staker is not in the `Queue`.
   **/
  | 'NotQueued'
  /**
   * The provided un-staker is already in Head, and cannot deregister.
   **/
  | 'AlreadyHead'
  /**
   * The call is not allowed at this point because the pallet is not active.
   **/
  | 'CallNotAllowed';

export type PalletMessageQueueBookState = {
  begin: number;
  end: number;
  count: number;
  readyNeighbours?: PalletMessageQueueNeighbours | undefined;
  messageCount: bigint;
  size: bigint;
};

export type PalletMessageQueueNeighbours = { prev: number; next: number };

export type PalletMessageQueuePage = {
  remaining: number;
  remainingSize: number;
  firstIndex: number;
  first: number;
  last: number;
  heap: Bytes;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMessageQueueError =
  /**
   * Page is not reapable because it has items remaining to be processed and is not old
   * enough.
   **/
  | 'NotReapable'
  /**
   * Page to be reaped does not exist.
   **/
  | 'NoPage'
  /**
   * The referenced message could not be found.
   **/
  | 'NoMessage'
  /**
   * The message was already processed and cannot be processed again.
   **/
  | 'AlreadyProcessed'
  /**
   * The message is queued for future execution.
   **/
  | 'Queued'
  /**
   * There is temporarily not enough weight to continue servicing messages.
   **/
  | 'InsufficientWeight'
  /**
   * This message is temporarily unprocessable.
   *
   * Such errors are expected, but not guaranteed, to resolve themselves eventually through
   * retrying.
   **/
  | 'TemporarilyUnprocessable'
  /**
   * The queue is paused and no message can be executed from it.
   *
   * This can change at any time and may resolve in the future by re-trying.
   **/
  | 'QueuePaused'
  /**
   * Another call is in progress and needs to finish before this call can happen.
   **/
  | 'RecursiveDisallowed';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletTxPauseError =
  /**
   * The call is paused.
   **/
  | 'IsPaused'
  /**
   * The call is unpaused.
   **/
  | 'IsUnpaused'
  /**
   * The call is whitelisted and cannot be paused.
   **/
  | 'Unpausable'
  | 'NotFound';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSafeModeError =
  /**
   * The safe-mode is (already or still) entered.
   **/
  | 'Entered'
  /**
   * The safe-mode is (already or still) exited.
   **/
  | 'Exited'
  /**
   * This functionality of the pallet is disabled by the configuration.
   **/
  | 'NotConfigured'
  /**
   * There is no balance reserved.
   **/
  | 'NoDeposit'
  /**
   * The account already has a deposit reserved and can therefore not enter or extend again.
   **/
  | 'AlreadyDeposited'
  /**
   * This deposit cannot be released yet.
   **/
  | 'CannotReleaseYet'
  /**
   * An error from the underlying `Currency`.
   **/
  | 'CurrencyError';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMigrationsError =
  /**
   * The operation cannot complete since some MBMs are ongoing.
   **/
  'Ongoing';

export type PalletBrokerLeaseRecordItem = { until: number; task: number };

export type PalletBrokerStatusRecord = {
  coreCount: number;
  privatePoolSize: number;
  systemPoolSize: number;
  lastCommittedTimeslice: number;
  lastTimeslice: number;
};

export type PalletBrokerSaleInfoRecord = {
  saleStart: number;
  leadinLength: number;
  price: bigint;
  regionBegin: number;
  regionEnd: number;
  idealCoresSold: number;
  coresOffered: number;
  firstCore: number;
  selloutPrice?: bigint | undefined;
  coresSold: number;
};

export type PalletBrokerAllowedRenewalId = { core: number; when: number };

export type PalletBrokerAllowedRenewalRecord = { price: bigint; completion: PalletBrokerCompletionStatus };

export type PalletBrokerCompletionStatus =
  | { tag: 'Partial'; value: PalletBrokerCoreMask }
  | { tag: 'Complete'; value: Array<PalletBrokerScheduleItem> };

export type PalletBrokerRegionRecord = { end: number; owner: AccountId32; paid?: bigint | undefined };

export type PalletBrokerContributionRecord = { length: number; payee: AccountId32 };

export type PalletBrokerPoolIoRecord = { private: number; system: number };

export type PalletBrokerInstaPoolHistoryRecord = {
  privateContributions: number;
  systemContributions: number;
  maybePayout?: bigint | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBrokerError =
  /**
   * The given region identity is not known.
   **/
  | 'UnknownRegion'
  /**
   * The owner of the region is not the origin.
   **/
  | 'NotOwner'
  /**
   * The pivot point of the partition at or after the end of the region.
   **/
  | 'PivotTooLate'
  /**
   * The pivot point of the partition at the beginning of the region.
   **/
  | 'PivotTooEarly'
  /**
   * The pivot mask for the interlacing is not contained within the region's interlace mask.
   **/
  | 'ExteriorPivot'
  /**
   * The pivot mask for the interlacing is void (and therefore unschedulable).
   **/
  | 'VoidPivot'
  /**
   * The pivot mask for the interlacing is complete (and therefore not a strict subset).
   **/
  | 'CompletePivot'
  /**
   * The workplan of the pallet's state is invalid. This indicates a state corruption.
   **/
  | 'CorruptWorkplan'
  /**
   * There is no sale happening currently.
   **/
  | 'NoSales'
  /**
   * The price limit is exceeded.
   **/
  | 'Overpriced'
  /**
   * There are no cores available.
   **/
  | 'Unavailable'
  /**
   * The sale limit has been reached.
   **/
  | 'SoldOut'
  /**
   * The renewal operation is not valid at the current time (it may become valid in the next
   * sale).
   **/
  | 'WrongTime'
  /**
   * Invalid attempt to renew.
   **/
  | 'NotAllowed'
  /**
   * This pallet has not yet been initialized.
   **/
  | 'Uninitialized'
  /**
   * The purchase cannot happen yet as the sale period is yet to begin.
   **/
  | 'TooEarly'
  /**
   * There is no work to be done.
   **/
  | 'NothingToDo'
  /**
   * The maximum amount of reservations has already been reached.
   **/
  | 'TooManyReservations'
  /**
   * The maximum amount of leases has already been reached.
   **/
  | 'TooManyLeases'
  /**
   * The revenue for the Instantaneous Core Sales of this period is not (yet) known and thus
   * this operation cannot proceed.
   **/
  | 'UnknownRevenue'
  /**
   * The identified contribution to the Instantaneous Core Pool is unknown.
   **/
  | 'UnknownContribution'
  /**
   * The workload assigned for renewal is incomplete. This is unexpected and indicates a
   * logic error.
   **/
  | 'IncompleteAssignment'
  /**
   * An item cannot be dropped because it is still valid.
   **/
  | 'StillValid'
  /**
   * The history item does not exist.
   **/
  | 'NoHistory'
  /**
   * No reservation of the given index exists.
   **/
  | 'UnknownReservation'
  /**
   * The renewal record cannot be found.
   **/
  | 'UnknownRenewal'
  /**
   * The lease expiry time has already passed.
   **/
  | 'AlreadyExpired'
  /**
   * The configuration could not be applied because it is invalid.
   **/
  | 'InvalidConfig';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletExampleTasksError =
  /**
   * The referenced task was not found.
   **/
  'NotFound';

export type FrameSystemExtensionsCheckNonZeroSender = {};

export type FrameSystemExtensionsCheckSpecVersion = {};

export type FrameSystemExtensionsCheckTxVersion = {};

export type FrameSystemExtensionsCheckGenesis = {};

export type FrameSystemExtensionsCheckMortality = Era;

export type FrameSystemExtensionsCheckNonce = number;

export type FrameSystemExtensionsCheckWeight = {};

export type PalletAssetConversionTxPaymentChargeAssetTxPayment = { tip: bigint; assetId?: number | undefined };

export type SpRuntimeBlock = { header: Header; extrinsics: Array<UncheckedExtrinsic> };

export type SpRuntimeExtrinsicInclusionMode = 'AllExtrinsics' | 'OnlyInherents';

export type SpCoreOpaqueMetadata = Bytes;

export type SpRuntimeTransactionValidityTransactionValidityError =
  | { tag: 'Invalid'; value: SpRuntimeTransactionValidityInvalidTransaction }
  | { tag: 'Unknown'; value: SpRuntimeTransactionValidityUnknownTransaction };

export type SpRuntimeTransactionValidityInvalidTransaction =
  | { tag: 'Call' }
  | { tag: 'Payment' }
  | { tag: 'Future' }
  | { tag: 'Stale' }
  | { tag: 'BadProof' }
  | { tag: 'AncientBirthBlock' }
  | { tag: 'ExhaustsResources' }
  | { tag: 'Custom'; value: number }
  | { tag: 'BadMandatory' }
  | { tag: 'MandatoryValidation' }
  | { tag: 'BadSigner' };

export type SpRuntimeTransactionValidityUnknownTransaction =
  | { tag: 'CannotLookup' }
  | { tag: 'NoUnsignedValidator' }
  | { tag: 'Custom'; value: number };

export type SpInherentsInherentData = { data: Array<[FixedBytes<8>, Bytes]> };

export type SpInherentsCheckInherentsResult = { okay: boolean; fatalError: boolean; errors: SpInherentsInherentData };

export type SpRuntimeTransactionValidityTransactionSource = 'InBlock' | 'Local' | 'External';

export type SpRuntimeTransactionValidityValidTransaction = {
  priority: bigint;
  requires: Array<Bytes>;
  provides: Array<Bytes>;
  longevity: bigint;
  propagate: boolean;
};

export type SpStatementStoreRuntimeApiStatementSource = 'Chain' | 'Network' | 'Local';

export type SpStatementStoreRuntimeApiValidStatement = { maxCount: number; maxSize: number };

export type SpStatementStoreRuntimeApiInvalidStatement = 'BadProof' | 'NoProof' | 'InternalError';

export type SpConsensusGrandpaOpaqueKeyOwnershipProof = Bytes;

export type SpConsensusBabeBabeConfiguration = {
  slotDuration: bigint;
  epochLength: bigint;
  c: [bigint, bigint];
  authorities: Array<[SpConsensusBabeAppPublic, bigint]>;
  randomness: FixedBytes<32>;
  allowedSlots: SpConsensusBabeAllowedSlots;
};

export type SpConsensusBabeEpoch = {
  epochIndex: bigint;
  startSlot: SpConsensusSlotsSlot;
  duration: bigint;
  authorities: Array<[SpConsensusBabeAppPublic, bigint]>;
  randomness: FixedBytes<32>;
  config: SpConsensusBabeBabeEpochConfiguration;
};

export type SpConsensusBabeOpaqueKeyOwnershipProof = Bytes;

export type PalletContractsPrimitivesContractResult = {
  gasConsumed: SpWeightsWeightV2Weight;
  gasRequired: SpWeightsWeightV2Weight;
  storageDeposit: PalletContractsPrimitivesStorageDeposit;
  debugMessage: Bytes;
  result: Result<PalletContractsPrimitivesExecReturnValue, DispatchError>;
  events?: Array<FrameSystemEventRecord> | undefined;
};

export type PalletContractsPrimitivesExecReturnValue = { flags: PalletContractsUapiFlagsReturnFlags; data: Bytes };

export type PalletContractsUapiFlagsReturnFlags = { bits: number };

export type PalletContractsPrimitivesStorageDeposit =
  | { tag: 'Refund'; value: bigint }
  | { tag: 'Charge'; value: bigint };

export type PalletContractsPrimitivesCode = { tag: 'Upload'; value: Bytes } | { tag: 'Existing'; value: H256 };

export type PalletContractsPrimitivesContractResultResult = {
  gasConsumed: SpWeightsWeightV2Weight;
  gasRequired: SpWeightsWeightV2Weight;
  storageDeposit: PalletContractsPrimitivesStorageDeposit;
  debugMessage: Bytes;
  result: Result<PalletContractsPrimitivesInstantiateReturnValue, DispatchError>;
  events?: Array<FrameSystemEventRecord> | undefined;
};

export type PalletContractsPrimitivesInstantiateReturnValue = {
  result: PalletContractsPrimitivesExecReturnValue;
  accountId: AccountId32;
};

export type PalletContractsPrimitivesCodeUploadReturnValue = { codeHash: H256; deposit: bigint };

export type PalletContractsPrimitivesContractAccessError = 'DoesntExist' | 'KeyDecodingFailed' | 'MigrationInProgress';

export type PalletTransactionPaymentRuntimeDispatchInfo = {
  weight: SpWeightsWeightV2Weight;
  class: FrameSupportDispatchDispatchClass;
  partialFee: bigint;
};

export type PalletTransactionPaymentFeeDetails = {
  inclusionFee?: PalletTransactionPaymentInclusionFee | undefined;
  tip: bigint;
};

export type PalletTransactionPaymentInclusionFee = { baseFee: bigint; lenFee: bigint; adjustedWeightFee: bigint };

export type SpConsensusBeefyValidatorSet = { validators: Array<SpConsensusBeefyEcdsaCryptoPublic>; id: bigint };

export type SpConsensusBeefyOpaqueKeyOwnershipProof = Bytes;

export type SpMmrPrimitivesError =
  | 'InvalidNumericOp'
  | 'Push'
  | 'GetRoot'
  | 'Commit'
  | 'GenerateProof'
  | 'Verify'
  | 'LeafNotFound'
  | 'PalletNotIncluded'
  | 'InvalidLeafIndex'
  | 'InvalidBestKnownBlock';

export type SpMmrPrimitivesEncodableOpaqueLeaf = Bytes;

export type SpMmrPrimitivesProof = { leafIndices: Array<bigint>; leafCount: bigint; items: Array<H256> };

export type SpMixnetSessionStatus = { currentIndex: number; phase: SpMixnetSessionPhase };

export type SpMixnetSessionPhase = 'CoverToCurrent' | 'RequestsToCurrent' | 'CoverToPrev' | 'DisconnectFromPrev';

export type SpMixnetMixnode = { kxPublic: FixedBytes<32>; peerId: FixedBytes<32>; externalAddresses: Array<Bytes> };

export type SpMixnetMixnodesErr = { tag: 'InsufficientRegistrations'; value: { num: number; min: number } };

export type KitchensinkRuntimeRuntimeError =
  | { pallet: 'System'; palletError: FrameSystemError }
  | { pallet: 'Utility'; palletError: PalletUtilityError }
  | { pallet: 'Babe'; palletError: PalletBabeError }
  | { pallet: 'Indices'; palletError: PalletIndicesError }
  | { pallet: 'Balances'; palletError: PalletBalancesError }
  | { pallet: 'ElectionProviderMultiPhase'; palletError: PalletElectionProviderMultiPhaseError }
  | { pallet: 'Staking'; palletError: PalletStakingPalletError }
  | { pallet: 'Session'; palletError: PalletSessionError }
  | { pallet: 'Democracy'; palletError: PalletDemocracyError }
  | { pallet: 'Council'; palletError: PalletCollectiveError }
  | { pallet: 'TechnicalCommittee'; palletError: PalletCollectiveError }
  | { pallet: 'Elections'; palletError: PalletElectionsPhragmenError }
  | { pallet: 'TechnicalMembership'; palletError: PalletMembershipError }
  | { pallet: 'Grandpa'; palletError: PalletGrandpaError }
  | { pallet: 'Treasury'; palletError: PalletTreasuryError }
  | { pallet: 'AssetRate'; palletError: PalletAssetRateError }
  | { pallet: 'Contracts'; palletError: PalletContractsError }
  | { pallet: 'Sudo'; palletError: PalletSudoError }
  | { pallet: 'ImOnline'; palletError: PalletImOnlineError }
  | { pallet: 'Identity'; palletError: PalletIdentityError }
  | { pallet: 'Society'; palletError: PalletSocietyError }
  | { pallet: 'Recovery'; palletError: PalletRecoveryError }
  | { pallet: 'Vesting'; palletError: PalletVestingError }
  | { pallet: 'Scheduler'; palletError: PalletSchedulerError }
  | { pallet: 'Glutton'; palletError: PalletGluttonError }
  | { pallet: 'Preimage'; palletError: PalletPreimageError }
  | { pallet: 'Proxy'; palletError: PalletProxyError }
  | { pallet: 'Multisig'; palletError: PalletMultisigError }
  | { pallet: 'Bounties'; palletError: PalletBountiesError }
  | { pallet: 'Tips'; palletError: PalletTipsError }
  | { pallet: 'Assets'; palletError: PalletAssetsError }
  | { pallet: 'PoolAssets'; palletError: PalletAssetsError }
  | { pallet: 'Beefy'; palletError: PalletBeefyError }
  | { pallet: 'Lottery'; palletError: PalletLotteryError }
  | { pallet: 'Nis'; palletError: PalletNisError }
  | { pallet: 'Uniques'; palletError: PalletUniquesError }
  | { pallet: 'Nfts'; palletError: PalletNftsError }
  | { pallet: 'NftFractionalization'; palletError: PalletNftFractionalizationError }
  | { pallet: 'Salary'; palletError: PalletSalaryError }
  | { pallet: 'CoreFellowship'; palletError: PalletCoreFellowshipError }
  | { pallet: 'TransactionStorage'; palletError: PalletTransactionStorageError }
  | { pallet: 'VoterList'; palletError: PalletBagsListError }
  | { pallet: 'StateTrieMigration'; palletError: PalletStateTrieMigrationError }
  | { pallet: 'ChildBounties'; palletError: PalletChildBountiesError }
  | { pallet: 'Referenda'; palletError: PalletReferendaError }
  | { pallet: 'Remark'; palletError: PalletRemarkError }
  | { pallet: 'ConvictionVoting'; palletError: PalletConvictionVotingError }
  | { pallet: 'Whitelist'; palletError: PalletWhitelistError }
  | { pallet: 'AllianceMotion'; palletError: PalletCollectiveError }
  | { pallet: 'Alliance'; palletError: PalletAllianceError }
  | { pallet: 'NominationPools'; palletError: PalletNominationPoolsError }
  | { pallet: 'RankedPolls'; palletError: PalletReferendaError }
  | { pallet: 'RankedCollective'; palletError: PalletRankedCollectiveError }
  | { pallet: 'AssetConversion'; palletError: PalletAssetConversionError }
  | { pallet: 'FastUnstake'; palletError: PalletFastUnstakeError }
  | { pallet: 'MessageQueue'; palletError: PalletMessageQueueError }
  | { pallet: 'TxPause'; palletError: PalletTxPauseError }
  | { pallet: 'SafeMode'; palletError: PalletSafeModeError }
  | { pallet: 'MultiBlockMigrations'; palletError: PalletMigrationsError }
  | { pallet: 'Broker'; palletError: PalletBrokerError }
  | { pallet: 'TasksExample'; palletError: PalletExampleTasksError };
