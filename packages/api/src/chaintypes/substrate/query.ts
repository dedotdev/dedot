// Generated by @dedot/codegen
import type {
  AccountId32,
  AccountId32Like,
  Bytes,
  BytesLike,
  Data,
  Digest,
  FixedBytes,
  FixedU128,
  FixedU64,
  H256,
  Perbill,
  Percent,
  Phase,
} from '@dedot/codecs';
import type { Callback, GenericChainStorage, GenericStorageQuery, RpcVersion } from '@dedot/types';
import type {
  FrameSupportDispatchPerDispatchClass,
  FrameSupportPreimagesBounded,
  FrameSupportTokensFungibleUnionOfNativeOrWithId,
  FrameSystemAccountInfo,
  FrameSystemCodeUpgradeAuthorization,
  FrameSystemEventRecord,
  FrameSystemLastRuntimeUpgradeInfo,
  KitchensinkRuntimeRuntimeCall,
  KitchensinkRuntimeRuntimeParametersKey,
  KitchensinkRuntimeRuntimeParametersValue,
  KitchensinkRuntimeSessionKeys,
  PalletAllianceCid,
  PalletAllianceMemberRole,
  PalletAssetConversionPoolInfo,
  PalletAssetsApproval,
  PalletAssetsAssetAccount,
  PalletAssetsAssetDetails,
  PalletAssetsAssetMetadata,
  PalletBagsListListBag,
  PalletBagsListListNode,
  PalletBalancesAccountData,
  PalletBalancesBalanceLock,
  PalletBalancesIdAmount,
  PalletBalancesIdAmountRuntimeFreezeReason,
  PalletBalancesReserveData,
  PalletBountiesBounty,
  PalletBrokerAllowedRenewalId,
  PalletBrokerAllowedRenewalRecord,
  PalletBrokerConfigRecord,
  PalletBrokerContributionRecord,
  PalletBrokerInstaPoolHistoryRecord,
  PalletBrokerLeaseRecordItem,
  PalletBrokerPoolIoRecord,
  PalletBrokerRegionId,
  PalletBrokerRegionRecord,
  PalletBrokerSaleInfoRecord,
  PalletBrokerScheduleItem,
  PalletBrokerStatusRecord,
  PalletChildBountiesChildBounty,
  PalletCollectiveVotes,
  PalletContractsStorageContractInfo,
  PalletContractsStorageDeletionQueueManager,
  PalletContractsWasmCodeInfo,
  PalletConvictionVotingVoteVoting,
  PalletCoreFellowshipMemberStatus,
  PalletCoreFellowshipParamsType,
  PalletCoreFellowshipWish,
  PalletDemocracyMetadataOwner,
  PalletDemocracyReferendumInfo,
  PalletDemocracyVoteThreshold,
  PalletDemocracyVoteVoting,
  PalletElectionProviderMultiPhasePhase,
  PalletElectionProviderMultiPhaseReadySolution,
  PalletElectionProviderMultiPhaseRoundSnapshot,
  PalletElectionProviderMultiPhaseSignedSignedSubmission,
  PalletElectionProviderMultiPhaseSolutionOrSnapshotSize,
  PalletElectionsPhragmenSeatHolder,
  PalletElectionsPhragmenVoter,
  PalletFastUnstakeUnstakeRequest,
  PalletGrandpaStoredPendingChange,
  PalletGrandpaStoredState,
  PalletIdentityAuthorityProperties,
  PalletIdentityRegistrarInfo,
  PalletIdentityRegistration,
  PalletImOnlineSr25519AppSr25519Public,
  PalletLotteryLotteryConfig,
  PalletMessageQueueBookState,
  PalletMessageQueuePage,
  PalletMigrationsMigrationCursor,
  PalletMixnetBoundedMixnode,
  PalletMultisigMultisig,
  PalletNftFractionalizationDetails,
  PalletNftsAttributeDeposit,
  PalletNftsAttributeNamespace,
  PalletNftsBitFlagsCollectionRole,
  PalletNftsCollectionConfig,
  PalletNftsCollectionDetails,
  PalletNftsCollectionMetadata,
  PalletNftsItemConfig,
  PalletNftsItemDetails,
  PalletNftsItemMetadata,
  PalletNftsPendingSwap,
  PalletNisBid,
  PalletNisReceiptRecord,
  PalletNisSummaryRecord,
  PalletNominationPoolsBondedPoolInner,
  PalletNominationPoolsClaimPermission,
  PalletNominationPoolsPoolMember,
  PalletNominationPoolsRewardPool,
  PalletNominationPoolsSubPools,
  PalletPreimageOldRequestStatus,
  PalletPreimageRequestStatus,
  PalletProxyAnnouncement,
  PalletProxyProxyDefinition,
  PalletRankedCollectiveMemberRecord,
  PalletRankedCollectiveVoteRecord,
  PalletRecoveryActiveRecovery,
  PalletRecoveryRecoveryConfig,
  PalletReferendaReferendumInfo,
  PalletReferendaReferendumInfoTally,
  PalletSalaryClaimantStatus,
  PalletSalaryStatusType,
  PalletSchedulerRetryConfig,
  PalletSchedulerScheduled,
  PalletSocietyBid,
  PalletSocietyCandidacy,
  PalletSocietyGroupParams,
  PalletSocietyIntakeRecord,
  PalletSocietyMemberRecord,
  PalletSocietyPayoutRecord,
  PalletSocietyTally,
  PalletSocietyVote,
  PalletStakingActiveEraInfo,
  PalletStakingEraRewardPoints,
  PalletStakingForcing,
  PalletStakingNominations,
  PalletStakingRewardDestination,
  PalletStakingSlashingSlashingSpans,
  PalletStakingSlashingSpanRecord,
  PalletStakingStakingLedger,
  PalletStakingUnappliedSlash,
  PalletStakingValidatorPrefs,
  PalletStateTrieMigrationMigrationLimits,
  PalletStateTrieMigrationMigrationTask,
  PalletTipsOpenTip,
  PalletTransactionPaymentReleases,
  PalletTransactionStorageTransactionInfo,
  PalletTreasuryProposal,
  PalletTreasurySpendStatus,
  PalletUniquesCollectionDetails,
  PalletUniquesCollectionMetadata,
  PalletUniquesItemDetails,
  PalletUniquesItemMetadata,
  PalletVestingReleases,
  PalletVestingVestingInfo,
  SpAuthorityDiscoveryAppPublic,
  SpConsensusBabeAppPublic,
  SpConsensusBabeBabeEpochConfiguration,
  SpConsensusBabeDigestsNextConfigDescriptor,
  SpConsensusBabeDigestsPreDigest,
  SpConsensusBeefyEcdsaCryptoPublic,
  SpConsensusBeefyMmrBeefyAuthoritySet,
  SpConsensusGrandpaAppPublic,
  SpConsensusSlotsSlot,
  SpCoreCryptoKeyTypeId,
  SpMixnetAppPublic,
  SpNposElectionsElectionScore,
  SpStakingExposure,
  SpStakingExposurePage,
  SpStakingOffenceOffenceDetails,
  SpStakingPagedExposureMetadata,
} from './types.js';

export interface ChainStorage<Rv extends RpcVersion> extends GenericChainStorage<Rv> {
  /**
   * Pallet `System`'s storage queries
   **/
  system: {
    /**
     * The full account information for a particular account ID.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<FrameSystemAccountInfo> =} callback
     **/
    account: GenericStorageQuery<Rv, (arg: AccountId32Like) => FrameSystemAccountInfo, AccountId32>;

    /**
     * Total extrinsics count for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    extrinsicCount: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Whether all inherents have been applied.
     *
     * @param {Callback<boolean> =} callback
     **/
    inherentsApplied: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The current weight for the block.
     *
     * @param {Callback<FrameSupportDispatchPerDispatchClass> =} callback
     **/
    blockWeight: GenericStorageQuery<Rv, () => FrameSupportDispatchPerDispatchClass>;

    /**
     * Total length (in bytes) for all extrinsics put together, for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    allExtrinsicsLen: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Map of block numbers to block hashes.
     *
     * @param {number} arg
     * @param {Callback<H256> =} callback
     **/
    blockHash: GenericStorageQuery<Rv, (arg: number) => H256, number>;

    /**
     * Extrinsics data for the current block (maps an extrinsic's index to its data).
     *
     * @param {number} arg
     * @param {Callback<Bytes> =} callback
     **/
    extrinsicData: GenericStorageQuery<Rv, (arg: number) => Bytes, number>;

    /**
     * The current block number being processed. Set by `execute_block`.
     *
     * @param {Callback<number> =} callback
     **/
    number: GenericStorageQuery<Rv, () => number>;

    /**
     * Hash of the previous block.
     *
     * @param {Callback<H256> =} callback
     **/
    parentHash: GenericStorageQuery<Rv, () => H256>;

    /**
     * Digest of the current block, also part of the block header.
     *
     * @param {Callback<Digest> =} callback
     **/
    digest: GenericStorageQuery<Rv, () => Digest>;

    /**
     * Events deposited for the current block.
     *
     * NOTE: The item is unbound and should therefore never be read on chain.
     * It could otherwise inflate the PoV size of a block.
     *
     * Events have a large in-memory size. Box the events to not go out-of-memory
     * just in case someone still reads them from within the runtime.
     *
     * @param {Callback<Array<FrameSystemEventRecord>> =} callback
     **/
    events: GenericStorageQuery<Rv, () => Array<FrameSystemEventRecord>>;

    /**
     * The number of events in the `Events<T>` list.
     *
     * @param {Callback<number> =} callback
     **/
    eventCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Mapping between a topic (represented by T::Hash) and a vector of indexes
     * of events in the `<Events<T>>` list.
     *
     * All topic vectors have deterministic storage locations depending on the topic. This
     * allows light-clients to leverage the changes trie storage tracking mechanism and
     * in case of changes fetch the list of events of interest.
     *
     * The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just
     * the `EventIndex` then in case if the topic has the same contents on the next block
     * no notification will be triggered thus the event might be lost.
     *
     * @param {H256} arg
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    eventTopics: GenericStorageQuery<Rv, (arg: H256) => Array<[number, number]>, H256>;

    /**
     * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
     *
     * @param {Callback<FrameSystemLastRuntimeUpgradeInfo | undefined> =} callback
     **/
    lastRuntimeUpgrade: GenericStorageQuery<Rv, () => FrameSystemLastRuntimeUpgradeInfo | undefined>;

    /**
     * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToU32RefCount: GenericStorageQuery<Rv, () => boolean>;

    /**
     * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
     * (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToTripleRefCount: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The execution phase of the block.
     *
     * @param {Callback<Phase | undefined> =} callback
     **/
    executionPhase: GenericStorageQuery<Rv, () => Phase | undefined>;

    /**
     * `Some` if a code upgrade has been authorized.
     *
     * @param {Callback<FrameSystemCodeUpgradeAuthorization | undefined> =} callback
     **/
    authorizedUpgrade: GenericStorageQuery<Rv, () => FrameSystemCodeUpgradeAuthorization | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Babe`'s storage queries
   **/
  babe: {
    /**
     * Current epoch index.
     *
     * @param {Callback<bigint> =} callback
     **/
    epochIndex: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Current epoch authorities.
     *
     * @param {Callback<Array<[SpConsensusBabeAppPublic, bigint]>> =} callback
     **/
    authorities: GenericStorageQuery<Rv, () => Array<[SpConsensusBabeAppPublic, bigint]>>;

    /**
     * The slot at which the first epoch actually started. This is 0
     * until the first block of the chain.
     *
     * @param {Callback<SpConsensusSlotsSlot> =} callback
     **/
    genesisSlot: GenericStorageQuery<Rv, () => SpConsensusSlotsSlot>;

    /**
     * Current slot number.
     *
     * @param {Callback<SpConsensusSlotsSlot> =} callback
     **/
    currentSlot: GenericStorageQuery<Rv, () => SpConsensusSlotsSlot>;

    /**
     * The epoch randomness for the *current* epoch.
     *
     * # Security
     *
     * This MUST NOT be used for gambling, as it can be influenced by a
     * malicious validator in the short term. It MAY be used in many
     * cryptographic protocols, however, so long as one remembers that this
     * (like everything else on-chain) it is public. For example, it can be
     * used where a number is needed that cannot have been chosen by an
     * adversary, for purposes such as public-coin zero-knowledge proofs.
     *
     * @param {Callback<FixedBytes<32>> =} callback
     **/
    randomness: GenericStorageQuery<Rv, () => FixedBytes<32>>;

    /**
     * Pending epoch configuration change that will be applied when the next epoch is enacted.
     *
     * @param {Callback<SpConsensusBabeDigestsNextConfigDescriptor | undefined> =} callback
     **/
    pendingEpochConfigChange: GenericStorageQuery<Rv, () => SpConsensusBabeDigestsNextConfigDescriptor | undefined>;

    /**
     * Next epoch randomness.
     *
     * @param {Callback<FixedBytes<32>> =} callback
     **/
    nextRandomness: GenericStorageQuery<Rv, () => FixedBytes<32>>;

    /**
     * Next epoch authorities.
     *
     * @param {Callback<Array<[SpConsensusBabeAppPublic, bigint]>> =} callback
     **/
    nextAuthorities: GenericStorageQuery<Rv, () => Array<[SpConsensusBabeAppPublic, bigint]>>;

    /**
     * Randomness under construction.
     *
     * We make a trade-off between storage accesses and list length.
     * We store the under-construction randomness in segments of up to
     * `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.
     *
     * Once a segment reaches this length, we begin the next one.
     * We reset all segments and return to `0` at the beginning of every
     * epoch.
     *
     * @param {Callback<number> =} callback
     **/
    segmentIndex: GenericStorageQuery<Rv, () => number>;

    /**
     * TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay.
     *
     * @param {number} arg
     * @param {Callback<Array<FixedBytes<32>>> =} callback
     **/
    underConstruction: GenericStorageQuery<Rv, (arg: number) => Array<FixedBytes<32>>, number>;

    /**
     * Temporary value (cleared at block finalization) which is `Some`
     * if per-block initialization has already been called for current block.
     *
     * @param {Callback<SpConsensusBabeDigestsPreDigest | undefined | undefined> =} callback
     **/
    initialized: GenericStorageQuery<Rv, () => SpConsensusBabeDigestsPreDigest | undefined | undefined>;

    /**
     * This field should always be populated during block processing unless
     * secondary plain slots are enabled (which don't contain a VRF output).
     *
     * It is set in `on_finalize`, before it will contain the value from the last block.
     *
     * @param {Callback<FixedBytes<32> | undefined> =} callback
     **/
    authorVrfRandomness: GenericStorageQuery<Rv, () => FixedBytes<32> | undefined>;

    /**
     * The block numbers when the last and current epoch have started, respectively `N-1` and
     * `N`.
     * NOTE: We track this is in order to annotate the block number when a given pool of
     * entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in
     * slots, which may be skipped, the block numbers may not line up with the slot numbers.
     *
     * @param {Callback<[number, number]> =} callback
     **/
    epochStart: GenericStorageQuery<Rv, () => [number, number]>;

    /**
     * How late the current block is compared to its parent.
     *
     * This entry is populated as part of block execution and is cleaned up
     * on block finalization. Querying this storage entry outside of block
     * execution context should always yield zero.
     *
     * @param {Callback<number> =} callback
     **/
    lateness: GenericStorageQuery<Rv, () => number>;

    /**
     * The configuration for the current epoch. Should never be `None` as it is initialized in
     * genesis.
     *
     * @param {Callback<SpConsensusBabeBabeEpochConfiguration | undefined> =} callback
     **/
    epochConfig: GenericStorageQuery<Rv, () => SpConsensusBabeBabeEpochConfiguration | undefined>;

    /**
     * The configuration for the next epoch, `None` if the config will not change
     * (you can fallback to `EpochConfig` instead in that case).
     *
     * @param {Callback<SpConsensusBabeBabeEpochConfiguration | undefined> =} callback
     **/
    nextEpochConfig: GenericStorageQuery<Rv, () => SpConsensusBabeBabeEpochConfiguration | undefined>;

    /**
     * A list of the last 100 skipped epochs and the corresponding session index
     * when the epoch was skipped.
     *
     * This is only used for validating equivocation proofs. An equivocation proof
     * must contains a key-ownership proof for a given session, therefore we need a
     * way to tie together sessions and epoch indices, i.e. we need to validate that
     * a validator was the owner of a given key on a given session, and what the
     * active epoch index was during that session.
     *
     * @param {Callback<Array<[bigint, number]>> =} callback
     **/
    skippedEpochs: GenericStorageQuery<Rv, () => Array<[bigint, number]>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Timestamp`'s storage queries
   **/
  timestamp: {
    /**
     * The current time for the current block.
     *
     * @param {Callback<bigint> =} callback
     **/
    now: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Whether the timestamp has been updated in this block.
     *
     * This value is updated to `true` upon successful submission of a timestamp by a node.
     * It is then checked at the end of each block execution in the `on_finalize` hook.
     *
     * @param {Callback<boolean> =} callback
     **/
    didUpdate: GenericStorageQuery<Rv, () => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Authorship`'s storage queries
   **/
  authorship: {
    /**
     * Author of current block.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    author: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Indices`'s storage queries
   **/
  indices: {
    /**
     * The lookup from index to account.
     *
     * @param {number} arg
     * @param {Callback<[AccountId32, bigint, boolean] | undefined> =} callback
     **/
    accounts: GenericStorageQuery<Rv, (arg: number) => [AccountId32, bigint, boolean] | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Balances`'s storage queries
   **/
  balances: {
    /**
     * The total units issued in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    totalIssuance: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The total units of outstanding deactivated balance in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    inactiveIssuance: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The Balances pallet example of storing the balance of an account.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
     * }
     * ```
     *
     * You can also store the balance of an account in the `System` pallet.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = System
     * }
     * ```
     *
     * But this comes with tradeoffs, storing account balances in the system pallet stores
     * `frame_system` data alongside the account data contrary to storing account balances in the
     * `Balances` pallet, which uses a `StorageMap` to store balances data only.
     * NOTE: This is only used in the case that this pallet is used to store balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletBalancesAccountData> =} callback
     **/
    account: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletBalancesAccountData, AccountId32>;

    /**
     * Any liquidity locks on some account balances.
     * NOTE: Should only be accessed when setting, changing and freeing a lock.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesBalanceLock>> =} callback
     **/
    locks: GenericStorageQuery<Rv, (arg: AccountId32Like) => Array<PalletBalancesBalanceLock>, AccountId32>;

    /**
     * Named reserves on some account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesReserveData>> =} callback
     **/
    reserves: GenericStorageQuery<Rv, (arg: AccountId32Like) => Array<PalletBalancesReserveData>, AccountId32>;

    /**
     * Holds on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesIdAmount>> =} callback
     **/
    holds: GenericStorageQuery<Rv, (arg: AccountId32Like) => Array<PalletBalancesIdAmount>, AccountId32>;

    /**
     * Freeze locks on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesIdAmountRuntimeFreezeReason>> =} callback
     **/
    freezes: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<PalletBalancesIdAmountRuntimeFreezeReason>,
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `TransactionPayment`'s storage queries
   **/
  transactionPayment: {
    /**
     *
     * @param {Callback<FixedU128> =} callback
     **/
    nextFeeMultiplier: GenericStorageQuery<Rv, () => FixedU128>;

    /**
     *
     * @param {Callback<PalletTransactionPaymentReleases> =} callback
     **/
    storageVersion: GenericStorageQuery<Rv, () => PalletTransactionPaymentReleases>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ElectionProviderMultiPhase`'s storage queries
   **/
  electionProviderMultiPhase: {
    /**
     * Internal counter for the number of rounds.
     *
     * This is useful for de-duplication of transactions submitted to the pool, and general
     * diagnostics of the pallet.
     *
     * This is merely incremented once per every time that an upstream `elect` is called.
     *
     * @param {Callback<number> =} callback
     **/
    round: GenericStorageQuery<Rv, () => number>;

    /**
     * Current phase.
     *
     * @param {Callback<PalletElectionProviderMultiPhasePhase> =} callback
     **/
    currentPhase: GenericStorageQuery<Rv, () => PalletElectionProviderMultiPhasePhase>;

    /**
     * Current best solution, signed or unsigned, queued to be returned upon `elect`.
     *
     * Always sorted by score.
     *
     * @param {Callback<PalletElectionProviderMultiPhaseReadySolution | undefined> =} callback
     **/
    queuedSolution: GenericStorageQuery<Rv, () => PalletElectionProviderMultiPhaseReadySolution | undefined>;

    /**
     * Snapshot data of the round.
     *
     * This is created at the beginning of the signed phase and cleared upon calling `elect`.
     * Note: This storage type must only be mutated through [`SnapshotWrapper`].
     *
     * @param {Callback<PalletElectionProviderMultiPhaseRoundSnapshot | undefined> =} callback
     **/
    snapshot: GenericStorageQuery<Rv, () => PalletElectionProviderMultiPhaseRoundSnapshot | undefined>;

    /**
     * Desired number of targets to elect for this round.
     *
     * Only exists when [`Snapshot`] is present.
     * Note: This storage type must only be mutated through [`SnapshotWrapper`].
     *
     * @param {Callback<number | undefined> =} callback
     **/
    desiredTargets: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * The metadata of the [`RoundSnapshot`]
     *
     * Only exists when [`Snapshot`] is present.
     * Note: This storage type must only be mutated through [`SnapshotWrapper`].
     *
     * @param {Callback<PalletElectionProviderMultiPhaseSolutionOrSnapshotSize | undefined> =} callback
     **/
    snapshotMetadata: GenericStorageQuery<Rv, () => PalletElectionProviderMultiPhaseSolutionOrSnapshotSize | undefined>;

    /**
     * The next index to be assigned to an incoming signed submission.
     *
     * Every accepted submission is assigned a unique index; that index is bound to that particular
     * submission for the duration of the election. On election finalization, the next index is
     * reset to 0.
     *
     * We can't just use `SignedSubmissionIndices.len()`, because that's a bounded set; past its
     * capacity, it will simply saturate. We can't just iterate over `SignedSubmissionsMap`,
     * because iteration is slow. Instead, we store the value here.
     *
     * @param {Callback<number> =} callback
     **/
    signedSubmissionNextIndex: GenericStorageQuery<Rv, () => number>;

    /**
     * A sorted, bounded vector of `(score, block_number, index)`, where each `index` points to a
     * value in `SignedSubmissions`.
     *
     * We never need to process more than a single signed submission at a time. Signed submissions
     * can be quite large, so we're willing to pay the cost of multiple database accesses to access
     * them one at a time instead of reading and decoding all of them at once.
     *
     * @param {Callback<Array<[SpNposElectionsElectionScore, number, number]>> =} callback
     **/
    signedSubmissionIndices: GenericStorageQuery<Rv, () => Array<[SpNposElectionsElectionScore, number, number]>>;

    /**
     * Unchecked, signed solutions.
     *
     * Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while
     * allowing us to keep only a single one in memory at a time.
     *
     * Twox note: the key of the map is an auto-incrementing index which users cannot inspect or
     * affect; we shouldn't need a cryptographically secure hasher.
     *
     * @param {number} arg
     * @param {Callback<PalletElectionProviderMultiPhaseSignedSignedSubmission | undefined> =} callback
     **/
    signedSubmissionsMap: GenericStorageQuery<
      Rv,
      (arg: number) => PalletElectionProviderMultiPhaseSignedSignedSubmission | undefined,
      number
    >;

    /**
     * The minimum score that each 'untrusted' solution must attain in order to be considered
     * feasible.
     *
     * Can be set via `set_minimum_untrusted_score`.
     *
     * @param {Callback<SpNposElectionsElectionScore | undefined> =} callback
     **/
    minimumUntrustedScore: GenericStorageQuery<Rv, () => SpNposElectionsElectionScore | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Staking`'s storage queries
   **/
  staking: {
    /**
     * The ideal number of active validators.
     *
     * @param {Callback<number> =} callback
     **/
    validatorCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Minimum number of staking participants before emergency conditions are imposed.
     *
     * @param {Callback<number> =} callback
     **/
    minimumValidatorCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
     * easy to initialize and the performance hit is minimal (we expect no more than four
     * invulnerables) and restricted to testnets.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    invulnerables: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * Map from all locked "stash" accounts to the controller account.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    bonded: GenericStorageQuery<Rv, (arg: AccountId32Like) => AccountId32 | undefined, AccountId32>;

    /**
     * The minimum active bond to become and maintain the role of a nominator.
     *
     * @param {Callback<bigint> =} callback
     **/
    minNominatorBond: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The minimum active bond to become and maintain the role of a validator.
     *
     * @param {Callback<bigint> =} callback
     **/
    minValidatorBond: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The minimum active nominator stake of the last successful election.
     *
     * @param {Callback<bigint> =} callback
     **/
    minimumActiveStake: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The minimum amount of commission that validators can set.
     *
     * If set to `0`, no limit exists.
     *
     * @param {Callback<Perbill> =} callback
     **/
    minCommission: GenericStorageQuery<Rv, () => Perbill>;

    /**
     * Map from all (unlocked) "controller" accounts to the info regarding the staking.
     *
     * Note: All the reads and mutations to this storage *MUST* be done through the methods exposed
     * by [`StakingLedger`] to ensure data and lock consistency.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletStakingStakingLedger | undefined> =} callback
     **/
    ledger: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletStakingStakingLedger | undefined, AccountId32>;

    /**
     * Where the reward payment should be made. Keyed by stash.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletStakingRewardDestination | undefined> =} callback
     **/
    payee: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletStakingRewardDestination | undefined, AccountId32>;

    /**
     * The map from (wannabe) validator stash key to the preferences of that validator.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletStakingValidatorPrefs> =} callback
     **/
    validators: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletStakingValidatorPrefs, AccountId32>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForValidators: GenericStorageQuery<Rv, () => number>;

    /**
     * The maximum validator count before we stop allowing new validators to join.
     *
     * When this value is not set, no limits are enforced.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    maxValidatorsCount: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * The map from nominator stash key to their nomination preferences, namely the validators that
     * they wish to support.
     *
     * Note that the keys of this storage map might become non-decodable in case the
     * account's [`NominationsQuota::MaxNominations`] configuration is decreased.
     * In this rare case, these nominators
     * are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
     * indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
     * nominators will effectively not-exist, until they re-submit their preferences such that it
     * is within the bounds of the newly set `Config::MaxNominations`.
     *
     * This implies that `::iter_keys().count()` and `::iter().count()` might return different
     * values for this map. Moreover, the main `::count()` is aligned with the former, namely the
     * number of keys that exist.
     *
     * Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
     * [`Call::chill_other`] dispatchable by anyone.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletStakingNominations | undefined> =} callback
     **/
    nominators: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletStakingNominations | undefined, AccountId32>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForNominators: GenericStorageQuery<Rv, () => number>;

    /**
     * The maximum nominator count before we stop allowing new validators to join.
     *
     * When this value is not set, no limits are enforced.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    maxNominatorsCount: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * The current era index.
     *
     * This is the latest planned era, depending on how the Session pallet queues the validator
     * set, it might be active or not.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    currentEra: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * The active era information, it holds index and start.
     *
     * The active era is the era being currently rewarded. Validator set of this era must be
     * equal to [`SessionInterface::validators`].
     *
     * @param {Callback<PalletStakingActiveEraInfo | undefined> =} callback
     **/
    activeEra: GenericStorageQuery<Rv, () => PalletStakingActiveEraInfo | undefined>;

    /**
     * The session index at which the era start for the last [`Config::HistoryDepth`] eras.
     *
     * Note: This tracks the starting session (i.e. session index when era start being active)
     * for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
     *
     * @param {number} arg
     * @param {Callback<number | undefined> =} callback
     **/
    erasStartSessionIndex: GenericStorageQuery<Rv, (arg: number) => number | undefined, number>;

    /**
     * Exposure of validator at era.
     *
     * This is keyed first by the era index to allow bulk deletion and then the stash account.
     *
     * Is it removed after [`Config::HistoryDepth`] eras.
     * If stakers hasn't been set or has been removed then empty exposure is returned.
     *
     * Note: Deprecated since v14. Use `EraInfo` instead to work with exposures.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<SpStakingExposure> =} callback
     **/
    erasStakers: GenericStorageQuery<Rv, (arg: [number, AccountId32Like]) => SpStakingExposure, [number, AccountId32]>;

    /**
     * Summary of validator exposure at a given era.
     *
     * This contains the total stake in support of the validator and their own stake. In addition,
     * it can also be used to get the number of nominators backing this validator and the number of
     * exposure pages they are divided into. The page count is useful to determine the number of
     * pages of rewards that needs to be claimed.
     *
     * This is keyed first by the era index to allow bulk deletion and then the stash account.
     * Should only be accessed through `EraInfo`.
     *
     * Is it removed after [`Config::HistoryDepth`] eras.
     * If stakers hasn't been set or has been removed then empty overview is returned.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<SpStakingPagedExposureMetadata | undefined> =} callback
     **/
    erasStakersOverview: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => SpStakingPagedExposureMetadata | undefined,
      [number, AccountId32]
    >;

    /**
     * Clipped Exposure of validator at era.
     *
     * Note: This is deprecated, should be used as read-only and will be removed in the future.
     * New `Exposure`s are stored in a paged manner in `ErasStakersPaged` instead.
     *
     * This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
     * `T::MaxExposurePageSize` biggest stakers.
     * (Note: the field `total` and `own` of the exposure remains unchanged).
     * This is used to limit the i/o cost for the nominator payout.
     *
     * This is keyed fist by the era index to allow bulk deletion and then the stash account.
     *
     * It is removed after [`Config::HistoryDepth`] eras.
     * If stakers hasn't been set or has been removed then empty exposure is returned.
     *
     * Note: Deprecated since v14. Use `EraInfo` instead to work with exposures.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<SpStakingExposure> =} callback
     **/
    erasStakersClipped: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => SpStakingExposure,
      [number, AccountId32]
    >;

    /**
     * Paginated exposure of a validator at given era.
     *
     * This is keyed first by the era index to allow bulk deletion, then stash account and finally
     * the page. Should only be accessed through `EraInfo`.
     *
     * This is cleared after [`Config::HistoryDepth`] eras.
     *
     * @param {[number, AccountId32Like, number]} arg
     * @param {Callback<SpStakingExposurePage | undefined> =} callback
     **/
    erasStakersPaged: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like, number]) => SpStakingExposurePage | undefined,
      [number, AccountId32, number]
    >;

    /**
     * History of claimed paged rewards by era and validator.
     *
     * This is keyed by era and validator stash which maps to the set of page indexes which have
     * been claimed.
     *
     * It is removed after [`Config::HistoryDepth`] eras.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<Array<number>> =} callback
     **/
    claimedRewards: GenericStorageQuery<Rv, (arg: [number, AccountId32Like]) => Array<number>, [number, AccountId32]>;

    /**
     * Similar to `ErasStakers`, this holds the preferences of validators.
     *
     * This is keyed first by the era index to allow bulk deletion and then the stash account.
     *
     * Is it removed after [`Config::HistoryDepth`] eras.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletStakingValidatorPrefs> =} callback
     **/
    erasValidatorPrefs: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => PalletStakingValidatorPrefs,
      [number, AccountId32]
    >;

    /**
     * The total validator era payout for the last [`Config::HistoryDepth`] eras.
     *
     * Eras that haven't finished yet or has been removed doesn't have reward.
     *
     * @param {number} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    erasValidatorReward: GenericStorageQuery<Rv, (arg: number) => bigint | undefined, number>;

    /**
     * Rewards for the last [`Config::HistoryDepth`] eras.
     * If reward hasn't been set or has been removed then 0 reward is returned.
     *
     * @param {number} arg
     * @param {Callback<PalletStakingEraRewardPoints> =} callback
     **/
    erasRewardPoints: GenericStorageQuery<Rv, (arg: number) => PalletStakingEraRewardPoints, number>;

    /**
     * The total amount staked for the last [`Config::HistoryDepth`] eras.
     * If total hasn't been set or has been removed then 0 stake is returned.
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    erasTotalStake: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * Mode of era forcing.
     *
     * @param {Callback<PalletStakingForcing> =} callback
     **/
    forceEra: GenericStorageQuery<Rv, () => PalletStakingForcing>;

    /**
     * Maximum staked rewards, i.e. the percentage of the era inflation that
     * is used for stake rewards.
     * See [Era payout](./index.html#era-payout).
     *
     * @param {Callback<Percent | undefined> =} callback
     **/
    maxStakedRewards: GenericStorageQuery<Rv, () => Percent | undefined>;

    /**
     * The percentage of the slash that is distributed to reporters.
     *
     * The rest of the slashed value is handled by the `Slash`.
     *
     * @param {Callback<Perbill> =} callback
     **/
    slashRewardFraction: GenericStorageQuery<Rv, () => Perbill>;

    /**
     * The amount of currency given to reporters of a slash event which was
     * canceled by extraordinary circumstances (e.g. governance).
     *
     * @param {Callback<bigint> =} callback
     **/
    canceledSlashPayout: GenericStorageQuery<Rv, () => bigint>;

    /**
     * All unapplied slashes that are queued for later.
     *
     * @param {number} arg
     * @param {Callback<Array<PalletStakingUnappliedSlash>> =} callback
     **/
    unappliedSlashes: GenericStorageQuery<Rv, (arg: number) => Array<PalletStakingUnappliedSlash>, number>;

    /**
     * A mapping from still-bonded eras to the first session index of that era.
     *
     * Must contains information for eras for the range:
     * `[active_era - bounding_duration; active_era]`
     *
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    bondedEras: GenericStorageQuery<Rv, () => Array<[number, number]>>;

    /**
     * All slashing events on validators, mapped by era to the highest slash proportion
     * and slash value of the era.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<[Perbill, bigint] | undefined> =} callback
     **/
    validatorSlashInEra: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => [Perbill, bigint] | undefined,
      [number, AccountId32]
    >;

    /**
     * All slashing events on nominators, mapped by era to the highest slash value of the era.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    nominatorSlashInEra: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => bigint | undefined,
      [number, AccountId32]
    >;

    /**
     * Slashing spans for stash accounts.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletStakingSlashingSlashingSpans | undefined> =} callback
     **/
    slashingSpans: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletStakingSlashingSlashingSpans | undefined,
      AccountId32
    >;

    /**
     * Records information about the maximum slash of a stash within a slashing span,
     * as well as how much reward has been paid out.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<PalletStakingSlashingSpanRecord> =} callback
     **/
    spanSlash: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number]) => PalletStakingSlashingSpanRecord,
      [AccountId32, number]
    >;

    /**
     * The last planned session scheduled by the session pallet.
     *
     * This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
     *
     * @param {Callback<number> =} callback
     **/
    currentPlannedSession: GenericStorageQuery<Rv, () => number>;

    /**
     * Indices of validators that have offended in the active era and whether they are currently
     * disabled.
     *
     * This value should be a superset of disabled validators since not all offences lead to the
     * validator being disabled (if there was no slash). This is needed to track the percentage of
     * validators that have offended in the current era, ensuring a new era is forced if
     * `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find
     * whether a given validator has previously offended using binary search. It gets cleared when
     * the era ends.
     *
     * @param {Callback<Array<[number, boolean]>> =} callback
     **/
    offendingValidators: GenericStorageQuery<Rv, () => Array<[number, boolean]>>;

    /**
     * The threshold for when users can start calling `chill_other` for other validators /
     * nominators. The threshold is compared to the actual number of validators / nominators
     * (`CountFor*`) in the system compared to the configured max (`Max*Count`).
     *
     * @param {Callback<Percent | undefined> =} callback
     **/
    chillThreshold: GenericStorageQuery<Rv, () => Percent | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Session`'s storage queries
   **/
  session: {
    /**
     * The current set of validators.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    validators: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * Current index of the session.
     *
     * @param {Callback<number> =} callback
     **/
    currentIndex: GenericStorageQuery<Rv, () => number>;

    /**
     * True if the underlying economic identities or weighting behind the validators
     * has changed in the queued validator set.
     *
     * @param {Callback<boolean> =} callback
     **/
    queuedChanged: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The queued keys for the next session. When the next session begins, these keys
     * will be used to determine the validator's session keys.
     *
     * @param {Callback<Array<[AccountId32, KitchensinkRuntimeSessionKeys]>> =} callback
     **/
    queuedKeys: GenericStorageQuery<Rv, () => Array<[AccountId32, KitchensinkRuntimeSessionKeys]>>;

    /**
     * Indices of disabled validators.
     *
     * The vec is always kept sorted so that we can find whether a given validator is
     * disabled using binary search. It gets cleared when `on_session_ending` returns
     * a new set of identities.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    disabledValidators: GenericStorageQuery<Rv, () => Array<number>>;

    /**
     * The next session keys for a validator.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<KitchensinkRuntimeSessionKeys | undefined> =} callback
     **/
    nextKeys: GenericStorageQuery<Rv, (arg: AccountId32Like) => KitchensinkRuntimeSessionKeys | undefined, AccountId32>;

    /**
     * The owner of a key. The key is the `KeyTypeId` + the encoded key.
     *
     * @param {[SpCoreCryptoKeyTypeId, BytesLike]} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    keyOwner: GenericStorageQuery<
      Rv,
      (arg: [SpCoreCryptoKeyTypeId, BytesLike]) => AccountId32 | undefined,
      [SpCoreCryptoKeyTypeId, Bytes]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Democracy`'s storage queries
   **/
  democracy: {
    /**
     * The number of (public) proposals that have been made so far.
     *
     * @param {Callback<number> =} callback
     **/
    publicPropCount: GenericStorageQuery<Rv, () => number>;

    /**
     * The public proposals. Unsorted. The second item is the proposal.
     *
     * @param {Callback<Array<[number, FrameSupportPreimagesBounded, AccountId32]>> =} callback
     **/
    publicProps: GenericStorageQuery<Rv, () => Array<[number, FrameSupportPreimagesBounded, AccountId32]>>;

    /**
     * Those who have locked a deposit.
     *
     * TWOX-NOTE: Safe, as increasing integer keys are safe.
     *
     * @param {number} arg
     * @param {Callback<[Array<AccountId32>, bigint] | undefined> =} callback
     **/
    depositOf: GenericStorageQuery<Rv, (arg: number) => [Array<AccountId32>, bigint] | undefined, number>;

    /**
     * The next free referendum index, aka the number of referenda started so far.
     *
     * @param {Callback<number> =} callback
     **/
    referendumCount: GenericStorageQuery<Rv, () => number>;

    /**
     * The lowest referendum index representing an unbaked referendum. Equal to
     * `ReferendumCount` if there isn't a unbaked referendum.
     *
     * @param {Callback<number> =} callback
     **/
    lowestUnbaked: GenericStorageQuery<Rv, () => number>;

    /**
     * Information concerning any given referendum.
     *
     * TWOX-NOTE: SAFE as indexes are not under an attackerâ€™s control.
     *
     * @param {number} arg
     * @param {Callback<PalletDemocracyReferendumInfo | undefined> =} callback
     **/
    referendumInfoOf: GenericStorageQuery<Rv, (arg: number) => PalletDemocracyReferendumInfo | undefined, number>;

    /**
     * All votes for a particular voter. We store the balance for the number of votes that we
     * have recorded. The second item is the total amount of delegations, that will be added.
     *
     * TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletDemocracyVoteVoting> =} callback
     **/
    votingOf: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletDemocracyVoteVoting, AccountId32>;

    /**
     * True if the last referendum tabled was submitted externally. False if it was a public
     * proposal.
     *
     * @param {Callback<boolean> =} callback
     **/
    lastTabledWasExternal: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The referendum to be tabled whenever it would be valid to table an external proposal.
     * This happens when a referendum needs to be tabled and one of two conditions are met:
     * - `LastTabledWasExternal` is `false`; or
     * - `PublicProps` is empty.
     *
     * @param {Callback<[FrameSupportPreimagesBounded, PalletDemocracyVoteThreshold] | undefined> =} callback
     **/
    nextExternal: GenericStorageQuery<
      Rv,
      () => [FrameSupportPreimagesBounded, PalletDemocracyVoteThreshold] | undefined
    >;

    /**
     * A record of who vetoed what. Maps proposal hash to a possible existent block number
     * (until when it may not be resubmitted) and who vetoed it.
     *
     * @param {H256} arg
     * @param {Callback<[number, Array<AccountId32>] | undefined> =} callback
     **/
    blacklist: GenericStorageQuery<Rv, (arg: H256) => [number, Array<AccountId32>] | undefined, H256>;

    /**
     * Record of all proposals that have been subject to emergency cancellation.
     *
     * @param {H256} arg
     * @param {Callback<boolean> =} callback
     **/
    cancellations: GenericStorageQuery<Rv, (arg: H256) => boolean, H256>;

    /**
     * General information concerning any proposal or referendum.
     * The `Hash` refers to the preimage of the `Preimages` provider which can be a JSON
     * dump or IPFS hash of a JSON file.
     *
     * Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
     * large preimages.
     *
     * @param {PalletDemocracyMetadataOwner} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    metadataOf: GenericStorageQuery<
      Rv,
      (arg: PalletDemocracyMetadataOwner) => H256 | undefined,
      PalletDemocracyMetadataOwner
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Council`'s storage queries
   **/
  council: {
    /**
     * The hashes of the active proposals.
     *
     * @param {Callback<Array<H256>> =} callback
     **/
    proposals: GenericStorageQuery<Rv, () => Array<H256>>;

    /**
     * Actual proposal for a given hash, if it's current.
     *
     * @param {H256} arg
     * @param {Callback<KitchensinkRuntimeRuntimeCall | undefined> =} callback
     **/
    proposalOf: GenericStorageQuery<Rv, (arg: H256) => KitchensinkRuntimeRuntimeCall | undefined, H256>;

    /**
     * Votes on a given proposal, if it is ongoing.
     *
     * @param {H256} arg
     * @param {Callback<PalletCollectiveVotes | undefined> =} callback
     **/
    voting: GenericStorageQuery<Rv, (arg: H256) => PalletCollectiveVotes | undefined, H256>;

    /**
     * Proposals so far.
     *
     * @param {Callback<number> =} callback
     **/
    proposalCount: GenericStorageQuery<Rv, () => number>;

    /**
     * The current members of the collective. This is stored sorted (just by value).
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    members: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * The prime member that helps determine the default vote behavior in case of absentations.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    prime: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `TechnicalCommittee`'s storage queries
   **/
  technicalCommittee: {
    /**
     * The hashes of the active proposals.
     *
     * @param {Callback<Array<H256>> =} callback
     **/
    proposals: GenericStorageQuery<Rv, () => Array<H256>>;

    /**
     * Actual proposal for a given hash, if it's current.
     *
     * @param {H256} arg
     * @param {Callback<KitchensinkRuntimeRuntimeCall | undefined> =} callback
     **/
    proposalOf: GenericStorageQuery<Rv, (arg: H256) => KitchensinkRuntimeRuntimeCall | undefined, H256>;

    /**
     * Votes on a given proposal, if it is ongoing.
     *
     * @param {H256} arg
     * @param {Callback<PalletCollectiveVotes | undefined> =} callback
     **/
    voting: GenericStorageQuery<Rv, (arg: H256) => PalletCollectiveVotes | undefined, H256>;

    /**
     * Proposals so far.
     *
     * @param {Callback<number> =} callback
     **/
    proposalCount: GenericStorageQuery<Rv, () => number>;

    /**
     * The current members of the collective. This is stored sorted (just by value).
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    members: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * The prime member that helps determine the default vote behavior in case of absentations.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    prime: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Elections`'s storage queries
   **/
  elections: {
    /**
     * The current elected members.
     *
     * Invariant: Always sorted based on account id.
     *
     * @param {Callback<Array<PalletElectionsPhragmenSeatHolder>> =} callback
     **/
    members: GenericStorageQuery<Rv, () => Array<PalletElectionsPhragmenSeatHolder>>;

    /**
     * The current reserved runners-up.
     *
     * Invariant: Always sorted based on rank (worse to best). Upon removal of a member, the
     * last (i.e. _best_) runner-up will be replaced.
     *
     * @param {Callback<Array<PalletElectionsPhragmenSeatHolder>> =} callback
     **/
    runnersUp: GenericStorageQuery<Rv, () => Array<PalletElectionsPhragmenSeatHolder>>;

    /**
     * The present candidate list. A current member or runner-up can never enter this vector
     * and is always implicitly assumed to be a candidate.
     *
     * Second element is the deposit.
     *
     * Invariant: Always sorted based on account id.
     *
     * @param {Callback<Array<[AccountId32, bigint]>> =} callback
     **/
    candidates: GenericStorageQuery<Rv, () => Array<[AccountId32, bigint]>>;

    /**
     * The total number of vote rounds that have happened, excluding the upcoming one.
     *
     * @param {Callback<number> =} callback
     **/
    electionRounds: GenericStorageQuery<Rv, () => number>;

    /**
     * Votes and locked stake of a particular voter.
     *
     * TWOX-NOTE: SAFE as `AccountId` is a crypto hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletElectionsPhragmenVoter> =} callback
     **/
    voting: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletElectionsPhragmenVoter, AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `TechnicalMembership`'s storage queries
   **/
  technicalMembership: {
    /**
     * The current membership, stored as an ordered Vec.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    members: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * The current prime member, if one exists.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    prime: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Grandpa`'s storage queries
   **/
  grandpa: {
    /**
     * State of the current authority set.
     *
     * @param {Callback<PalletGrandpaStoredState> =} callback
     **/
    state: GenericStorageQuery<Rv, () => PalletGrandpaStoredState>;

    /**
     * Pending change: (signaled at, scheduled change).
     *
     * @param {Callback<PalletGrandpaStoredPendingChange | undefined> =} callback
     **/
    pendingChange: GenericStorageQuery<Rv, () => PalletGrandpaStoredPendingChange | undefined>;

    /**
     * next block number where we can force a change.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    nextForced: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * `true` if we are currently stalled.
     *
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    stalled: GenericStorageQuery<Rv, () => [number, number] | undefined>;

    /**
     * The number of changes (both in terms of keys and underlying economic responsibilities)
     * in the "set" of Grandpa validators from genesis.
     *
     * @param {Callback<bigint> =} callback
     **/
    currentSetId: GenericStorageQuery<Rv, () => bigint>;

    /**
     * A mapping from grandpa set ID to the index of the *most recent* session for which its
     * members were responsible.
     *
     * This is only used for validating equivocation proofs. An equivocation proof must
     * contains a key-ownership proof for a given session, therefore we need a way to tie
     * together sessions and GRANDPA set ids, i.e. we need to validate that a validator
     * was the owner of a given key on a given session, and what the active set ID was
     * during that session.
     *
     * TWOX-NOTE: `SetId` is not under user control.
     *
     * @param {bigint} arg
     * @param {Callback<number | undefined> =} callback
     **/
    setIdSession: GenericStorageQuery<Rv, (arg: bigint) => number | undefined, bigint>;

    /**
     * The current list of authorities.
     *
     * @param {Callback<Array<[SpConsensusGrandpaAppPublic, bigint]>> =} callback
     **/
    authorities: GenericStorageQuery<Rv, () => Array<[SpConsensusGrandpaAppPublic, bigint]>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Treasury`'s storage queries
   **/
  treasury: {
    /**
     * Number of proposals that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    proposalCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Proposals that have been made.
     *
     * @param {number} arg
     * @param {Callback<PalletTreasuryProposal | undefined> =} callback
     **/
    proposals: GenericStorageQuery<Rv, (arg: number) => PalletTreasuryProposal | undefined, number>;

    /**
     * The amount which has been reported as inactive to Currency.
     *
     * @param {Callback<bigint> =} callback
     **/
    deactivated: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Proposal indices that have been approved but not yet awarded.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    approvals: GenericStorageQuery<Rv, () => Array<number>>;

    /**
     * The count of spends that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    spendCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Spends that have been approved and being processed.
     *
     * @param {number} arg
     * @param {Callback<PalletTreasurySpendStatus | undefined> =} callback
     **/
    spends: GenericStorageQuery<Rv, (arg: number) => PalletTreasurySpendStatus | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `AssetRate`'s storage queries
   **/
  assetRate: {
    /**
     * Maps an asset to its fixed point representation in the native balance.
     *
     * E.g. `native_amount = asset_amount * ConversionRateToNative::<T>::get(asset_kind)`
     *
     * @param {number} arg
     * @param {Callback<FixedU128 | undefined> =} callback
     **/
    conversionRateToNative: GenericStorageQuery<Rv, (arg: number) => FixedU128 | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Contracts`'s storage queries
   **/
  contracts: {
    /**
     * A mapping from a contract's code hash to its code.
     *
     * @param {H256} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    pristineCode: GenericStorageQuery<Rv, (arg: H256) => Bytes | undefined, H256>;

    /**
     * A mapping from a contract's code hash to its code info.
     *
     * @param {H256} arg
     * @param {Callback<PalletContractsWasmCodeInfo | undefined> =} callback
     **/
    codeInfoOf: GenericStorageQuery<Rv, (arg: H256) => PalletContractsWasmCodeInfo | undefined, H256>;

    /**
     * This is a **monotonic** counter incremented on contract instantiation.
     *
     * This is used in order to generate unique trie ids for contracts.
     * The trie id of a new contract is calculated from hash(account_id, nonce).
     * The nonce is required because otherwise the following sequence would lead to
     * a possible collision of storage:
     *
     * 1. Create a new contract.
     * 2. Terminate the contract.
     * 3. Immediately recreate the contract with the same account_id.
     *
     * This is bad because the contents of a trie are deleted lazily and there might be
     * storage of the old instantiation still in it when the new contract is created. Please
     * note that we can't replace the counter by the block number because the sequence above
     * can happen in the same block. We also can't keep the account counter in memory only
     * because storage is the only way to communicate across different extrinsics in the
     * same block.
     *
     * # Note
     *
     * Do not use it to determine the number of contracts. It won't be decremented if
     * a contract is destroyed.
     *
     * @param {Callback<bigint> =} callback
     **/
    nonce: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The code associated with a given account.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletContractsStorageContractInfo | undefined> =} callback
     **/
    contractInfoOf: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletContractsStorageContractInfo | undefined,
      AccountId32
    >;

    /**
     * Evicted contracts that await child trie deletion.
     *
     * Child trie deletion is a heavy operation depending on the amount of storage items
     * stored in said trie. Therefore this operation is performed lazily in `on_idle`.
     *
     * @param {number} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    deletionQueue: GenericStorageQuery<Rv, (arg: number) => Bytes | undefined, number>;

    /**
     * A pair of monotonic counters used to track the latest contract marked for deletion
     * and the latest deleted contract in queue.
     *
     * @param {Callback<PalletContractsStorageDeletionQueueManager> =} callback
     **/
    deletionQueueCounter: GenericStorageQuery<Rv, () => PalletContractsStorageDeletionQueueManager>;

    /**
     * A migration can span across multiple blocks. This storage defines a cursor to track the
     * progress of the migration, enabling us to resume from the last completed position.
     *
     * @param {Callback<Bytes | undefined> =} callback
     **/
    migrationInProgress: GenericStorageQuery<Rv, () => Bytes | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Sudo`'s storage queries
   **/
  sudo: {
    /**
     * The `AccountId` of the sudo key.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    key: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ImOnline`'s storage queries
   **/
  imOnline: {
    /**
     * The block number after which it's ok to send heartbeats in the current
     * session.
     *
     * At the beginning of each session we set this to a value that should fall
     * roughly in the middle of the session duration. The idea is to first wait for
     * the validators to produce a block in the current session, so that the
     * heartbeat later on will not be necessary.
     *
     * This value will only be used as a fallback if we fail to get a proper session
     * progress estimate from `NextSessionRotation`, as those estimates should be
     * more accurate then the value we calculate for `HeartbeatAfter`.
     *
     * @param {Callback<number> =} callback
     **/
    heartbeatAfter: GenericStorageQuery<Rv, () => number>;

    /**
     * The current set of keys that may issue a heartbeat.
     *
     * @param {Callback<Array<PalletImOnlineSr25519AppSr25519Public>> =} callback
     **/
    keys: GenericStorageQuery<Rv, () => Array<PalletImOnlineSr25519AppSr25519Public>>;

    /**
     * For each session index, we keep a mapping of `SessionIndex` and `AuthIndex`.
     *
     * @param {[number, number]} arg
     * @param {Callback<boolean | undefined> =} callback
     **/
    receivedHeartbeats: GenericStorageQuery<Rv, (arg: [number, number]) => boolean | undefined, [number, number]>;

    /**
     * For each session index, we keep a mapping of `ValidatorId<T>` to the
     * number of blocks authored by the given authority.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<number> =} callback
     **/
    authoredBlocks: GenericStorageQuery<Rv, (arg: [number, AccountId32Like]) => number, [number, AccountId32]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `AuthorityDiscovery`'s storage queries
   **/
  authorityDiscovery: {
    /**
     * Keys of the current authority set.
     *
     * @param {Callback<Array<SpAuthorityDiscoveryAppPublic>> =} callback
     **/
    keys: GenericStorageQuery<Rv, () => Array<SpAuthorityDiscoveryAppPublic>>;

    /**
     * Keys of the next authority set.
     *
     * @param {Callback<Array<SpAuthorityDiscoveryAppPublic>> =} callback
     **/
    nextKeys: GenericStorageQuery<Rv, () => Array<SpAuthorityDiscoveryAppPublic>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Offences`'s storage queries
   **/
  offences: {
    /**
     * The primary structure that holds all offence records keyed by report identifiers.
     *
     * @param {H256} arg
     * @param {Callback<SpStakingOffenceOffenceDetails | undefined> =} callback
     **/
    reports: GenericStorageQuery<Rv, (arg: H256) => SpStakingOffenceOffenceDetails | undefined, H256>;

    /**
     * A vector of reports of the same kind that happened at the same time slot.
     *
     * @param {[FixedBytes<16>, BytesLike]} arg
     * @param {Callback<Array<H256>> =} callback
     **/
    concurrentReportsIndex: GenericStorageQuery<
      Rv,
      (arg: [FixedBytes<16>, BytesLike]) => Array<H256>,
      [FixedBytes<16>, Bytes]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Historical`'s storage queries
   **/
  historical: {
    /**
     * Mapping from historical session indices to session-data root hash and validator count.
     *
     * @param {number} arg
     * @param {Callback<[H256, number] | undefined> =} callback
     **/
    historicalSessions: GenericStorageQuery<Rv, (arg: number) => [H256, number] | undefined, number>;

    /**
     * The range of historical sessions we store. [first, last)
     *
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    storedRange: GenericStorageQuery<Rv, () => [number, number] | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `RandomnessCollectiveFlip`'s storage queries
   **/
  randomnessCollectiveFlip: {
    /**
     * Series of block headers from the last 81 blocks that acts as random seed material. This
     * is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of
     * the oldest hash.
     *
     * @param {Callback<Array<H256>> =} callback
     **/
    randomMaterial: GenericStorageQuery<Rv, () => Array<H256>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Identity`'s storage queries
   **/
  identity: {
    /**
     * Information that is pertinent to identify the entity behind an account. First item is the
     * registration, second is the account's primary username.
     *
     * TWOX-NOTE: OK â€• `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[PalletIdentityRegistration, Bytes | undefined] | undefined> =} callback
     **/
    identityOf: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [PalletIdentityRegistration, Bytes | undefined] | undefined,
      AccountId32
    >;

    /**
     * The super-identity of an alternative "sub" identity together with its name, within that
     * context. If the account is not some other account's sub-identity, then just `None`.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[AccountId32, Data] | undefined> =} callback
     **/
    superOf: GenericStorageQuery<Rv, (arg: AccountId32Like) => [AccountId32, Data] | undefined, AccountId32>;

    /**
     * Alternative "sub" identities of this account.
     *
     * The first item is the deposit, the second is a vector of the accounts.
     *
     * TWOX-NOTE: OK â€• `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[bigint, Array<AccountId32>]> =} callback
     **/
    subsOf: GenericStorageQuery<Rv, (arg: AccountId32Like) => [bigint, Array<AccountId32>], AccountId32>;

    /**
     * The set of registrars. Not expected to get very big as can only be added through a
     * special origin (likely a council motion).
     *
     * The index into this can be cast to `RegistrarIndex` to get a valid value.
     *
     * @param {Callback<Array<PalletIdentityRegistrarInfo | undefined>> =} callback
     **/
    registrars: GenericStorageQuery<Rv, () => Array<PalletIdentityRegistrarInfo | undefined>>;

    /**
     * A map of the accounts who are authorized to grant usernames.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletIdentityAuthorityProperties | undefined> =} callback
     **/
    usernameAuthorities: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletIdentityAuthorityProperties | undefined,
      AccountId32
    >;

    /**
     * Reverse lookup from `username` to the `AccountId` that has registered it. The value should
     * be a key in the `IdentityOf` map, but it may not if the user has cleared their identity.
     *
     * Multiple usernames may map to the same `AccountId`, but `IdentityOf` will only map to one
     * primary username.
     *
     * @param {BytesLike} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    accountOfUsername: GenericStorageQuery<Rv, (arg: BytesLike) => AccountId32 | undefined, Bytes>;

    /**
     * Usernames that an authority has granted, but that the account controller has not confirmed
     * that they want it. Used primarily in cases where the `AccountId` cannot provide a signature
     * because they are a pure proxy, multisig, etc. In order to confirm it, they should call
     * [`Call::accept_username`].
     *
     * First tuple item is the account and second is the acceptance deadline.
     *
     * @param {BytesLike} arg
     * @param {Callback<[AccountId32, number] | undefined> =} callback
     **/
    pendingUsernames: GenericStorageQuery<Rv, (arg: BytesLike) => [AccountId32, number] | undefined, Bytes>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Society`'s storage queries
   **/
  society: {
    /**
     * The max number of members for the society at one time.
     *
     * @param {Callback<PalletSocietyGroupParams | undefined> =} callback
     **/
    parameters: GenericStorageQuery<Rv, () => PalletSocietyGroupParams | undefined>;

    /**
     * Amount of our account balance that is specifically for the next round's bid(s).
     *
     * @param {Callback<bigint> =} callback
     **/
    pot: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The first member.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    founder: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * The most primary from the most recently approved rank 0 members in the society.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    head: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * A hash of the rules of this society concerning membership. Can only be set once and
     * only by the founder.
     *
     * @param {Callback<H256 | undefined> =} callback
     **/
    rules: GenericStorageQuery<Rv, () => H256 | undefined>;

    /**
     * The current members and their rank. Doesn't include `SuspendedMembers`.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletSocietyMemberRecord | undefined> =} callback
     **/
    members: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletSocietyMemberRecord | undefined, AccountId32>;

    /**
     * Information regarding rank-0 payouts, past and future.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletSocietyPayoutRecord> =} callback
     **/
    payouts: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletSocietyPayoutRecord, AccountId32>;

    /**
     * The number of items in `Members` currently. (Doesn't include `SuspendedMembers`.)
     *
     * @param {Callback<number> =} callback
     **/
    memberCount: GenericStorageQuery<Rv, () => number>;

    /**
     * The current items in `Members` keyed by their unique index. Keys are densely populated
     * `0..MemberCount` (does not include `MemberCount`).
     *
     * @param {number} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    memberByIndex: GenericStorageQuery<Rv, (arg: number) => AccountId32 | undefined, number>;

    /**
     * The set of suspended members, with their old membership record.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletSocietyMemberRecord | undefined> =} callback
     **/
    suspendedMembers: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletSocietyMemberRecord | undefined,
      AccountId32
    >;

    /**
     * The number of rounds which have passed.
     *
     * @param {Callback<number> =} callback
     **/
    roundCount: GenericStorageQuery<Rv, () => number>;

    /**
     * The current bids, stored ordered by the value of the bid.
     *
     * @param {Callback<Array<PalletSocietyBid>> =} callback
     **/
    bids: GenericStorageQuery<Rv, () => Array<PalletSocietyBid>>;

    /**
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletSocietyCandidacy | undefined> =} callback
     **/
    candidates: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletSocietyCandidacy | undefined, AccountId32>;

    /**
     * The current skeptic.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    skeptic: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Double map from Candidate -> Voter -> (Maybe) Vote.
     *
     * @param {[AccountId32Like, AccountId32Like]} arg
     * @param {Callback<PalletSocietyVote | undefined> =} callback
     **/
    votes: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, AccountId32Like]) => PalletSocietyVote | undefined,
      [AccountId32, AccountId32]
    >;

    /**
     * Clear-cursor for Vote, map from Candidate -> (Maybe) Cursor.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    voteClearCursor: GenericStorageQuery<Rv, (arg: AccountId32Like) => Bytes | undefined, AccountId32>;

    /**
     * At the end of the claim period, this contains the most recently approved members (along with
     * their bid and round ID) who is from the most recent round with the lowest bid. They will
     * become the new `Head`.
     *
     * @param {Callback<PalletSocietyIntakeRecord | undefined> =} callback
     **/
    nextHead: GenericStorageQuery<Rv, () => PalletSocietyIntakeRecord | undefined>;

    /**
     * The number of challenge rounds there have been. Used to identify stale DefenderVotes.
     *
     * @param {Callback<number> =} callback
     **/
    challengeRoundCount: GenericStorageQuery<Rv, () => number>;

    /**
     * The defending member currently being challenged, along with a running tally of votes.
     *
     * @param {Callback<[AccountId32, AccountId32, PalletSocietyTally] | undefined> =} callback
     **/
    defending: GenericStorageQuery<Rv, () => [AccountId32, AccountId32, PalletSocietyTally] | undefined>;

    /**
     * Votes for the defender, keyed by challenge round.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletSocietyVote | undefined> =} callback
     **/
    defenderVotes: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => PalletSocietyVote | undefined,
      [number, AccountId32]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Recovery`'s storage queries
   **/
  recovery: {
    /**
     * The set of recoverable accounts and their recovery configuration.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletRecoveryRecoveryConfig | undefined> =} callback
     **/
    recoverable: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletRecoveryRecoveryConfig | undefined,
      AccountId32
    >;

    /**
     * Active recovery attempts.
     *
     * First account is the account to be recovered, and the second account
     * is the user trying to recover the account.
     *
     * @param {[AccountId32Like, AccountId32Like]} arg
     * @param {Callback<PalletRecoveryActiveRecovery | undefined> =} callback
     **/
    activeRecoveries: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, AccountId32Like]) => PalletRecoveryActiveRecovery | undefined,
      [AccountId32, AccountId32]
    >;

    /**
     * The list of allowed proxy accounts.
     *
     * Map from the user who can access it to the recovered account.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    proxy: GenericStorageQuery<Rv, (arg: AccountId32Like) => AccountId32 | undefined, AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Vesting`'s storage queries
   **/
  vesting: {
    /**
     * Information regarding the vesting of a given account.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletVestingVestingInfo> | undefined> =} callback
     **/
    vesting: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<PalletVestingVestingInfo> | undefined,
      AccountId32
    >;

    /**
     * Storage version of the pallet.
     *
     * New networks start with latest version, as determined by the genesis build.
     *
     * @param {Callback<PalletVestingReleases> =} callback
     **/
    storageVersion: GenericStorageQuery<Rv, () => PalletVestingReleases>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Scheduler`'s storage queries
   **/
  scheduler: {
    /**
     *
     * @param {Callback<number | undefined> =} callback
     **/
    incompleteSince: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Items to be executed, indexed by the block number that they should be executed on.
     *
     * @param {number} arg
     * @param {Callback<Array<PalletSchedulerScheduled | undefined>> =} callback
     **/
    agenda: GenericStorageQuery<Rv, (arg: number) => Array<PalletSchedulerScheduled | undefined>, number>;

    /**
     * Retry configurations for items to be executed, indexed by task address.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletSchedulerRetryConfig | undefined> =} callback
     **/
    retries: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletSchedulerRetryConfig | undefined,
      [number, number]
    >;

    /**
     * Lookup from a name to the block number and index of the task.
     *
     * For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
     * identities.
     *
     * @param {FixedBytes<32>} arg
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    lookup: GenericStorageQuery<Rv, (arg: FixedBytes<32>) => [number, number] | undefined, FixedBytes<32>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Glutton`'s storage queries
   **/
  glutton: {
    /**
     * The proportion of the remaining `ref_time` to consume during `on_idle`.
     *
     * `1.0` is mapped to `100%`. Must be at most [`crate::RESOURCE_HARD_LIMIT`]. Setting this to
     * over `1.0` could stall the chain.
     *
     * @param {Callback<FixedU64> =} callback
     **/
    compute: GenericStorageQuery<Rv, () => FixedU64>;

    /**
     * The proportion of the remaining `proof_size` to consume during `on_idle`.
     *
     * `1.0` is mapped to `100%`. Must be at most [`crate::RESOURCE_HARD_LIMIT`]. Setting this to
     * over `1.0` could stall the chain.
     *
     * @param {Callback<FixedU64> =} callback
     **/
    storage: GenericStorageQuery<Rv, () => FixedU64>;

    /**
     * Storage map used for wasting proof size.
     *
     * It contains no meaningful data - hence the name "Trash". The maximal number of entries is
     * set to 65k, which is just below the next jump at 16^4. This is important to reduce the proof
     * size benchmarking overestimate. The assumption here is that we won't have more than 65k *
     * 1KiB = 65MiB of proof size wasting in practice. However, this limit is not enforced, so the
     * pallet would also work out of the box with more entries, but its benchmarked proof weight
     * would possibly be underestimated in that case.
     *
     * @param {number} arg
     * @param {Callback<FixedBytes<1024> | undefined> =} callback
     **/
    trashData: GenericStorageQuery<Rv, (arg: number) => FixedBytes<1024> | undefined, number>;

    /**
     * The current number of entries in `TrashData`.
     *
     * @param {Callback<number> =} callback
     **/
    trashDataCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Preimage`'s storage queries
   **/
  preimage: {
    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageOldRequestStatus | undefined> =} callback
     **/
    statusFor: GenericStorageQuery<Rv, (arg: H256) => PalletPreimageOldRequestStatus | undefined, H256>;

    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageRequestStatus | undefined> =} callback
     **/
    requestStatusFor: GenericStorageQuery<Rv, (arg: H256) => PalletPreimageRequestStatus | undefined, H256>;

    /**
     *
     * @param {[H256, number]} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    preimageFor: GenericStorageQuery<Rv, (arg: [H256, number]) => Bytes | undefined, [H256, number]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Proxy`'s storage queries
   **/
  proxy: {
    /**
     * The set of account proxies. Maps the account which has delegated to the accounts
     * which are being delegated to, together with the amount held on deposit.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyProxyDefinition>, bigint]> =} callback
     **/
    proxies: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [Array<PalletProxyProxyDefinition>, bigint],
      AccountId32
    >;

    /**
     * The announcements made by the proxy (key).
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyAnnouncement>, bigint]> =} callback
     **/
    announcements: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [Array<PalletProxyAnnouncement>, bigint],
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Multisig`'s storage queries
   **/
  multisig: {
    /**
     * The set of open multisig operations.
     *
     * @param {[AccountId32Like, FixedBytes<32>]} arg
     * @param {Callback<PalletMultisigMultisig | undefined> =} callback
     **/
    multisigs: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, FixedBytes<32>]) => PalletMultisigMultisig | undefined,
      [AccountId32, FixedBytes<32>]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Bounties`'s storage queries
   **/
  bounties: {
    /**
     * Number of bounty proposals that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    bountyCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Bounties that have been made.
     *
     * @param {number} arg
     * @param {Callback<PalletBountiesBounty | undefined> =} callback
     **/
    bounties: GenericStorageQuery<Rv, (arg: number) => PalletBountiesBounty | undefined, number>;

    /**
     * The description of each bounty.
     *
     * @param {number} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    bountyDescriptions: GenericStorageQuery<Rv, (arg: number) => Bytes | undefined, number>;

    /**
     * Bounty indices that have been approved but not yet funded.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    bountyApprovals: GenericStorageQuery<Rv, () => Array<number>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Tips`'s storage queries
   **/
  tips: {
    /**
     * TipsMap that are not yet completed. Keyed by the hash of `(reason, who)` from the value.
     * This has the insecure enumerable hash function since the key itself is already
     * guaranteed to be a secure hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletTipsOpenTip | undefined> =} callback
     **/
    tips: GenericStorageQuery<Rv, (arg: H256) => PalletTipsOpenTip | undefined, H256>;

    /**
     * Simple preimage lookup from the reason's hash to the original data. Again, has an
     * insecure enumerable hash since the key is guaranteed to be the result of a secure hash.
     *
     * @param {H256} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    reasons: GenericStorageQuery<Rv, (arg: H256) => Bytes | undefined, H256>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Assets`'s storage queries
   **/
  assets: {
    /**
     * Details of an asset.
     *
     * @param {number} arg
     * @param {Callback<PalletAssetsAssetDetails | undefined> =} callback
     **/
    asset: GenericStorageQuery<Rv, (arg: number) => PalletAssetsAssetDetails | undefined, number>;

    /**
     * The holdings of a specific account for a specific asset.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletAssetsAssetAccount | undefined> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => PalletAssetsAssetAccount | undefined,
      [number, AccountId32]
    >;

    /**
     * Approved balance transfers. First balance is the amount approved for transfer. Second
     * is the amount of `T::Currency` reserved for storing this.
     * First key is the asset ID, second key is the owner and third key is the delegate.
     *
     * @param {[number, AccountId32Like, AccountId32Like]} arg
     * @param {Callback<PalletAssetsApproval | undefined> =} callback
     **/
    approvals: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like, AccountId32Like]) => PalletAssetsApproval | undefined,
      [number, AccountId32, AccountId32]
    >;

    /**
     * Metadata of an asset.
     *
     * @param {number} arg
     * @param {Callback<PalletAssetsAssetMetadata> =} callback
     **/
    metadata: GenericStorageQuery<Rv, (arg: number) => PalletAssetsAssetMetadata, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `PoolAssets`'s storage queries
   **/
  poolAssets: {
    /**
     * Details of an asset.
     *
     * @param {number} arg
     * @param {Callback<PalletAssetsAssetDetails | undefined> =} callback
     **/
    asset: GenericStorageQuery<Rv, (arg: number) => PalletAssetsAssetDetails | undefined, number>;

    /**
     * The holdings of a specific account for a specific asset.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletAssetsAssetAccount | undefined> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => PalletAssetsAssetAccount | undefined,
      [number, AccountId32]
    >;

    /**
     * Approved balance transfers. First balance is the amount approved for transfer. Second
     * is the amount of `T::Currency` reserved for storing this.
     * First key is the asset ID, second key is the owner and third key is the delegate.
     *
     * @param {[number, AccountId32Like, AccountId32Like]} arg
     * @param {Callback<PalletAssetsApproval | undefined> =} callback
     **/
    approvals: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like, AccountId32Like]) => PalletAssetsApproval | undefined,
      [number, AccountId32, AccountId32]
    >;

    /**
     * Metadata of an asset.
     *
     * @param {number} arg
     * @param {Callback<PalletAssetsAssetMetadata> =} callback
     **/
    metadata: GenericStorageQuery<Rv, (arg: number) => PalletAssetsAssetMetadata, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Beefy`'s storage queries
   **/
  beefy: {
    /**
     * The current authorities set
     *
     * @param {Callback<Array<SpConsensusBeefyEcdsaCryptoPublic>> =} callback
     **/
    authorities: GenericStorageQuery<Rv, () => Array<SpConsensusBeefyEcdsaCryptoPublic>>;

    /**
     * The current validator set id
     *
     * @param {Callback<bigint> =} callback
     **/
    validatorSetId: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Authorities set scheduled to be used with the next session
     *
     * @param {Callback<Array<SpConsensusBeefyEcdsaCryptoPublic>> =} callback
     **/
    nextAuthorities: GenericStorageQuery<Rv, () => Array<SpConsensusBeefyEcdsaCryptoPublic>>;

    /**
     * A mapping from BEEFY set ID to the index of the *most recent* session for which its
     * members were responsible.
     *
     * This is only used for validating equivocation proofs. An equivocation proof must
     * contains a key-ownership proof for a given session, therefore we need a way to tie
     * together sessions and BEEFY set ids, i.e. we need to validate that a validator
     * was the owner of a given key on a given session, and what the active set ID was
     * during that session.
     *
     * TWOX-NOTE: `ValidatorSetId` is not under user control.
     *
     * @param {bigint} arg
     * @param {Callback<number | undefined> =} callback
     **/
    setIdSession: GenericStorageQuery<Rv, (arg: bigint) => number | undefined, bigint>;

    /**
     * Block number where BEEFY consensus is enabled/started.
     * By changing this (through privileged `set_new_genesis()`), BEEFY consensus is effectively
     * restarted from the newly set block number.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    genesisBlock: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Mmr`'s storage queries
   **/
  mmr: {
    /**
     * Latest MMR Root hash.
     *
     * @param {Callback<H256> =} callback
     **/
    rootHash: GenericStorageQuery<Rv, () => H256>;

    /**
     * Current size of the MMR (number of leaves).
     *
     * @param {Callback<bigint> =} callback
     **/
    numberOfLeaves: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Hashes of the nodes in the MMR.
     *
     * Note this collection only contains MMR peaks, the inner nodes (and leaves)
     * are pruned and only stored in the Offchain DB.
     *
     * @param {bigint} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    nodes: GenericStorageQuery<Rv, (arg: bigint) => H256 | undefined, bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `MmrLeaf`'s storage queries
   **/
  mmrLeaf: {
    /**
     * Details of current BEEFY authority set.
     *
     * @param {Callback<SpConsensusBeefyMmrBeefyAuthoritySet> =} callback
     **/
    beefyAuthorities: GenericStorageQuery<Rv, () => SpConsensusBeefyMmrBeefyAuthoritySet>;

    /**
     * Details of next BEEFY authority set.
     *
     * This storage entry is used as cache for calls to `update_beefy_next_authority_set`.
     *
     * @param {Callback<SpConsensusBeefyMmrBeefyAuthoritySet> =} callback
     **/
    beefyNextAuthorities: GenericStorageQuery<Rv, () => SpConsensusBeefyMmrBeefyAuthoritySet>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Lottery`'s storage queries
   **/
  lottery: {
    /**
     *
     * @param {Callback<number> =} callback
     **/
    lotteryIndex: GenericStorageQuery<Rv, () => number>;

    /**
     * The configuration for the current lottery.
     *
     * @param {Callback<PalletLotteryLotteryConfig | undefined> =} callback
     **/
    lottery: GenericStorageQuery<Rv, () => PalletLotteryLotteryConfig | undefined>;

    /**
     * Users who have purchased a ticket. (Lottery Index, Tickets Purchased)
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[number, Array<[number, number]>]> =} callback
     **/
    participants: GenericStorageQuery<Rv, (arg: AccountId32Like) => [number, Array<[number, number]>], AccountId32>;

    /**
     * Total number of tickets sold.
     *
     * @param {Callback<number> =} callback
     **/
    ticketsCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Each ticket's owner.
     *
     * May have residual storage from previous lotteries. Use `TicketsCount` to see which ones
     * are actually valid ticket mappings.
     *
     * @param {number} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    tickets: GenericStorageQuery<Rv, (arg: number) => AccountId32 | undefined, number>;

    /**
     * The calls stored in this pallet to be used in an active lottery if configured
     * by `Config::ValidateCall`.
     *
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    callIndices: GenericStorageQuery<Rv, () => Array<[number, number]>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Nis`'s storage queries
   **/
  nis: {
    /**
     * The totals of items and balances within each queue. Saves a lot of storage reads in the
     * case of sparsely packed queues.
     *
     * The vector is indexed by duration in `Period`s, offset by one, so information on the queue
     * whose duration is one `Period` would be storage `0`.
     *
     * @param {Callback<Array<[number, bigint]>> =} callback
     **/
    queueTotals: GenericStorageQuery<Rv, () => Array<[number, bigint]>>;

    /**
     * The queues of bids. Indexed by duration (in `Period`s).
     *
     * @param {number} arg
     * @param {Callback<Array<PalletNisBid>> =} callback
     **/
    queues: GenericStorageQuery<Rv, (arg: number) => Array<PalletNisBid>, number>;

    /**
     * Summary information over the general state.
     *
     * @param {Callback<PalletNisSummaryRecord> =} callback
     **/
    summary: GenericStorageQuery<Rv, () => PalletNisSummaryRecord>;

    /**
     * The currently outstanding receipts, indexed according to the order of creation.
     *
     * @param {number} arg
     * @param {Callback<PalletNisReceiptRecord | undefined> =} callback
     **/
    receipts: GenericStorageQuery<Rv, (arg: number) => PalletNisReceiptRecord | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Uniques`'s storage queries
   **/
  uniques: {
    /**
     * Details of a collection.
     *
     * @param {number} arg
     * @param {Callback<PalletUniquesCollectionDetails | undefined> =} callback
     **/
    class: GenericStorageQuery<Rv, (arg: number) => PalletUniquesCollectionDetails | undefined, number>;

    /**
     * The collection, if any, of which an account is willing to take ownership.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<number | undefined> =} callback
     **/
    ownershipAcceptance: GenericStorageQuery<Rv, (arg: AccountId32Like) => number | undefined, AccountId32>;

    /**
     * The items held by any given account; set out this way so that items owned by a single
     * account can be enumerated.
     *
     * @param {[AccountId32Like, number, number]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number, number]) => [] | undefined,
      [AccountId32, number, number]
    >;

    /**
     * The collections owned by any given account; set out this way so that collections owned by
     * a single account can be enumerated.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    classAccount: GenericStorageQuery<Rv, (arg: [AccountId32Like, number]) => [] | undefined, [AccountId32, number]>;

    /**
     * The items in existence and their ownership details.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletUniquesItemDetails | undefined> =} callback
     **/
    asset: GenericStorageQuery<Rv, (arg: [number, number]) => PalletUniquesItemDetails | undefined, [number, number]>;

    /**
     * Metadata of a collection.
     *
     * @param {number} arg
     * @param {Callback<PalletUniquesCollectionMetadata | undefined> =} callback
     **/
    classMetadataOf: GenericStorageQuery<Rv, (arg: number) => PalletUniquesCollectionMetadata | undefined, number>;

    /**
     * Metadata of an item.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletUniquesItemMetadata | undefined> =} callback
     **/
    instanceMetadataOf: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletUniquesItemMetadata | undefined,
      [number, number]
    >;

    /**
     * Attributes of a collection.
     *
     * @param {[number, number | undefined, BytesLike]} arg
     * @param {Callback<[Bytes, bigint] | undefined> =} callback
     **/
    attribute: GenericStorageQuery<
      Rv,
      (arg: [number, number | undefined, BytesLike]) => [Bytes, bigint] | undefined,
      [number, number | undefined, Bytes]
    >;

    /**
     * Price of an asset instance.
     *
     * @param {[number, number]} arg
     * @param {Callback<[bigint, AccountId32 | undefined] | undefined> =} callback
     **/
    itemPriceOf: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => [bigint, AccountId32 | undefined] | undefined,
      [number, number]
    >;

    /**
     * Keeps track of the number of items a collection might have.
     *
     * @param {number} arg
     * @param {Callback<number | undefined> =} callback
     **/
    collectionMaxSupply: GenericStorageQuery<Rv, (arg: number) => number | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Nfts`'s storage queries
   **/
  nfts: {
    /**
     * Details of a collection.
     *
     * @param {number} arg
     * @param {Callback<PalletNftsCollectionDetails | undefined> =} callback
     **/
    collection: GenericStorageQuery<Rv, (arg: number) => PalletNftsCollectionDetails | undefined, number>;

    /**
     * The collection, if any, of which an account is willing to take ownership.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<number | undefined> =} callback
     **/
    ownershipAcceptance: GenericStorageQuery<Rv, (arg: AccountId32Like) => number | undefined, AccountId32>;

    /**
     * The items held by any given account; set out this way so that items owned by a single
     * account can be enumerated.
     *
     * @param {[AccountId32Like, number, number]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number, number]) => [] | undefined,
      [AccountId32, number, number]
    >;

    /**
     * The collections owned by any given account; set out this way so that collections owned by
     * a single account can be enumerated.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    collectionAccount: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number]) => [] | undefined,
      [AccountId32, number]
    >;

    /**
     * The items in existence and their ownership details.
     * Stores collection roles as per account.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletNftsBitFlagsCollectionRole | undefined> =} callback
     **/
    collectionRoleOf: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => PalletNftsBitFlagsCollectionRole | undefined,
      [number, AccountId32]
    >;

    /**
     * The items in existence and their ownership details.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletNftsItemDetails | undefined> =} callback
     **/
    item: GenericStorageQuery<Rv, (arg: [number, number]) => PalletNftsItemDetails | undefined, [number, number]>;

    /**
     * Metadata of a collection.
     *
     * @param {number} arg
     * @param {Callback<PalletNftsCollectionMetadata | undefined> =} callback
     **/
    collectionMetadataOf: GenericStorageQuery<Rv, (arg: number) => PalletNftsCollectionMetadata | undefined, number>;

    /**
     * Metadata of an item.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletNftsItemMetadata | undefined> =} callback
     **/
    itemMetadataOf: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletNftsItemMetadata | undefined,
      [number, number]
    >;

    /**
     * Attributes of a collection.
     *
     * @param {[number, number | undefined, PalletNftsAttributeNamespace, BytesLike]} arg
     * @param {Callback<[Bytes, PalletNftsAttributeDeposit] | undefined> =} callback
     **/
    attribute: GenericStorageQuery<
      Rv,
      (
        arg: [number, number | undefined, PalletNftsAttributeNamespace, BytesLike],
      ) => [Bytes, PalletNftsAttributeDeposit] | undefined,
      [number, number | undefined, PalletNftsAttributeNamespace, Bytes]
    >;

    /**
     * A price of an item.
     *
     * @param {[number, number]} arg
     * @param {Callback<[bigint, AccountId32 | undefined] | undefined> =} callback
     **/
    itemPriceOf: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => [bigint, AccountId32 | undefined] | undefined,
      [number, number]
    >;

    /**
     * Item attribute approvals.
     *
     * @param {[number, number]} arg
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    itemAttributesApprovalsOf: GenericStorageQuery<Rv, (arg: [number, number]) => Array<AccountId32>, [number, number]>;

    /**
     * Stores the `CollectionId` that is going to be used for the next collection.
     * This gets incremented whenever a new collection is created.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    nextCollectionId: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Handles all the pending swaps.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletNftsPendingSwap | undefined> =} callback
     **/
    pendingSwapOf: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletNftsPendingSwap | undefined,
      [number, number]
    >;

    /**
     * Config of a collection.
     *
     * @param {number} arg
     * @param {Callback<PalletNftsCollectionConfig | undefined> =} callback
     **/
    collectionConfigOf: GenericStorageQuery<Rv, (arg: number) => PalletNftsCollectionConfig | undefined, number>;

    /**
     * Config of an item.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletNftsItemConfig | undefined> =} callback
     **/
    itemConfigOf: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletNftsItemConfig | undefined,
      [number, number]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `NftFractionalization`'s storage queries
   **/
  nftFractionalization: {
    /**
     * Keeps track of the corresponding NFT ID, asset ID and amount minted.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletNftFractionalizationDetails | undefined> =} callback
     **/
    nftToAsset: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletNftFractionalizationDetails | undefined,
      [number, number]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Salary`'s storage queries
   **/
  salary: {
    /**
     * The overall status of the system.
     *
     * @param {Callback<PalletSalaryStatusType | undefined> =} callback
     **/
    status: GenericStorageQuery<Rv, () => PalletSalaryStatusType | undefined>;

    /**
     * The status of a claimant.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletSalaryClaimantStatus | undefined> =} callback
     **/
    claimant: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletSalaryClaimantStatus | undefined, AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `CoreFellowship`'s storage queries
   **/
  coreFellowship: {
    /**
     * The overall status of the system.
     *
     * @param {Callback<PalletCoreFellowshipParamsType> =} callback
     **/
    params: GenericStorageQuery<Rv, () => PalletCoreFellowshipParamsType>;

    /**
     * The status of a claimant.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletCoreFellowshipMemberStatus | undefined> =} callback
     **/
    member: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletCoreFellowshipMemberStatus | undefined,
      AccountId32
    >;

    /**
     * Some evidence together with the desired outcome for which it was presented.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[PalletCoreFellowshipWish, Bytes] | undefined> =} callback
     **/
    memberEvidence: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [PalletCoreFellowshipWish, Bytes] | undefined,
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `TransactionStorage`'s storage queries
   **/
  transactionStorage: {
    /**
     * Collection of transaction metadata by block number.
     *
     * @param {number} arg
     * @param {Callback<Array<PalletTransactionStorageTransactionInfo> | undefined> =} callback
     **/
    transactions: GenericStorageQuery<
      Rv,
      (arg: number) => Array<PalletTransactionStorageTransactionInfo> | undefined,
      number
    >;

    /**
     * Count indexed chunks for each block.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    chunkCount: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * Storage fee per byte.
     *
     * @param {Callback<bigint | undefined> =} callback
     **/
    byteFee: GenericStorageQuery<Rv, () => bigint | undefined>;

    /**
     * Storage fee per transaction.
     *
     * @param {Callback<bigint | undefined> =} callback
     **/
    entryFee: GenericStorageQuery<Rv, () => bigint | undefined>;

    /**
     * Storage period for data in blocks. Should match `sp_storage_proof::DEFAULT_STORAGE_PERIOD`
     * for block authoring.
     *
     * @param {Callback<number> =} callback
     **/
    storagePeriod: GenericStorageQuery<Rv, () => number>;

    /**
     *
     * @param {Callback<Array<PalletTransactionStorageTransactionInfo>> =} callback
     **/
    blockTransactions: GenericStorageQuery<Rv, () => Array<PalletTransactionStorageTransactionInfo>>;

    /**
     * Was the proof checked in this block?
     *
     * @param {Callback<boolean> =} callback
     **/
    proofChecked: GenericStorageQuery<Rv, () => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `VoterList`'s storage queries
   **/
  voterList: {
    /**
     * A single node, within some bag.
     *
     * Nodes store links forward and back within their respective bags.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletBagsListListNode | undefined> =} callback
     **/
    listNodes: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletBagsListListNode | undefined, AccountId32>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForListNodes: GenericStorageQuery<Rv, () => number>;

    /**
     * A bag stored in storage.
     *
     * Stores a `Bag` struct, which stores head and tail pointers to itself.
     *
     * @param {bigint} arg
     * @param {Callback<PalletBagsListListBag | undefined> =} callback
     **/
    listBags: GenericStorageQuery<Rv, (arg: bigint) => PalletBagsListListBag | undefined, bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `StateTrieMigration`'s storage queries
   **/
  stateTrieMigration: {
    /**
     * Migration progress.
     *
     * This stores the snapshot of the last migrated keys. It can be set into motion and move
     * forward by any of the means provided by this pallet.
     *
     * @param {Callback<PalletStateTrieMigrationMigrationTask> =} callback
     **/
    migrationProcess: GenericStorageQuery<Rv, () => PalletStateTrieMigrationMigrationTask>;

    /**
     * The limits that are imposed on automatic migrations.
     *
     * If set to None, then no automatic migration happens.
     *
     * @param {Callback<PalletStateTrieMigrationMigrationLimits | undefined> =} callback
     **/
    autoLimits: GenericStorageQuery<Rv, () => PalletStateTrieMigrationMigrationLimits | undefined>;

    /**
     * The maximum limits that the signed migration could use.
     *
     * If not set, no signed submission is allowed.
     *
     * @param {Callback<PalletStateTrieMigrationMigrationLimits | undefined> =} callback
     **/
    signedMigrationMaxLimits: GenericStorageQuery<Rv, () => PalletStateTrieMigrationMigrationLimits | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ChildBounties`'s storage queries
   **/
  childBounties: {
    /**
     * Number of total child bounties.
     *
     * @param {Callback<number> =} callback
     **/
    childBountyCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Number of child bounties per parent bounty.
     * Map of parent bounty index to number of child bounties.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    parentChildBounties: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * Child bounties that have been added.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletChildBountiesChildBounty | undefined> =} callback
     **/
    childBounties: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletChildBountiesChildBounty | undefined,
      [number, number]
    >;

    /**
     * The description of each child-bounty.
     *
     * @param {number} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    childBountyDescriptions: GenericStorageQuery<Rv, (arg: number) => Bytes | undefined, number>;

    /**
     * The cumulative child-bounty curator fee for each parent bounty.
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    childrenCuratorFees: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Referenda`'s storage queries
   **/
  referenda: {
    /**
     * The next free referendum index, aka the number of referenda started so far.
     *
     * @param {Callback<number> =} callback
     **/
    referendumCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Information concerning any given referendum.
     *
     * @param {number} arg
     * @param {Callback<PalletReferendaReferendumInfo | undefined> =} callback
     **/
    referendumInfoFor: GenericStorageQuery<Rv, (arg: number) => PalletReferendaReferendumInfo | undefined, number>;

    /**
     * The sorted list of referenda ready to be decided but not yet being decided, ordered by
     * conviction-weighted approvals.
     *
     * This should be empty if `DecidingCount` is less than `TrackInfo::max_deciding`.
     *
     * @param {number} arg
     * @param {Callback<Array<[number, bigint]>> =} callback
     **/
    trackQueue: GenericStorageQuery<Rv, (arg: number) => Array<[number, bigint]>, number>;

    /**
     * The number of referenda being decided currently.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    decidingCount: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * The metadata is a general information concerning the referendum.
     * The `Hash` refers to the preimage of the `Preimages` provider which can be a JSON
     * dump or IPFS hash of a JSON file.
     *
     * Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
     * large preimages.
     *
     * @param {number} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    metadataOf: GenericStorageQuery<Rv, (arg: number) => H256 | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ConvictionVoting`'s storage queries
   **/
  convictionVoting: {
    /**
     * All voting for a particular voter in a particular voting class. We store the balance for the
     * number of votes that we have recorded.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<PalletConvictionVotingVoteVoting> =} callback
     **/
    votingFor: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number]) => PalletConvictionVotingVoteVoting,
      [AccountId32, number]
    >;

    /**
     * The voting classes which have a non-zero lock requirement and the lock amounts which they
     * require. The actual amount locked on behalf of this pallet should always be the maximum of
     * this list.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<[number, bigint]>> =} callback
     **/
    classLocksFor: GenericStorageQuery<Rv, (arg: AccountId32Like) => Array<[number, bigint]>, AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Whitelist`'s storage queries
   **/
  whitelist: {
    /**
     *
     * @param {H256} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    whitelistedCall: GenericStorageQuery<Rv, (arg: H256) => [] | undefined, H256>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `AllianceMotion`'s storage queries
   **/
  allianceMotion: {
    /**
     * The hashes of the active proposals.
     *
     * @param {Callback<Array<H256>> =} callback
     **/
    proposals: GenericStorageQuery<Rv, () => Array<H256>>;

    /**
     * Actual proposal for a given hash, if it's current.
     *
     * @param {H256} arg
     * @param {Callback<KitchensinkRuntimeRuntimeCall | undefined> =} callback
     **/
    proposalOf: GenericStorageQuery<Rv, (arg: H256) => KitchensinkRuntimeRuntimeCall | undefined, H256>;

    /**
     * Votes on a given proposal, if it is ongoing.
     *
     * @param {H256} arg
     * @param {Callback<PalletCollectiveVotes | undefined> =} callback
     **/
    voting: GenericStorageQuery<Rv, (arg: H256) => PalletCollectiveVotes | undefined, H256>;

    /**
     * Proposals so far.
     *
     * @param {Callback<number> =} callback
     **/
    proposalCount: GenericStorageQuery<Rv, () => number>;

    /**
     * The current members of the collective. This is stored sorted (just by value).
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    members: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * The prime member that helps determine the default vote behavior in case of absentations.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    prime: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Alliance`'s storage queries
   **/
  alliance: {
    /**
     * The IPFS CID of the alliance rule.
     * Fellows can propose a new rule with a super-majority.
     *
     * @param {Callback<PalletAllianceCid | undefined> =} callback
     **/
    rule: GenericStorageQuery<Rv, () => PalletAllianceCid | undefined>;

    /**
     * The current IPFS CIDs of any announcements.
     *
     * @param {Callback<Array<PalletAllianceCid>> =} callback
     **/
    announcements: GenericStorageQuery<Rv, () => Array<PalletAllianceCid>>;

    /**
     * Maps members to their candidacy deposit.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    depositOf: GenericStorageQuery<Rv, (arg: AccountId32Like) => bigint | undefined, AccountId32>;

    /**
     * Maps member type to members of each type.
     *
     * @param {PalletAllianceMemberRole} arg
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    members: GenericStorageQuery<Rv, (arg: PalletAllianceMemberRole) => Array<AccountId32>, PalletAllianceMemberRole>;

    /**
     * A set of members who gave a retirement notice. They can retire after the end of retirement
     * period stored as a future block number.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<number | undefined> =} callback
     **/
    retiringMembers: GenericStorageQuery<Rv, (arg: AccountId32Like) => number | undefined, AccountId32>;

    /**
     * The current list of accounts deemed unscrupulous. These accounts non grata cannot submit
     * candidacy.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    unscrupulousAccounts: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * The current list of websites deemed unscrupulous.
     *
     * @param {Callback<Array<Bytes>> =} callback
     **/
    unscrupulousWebsites: GenericStorageQuery<Rv, () => Array<Bytes>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `NominationPools`'s storage queries
   **/
  nominationPools: {
    /**
     * The sum of funds across all pools.
     *
     * This might be lower but never higher than the sum of `total_balance` of all [`PoolMembers`]
     * because calling `pool_withdraw_unbonded` might decrease the total stake of the pool's
     * `bonded_account` without adjusting the pallet-internal `UnbondingPool`'s.
     *
     * @param {Callback<bigint> =} callback
     **/
    totalValueLocked: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Minimum amount to bond to join a pool.
     *
     * @param {Callback<bigint> =} callback
     **/
    minJoinBond: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Minimum bond required to create a pool.
     *
     * This is the amount that the depositor must put as their initial stake in the pool, as an
     * indication of "skin in the game".
     *
     * This is the value that will always exist in the staking ledger of the pool bonded account
     * while all other accounts leave.
     *
     * @param {Callback<bigint> =} callback
     **/
    minCreateBond: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Maximum number of nomination pools that can exist. If `None`, then an unbounded number of
     * pools can exist.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    maxPools: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Maximum number of members that can exist in the system. If `None`, then the count
     * members are not bound on a system wide basis.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    maxPoolMembers: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Maximum number of members that may belong to pool. If `None`, then the count of
     * members is not bound on a per pool basis.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    maxPoolMembersPerPool: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * The maximum commission that can be charged by a pool. Used on commission payouts to bound
     * pool commissions that are > `GlobalMaxCommission`, necessary if a future
     * `GlobalMaxCommission` is lower than some current pool commissions.
     *
     * @param {Callback<Perbill | undefined> =} callback
     **/
    globalMaxCommission: GenericStorageQuery<Rv, () => Perbill | undefined>;

    /**
     * Active members.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletNominationPoolsPoolMember | undefined> =} callback
     **/
    poolMembers: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletNominationPoolsPoolMember | undefined,
      AccountId32
    >;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForPoolMembers: GenericStorageQuery<Rv, () => number>;

    /**
     * Storage for bonded pools.
     *
     * @param {number} arg
     * @param {Callback<PalletNominationPoolsBondedPoolInner | undefined> =} callback
     **/
    bondedPools: GenericStorageQuery<Rv, (arg: number) => PalletNominationPoolsBondedPoolInner | undefined, number>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForBondedPools: GenericStorageQuery<Rv, () => number>;

    /**
     * Reward pools. This is where there rewards for each pool accumulate. When a members payout is
     * claimed, the balance comes out of the reward pool. Keyed by the bonded pools account.
     *
     * @param {number} arg
     * @param {Callback<PalletNominationPoolsRewardPool | undefined> =} callback
     **/
    rewardPools: GenericStorageQuery<Rv, (arg: number) => PalletNominationPoolsRewardPool | undefined, number>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForRewardPools: GenericStorageQuery<Rv, () => number>;

    /**
     * Groups of unbonding pools. Each group of unbonding pools belongs to a
     * bonded pool, hence the name sub-pools. Keyed by the bonded pools account.
     *
     * @param {number} arg
     * @param {Callback<PalletNominationPoolsSubPools | undefined> =} callback
     **/
    subPoolsStorage: GenericStorageQuery<Rv, (arg: number) => PalletNominationPoolsSubPools | undefined, number>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForSubPoolsStorage: GenericStorageQuery<Rv, () => number>;

    /**
     * Metadata for the pool.
     *
     * @param {number} arg
     * @param {Callback<Bytes> =} callback
     **/
    metadata: GenericStorageQuery<Rv, (arg: number) => Bytes, number>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForMetadata: GenericStorageQuery<Rv, () => number>;

    /**
     * Ever increasing number of all pools created so far.
     *
     * @param {Callback<number> =} callback
     **/
    lastPoolId: GenericStorageQuery<Rv, () => number>;

    /**
     * A reverse lookup from the pool's account id to its id.
     *
     * This is only used for slashing and on automatic withdraw update. In all other instances, the
     * pool id is used, and the accounts are deterministically derived from it.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<number | undefined> =} callback
     **/
    reversePoolIdLookup: GenericStorageQuery<Rv, (arg: AccountId32Like) => number | undefined, AccountId32>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForReversePoolIdLookup: GenericStorageQuery<Rv, () => number>;

    /**
     * Map from a pool member account to their opted claim permission.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletNominationPoolsClaimPermission> =} callback
     **/
    claimPermissions: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletNominationPoolsClaimPermission,
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `RankedPolls`'s storage queries
   **/
  rankedPolls: {
    /**
     * The next free referendum index, aka the number of referenda started so far.
     *
     * @param {Callback<number> =} callback
     **/
    referendumCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Information concerning any given referendum.
     *
     * @param {number} arg
     * @param {Callback<PalletReferendaReferendumInfoTally | undefined> =} callback
     **/
    referendumInfoFor: GenericStorageQuery<Rv, (arg: number) => PalletReferendaReferendumInfoTally | undefined, number>;

    /**
     * The sorted list of referenda ready to be decided but not yet being decided, ordered by
     * conviction-weighted approvals.
     *
     * This should be empty if `DecidingCount` is less than `TrackInfo::max_deciding`.
     *
     * @param {number} arg
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    trackQueue: GenericStorageQuery<Rv, (arg: number) => Array<[number, number]>, number>;

    /**
     * The number of referenda being decided currently.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    decidingCount: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * The metadata is a general information concerning the referendum.
     * The `Hash` refers to the preimage of the `Preimages` provider which can be a JSON
     * dump or IPFS hash of a JSON file.
     *
     * Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
     * large preimages.
     *
     * @param {number} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    metadataOf: GenericStorageQuery<Rv, (arg: number) => H256 | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `RankedCollective`'s storage queries
   **/
  rankedCollective: {
    /**
     * The number of members in the collective who have at least the rank according to the index
     * of the vec.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    memberCount: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * The current members of the collective.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletRankedCollectiveMemberRecord | undefined> =} callback
     **/
    members: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletRankedCollectiveMemberRecord | undefined,
      AccountId32
    >;

    /**
     * The index of each ranks's member into the group of members who have at least that rank.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    idToIndex: GenericStorageQuery<Rv, (arg: [number, AccountId32Like]) => number | undefined, [number, AccountId32]>;

    /**
     * The members in the collective by index. All indices in the range `0..MemberCount` will
     * return `Some`, however a member's index is not guaranteed to remain unchanged over time.
     *
     * @param {[number, number]} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    indexToId: GenericStorageQuery<Rv, (arg: [number, number]) => AccountId32 | undefined, [number, number]>;

    /**
     * Votes on a given proposal, if it is ongoing.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletRankedCollectiveVoteRecord | undefined> =} callback
     **/
    voting: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => PalletRankedCollectiveVoteRecord | undefined,
      [number, AccountId32]
    >;

    /**
     *
     * @param {number} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    votingCleanup: GenericStorageQuery<Rv, (arg: number) => Bytes | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `AssetConversion`'s storage queries
   **/
  assetConversion: {
    /**
     * Map from `PoolAssetId` to `PoolInfo`. This establishes whether a pool has been officially
     * created rather than people sending tokens directly to a pool's public account.
     *
     * @param {[FrameSupportTokensFungibleUnionOfNativeOrWithId, FrameSupportTokensFungibleUnionOfNativeOrWithId]} arg
     * @param {Callback<PalletAssetConversionPoolInfo | undefined> =} callback
     **/
    pools: GenericStorageQuery<
      Rv,
      (
        arg: [FrameSupportTokensFungibleUnionOfNativeOrWithId, FrameSupportTokensFungibleUnionOfNativeOrWithId],
      ) => PalletAssetConversionPoolInfo | undefined,
      [FrameSupportTokensFungibleUnionOfNativeOrWithId, FrameSupportTokensFungibleUnionOfNativeOrWithId]
    >;

    /**
     * Stores the `PoolAssetId` that is going to be used for the next lp token.
     * This gets incremented whenever a new lp pool is created.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    nextPoolAssetId: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `FastUnstake`'s storage queries
   **/
  fastUnstake: {
    /**
     * The current "head of the queue" being unstaked.
     *
     * The head in itself can be a batch of up to [`Config::BatchSize`] stakers.
     *
     * @param {Callback<PalletFastUnstakeUnstakeRequest | undefined> =} callback
     **/
    head: GenericStorageQuery<Rv, () => PalletFastUnstakeUnstakeRequest | undefined>;

    /**
     * The map of all accounts wishing to be unstaked.
     *
     * Keeps track of `AccountId` wishing to unstake and it's corresponding deposit.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    queue: GenericStorageQuery<Rv, (arg: AccountId32Like) => bigint | undefined, AccountId32>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForQueue: GenericStorageQuery<Rv, () => number>;

    /**
     * Number of eras to check per block.
     *
     * If set to 0, this pallet does absolutely nothing. Cannot be set to more than
     * [`Config::MaxErasToCheckPerBlock`].
     *
     * Based on the amount of weight available at [`Pallet::on_idle`], up to this many eras are
     * checked. The checking is represented by updating [`UnstakeRequest::checked`], which is
     * stored in [`Head`].
     *
     * @param {Callback<number> =} callback
     **/
    erasToCheckPerBlock: GenericStorageQuery<Rv, () => number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `MessageQueue`'s storage queries
   **/
  messageQueue: {
    /**
     * The index of the first and last (non-empty) pages.
     *
     * @param {number} arg
     * @param {Callback<PalletMessageQueueBookState> =} callback
     **/
    bookStateFor: GenericStorageQuery<Rv, (arg: number) => PalletMessageQueueBookState, number>;

    /**
     * The origin at which we should begin servicing.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    serviceHead: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * The map of page indices to pages.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletMessageQueuePage | undefined> =} callback
     **/
    pages: GenericStorageQuery<Rv, (arg: [number, number]) => PalletMessageQueuePage | undefined, [number, number]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Pov`'s storage queries
   **/
  pov: {
    /**
     *
     * @param {Callback<number | undefined> =} callback
     **/
    value: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     *
     * @param {Callback<number | undefined> =} callback
     **/
    value2: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * A value without a MEL bound.
     *
     * @param {Callback<Bytes | undefined> =} callback
     **/
    unboundedValue: GenericStorageQuery<Rv, () => Bytes | undefined>;

    /**
     * A value with a MEL bound of 32 byte.
     *
     * @param {Callback<Bytes | undefined> =} callback
     **/
    boundedValue: GenericStorageQuery<Rv, () => Bytes | undefined>;

    /**
     * 4MiB value.
     *
     * @param {Callback<Bytes | undefined> =} callback
     **/
    largeValue: GenericStorageQuery<Rv, () => Bytes | undefined>;

    /**
     *
     * @param {Callback<Bytes | undefined> =} callback
     **/
    largeValue2: GenericStorageQuery<Rv, () => Bytes | undefined>;

    /**
     * A map with a maximum of 1M entries.
     *
     * @param {number} arg
     * @param {Callback<number | undefined> =} callback
     **/
    map1M: GenericStorageQuery<Rv, (arg: number) => number | undefined, number>;

    /**
     * A map with a maximum of 16M entries.
     *
     * @param {number} arg
     * @param {Callback<number | undefined> =} callback
     **/
    map16M: GenericStorageQuery<Rv, (arg: number) => number | undefined, number>;

    /**
     *
     * @param {[number, number]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    doubleMap1M: GenericStorageQuery<Rv, (arg: [number, number]) => number | undefined, [number, number]>;

    /**
     *
     * @param {number} arg
     * @param {Callback<Array<number> | undefined> =} callback
     **/
    unboundedMap: GenericStorageQuery<Rv, (arg: number) => Array<number> | undefined, number>;

    /**
     *
     * @param {number} arg
     * @param {Callback<Array<number> | undefined> =} callback
     **/
    unboundedMap2: GenericStorageQuery<Rv, (arg: number) => Array<number> | undefined, number>;

    /**
     *
     * @param {number} arg
     * @param {Callback<Array<number> | undefined> =} callback
     **/
    unboundedMapTwox: GenericStorageQuery<Rv, (arg: number) => Array<number> | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `TxPause`'s storage queries
   **/
  txPause: {
    /**
     * The set of calls that are explicitly paused.
     *
     * @param {[BytesLike, BytesLike]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    pausedCalls: GenericStorageQuery<Rv, (arg: [BytesLike, BytesLike]) => [] | undefined, [Bytes, Bytes]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `SafeMode`'s storage queries
   **/
  safeMode: {
    /**
     * Contains the last block number that the safe-mode will remain entered in.
     *
     * Set to `None` when safe-mode is exited.
     *
     * Safe-mode is automatically exited when the current block number exceeds this value.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    enteredUntil: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Holds the reserve that was taken from an account at a specific block number.
     *
     * This helps governance to have an overview of outstanding deposits that should be returned or
     * slashed.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    deposits: GenericStorageQuery<Rv, (arg: [AccountId32Like, number]) => bigint | undefined, [AccountId32, number]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `MultiBlockMigrations`'s storage queries
   **/
  multiBlockMigrations: {
    /**
     * The currently active migration to run and its cursor.
     *
     * `None` indicates that no migration is running.
     *
     * @param {Callback<PalletMigrationsMigrationCursor | undefined> =} callback
     **/
    cursor: GenericStorageQuery<Rv, () => PalletMigrationsMigrationCursor | undefined>;

    /**
     * Set of all successfully executed migrations.
     *
     * This is used as blacklist, to not re-execute migrations that have not been removed from the
     * codebase yet. Governance can regularly clear this out via `clear_historic`.
     *
     * @param {BytesLike} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    historic: GenericStorageQuery<Rv, (arg: BytesLike) => [] | undefined, Bytes>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Broker`'s storage queries
   **/
  broker: {
    /**
     * The current configuration of this pallet.
     *
     * @param {Callback<PalletBrokerConfigRecord | undefined> =} callback
     **/
    configuration: GenericStorageQuery<Rv, () => PalletBrokerConfigRecord | undefined>;

    /**
     * The Polkadot Core reservations (generally tasked with the maintenance of System Chains).
     *
     * @param {Callback<Array<Array<PalletBrokerScheduleItem>>> =} callback
     **/
    reservations: GenericStorageQuery<Rv, () => Array<Array<PalletBrokerScheduleItem>>>;

    /**
     * The Polkadot Core legacy leases.
     *
     * @param {Callback<Array<PalletBrokerLeaseRecordItem>> =} callback
     **/
    leases: GenericStorageQuery<Rv, () => Array<PalletBrokerLeaseRecordItem>>;

    /**
     * The current status of miscellaneous subsystems of this pallet.
     *
     * @param {Callback<PalletBrokerStatusRecord | undefined> =} callback
     **/
    status: GenericStorageQuery<Rv, () => PalletBrokerStatusRecord | undefined>;

    /**
     * The details of the current sale, including its properties and status.
     *
     * @param {Callback<PalletBrokerSaleInfoRecord | undefined> =} callback
     **/
    saleInfo: GenericStorageQuery<Rv, () => PalletBrokerSaleInfoRecord | undefined>;

    /**
     * Records of allowed renewals.
     *
     * @param {PalletBrokerAllowedRenewalId} arg
     * @param {Callback<PalletBrokerAllowedRenewalRecord | undefined> =} callback
     **/
    allowedRenewals: GenericStorageQuery<
      Rv,
      (arg: PalletBrokerAllowedRenewalId) => PalletBrokerAllowedRenewalRecord | undefined,
      PalletBrokerAllowedRenewalId
    >;

    /**
     * The current (unassigned) Regions.
     *
     * @param {PalletBrokerRegionId} arg
     * @param {Callback<PalletBrokerRegionRecord | undefined> =} callback
     **/
    regions: GenericStorageQuery<
      Rv,
      (arg: PalletBrokerRegionId) => PalletBrokerRegionRecord | undefined,
      PalletBrokerRegionId
    >;

    /**
     * The work we plan on having each core do at a particular time in the future.
     *
     * @param {[number, number]} arg
     * @param {Callback<Array<PalletBrokerScheduleItem> | undefined> =} callback
     **/
    workplan: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => Array<PalletBrokerScheduleItem> | undefined,
      [number, number]
    >;

    /**
     * The current workload of each core. This gets updated with workplan as timeslices pass.
     *
     * @param {number} arg
     * @param {Callback<Array<PalletBrokerScheduleItem>> =} callback
     **/
    workload: GenericStorageQuery<Rv, (arg: number) => Array<PalletBrokerScheduleItem>, number>;

    /**
     * Record of a single contribution to the Instantaneous Coretime Pool.
     *
     * @param {PalletBrokerRegionId} arg
     * @param {Callback<PalletBrokerContributionRecord | undefined> =} callback
     **/
    instaPoolContribution: GenericStorageQuery<
      Rv,
      (arg: PalletBrokerRegionId) => PalletBrokerContributionRecord | undefined,
      PalletBrokerRegionId
    >;

    /**
     * Record of Coretime entering or leaving the Instantaneous Coretime Pool.
     *
     * @param {number} arg
     * @param {Callback<PalletBrokerPoolIoRecord> =} callback
     **/
    instaPoolIo: GenericStorageQuery<Rv, (arg: number) => PalletBrokerPoolIoRecord, number>;

    /**
     * Total InstaPool rewards for each Timeslice and the number of core parts which contributed.
     *
     * @param {number} arg
     * @param {Callback<PalletBrokerInstaPoolHistoryRecord | undefined> =} callback
     **/
    instaPoolHistory: GenericStorageQuery<Rv, (arg: number) => PalletBrokerInstaPoolHistoryRecord | undefined, number>;

    /**
     * Received core count change from the relay chain.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    coreCountInbox: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `TasksExample`'s storage queries
   **/
  tasksExample: {
    /**
     * Some running total.
     *
     * @param {Callback<[number, number]> =} callback
     **/
    total: GenericStorageQuery<Rv, () => [number, number]>;

    /**
     * Numbers to be added into the total.
     *
     * @param {number} arg
     * @param {Callback<number | undefined> =} callback
     **/
    numbers: GenericStorageQuery<Rv, (arg: number) => number | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Mixnet`'s storage queries
   **/
  mixnet: {
    /**
     * Index of the current session. This may be offset relative to the session index tracked by
     * eg `pallet_session`; mixnet session indices are independent.
     *
     * @param {Callback<number> =} callback
     **/
    currentSessionIndex: GenericStorageQuery<Rv, () => number>;

    /**
     * Block in which the current session started.
     *
     * @param {Callback<number> =} callback
     **/
    currentSessionStartBlock: GenericStorageQuery<Rv, () => number>;

    /**
     * Authority list for the next session.
     *
     * @param {number} arg
     * @param {Callback<SpMixnetAppPublic | undefined> =} callback
     **/
    nextAuthorityIds: GenericStorageQuery<Rv, (arg: number) => SpMixnetAppPublic | undefined, number>;

    /**
     * Mixnode sets by session index. Only the mixnode sets for the previous, current, and next
     * sessions are kept; older sets are discarded.
     *
     * The mixnodes in each set are keyed by authority index so we can easily check if an
     * authority has registered a mixnode. The authority indices should only be used during
     * registration; the authority indices for the very first session are made up.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletMixnetBoundedMixnode | undefined> =} callback
     **/
    mixnodes: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletMixnetBoundedMixnode | undefined,
      [number, number]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Parameters`'s storage queries
   **/
  parameters: {
    /**
     * Stored parameters.
     *
     * @param {KitchensinkRuntimeRuntimeParametersKey} arg
     * @param {Callback<KitchensinkRuntimeRuntimeParametersValue | undefined> =} callback
     **/
    parameters: GenericStorageQuery<
      Rv,
      (arg: KitchensinkRuntimeRuntimeParametersKey) => KitchensinkRuntimeRuntimeParametersValue | undefined,
      KitchensinkRuntimeRuntimeParametersKey
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
}
