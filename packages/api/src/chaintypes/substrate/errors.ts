// Generated by dedot cli

import type { GenericChainErrors, GenericPalletError, RpcVersion } from '@dedot/types';

export interface ChainErrors<Rv extends RpcVersion> extends GenericChainErrors<Rv> {
  /**
   * Pallet `System`'s errors
   **/
  system: {
    /**
     * The name of specification does not match between the current runtime
     * and the new runtime.
     **/
    InvalidSpecName: GenericPalletError<Rv>;

    /**
     * The specification version is not allowed to decrease between the current runtime
     * and the new runtime.
     **/
    SpecVersionNeedsToIncrease: GenericPalletError<Rv>;

    /**
     * Failed to extract the runtime version from the new runtime.
     *
     * Either calling `Core_version` or decoding `RuntimeVersion` failed.
     **/
    FailedToExtractRuntimeVersion: GenericPalletError<Rv>;

    /**
     * Suicide called when the account has non-default composite data.
     **/
    NonDefaultComposite: GenericPalletError<Rv>;

    /**
     * There is a non-zero reference count preventing the account from being purged.
     **/
    NonZeroRefCount: GenericPalletError<Rv>;

    /**
     * The origin filter prevent the call to be dispatched.
     **/
    CallFiltered: GenericPalletError<Rv>;

    /**
     * A multi-block migration is ongoing and prevents the current code from being replaced.
     **/
    MultiBlockMigrationsOngoing: GenericPalletError<Rv>;

    /**
     * No upgrade authorized.
     **/
    NothingAuthorized: GenericPalletError<Rv>;

    /**
     * The submitted code is not authorized.
     **/
    Unauthorized: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Utility`'s errors
   **/
  utility: {
    /**
     * Too many calls batched.
     **/
    TooManyCalls: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Babe`'s errors
   **/
  babe: {
    /**
     * An equivocation proof provided as part of an equivocation report is invalid.
     **/
    InvalidEquivocationProof: GenericPalletError<Rv>;

    /**
     * A key ownership proof provided as part of an equivocation report is invalid.
     **/
    InvalidKeyOwnershipProof: GenericPalletError<Rv>;

    /**
     * A given equivocation report is valid but already previously reported.
     **/
    DuplicateOffenceReport: GenericPalletError<Rv>;

    /**
     * Submitted configuration is invalid.
     **/
    InvalidConfiguration: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Indices`'s errors
   **/
  indices: {
    /**
     * The index was not already assigned.
     **/
    NotAssigned: GenericPalletError<Rv>;

    /**
     * The index is assigned to another account.
     **/
    NotOwner: GenericPalletError<Rv>;

    /**
     * The index was not available.
     **/
    InUse: GenericPalletError<Rv>;

    /**
     * The source and destination accounts are identical.
     **/
    NotTransfer: GenericPalletError<Rv>;

    /**
     * The index is permanent and may not be freed/changed.
     **/
    Permanent: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Balances`'s errors
   **/
  balances: {
    /**
     * Vesting balance too high to send value.
     **/
    VestingBalance: GenericPalletError<Rv>;

    /**
     * Account liquidity restrictions prevent withdrawal.
     **/
    LiquidityRestrictions: GenericPalletError<Rv>;

    /**
     * Balance too low to send value.
     **/
    InsufficientBalance: GenericPalletError<Rv>;

    /**
     * Value too low to create account due to existential deposit.
     **/
    ExistentialDeposit: GenericPalletError<Rv>;

    /**
     * Transfer/payment would kill account.
     **/
    Expendability: GenericPalletError<Rv>;

    /**
     * A vesting schedule already exists for this account.
     **/
    ExistingVestingSchedule: GenericPalletError<Rv>;

    /**
     * Beneficiary account must pre-exist.
     **/
    DeadAccount: GenericPalletError<Rv>;

    /**
     * Number of named reserves exceed `MaxReserves`.
     **/
    TooManyReserves: GenericPalletError<Rv>;

    /**
     * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
     **/
    TooManyHolds: GenericPalletError<Rv>;

    /**
     * Number of freezes exceed `MaxFreezes`.
     **/
    TooManyFreezes: GenericPalletError<Rv>;

    /**
     * The issuance cannot be modified since it is already deactivated.
     **/
    IssuanceDeactivated: GenericPalletError<Rv>;

    /**
     * The delta cannot be zero.
     **/
    DeltaZero: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `ElectionProviderMultiPhase`'s errors
   **/
  electionProviderMultiPhase: {
    /**
     * Submission was too early.
     **/
    PreDispatchEarlySubmission: GenericPalletError<Rv>;

    /**
     * Wrong number of winners presented.
     **/
    PreDispatchWrongWinnerCount: GenericPalletError<Rv>;

    /**
     * Submission was too weak, score-wise.
     **/
    PreDispatchWeakSubmission: GenericPalletError<Rv>;

    /**
     * The queue was full, and the solution was not better than any of the existing ones.
     **/
    SignedQueueFull: GenericPalletError<Rv>;

    /**
     * The origin failed to pay the deposit.
     **/
    SignedCannotPayDeposit: GenericPalletError<Rv>;

    /**
     * Witness data to dispatchable is invalid.
     **/
    SignedInvalidWitness: GenericPalletError<Rv>;

    /**
     * The signed submission consumes too much weight
     **/
    SignedTooMuchWeight: GenericPalletError<Rv>;

    /**
     * OCW submitted solution for wrong round
     **/
    OcwCallWrongEra: GenericPalletError<Rv>;

    /**
     * Snapshot metadata should exist but didn't.
     **/
    MissingSnapshotMetadata: GenericPalletError<Rv>;

    /**
     * `Self::insert_submission` returned an invalid index.
     **/
    InvalidSubmissionIndex: GenericPalletError<Rv>;

    /**
     * The call is not allowed at this point.
     **/
    CallNotAllowed: GenericPalletError<Rv>;

    /**
     * The fallback failed
     **/
    FallbackFailed: GenericPalletError<Rv>;

    /**
     * Some bound not met
     **/
    BoundNotMet: GenericPalletError<Rv>;

    /**
     * Submitted solution has too many winners
     **/
    TooManyWinners: GenericPalletError<Rv>;

    /**
     * Submission was prepared for a different round.
     **/
    PreDispatchDifferentRound: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Staking`'s errors
   **/
  staking: {
    /**
     * Not a controller account.
     **/
    NotController: GenericPalletError<Rv>;

    /**
     * Not a stash account.
     **/
    NotStash: GenericPalletError<Rv>;

    /**
     * Stash is already bonded.
     **/
    AlreadyBonded: GenericPalletError<Rv>;

    /**
     * Controller is already paired.
     **/
    AlreadyPaired: GenericPalletError<Rv>;

    /**
     * Targets cannot be empty.
     **/
    EmptyTargets: GenericPalletError<Rv>;

    /**
     * Duplicate index.
     **/
    DuplicateIndex: GenericPalletError<Rv>;

    /**
     * Slash record index out of bounds.
     **/
    InvalidSlashIndex: GenericPalletError<Rv>;

    /**
     * Cannot have a validator or nominator role, with value less than the minimum defined by
     * governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
     * intention, `chill` first to remove one's role as validator/nominator.
     **/
    InsufficientBond: GenericPalletError<Rv>;

    /**
     * Can not schedule more unlock chunks.
     **/
    NoMoreChunks: GenericPalletError<Rv>;

    /**
     * Can not rebond without unlocking chunks.
     **/
    NoUnlockChunk: GenericPalletError<Rv>;

    /**
     * Attempting to target a stash that still has funds.
     **/
    FundedTarget: GenericPalletError<Rv>;

    /**
     * Invalid era to reward.
     **/
    InvalidEraToReward: GenericPalletError<Rv>;

    /**
     * Invalid number of nominations.
     **/
    InvalidNumberOfNominations: GenericPalletError<Rv>;

    /**
     * Items are not sorted and unique.
     **/
    NotSortedAndUnique: GenericPalletError<Rv>;

    /**
     * Rewards for this era have already been claimed for this validator.
     **/
    AlreadyClaimed: GenericPalletError<Rv>;

    /**
     * No nominators exist on this page.
     **/
    InvalidPage: GenericPalletError<Rv>;

    /**
     * Incorrect previous history depth input provided.
     **/
    IncorrectHistoryDepth: GenericPalletError<Rv>;

    /**
     * Incorrect number of slashing spans provided.
     **/
    IncorrectSlashingSpans: GenericPalletError<Rv>;

    /**
     * Internal state has become somehow corrupted and the operation cannot continue.
     **/
    BadState: GenericPalletError<Rv>;

    /**
     * Too many nomination targets supplied.
     **/
    TooManyTargets: GenericPalletError<Rv>;

    /**
     * A nomination target was supplied that was blocked or otherwise not a validator.
     **/
    BadTarget: GenericPalletError<Rv>;

    /**
     * The user has enough bond and thus cannot be chilled forcefully by an external person.
     **/
    CannotChillOther: GenericPalletError<Rv>;

    /**
     * There are too many nominators in the system. Governance needs to adjust the staking
     * settings to keep things safe for the runtime.
     **/
    TooManyNominators: GenericPalletError<Rv>;

    /**
     * There are too many validator candidates in the system. Governance needs to adjust the
     * staking settings to keep things safe for the runtime.
     **/
    TooManyValidators: GenericPalletError<Rv>;

    /**
     * Commission is too low. Must be at least `MinCommission`.
     **/
    CommissionTooLow: GenericPalletError<Rv>;

    /**
     * Some bound is not met.
     **/
    BoundNotMet: GenericPalletError<Rv>;

    /**
     * Used when attempting to use deprecated controller account logic.
     **/
    ControllerDeprecated: GenericPalletError<Rv>;

    /**
     * Cannot reset a ledger.
     **/
    CannotRestoreLedger: GenericPalletError<Rv>;

    /**
     * Provided reward destination is not allowed.
     **/
    RewardDestinationRestricted: GenericPalletError<Rv>;

    /**
     * Not enough funds available to withdraw.
     **/
    NotEnoughFunds: GenericPalletError<Rv>;

    /**
     * Operation not allowed for virtual stakers.
     **/
    VirtualStakerNotAllowed: GenericPalletError<Rv>;

    /**
     * Stash could not be reaped as other pallet might depend on it.
     **/
    CannotReapStash: GenericPalletError<Rv>;

    /**
     * The stake of this account is already migrated to `Fungible` holds.
     **/
    AlreadyMigrated: GenericPalletError<Rv>;

    /**
     * Account is restricted from participation in staking. This may happen if the account is
     * staking in another way already, such as via pool.
     **/
    Restricted: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Session`'s errors
   **/
  session: {
    /**
     * Invalid ownership proof.
     **/
    InvalidProof: GenericPalletError<Rv>;

    /**
     * No associated validator ID for account.
     **/
    NoAssociatedValidatorId: GenericPalletError<Rv>;

    /**
     * Registered duplicate key.
     **/
    DuplicatedKey: GenericPalletError<Rv>;

    /**
     * No keys are associated with this account.
     **/
    NoKeys: GenericPalletError<Rv>;

    /**
     * Key setting account is not live, so it's impossible to associate keys.
     **/
    NoAccount: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Democracy`'s errors
   **/
  democracy: {
    /**
     * Value too low
     **/
    ValueLow: GenericPalletError<Rv>;

    /**
     * Proposal does not exist
     **/
    ProposalMissing: GenericPalletError<Rv>;

    /**
     * Cannot cancel the same proposal twice
     **/
    AlreadyCanceled: GenericPalletError<Rv>;

    /**
     * Proposal already made
     **/
    DuplicateProposal: GenericPalletError<Rv>;

    /**
     * Proposal still blacklisted
     **/
    ProposalBlacklisted: GenericPalletError<Rv>;

    /**
     * Next external proposal not simple majority
     **/
    NotSimpleMajority: GenericPalletError<Rv>;

    /**
     * Invalid hash
     **/
    InvalidHash: GenericPalletError<Rv>;

    /**
     * No external proposal
     **/
    NoProposal: GenericPalletError<Rv>;

    /**
     * Identity may not veto a proposal twice
     **/
    AlreadyVetoed: GenericPalletError<Rv>;

    /**
     * Vote given for invalid referendum
     **/
    ReferendumInvalid: GenericPalletError<Rv>;

    /**
     * No proposals waiting
     **/
    NoneWaiting: GenericPalletError<Rv>;

    /**
     * The given account did not vote on the referendum.
     **/
    NotVoter: GenericPalletError<Rv>;

    /**
     * The actor has no permission to conduct the action.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * The account is already delegating.
     **/
    AlreadyDelegating: GenericPalletError<Rv>;

    /**
     * Too high a balance was provided that the account cannot afford.
     **/
    InsufficientFunds: GenericPalletError<Rv>;

    /**
     * The account is not currently delegating.
     **/
    NotDelegating: GenericPalletError<Rv>;

    /**
     * The account currently has votes attached to it and the operation cannot succeed until
     * these are removed, either through `unvote` or `reap_vote`.
     **/
    VotesExist: GenericPalletError<Rv>;

    /**
     * The instant referendum origin is currently disallowed.
     **/
    InstantNotAllowed: GenericPalletError<Rv>;

    /**
     * Delegation to oneself makes no sense.
     **/
    Nonsense: GenericPalletError<Rv>;

    /**
     * Invalid upper bound.
     **/
    WrongUpperBound: GenericPalletError<Rv>;

    /**
     * Maximum number of votes reached.
     **/
    MaxVotesReached: GenericPalletError<Rv>;

    /**
     * Maximum number of items reached.
     **/
    TooMany: GenericPalletError<Rv>;

    /**
     * Voting period too low
     **/
    VotingPeriodLow: GenericPalletError<Rv>;

    /**
     * The preimage does not exist.
     **/
    PreimageNotExist: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Council`'s errors
   **/
  council: {
    /**
     * Account is not a member
     **/
    NotMember: GenericPalletError<Rv>;

    /**
     * Duplicate proposals not allowed
     **/
    DuplicateProposal: GenericPalletError<Rv>;

    /**
     * Proposal must exist
     **/
    ProposalMissing: GenericPalletError<Rv>;

    /**
     * Mismatched index
     **/
    WrongIndex: GenericPalletError<Rv>;

    /**
     * Duplicate vote ignored
     **/
    DuplicateVote: GenericPalletError<Rv>;

    /**
     * Members are already initialized!
     **/
    AlreadyInitialized: GenericPalletError<Rv>;

    /**
     * The close call was made too early, before the end of the voting.
     **/
    TooEarly: GenericPalletError<Rv>;

    /**
     * There can only be a maximum of `MaxProposals` active proposals.
     **/
    TooManyProposals: GenericPalletError<Rv>;

    /**
     * The given weight bound for the proposal was too low.
     **/
    WrongProposalWeight: GenericPalletError<Rv>;

    /**
     * The given length bound for the proposal was too low.
     **/
    WrongProposalLength: GenericPalletError<Rv>;

    /**
     * Prime account is not a member
     **/
    PrimeAccountNotMember: GenericPalletError<Rv>;

    /**
     * Proposal is still active.
     **/
    ProposalActive: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `TechnicalCommittee`'s errors
   **/
  technicalCommittee: {
    /**
     * Account is not a member
     **/
    NotMember: GenericPalletError<Rv>;

    /**
     * Duplicate proposals not allowed
     **/
    DuplicateProposal: GenericPalletError<Rv>;

    /**
     * Proposal must exist
     **/
    ProposalMissing: GenericPalletError<Rv>;

    /**
     * Mismatched index
     **/
    WrongIndex: GenericPalletError<Rv>;

    /**
     * Duplicate vote ignored
     **/
    DuplicateVote: GenericPalletError<Rv>;

    /**
     * Members are already initialized!
     **/
    AlreadyInitialized: GenericPalletError<Rv>;

    /**
     * The close call was made too early, before the end of the voting.
     **/
    TooEarly: GenericPalletError<Rv>;

    /**
     * There can only be a maximum of `MaxProposals` active proposals.
     **/
    TooManyProposals: GenericPalletError<Rv>;

    /**
     * The given weight bound for the proposal was too low.
     **/
    WrongProposalWeight: GenericPalletError<Rv>;

    /**
     * The given length bound for the proposal was too low.
     **/
    WrongProposalLength: GenericPalletError<Rv>;

    /**
     * Prime account is not a member
     **/
    PrimeAccountNotMember: GenericPalletError<Rv>;

    /**
     * Proposal is still active.
     **/
    ProposalActive: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Elections`'s errors
   **/
  elections: {
    /**
     * Cannot vote when no candidates or members exist.
     **/
    UnableToVote: GenericPalletError<Rv>;

    /**
     * Must vote for at least one candidate.
     **/
    NoVotes: GenericPalletError<Rv>;

    /**
     * Cannot vote more than candidates.
     **/
    TooManyVotes: GenericPalletError<Rv>;

    /**
     * Cannot vote more than maximum allowed.
     **/
    MaximumVotesExceeded: GenericPalletError<Rv>;

    /**
     * Cannot vote with stake less than minimum balance.
     **/
    LowBalance: GenericPalletError<Rv>;

    /**
     * Voter can not pay voting bond.
     **/
    UnableToPayBond: GenericPalletError<Rv>;

    /**
     * Must be a voter.
     **/
    MustBeVoter: GenericPalletError<Rv>;

    /**
     * Duplicated candidate submission.
     **/
    DuplicatedCandidate: GenericPalletError<Rv>;

    /**
     * Too many candidates have been created.
     **/
    TooManyCandidates: GenericPalletError<Rv>;

    /**
     * Member cannot re-submit candidacy.
     **/
    MemberSubmit: GenericPalletError<Rv>;

    /**
     * Runner cannot re-submit candidacy.
     **/
    RunnerUpSubmit: GenericPalletError<Rv>;

    /**
     * Candidate does not have enough funds.
     **/
    InsufficientCandidateFunds: GenericPalletError<Rv>;

    /**
     * Not a member.
     **/
    NotMember: GenericPalletError<Rv>;

    /**
     * The provided count of number of candidates is incorrect.
     **/
    InvalidWitnessData: GenericPalletError<Rv>;

    /**
     * The provided count of number of votes is incorrect.
     **/
    InvalidVoteCount: GenericPalletError<Rv>;

    /**
     * The renouncing origin presented a wrong `Renouncing` parameter.
     **/
    InvalidRenouncing: GenericPalletError<Rv>;

    /**
     * Prediction regarding replacement after member removal is wrong.
     **/
    InvalidReplacement: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `TechnicalMembership`'s errors
   **/
  technicalMembership: {
    /**
     * Already a member.
     **/
    AlreadyMember: GenericPalletError<Rv>;

    /**
     * Not a member.
     **/
    NotMember: GenericPalletError<Rv>;

    /**
     * Too many members.
     **/
    TooManyMembers: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Grandpa`'s errors
   **/
  grandpa: {
    /**
     * Attempt to signal GRANDPA pause when the authority set isn't live
     * (either paused or already pending pause).
     **/
    PauseFailed: GenericPalletError<Rv>;

    /**
     * Attempt to signal GRANDPA resume when the authority set isn't paused
     * (either live or already pending resume).
     **/
    ResumeFailed: GenericPalletError<Rv>;

    /**
     * Attempt to signal GRANDPA change with one already pending.
     **/
    ChangePending: GenericPalletError<Rv>;

    /**
     * Cannot signal forced change so soon after last.
     **/
    TooSoon: GenericPalletError<Rv>;

    /**
     * A key ownership proof provided as part of an equivocation report is invalid.
     **/
    InvalidKeyOwnershipProof: GenericPalletError<Rv>;

    /**
     * An equivocation proof provided as part of an equivocation report is invalid.
     **/
    InvalidEquivocationProof: GenericPalletError<Rv>;

    /**
     * A given equivocation report is valid but already previously reported.
     **/
    DuplicateOffenceReport: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Treasury`'s errors
   **/
  treasury: {
    /**
     * No proposal, bounty or spend at that index.
     **/
    InvalidIndex: GenericPalletError<Rv>;

    /**
     * Too many approvals in the queue.
     **/
    TooManyApprovals: GenericPalletError<Rv>;

    /**
     * The spend origin is valid but the amount it is allowed to spend is lower than the
     * amount to be spent.
     **/
    InsufficientPermission: GenericPalletError<Rv>;

    /**
     * Proposal has not been approved.
     **/
    ProposalNotApproved: GenericPalletError<Rv>;

    /**
     * The balance of the asset kind is not convertible to the balance of the native asset.
     **/
    FailedToConvertBalance: GenericPalletError<Rv>;

    /**
     * The spend has expired and cannot be claimed.
     **/
    SpendExpired: GenericPalletError<Rv>;

    /**
     * The spend is not yet eligible for payout.
     **/
    EarlyPayout: GenericPalletError<Rv>;

    /**
     * The payment has already been attempted.
     **/
    AlreadyAttempted: GenericPalletError<Rv>;

    /**
     * There was some issue with the mechanism of payment.
     **/
    PayoutError: GenericPalletError<Rv>;

    /**
     * The payout was not yet attempted/claimed.
     **/
    NotAttempted: GenericPalletError<Rv>;

    /**
     * The payment has neither failed nor succeeded yet.
     **/
    Inconclusive: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `AssetRate`'s errors
   **/
  assetRate: {
    /**
     * The given asset ID is unknown.
     **/
    UnknownAssetKind: GenericPalletError<Rv>;

    /**
     * The given asset ID already has an assigned conversion rate and cannot be re-created.
     **/
    AlreadyExists: GenericPalletError<Rv>;

    /**
     * Overflow ocurred when calculating the inverse rate.
     **/
    Overflow: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Contracts`'s errors
   **/
  contracts: {
    /**
     * Invalid schedule supplied, e.g. with zero weight of a basic operation.
     **/
    InvalidSchedule: GenericPalletError<Rv>;

    /**
     * Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`.
     **/
    InvalidCallFlags: GenericPalletError<Rv>;

    /**
     * The executed contract exhausted its gas limit.
     **/
    OutOfGas: GenericPalletError<Rv>;

    /**
     * The output buffer supplied to a contract API call was too small.
     **/
    OutputBufferTooSmall: GenericPalletError<Rv>;

    /**
     * Performing the requested transfer failed. Probably because there isn't enough
     * free balance in the sender's account.
     **/
    TransferFailed: GenericPalletError<Rv>;

    /**
     * Performing a call was denied because the calling depth reached the limit
     * of what is specified in the schedule.
     **/
    MaxCallDepthReached: GenericPalletError<Rv>;

    /**
     * No contract was found at the specified address.
     **/
    ContractNotFound: GenericPalletError<Rv>;

    /**
     * The code supplied to `instantiate_with_code` exceeds the limit specified in the
     * current schedule.
     **/
    CodeTooLarge: GenericPalletError<Rv>;

    /**
     * No code could be found at the supplied code hash.
     **/
    CodeNotFound: GenericPalletError<Rv>;

    /**
     * No code info could be found at the supplied code hash.
     **/
    CodeInfoNotFound: GenericPalletError<Rv>;

    /**
     * A buffer outside of sandbox memory was passed to a contract API function.
     **/
    OutOfBounds: GenericPalletError<Rv>;

    /**
     * Input passed to a contract API function failed to decode as expected type.
     **/
    DecodingFailed: GenericPalletError<Rv>;

    /**
     * Contract trapped during execution.
     **/
    ContractTrapped: GenericPalletError<Rv>;

    /**
     * The size defined in `T::MaxValueSize` was exceeded.
     **/
    ValueTooLarge: GenericPalletError<Rv>;

    /**
     * Termination of a contract is not allowed while the contract is already
     * on the call stack. Can be triggered by `seal_terminate`.
     **/
    TerminatedWhileReentrant: GenericPalletError<Rv>;

    /**
     * `seal_call` forwarded this contracts input. It therefore is no longer available.
     **/
    InputForwarded: GenericPalletError<Rv>;

    /**
     * The subject passed to `seal_random` exceeds the limit.
     **/
    RandomSubjectTooLong: GenericPalletError<Rv>;

    /**
     * The amount of topics passed to `seal_deposit_events` exceeds the limit.
     **/
    TooManyTopics: GenericPalletError<Rv>;

    /**
     * The chain does not provide a chain extension. Calling the chain extension results
     * in this error. Note that this usually shouldn't happen as deploying such contracts
     * is rejected.
     **/
    NoChainExtension: GenericPalletError<Rv>;

    /**
     * Failed to decode the XCM program.
     **/
    XcmDecodeFailed: GenericPalletError<Rv>;

    /**
     * A contract with the same AccountId already exists.
     **/
    DuplicateContract: GenericPalletError<Rv>;

    /**
     * A contract self destructed in its constructor.
     *
     * This can be triggered by a call to `seal_terminate`.
     **/
    TerminatedInConstructor: GenericPalletError<Rv>;

    /**
     * A call tried to invoke a contract that is flagged as non-reentrant.
     * The only other cause is that a call from a contract into the runtime tried to call back
     * into `pallet-contracts`. This would make the whole pallet reentrant with regard to
     * contract code execution which is not supported.
     **/
    ReentranceDenied: GenericPalletError<Rv>;

    /**
     * A contract attempted to invoke a state modifying API while being in read-only mode.
     **/
    StateChangeDenied: GenericPalletError<Rv>;

    /**
     * Origin doesn't have enough balance to pay the required storage deposits.
     **/
    StorageDepositNotEnoughFunds: GenericPalletError<Rv>;

    /**
     * More storage was created than allowed by the storage deposit limit.
     **/
    StorageDepositLimitExhausted: GenericPalletError<Rv>;

    /**
     * Code removal was denied because the code is still in use by at least one contract.
     **/
    CodeInUse: GenericPalletError<Rv>;

    /**
     * The contract ran to completion but decided to revert its storage changes.
     * Please note that this error is only returned from extrinsics. When called directly
     * or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags
     * to determine whether a reversion has taken place.
     **/
    ContractReverted: GenericPalletError<Rv>;

    /**
     * The contract's code was found to be invalid during validation.
     *
     * The most likely cause of this is that an API was used which is not supported by the
     * node. This happens if an older node is used with a new version of ink!. Try updating
     * your node to the newest available version.
     *
     * A more detailed error can be found on the node console if debug messages are enabled
     * by supplying `-lruntime::contracts=debug`.
     **/
    CodeRejected: GenericPalletError<Rv>;

    /**
     * An indeterministic code was used in a context where this is not permitted.
     **/
    Indeterministic: GenericPalletError<Rv>;

    /**
     * A pending migration needs to complete before the extrinsic can be called.
     **/
    MigrationInProgress: GenericPalletError<Rv>;

    /**
     * Migrate dispatch call was attempted but no migration was performed.
     **/
    NoMigrationPerformed: GenericPalletError<Rv>;

    /**
     * The contract has reached its maximum number of delegate dependencies.
     **/
    MaxDelegateDependenciesReached: GenericPalletError<Rv>;

    /**
     * The dependency was not found in the contract's delegate dependencies.
     **/
    DelegateDependencyNotFound: GenericPalletError<Rv>;

    /**
     * The contract already depends on the given delegate dependency.
     **/
    DelegateDependencyAlreadyExists: GenericPalletError<Rv>;

    /**
     * Can not add a delegate dependency to the code hash of the contract itself.
     **/
    CannotAddSelfAsDelegateDependency: GenericPalletError<Rv>;

    /**
     * Can not add more data to transient storage.
     **/
    OutOfTransientStorage: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Sudo`'s errors
   **/
  sudo: {
    /**
     * Sender must be the Sudo account.
     **/
    RequireSudo: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `ImOnline`'s errors
   **/
  imOnline: {
    /**
     * Non existent public key.
     **/
    InvalidKey: GenericPalletError<Rv>;

    /**
     * Duplicated heartbeat.
     **/
    DuplicatedHeartbeat: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Identity`'s errors
   **/
  identity: {
    /**
     * Too many subs-accounts.
     **/
    TooManySubAccounts: GenericPalletError<Rv>;

    /**
     * Account isn't found.
     **/
    NotFound: GenericPalletError<Rv>;

    /**
     * Account isn't named.
     **/
    NotNamed: GenericPalletError<Rv>;

    /**
     * Empty index.
     **/
    EmptyIndex: GenericPalletError<Rv>;

    /**
     * Fee is changed.
     **/
    FeeChanged: GenericPalletError<Rv>;

    /**
     * No identity found.
     **/
    NoIdentity: GenericPalletError<Rv>;

    /**
     * Sticky judgement.
     **/
    StickyJudgement: GenericPalletError<Rv>;

    /**
     * Judgement given.
     **/
    JudgementGiven: GenericPalletError<Rv>;

    /**
     * Invalid judgement.
     **/
    InvalidJudgement: GenericPalletError<Rv>;

    /**
     * The index is invalid.
     **/
    InvalidIndex: GenericPalletError<Rv>;

    /**
     * The target is invalid.
     **/
    InvalidTarget: GenericPalletError<Rv>;

    /**
     * Maximum amount of registrars reached. Cannot add any more.
     **/
    TooManyRegistrars: GenericPalletError<Rv>;

    /**
     * Account ID is already named.
     **/
    AlreadyClaimed: GenericPalletError<Rv>;

    /**
     * Sender is not a sub-account.
     **/
    NotSub: GenericPalletError<Rv>;

    /**
     * Sub-account isn't owned by sender.
     **/
    NotOwned: GenericPalletError<Rv>;

    /**
     * The provided judgement was for a different identity.
     **/
    JudgementForDifferentIdentity: GenericPalletError<Rv>;

    /**
     * Error that occurs when there is an issue paying for judgement.
     **/
    JudgementPaymentFailed: GenericPalletError<Rv>;

    /**
     * The provided suffix is too long.
     **/
    InvalidSuffix: GenericPalletError<Rv>;

    /**
     * The sender does not have permission to issue a username.
     **/
    NotUsernameAuthority: GenericPalletError<Rv>;

    /**
     * The authority cannot allocate any more usernames.
     **/
    NoAllocation: GenericPalletError<Rv>;

    /**
     * The signature on a username was not valid.
     **/
    InvalidSignature: GenericPalletError<Rv>;

    /**
     * Setting this username requires a signature, but none was provided.
     **/
    RequiresSignature: GenericPalletError<Rv>;

    /**
     * The username does not meet the requirements.
     **/
    InvalidUsername: GenericPalletError<Rv>;

    /**
     * The username is already taken.
     **/
    UsernameTaken: GenericPalletError<Rv>;

    /**
     * The requested username does not exist.
     **/
    NoUsername: GenericPalletError<Rv>;

    /**
     * The username cannot be forcefully removed because it can still be accepted.
     **/
    NotExpired: GenericPalletError<Rv>;

    /**
     * The username cannot be removed because it's still in the grace period.
     **/
    TooEarly: GenericPalletError<Rv>;

    /**
     * The username cannot be removed because it is not unbinding.
     **/
    NotUnbinding: GenericPalletError<Rv>;

    /**
     * The username cannot be unbound because it is already unbinding.
     **/
    AlreadyUnbinding: GenericPalletError<Rv>;

    /**
     * The action cannot be performed because of insufficient privileges (e.g. authority
     * trying to unbind a username provided by the system).
     **/
    InsufficientPrivileges: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Society`'s errors
   **/
  society: {
    /**
     * User is not a member.
     **/
    NotMember: GenericPalletError<Rv>;

    /**
     * User is already a member.
     **/
    AlreadyMember: GenericPalletError<Rv>;

    /**
     * User is suspended.
     **/
    Suspended: GenericPalletError<Rv>;

    /**
     * User is not suspended.
     **/
    NotSuspended: GenericPalletError<Rv>;

    /**
     * Nothing to payout.
     **/
    NoPayout: GenericPalletError<Rv>;

    /**
     * Society already founded.
     **/
    AlreadyFounded: GenericPalletError<Rv>;

    /**
     * Not enough in pot to accept candidate.
     **/
    InsufficientPot: GenericPalletError<Rv>;

    /**
     * Member is already vouching or banned from vouching again.
     **/
    AlreadyVouching: GenericPalletError<Rv>;

    /**
     * Member is not vouching.
     **/
    NotVouchingOnBidder: GenericPalletError<Rv>;

    /**
     * Cannot remove the head of the chain.
     **/
    Head: GenericPalletError<Rv>;

    /**
     * Cannot remove the founder.
     **/
    Founder: GenericPalletError<Rv>;

    /**
     * User has already made a bid.
     **/
    AlreadyBid: GenericPalletError<Rv>;

    /**
     * User is already a candidate.
     **/
    AlreadyCandidate: GenericPalletError<Rv>;

    /**
     * User is not a candidate.
     **/
    NotCandidate: GenericPalletError<Rv>;

    /**
     * Too many members in the society.
     **/
    MaxMembers: GenericPalletError<Rv>;

    /**
     * The caller is not the founder.
     **/
    NotFounder: GenericPalletError<Rv>;

    /**
     * The caller is not the head.
     **/
    NotHead: GenericPalletError<Rv>;

    /**
     * The membership cannot be claimed as the candidate was not clearly approved.
     **/
    NotApproved: GenericPalletError<Rv>;

    /**
     * The candidate cannot be kicked as the candidate was not clearly rejected.
     **/
    NotRejected: GenericPalletError<Rv>;

    /**
     * The candidacy cannot be dropped as the candidate was clearly approved.
     **/
    Approved: GenericPalletError<Rv>;

    /**
     * The candidacy cannot be bestowed as the candidate was clearly rejected.
     **/
    Rejected: GenericPalletError<Rv>;

    /**
     * The candidacy cannot be concluded as the voting is still in progress.
     **/
    InProgress: GenericPalletError<Rv>;

    /**
     * The candidacy cannot be pruned until a full additional intake period has passed.
     **/
    TooEarly: GenericPalletError<Rv>;

    /**
     * The skeptic already voted.
     **/
    Voted: GenericPalletError<Rv>;

    /**
     * The skeptic need not vote on candidates from expired rounds.
     **/
    Expired: GenericPalletError<Rv>;

    /**
     * User is not a bidder.
     **/
    NotBidder: GenericPalletError<Rv>;

    /**
     * There is no defender currently.
     **/
    NoDefender: GenericPalletError<Rv>;

    /**
     * Group doesn't exist.
     **/
    NotGroup: GenericPalletError<Rv>;

    /**
     * The member is already elevated to this rank.
     **/
    AlreadyElevated: GenericPalletError<Rv>;

    /**
     * The skeptic has already been punished for this offence.
     **/
    AlreadyPunished: GenericPalletError<Rv>;

    /**
     * Funds are insufficient to pay off society debts.
     **/
    InsufficientFunds: GenericPalletError<Rv>;

    /**
     * The candidate/defender has no stale votes to remove.
     **/
    NoVotes: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Recovery`'s errors
   **/
  recovery: {
    /**
     * User is not allowed to make a call on behalf of this account
     **/
    NotAllowed: GenericPalletError<Rv>;

    /**
     * Threshold must be greater than zero
     **/
    ZeroThreshold: GenericPalletError<Rv>;

    /**
     * Friends list must be greater than zero and threshold
     **/
    NotEnoughFriends: GenericPalletError<Rv>;

    /**
     * Friends list must be less than max friends
     **/
    MaxFriends: GenericPalletError<Rv>;

    /**
     * Friends list must be sorted and free of duplicates
     **/
    NotSorted: GenericPalletError<Rv>;

    /**
     * This account is not set up for recovery
     **/
    NotRecoverable: GenericPalletError<Rv>;

    /**
     * This account is already set up for recovery
     **/
    AlreadyRecoverable: GenericPalletError<Rv>;

    /**
     * A recovery process has already started for this account
     **/
    AlreadyStarted: GenericPalletError<Rv>;

    /**
     * A recovery process has not started for this rescuer
     **/
    NotStarted: GenericPalletError<Rv>;

    /**
     * This account is not a friend who can vouch
     **/
    NotFriend: GenericPalletError<Rv>;

    /**
     * The friend must wait until the delay period to vouch for this recovery
     **/
    DelayPeriod: GenericPalletError<Rv>;

    /**
     * This user has already vouched for this recovery
     **/
    AlreadyVouched: GenericPalletError<Rv>;

    /**
     * The threshold for recovering this account has not been met
     **/
    Threshold: GenericPalletError<Rv>;

    /**
     * There are still active recovery attempts that need to be closed
     **/
    StillActive: GenericPalletError<Rv>;

    /**
     * This account is already set up for recovery
     **/
    AlreadyProxy: GenericPalletError<Rv>;

    /**
     * Some internal state is broken.
     **/
    BadState: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Vesting`'s errors
   **/
  vesting: {
    /**
     * The account given is not vesting.
     **/
    NotVesting: GenericPalletError<Rv>;

    /**
     * The account already has `MaxVestingSchedules` count of schedules and thus
     * cannot add another one. Consider merging existing schedules in order to add another.
     **/
    AtMaxVestingSchedules: GenericPalletError<Rv>;

    /**
     * Amount being transferred is too low to create a vesting schedule.
     **/
    AmountLow: GenericPalletError<Rv>;

    /**
     * An index was out of bounds of the vesting schedules.
     **/
    ScheduleIndexOutOfBounds: GenericPalletError<Rv>;

    /**
     * Failed to create a new schedule because some parameter was invalid.
     **/
    InvalidScheduleParams: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Scheduler`'s errors
   **/
  scheduler: {
    /**
     * Failed to schedule a call
     **/
    FailedToSchedule: GenericPalletError<Rv>;

    /**
     * Cannot find the scheduled call.
     **/
    NotFound: GenericPalletError<Rv>;

    /**
     * Given target block number is in the past.
     **/
    TargetBlockNumberInPast: GenericPalletError<Rv>;

    /**
     * Reschedule failed because it does not change scheduled time.
     **/
    RescheduleNoChange: GenericPalletError<Rv>;

    /**
     * Attempt to use a non-named function on a named task.
     **/
    Named: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Glutton`'s errors
   **/
  glutton: {
    /**
     * The pallet was already initialized.
     *
     * Set `witness_count` to `Some` to bypass this error.
     **/
    AlreadyInitialized: GenericPalletError<Rv>;

    /**
     * The limit was over [`crate::RESOURCE_HARD_LIMIT`].
     **/
    InsaneLimit: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Preimage`'s errors
   **/
  preimage: {
    /**
     * Preimage is too large to store on-chain.
     **/
    TooBig: GenericPalletError<Rv>;

    /**
     * Preimage has already been noted on-chain.
     **/
    AlreadyNoted: GenericPalletError<Rv>;

    /**
     * The user is not authorized to perform this action.
     **/
    NotAuthorized: GenericPalletError<Rv>;

    /**
     * The preimage cannot be removed since it has not yet been noted.
     **/
    NotNoted: GenericPalletError<Rv>;

    /**
     * A preimage may not be removed when there are outstanding requests.
     **/
    Requested: GenericPalletError<Rv>;

    /**
     * The preimage request cannot be removed since no outstanding requests exist.
     **/
    NotRequested: GenericPalletError<Rv>;

    /**
     * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
     **/
    TooMany: GenericPalletError<Rv>;

    /**
     * Too few hashes were requested to be upgraded (i.e. zero).
     **/
    TooFew: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Proxy`'s errors
   **/
  proxy: {
    /**
     * There are too many proxies registered or too many announcements pending.
     **/
    TooMany: GenericPalletError<Rv>;

    /**
     * Proxy registration not found.
     **/
    NotFound: GenericPalletError<Rv>;

    /**
     * Sender is not a proxy of the account to be proxied.
     **/
    NotProxy: GenericPalletError<Rv>;

    /**
     * A call which is incompatible with the proxy type's filter was attempted.
     **/
    Unproxyable: GenericPalletError<Rv>;

    /**
     * Account is already a proxy.
     **/
    Duplicate: GenericPalletError<Rv>;

    /**
     * Call may not be made by proxy because it may escalate its privileges.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * Announcement, if made at all, was made too recently.
     **/
    Unannounced: GenericPalletError<Rv>;

    /**
     * Cannot add self as proxy.
     **/
    NoSelfProxy: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Multisig`'s errors
   **/
  multisig: {
    /**
     * Threshold must be 2 or greater.
     **/
    MinimumThreshold: GenericPalletError<Rv>;

    /**
     * Call is already approved by this signatory.
     **/
    AlreadyApproved: GenericPalletError<Rv>;

    /**
     * Call doesn't need any (more) approvals.
     **/
    NoApprovalsNeeded: GenericPalletError<Rv>;

    /**
     * There are too few signatories in the list.
     **/
    TooFewSignatories: GenericPalletError<Rv>;

    /**
     * There are too many signatories in the list.
     **/
    TooManySignatories: GenericPalletError<Rv>;

    /**
     * The signatories were provided out of order; they should be ordered.
     **/
    SignatoriesOutOfOrder: GenericPalletError<Rv>;

    /**
     * The sender was contained in the other signatories; it shouldn't be.
     **/
    SenderInSignatories: GenericPalletError<Rv>;

    /**
     * Multisig operation not found in storage.
     **/
    NotFound: GenericPalletError<Rv>;

    /**
     * Only the account that originally created the multisig is able to cancel it or update
     * its deposits.
     **/
    NotOwner: GenericPalletError<Rv>;

    /**
     * No timepoint was given, yet the multisig operation is already underway.
     **/
    NoTimepoint: GenericPalletError<Rv>;

    /**
     * A different timepoint was given to the multisig operation that is underway.
     **/
    WrongTimepoint: GenericPalletError<Rv>;

    /**
     * A timepoint was given, yet no multisig operation is underway.
     **/
    UnexpectedTimepoint: GenericPalletError<Rv>;

    /**
     * The maximum weight information provided was too low.
     **/
    MaxWeightTooLow: GenericPalletError<Rv>;

    /**
     * The data to be stored is already stored.
     **/
    AlreadyStored: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Bounties`'s errors
   **/
  bounties: {
    /**
     * Proposer's balance is too low.
     **/
    InsufficientProposersBalance: GenericPalletError<Rv>;

    /**
     * No proposal or bounty at that index.
     **/
    InvalidIndex: GenericPalletError<Rv>;

    /**
     * The reason given is just too big.
     **/
    ReasonTooBig: GenericPalletError<Rv>;

    /**
     * The bounty status is unexpected.
     **/
    UnexpectedStatus: GenericPalletError<Rv>;

    /**
     * Require bounty curator.
     **/
    RequireCurator: GenericPalletError<Rv>;

    /**
     * Invalid bounty value.
     **/
    InvalidValue: GenericPalletError<Rv>;

    /**
     * Invalid bounty fee.
     **/
    InvalidFee: GenericPalletError<Rv>;

    /**
     * A bounty payout is pending.
     * To cancel the bounty, you must unassign and slash the curator.
     **/
    PendingPayout: GenericPalletError<Rv>;

    /**
     * The bounties cannot be claimed/closed because it's still in the countdown period.
     **/
    Premature: GenericPalletError<Rv>;

    /**
     * The bounty cannot be closed because it has active child bounties.
     **/
    HasActiveChildBounty: GenericPalletError<Rv>;

    /**
     * Too many approvals are already queued.
     **/
    TooManyQueued: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Tips`'s errors
   **/
  tips: {
    /**
     * The reason given is just too big.
     **/
    ReasonTooBig: GenericPalletError<Rv>;

    /**
     * The tip was already found/started.
     **/
    AlreadyKnown: GenericPalletError<Rv>;

    /**
     * The tip hash is unknown.
     **/
    UnknownTip: GenericPalletError<Rv>;

    /**
     * The tip given was too generous.
     **/
    MaxTipAmountExceeded: GenericPalletError<Rv>;

    /**
     * The account attempting to retract the tip is not the finder of the tip.
     **/
    NotFinder: GenericPalletError<Rv>;

    /**
     * The tip cannot be claimed/closed because there are not enough tippers yet.
     **/
    StillOpen: GenericPalletError<Rv>;

    /**
     * The tip cannot be claimed/closed because it's still in the countdown period.
     **/
    Premature: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Assets`'s errors
   **/
  assets: {
    /**
     * Account balance must be greater than or equal to the transfer amount.
     **/
    BalanceLow: GenericPalletError<Rv>;

    /**
     * The account to alter does not exist.
     **/
    NoAccount: GenericPalletError<Rv>;

    /**
     * The signing account has no permission to do the operation.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * The given asset ID is unknown.
     **/
    Unknown: GenericPalletError<Rv>;

    /**
     * The origin account is frozen.
     **/
    Frozen: GenericPalletError<Rv>;

    /**
     * The asset ID is already taken.
     **/
    InUse: GenericPalletError<Rv>;

    /**
     * Invalid witness data given.
     **/
    BadWitness: GenericPalletError<Rv>;

    /**
     * Minimum balance should be non-zero.
     **/
    MinBalanceZero: GenericPalletError<Rv>;

    /**
     * Unable to increment the consumer reference counters on the account. Either no provider
     * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
     * fewer then the maximum number of consumers has been reached.
     **/
    UnavailableConsumer: GenericPalletError<Rv>;

    /**
     * Invalid metadata given.
     **/
    BadMetadata: GenericPalletError<Rv>;

    /**
     * No approval exists that would allow the transfer.
     **/
    Unapproved: GenericPalletError<Rv>;

    /**
     * The source account would not survive the transfer and it needs to stay alive.
     **/
    WouldDie: GenericPalletError<Rv>;

    /**
     * The asset-account already exists.
     **/
    AlreadyExists: GenericPalletError<Rv>;

    /**
     * The asset-account doesn't have an associated deposit.
     **/
    NoDeposit: GenericPalletError<Rv>;

    /**
     * The operation would result in funds being burned.
     **/
    WouldBurn: GenericPalletError<Rv>;

    /**
     * The asset is a live asset and is actively being used. Usually emit for operations such
     * as `start_destroy` which require the asset to be in a destroying state.
     **/
    LiveAsset: GenericPalletError<Rv>;

    /**
     * The asset is not live, and likely being destroyed.
     **/
    AssetNotLive: GenericPalletError<Rv>;

    /**
     * The asset status is not the expected status.
     **/
    IncorrectStatus: GenericPalletError<Rv>;

    /**
     * The asset should be frozen before the given operation.
     **/
    NotFrozen: GenericPalletError<Rv>;

    /**
     * Callback action resulted in error
     **/
    CallbackFailed: GenericPalletError<Rv>;

    /**
     * The asset ID must be equal to the [`NextAssetId`].
     **/
    BadAssetId: GenericPalletError<Rv>;

    /**
     * The asset cannot be destroyed because some accounts for this asset contain freezes.
     **/
    ContainsFreezes: GenericPalletError<Rv>;

    /**
     * The asset cannot be destroyed because some accounts for this asset contain holds.
     **/
    ContainsHolds: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `PoolAssets`'s errors
   **/
  poolAssets: {
    /**
     * Account balance must be greater than or equal to the transfer amount.
     **/
    BalanceLow: GenericPalletError<Rv>;

    /**
     * The account to alter does not exist.
     **/
    NoAccount: GenericPalletError<Rv>;

    /**
     * The signing account has no permission to do the operation.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * The given asset ID is unknown.
     **/
    Unknown: GenericPalletError<Rv>;

    /**
     * The origin account is frozen.
     **/
    Frozen: GenericPalletError<Rv>;

    /**
     * The asset ID is already taken.
     **/
    InUse: GenericPalletError<Rv>;

    /**
     * Invalid witness data given.
     **/
    BadWitness: GenericPalletError<Rv>;

    /**
     * Minimum balance should be non-zero.
     **/
    MinBalanceZero: GenericPalletError<Rv>;

    /**
     * Unable to increment the consumer reference counters on the account. Either no provider
     * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
     * fewer then the maximum number of consumers has been reached.
     **/
    UnavailableConsumer: GenericPalletError<Rv>;

    /**
     * Invalid metadata given.
     **/
    BadMetadata: GenericPalletError<Rv>;

    /**
     * No approval exists that would allow the transfer.
     **/
    Unapproved: GenericPalletError<Rv>;

    /**
     * The source account would not survive the transfer and it needs to stay alive.
     **/
    WouldDie: GenericPalletError<Rv>;

    /**
     * The asset-account already exists.
     **/
    AlreadyExists: GenericPalletError<Rv>;

    /**
     * The asset-account doesn't have an associated deposit.
     **/
    NoDeposit: GenericPalletError<Rv>;

    /**
     * The operation would result in funds being burned.
     **/
    WouldBurn: GenericPalletError<Rv>;

    /**
     * The asset is a live asset and is actively being used. Usually emit for operations such
     * as `start_destroy` which require the asset to be in a destroying state.
     **/
    LiveAsset: GenericPalletError<Rv>;

    /**
     * The asset is not live, and likely being destroyed.
     **/
    AssetNotLive: GenericPalletError<Rv>;

    /**
     * The asset status is not the expected status.
     **/
    IncorrectStatus: GenericPalletError<Rv>;

    /**
     * The asset should be frozen before the given operation.
     **/
    NotFrozen: GenericPalletError<Rv>;

    /**
     * Callback action resulted in error
     **/
    CallbackFailed: GenericPalletError<Rv>;

    /**
     * The asset ID must be equal to the [`NextAssetId`].
     **/
    BadAssetId: GenericPalletError<Rv>;

    /**
     * The asset cannot be destroyed because some accounts for this asset contain freezes.
     **/
    ContainsFreezes: GenericPalletError<Rv>;

    /**
     * The asset cannot be destroyed because some accounts for this asset contain holds.
     **/
    ContainsHolds: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Beefy`'s errors
   **/
  beefy: {
    /**
     * A key ownership proof provided as part of an equivocation report is invalid.
     **/
    InvalidKeyOwnershipProof: GenericPalletError<Rv>;

    /**
     * A double voting proof provided as part of an equivocation report is invalid.
     **/
    InvalidDoubleVotingProof: GenericPalletError<Rv>;

    /**
     * A fork voting proof provided as part of an equivocation report is invalid.
     **/
    InvalidForkVotingProof: GenericPalletError<Rv>;

    /**
     * A future block voting proof provided as part of an equivocation report is invalid.
     **/
    InvalidFutureBlockVotingProof: GenericPalletError<Rv>;

    /**
     * The session of the equivocation proof is invalid
     **/
    InvalidEquivocationProofSession: GenericPalletError<Rv>;

    /**
     * A given equivocation report is valid but already previously reported.
     **/
    DuplicateOffenceReport: GenericPalletError<Rv>;

    /**
     * Submitted configuration is invalid.
     **/
    InvalidConfiguration: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Lottery`'s errors
   **/
  lottery: {
    /**
     * A lottery has not been configured.
     **/
    NotConfigured: GenericPalletError<Rv>;

    /**
     * A lottery is already in progress.
     **/
    InProgress: GenericPalletError<Rv>;

    /**
     * A lottery has already ended.
     **/
    AlreadyEnded: GenericPalletError<Rv>;

    /**
     * The call is not valid for an open lottery.
     **/
    InvalidCall: GenericPalletError<Rv>;

    /**
     * You are already participating in the lottery with this call.
     **/
    AlreadyParticipating: GenericPalletError<Rv>;

    /**
     * Too many calls for a single lottery.
     **/
    TooManyCalls: GenericPalletError<Rv>;

    /**
     * Failed to encode calls
     **/
    EncodingFailed: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Nis`'s errors
   **/
  nis: {
    /**
     * The duration of the bid is less than one.
     **/
    DurationTooSmall: GenericPalletError<Rv>;

    /**
     * The duration is the bid is greater than the number of queues.
     **/
    DurationTooBig: GenericPalletError<Rv>;

    /**
     * The amount of the bid is less than the minimum allowed.
     **/
    AmountTooSmall: GenericPalletError<Rv>;

    /**
     * The queue for the bid's duration is full and the amount bid is too low to get in
     * through replacing an existing bid.
     **/
    BidTooLow: GenericPalletError<Rv>;

    /**
     * Receipt index is unknown.
     **/
    UnknownReceipt: GenericPalletError<Rv>;

    /**
     * Not the owner of the receipt.
     **/
    NotOwner: GenericPalletError<Rv>;

    /**
     * Bond not yet at expiry date.
     **/
    NotExpired: GenericPalletError<Rv>;

    /**
     * The given bid for retraction is not found.
     **/
    UnknownBid: GenericPalletError<Rv>;

    /**
     * The portion supplied is beyond the value of the receipt.
     **/
    PortionTooBig: GenericPalletError<Rv>;

    /**
     * Not enough funds are held to pay out.
     **/
    Unfunded: GenericPalletError<Rv>;

    /**
     * There are enough funds for what is required.
     **/
    AlreadyFunded: GenericPalletError<Rv>;

    /**
     * The thaw throttle has been reached for this period.
     **/
    Throttled: GenericPalletError<Rv>;

    /**
     * The operation would result in a receipt worth an insignificant value.
     **/
    MakesDust: GenericPalletError<Rv>;

    /**
     * The receipt is already communal.
     **/
    AlreadyCommunal: GenericPalletError<Rv>;

    /**
     * The receipt is already private.
     **/
    AlreadyPrivate: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Uniques`'s errors
   **/
  uniques: {
    /**
     * The signing account has no permission to do the operation.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * The given item ID is unknown.
     **/
    UnknownCollection: GenericPalletError<Rv>;

    /**
     * The item ID has already been used for an item.
     **/
    AlreadyExists: GenericPalletError<Rv>;

    /**
     * The owner turned out to be different to what was expected.
     **/
    WrongOwner: GenericPalletError<Rv>;

    /**
     * Invalid witness data given.
     **/
    BadWitness: GenericPalletError<Rv>;

    /**
     * The item ID is already taken.
     **/
    InUse: GenericPalletError<Rv>;

    /**
     * The item or collection is frozen.
     **/
    Frozen: GenericPalletError<Rv>;

    /**
     * The delegate turned out to be different to what was expected.
     **/
    WrongDelegate: GenericPalletError<Rv>;

    /**
     * There is no delegate approved.
     **/
    NoDelegate: GenericPalletError<Rv>;

    /**
     * No approval exists that would allow the transfer.
     **/
    Unapproved: GenericPalletError<Rv>;

    /**
     * The named owner has not signed ownership of the collection is acceptable.
     **/
    Unaccepted: GenericPalletError<Rv>;

    /**
     * The item is locked.
     **/
    Locked: GenericPalletError<Rv>;

    /**
     * All items have been minted.
     **/
    MaxSupplyReached: GenericPalletError<Rv>;

    /**
     * The max supply has already been set.
     **/
    MaxSupplyAlreadySet: GenericPalletError<Rv>;

    /**
     * The provided max supply is less to the amount of items a collection already has.
     **/
    MaxSupplyTooSmall: GenericPalletError<Rv>;

    /**
     * The given item ID is unknown.
     **/
    UnknownItem: GenericPalletError<Rv>;

    /**
     * Item is not for sale.
     **/
    NotForSale: GenericPalletError<Rv>;

    /**
     * The provided bid is too low.
     **/
    BidTooLow: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Nfts`'s errors
   **/
  nfts: {
    /**
     * The signing account has no permission to do the operation.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * The given item ID is unknown.
     **/
    UnknownCollection: GenericPalletError<Rv>;

    /**
     * The item ID has already been used for an item.
     **/
    AlreadyExists: GenericPalletError<Rv>;

    /**
     * The approval had a deadline that expired, so the approval isn't valid anymore.
     **/
    ApprovalExpired: GenericPalletError<Rv>;

    /**
     * The owner turned out to be different to what was expected.
     **/
    WrongOwner: GenericPalletError<Rv>;

    /**
     * The witness data given does not match the current state of the chain.
     **/
    BadWitness: GenericPalletError<Rv>;

    /**
     * Collection ID is already taken.
     **/
    CollectionIdInUse: GenericPalletError<Rv>;

    /**
     * Items within that collection are non-transferable.
     **/
    ItemsNonTransferable: GenericPalletError<Rv>;

    /**
     * The provided account is not a delegate.
     **/
    NotDelegate: GenericPalletError<Rv>;

    /**
     * The delegate turned out to be different to what was expected.
     **/
    WrongDelegate: GenericPalletError<Rv>;

    /**
     * No approval exists that would allow the transfer.
     **/
    Unapproved: GenericPalletError<Rv>;

    /**
     * The named owner has not signed ownership acceptance of the collection.
     **/
    Unaccepted: GenericPalletError<Rv>;

    /**
     * The item is locked (non-transferable).
     **/
    ItemLocked: GenericPalletError<Rv>;

    /**
     * Item's attributes are locked.
     **/
    LockedItemAttributes: GenericPalletError<Rv>;

    /**
     * Collection's attributes are locked.
     **/
    LockedCollectionAttributes: GenericPalletError<Rv>;

    /**
     * Item's metadata is locked.
     **/
    LockedItemMetadata: GenericPalletError<Rv>;

    /**
     * Collection's metadata is locked.
     **/
    LockedCollectionMetadata: GenericPalletError<Rv>;

    /**
     * All items have been minted.
     **/
    MaxSupplyReached: GenericPalletError<Rv>;

    /**
     * The max supply is locked and can't be changed.
     **/
    MaxSupplyLocked: GenericPalletError<Rv>;

    /**
     * The provided max supply is less than the number of items a collection already has.
     **/
    MaxSupplyTooSmall: GenericPalletError<Rv>;

    /**
     * The given item ID is unknown.
     **/
    UnknownItem: GenericPalletError<Rv>;

    /**
     * Swap doesn't exist.
     **/
    UnknownSwap: GenericPalletError<Rv>;

    /**
     * The given item has no metadata set.
     **/
    MetadataNotFound: GenericPalletError<Rv>;

    /**
     * The provided attribute can't be found.
     **/
    AttributeNotFound: GenericPalletError<Rv>;

    /**
     * Item is not for sale.
     **/
    NotForSale: GenericPalletError<Rv>;

    /**
     * The provided bid is too low.
     **/
    BidTooLow: GenericPalletError<Rv>;

    /**
     * The item has reached its approval limit.
     **/
    ReachedApprovalLimit: GenericPalletError<Rv>;

    /**
     * The deadline has already expired.
     **/
    DeadlineExpired: GenericPalletError<Rv>;

    /**
     * The duration provided should be less than or equal to `MaxDeadlineDuration`.
     **/
    WrongDuration: GenericPalletError<Rv>;

    /**
     * The method is disabled by system settings.
     **/
    MethodDisabled: GenericPalletError<Rv>;

    /**
     * The provided setting can't be set.
     **/
    WrongSetting: GenericPalletError<Rv>;

    /**
     * Item's config already exists and should be equal to the provided one.
     **/
    InconsistentItemConfig: GenericPalletError<Rv>;

    /**
     * Config for a collection or an item can't be found.
     **/
    NoConfig: GenericPalletError<Rv>;

    /**
     * Some roles were not cleared.
     **/
    RolesNotCleared: GenericPalletError<Rv>;

    /**
     * Mint has not started yet.
     **/
    MintNotStarted: GenericPalletError<Rv>;

    /**
     * Mint has already ended.
     **/
    MintEnded: GenericPalletError<Rv>;

    /**
     * The provided Item was already used for claiming.
     **/
    AlreadyClaimed: GenericPalletError<Rv>;

    /**
     * The provided data is incorrect.
     **/
    IncorrectData: GenericPalletError<Rv>;

    /**
     * The extrinsic was sent by the wrong origin.
     **/
    WrongOrigin: GenericPalletError<Rv>;

    /**
     * The provided signature is incorrect.
     **/
    WrongSignature: GenericPalletError<Rv>;

    /**
     * The provided metadata might be too long.
     **/
    IncorrectMetadata: GenericPalletError<Rv>;

    /**
     * Can't set more attributes per one call.
     **/
    MaxAttributesLimitReached: GenericPalletError<Rv>;

    /**
     * The provided namespace isn't supported in this call.
     **/
    WrongNamespace: GenericPalletError<Rv>;

    /**
     * Can't delete non-empty collections.
     **/
    CollectionNotEmpty: GenericPalletError<Rv>;

    /**
     * The witness data should be provided.
     **/
    WitnessRequired: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `NftFractionalization`'s errors
   **/
  nftFractionalization: {
    /**
     * Asset ID does not correspond to locked NFT.
     **/
    IncorrectAssetId: GenericPalletError<Rv>;

    /**
     * The signing account has no permission to do the operation.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * NFT doesn't exist.
     **/
    NftNotFound: GenericPalletError<Rv>;

    /**
     * NFT has not yet been fractionalised.
     **/
    NftNotFractionalized: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Salary`'s errors
   **/
  salary: {
    /**
     * The salary system has already been started.
     **/
    AlreadyStarted: GenericPalletError<Rv>;

    /**
     * The account is not a ranked member.
     **/
    NotMember: GenericPalletError<Rv>;

    /**
     * The account is already inducted.
     **/
    AlreadyInducted: GenericPalletError<Rv>;
    NotInducted: GenericPalletError<Rv>;

    /**
     * The member does not have a current valid claim.
     **/
    NoClaim: GenericPalletError<Rv>;

    /**
     * The member's claim is zero.
     **/
    ClaimZero: GenericPalletError<Rv>;

    /**
     * Current cycle's registration period is over.
     **/
    TooLate: GenericPalletError<Rv>;

    /**
     * Current cycle's payment period is not yet begun.
     **/
    TooEarly: GenericPalletError<Rv>;

    /**
     * Cycle is not yet over.
     **/
    NotYet: GenericPalletError<Rv>;

    /**
     * The payout cycles have not yet started.
     **/
    NotStarted: GenericPalletError<Rv>;

    /**
     * There is no budget left for the payout.
     **/
    Bankrupt: GenericPalletError<Rv>;

    /**
     * There was some issue with the mechanism of payment.
     **/
    PayError: GenericPalletError<Rv>;

    /**
     * The payment has neither failed nor succeeded yet.
     **/
    Inconclusive: GenericPalletError<Rv>;

    /**
     * The cycle is after that in which the payment was made.
     **/
    NotCurrent: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `CoreFellowship`'s errors
   **/
  coreFellowship: {
    /**
     * Member's rank is too low.
     **/
    Unranked: GenericPalletError<Rv>;

    /**
     * Member's rank is not zero.
     **/
    Ranked: GenericPalletError<Rv>;

    /**
     * Member's rank is not as expected - generally means that the rank provided to the call
     * does not agree with the state of the system.
     **/
    UnexpectedRank: GenericPalletError<Rv>;

    /**
     * The given rank is invalid - this generally means it's not between 1 and `RANK_COUNT`.
     **/
    InvalidRank: GenericPalletError<Rv>;

    /**
     * The origin does not have enough permission to do this operation.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * No work needs to be done at present for this member.
     **/
    NothingDoing: GenericPalletError<Rv>;

    /**
     * The candidate has already been inducted. This should never happen since it would
     * require a candidate (rank 0) to already be tracked in the pallet.
     **/
    AlreadyInducted: GenericPalletError<Rv>;

    /**
     * The candidate has not been inducted, so cannot be offboarded from this pallet.
     **/
    NotTracked: GenericPalletError<Rv>;

    /**
     * Operation cannot be done yet since not enough time has passed.
     **/
    TooSoon: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `TransactionStorage`'s errors
   **/
  transactionStorage: {
    /**
     * Invalid configuration.
     **/
    NotConfigured: GenericPalletError<Rv>;

    /**
     * Renewed extrinsic is not found.
     **/
    RenewedNotFound: GenericPalletError<Rv>;

    /**
     * Attempting to store empty transaction
     **/
    EmptyTransaction: GenericPalletError<Rv>;

    /**
     * Proof was not expected in this block.
     **/
    UnexpectedProof: GenericPalletError<Rv>;

    /**
     * Proof failed verification.
     **/
    InvalidProof: GenericPalletError<Rv>;

    /**
     * Missing storage proof.
     **/
    MissingProof: GenericPalletError<Rv>;

    /**
     * Unable to verify proof because state data is missing.
     **/
    MissingStateData: GenericPalletError<Rv>;

    /**
     * Double proof check in the block.
     **/
    DoubleCheck: GenericPalletError<Rv>;

    /**
     * Storage proof was not checked in the block.
     **/
    ProofNotChecked: GenericPalletError<Rv>;

    /**
     * Transaction is too large.
     **/
    TransactionTooLarge: GenericPalletError<Rv>;

    /**
     * Too many transactions in the block.
     **/
    TooManyTransactions: GenericPalletError<Rv>;

    /**
     * Attempted to call `store` outside of block execution.
     **/
    BadContext: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `VoterList`'s errors
   **/
  voterList: {
    /**
     * A error in the list interface implementation.
     **/
    List: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `StateTrieMigration`'s errors
   **/
  stateTrieMigration: {
    /**
     * Max signed limits not respected.
     **/
    MaxSignedLimits: GenericPalletError<Rv>;

    /**
     * A key was longer than the configured maximum.
     *
     * This means that the migration halted at the current [`Progress`] and
     * can be resumed with a larger [`crate::Config::MaxKeyLen`] value.
     * Retrying with the same [`crate::Config::MaxKeyLen`] value will not work.
     * The value should only be increased to avoid a storage migration for the currently
     * stored [`crate::Progress::LastKey`].
     **/
    KeyTooLong: GenericPalletError<Rv>;

    /**
     * submitter does not have enough funds.
     **/
    NotEnoughFunds: GenericPalletError<Rv>;

    /**
     * Bad witness data provided.
     **/
    BadWitness: GenericPalletError<Rv>;

    /**
     * Signed migration is not allowed because the maximum limit is not set yet.
     **/
    SignedMigrationNotAllowed: GenericPalletError<Rv>;

    /**
     * Bad child root provided.
     **/
    BadChildRoot: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `ChildBounties`'s errors
   **/
  childBounties: {
    /**
     * The parent bounty is not in active state.
     **/
    ParentBountyNotActive: GenericPalletError<Rv>;

    /**
     * The bounty balance is not enough to add new child-bounty.
     **/
    InsufficientBountyBalance: GenericPalletError<Rv>;

    /**
     * Number of child bounties exceeds limit `MaxActiveChildBountyCount`.
     **/
    TooManyChildBounties: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Referenda`'s errors
   **/
  referenda: {
    /**
     * Referendum is not ongoing.
     **/
    NotOngoing: GenericPalletError<Rv>;

    /**
     * Referendum's decision deposit is already paid.
     **/
    HasDeposit: GenericPalletError<Rv>;

    /**
     * The track identifier given was invalid.
     **/
    BadTrack: GenericPalletError<Rv>;

    /**
     * There are already a full complement of referenda in progress for this track.
     **/
    Full: GenericPalletError<Rv>;

    /**
     * The queue of the track is empty.
     **/
    QueueEmpty: GenericPalletError<Rv>;

    /**
     * The referendum index provided is invalid in this context.
     **/
    BadReferendum: GenericPalletError<Rv>;

    /**
     * There was nothing to do in the advancement.
     **/
    NothingToDo: GenericPalletError<Rv>;

    /**
     * No track exists for the proposal origin.
     **/
    NoTrack: GenericPalletError<Rv>;

    /**
     * Any deposit cannot be refunded until after the decision is over.
     **/
    Unfinished: GenericPalletError<Rv>;

    /**
     * The deposit refunder is not the depositor.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * The deposit cannot be refunded since none was made.
     **/
    NoDeposit: GenericPalletError<Rv>;

    /**
     * The referendum status is invalid for this operation.
     **/
    BadStatus: GenericPalletError<Rv>;

    /**
     * The preimage does not exist.
     **/
    PreimageNotExist: GenericPalletError<Rv>;

    /**
     * The preimage is stored with a different length than the one provided.
     **/
    PreimageStoredWithDifferentLength: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Remark`'s errors
   **/
  remark: {
    /**
     * Attempting to store empty data.
     **/
    Empty: GenericPalletError<Rv>;

    /**
     * Attempted to call `store` outside of block execution.
     **/
    BadContext: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `ConvictionVoting`'s errors
   **/
  convictionVoting: {
    /**
     * Poll is not ongoing.
     **/
    NotOngoing: GenericPalletError<Rv>;

    /**
     * The given account did not vote on the poll.
     **/
    NotVoter: GenericPalletError<Rv>;

    /**
     * The actor has no permission to conduct the action.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * The actor has no permission to conduct the action right now but will do in the future.
     **/
    NoPermissionYet: GenericPalletError<Rv>;

    /**
     * The account is already delegating.
     **/
    AlreadyDelegating: GenericPalletError<Rv>;

    /**
     * The account currently has votes attached to it and the operation cannot succeed until
     * these are removed through `remove_vote`.
     **/
    AlreadyVoting: GenericPalletError<Rv>;

    /**
     * Too high a balance was provided that the account cannot afford.
     **/
    InsufficientFunds: GenericPalletError<Rv>;

    /**
     * The account is not currently delegating.
     **/
    NotDelegating: GenericPalletError<Rv>;

    /**
     * Delegation to oneself makes no sense.
     **/
    Nonsense: GenericPalletError<Rv>;

    /**
     * Maximum number of votes reached.
     **/
    MaxVotesReached: GenericPalletError<Rv>;

    /**
     * The class must be supplied since it is not easily determinable from the state.
     **/
    ClassNeeded: GenericPalletError<Rv>;

    /**
     * The class ID supplied is invalid.
     **/
    BadClass: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Whitelist`'s errors
   **/
  whitelist: {
    /**
     * The preimage of the call hash could not be loaded.
     **/
    UnavailablePreImage: GenericPalletError<Rv>;

    /**
     * The call could not be decoded.
     **/
    UndecodableCall: GenericPalletError<Rv>;

    /**
     * The weight of the decoded call was higher than the witness.
     **/
    InvalidCallWeightWitness: GenericPalletError<Rv>;

    /**
     * The call was not whitelisted.
     **/
    CallIsNotWhitelisted: GenericPalletError<Rv>;

    /**
     * The call was already whitelisted; No-Op.
     **/
    CallAlreadyWhitelisted: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `AllianceMotion`'s errors
   **/
  allianceMotion: {
    /**
     * Account is not a member
     **/
    NotMember: GenericPalletError<Rv>;

    /**
     * Duplicate proposals not allowed
     **/
    DuplicateProposal: GenericPalletError<Rv>;

    /**
     * Proposal must exist
     **/
    ProposalMissing: GenericPalletError<Rv>;

    /**
     * Mismatched index
     **/
    WrongIndex: GenericPalletError<Rv>;

    /**
     * Duplicate vote ignored
     **/
    DuplicateVote: GenericPalletError<Rv>;

    /**
     * Members are already initialized!
     **/
    AlreadyInitialized: GenericPalletError<Rv>;

    /**
     * The close call was made too early, before the end of the voting.
     **/
    TooEarly: GenericPalletError<Rv>;

    /**
     * There can only be a maximum of `MaxProposals` active proposals.
     **/
    TooManyProposals: GenericPalletError<Rv>;

    /**
     * The given weight bound for the proposal was too low.
     **/
    WrongProposalWeight: GenericPalletError<Rv>;

    /**
     * The given length bound for the proposal was too low.
     **/
    WrongProposalLength: GenericPalletError<Rv>;

    /**
     * Prime account is not a member
     **/
    PrimeAccountNotMember: GenericPalletError<Rv>;

    /**
     * Proposal is still active.
     **/
    ProposalActive: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Alliance`'s errors
   **/
  alliance: {
    /**
     * The Alliance has not been initialized yet, therefore accounts cannot join it.
     **/
    AllianceNotYetInitialized: GenericPalletError<Rv>;

    /**
     * The Alliance has been initialized, therefore cannot be initialized again.
     **/
    AllianceAlreadyInitialized: GenericPalletError<Rv>;

    /**
     * Account is already a member.
     **/
    AlreadyMember: GenericPalletError<Rv>;

    /**
     * Account is not a member.
     **/
    NotMember: GenericPalletError<Rv>;

    /**
     * Account is not an ally.
     **/
    NotAlly: GenericPalletError<Rv>;

    /**
     * Account does not have voting rights.
     **/
    NoVotingRights: GenericPalletError<Rv>;

    /**
     * Account is already an elevated (fellow) member.
     **/
    AlreadyElevated: GenericPalletError<Rv>;

    /**
     * Item is already listed as unscrupulous.
     **/
    AlreadyUnscrupulous: GenericPalletError<Rv>;

    /**
     * Account has been deemed unscrupulous by the Alliance and is not welcome to join or be
     * nominated.
     **/
    AccountNonGrata: GenericPalletError<Rv>;

    /**
     * Item has not been deemed unscrupulous.
     **/
    NotListedAsUnscrupulous: GenericPalletError<Rv>;

    /**
     * The number of unscrupulous items exceeds `MaxUnscrupulousItems`.
     **/
    TooManyUnscrupulousItems: GenericPalletError<Rv>;

    /**
     * Length of website URL exceeds `MaxWebsiteUrlLength`.
     **/
    TooLongWebsiteUrl: GenericPalletError<Rv>;

    /**
     * Balance is insufficient for the required deposit.
     **/
    InsufficientFunds: GenericPalletError<Rv>;

    /**
     * The account's identity does not have display field and website field.
     **/
    WithoutRequiredIdentityFields: GenericPalletError<Rv>;

    /**
     * The account's identity has no good judgement.
     **/
    WithoutGoodIdentityJudgement: GenericPalletError<Rv>;

    /**
     * The proposal hash is not found.
     **/
    MissingProposalHash: GenericPalletError<Rv>;

    /**
     * The announcement is not found.
     **/
    MissingAnnouncement: GenericPalletError<Rv>;

    /**
     * Number of members exceeds `MaxMembersCount`.
     **/
    TooManyMembers: GenericPalletError<Rv>;

    /**
     * Number of announcements exceeds `MaxAnnouncementsCount`.
     **/
    TooManyAnnouncements: GenericPalletError<Rv>;

    /**
     * Invalid witness data given.
     **/
    BadWitness: GenericPalletError<Rv>;

    /**
     * Account already gave retirement notice
     **/
    AlreadyRetiring: GenericPalletError<Rv>;

    /**
     * Account did not give a retirement notice required to retire.
     **/
    RetirementNoticeNotGiven: GenericPalletError<Rv>;

    /**
     * Retirement period has not passed.
     **/
    RetirementPeriodNotPassed: GenericPalletError<Rv>;

    /**
     * Fellows must be provided to initialize the Alliance.
     **/
    FellowsMissing: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `NominationPools`'s errors
   **/
  nominationPools: {
    /**
     * A (bonded) pool id does not exist.
     **/
    PoolNotFound: GenericPalletError<Rv>;

    /**
     * An account is not a member.
     **/
    PoolMemberNotFound: GenericPalletError<Rv>;

    /**
     * A reward pool does not exist. In all cases this is a system logic error.
     **/
    RewardPoolNotFound: GenericPalletError<Rv>;

    /**
     * A sub pool does not exist.
     **/
    SubPoolsNotFound: GenericPalletError<Rv>;

    /**
     * An account is already delegating in another pool. An account may only belong to one
     * pool at a time.
     **/
    AccountBelongsToOtherPool: GenericPalletError<Rv>;

    /**
     * The member is fully unbonded (and thus cannot access the bonded and reward pool
     * anymore to, for example, collect rewards).
     **/
    FullyUnbonding: GenericPalletError<Rv>;

    /**
     * The member cannot unbond further chunks due to reaching the limit.
     **/
    MaxUnbondingLimit: GenericPalletError<Rv>;

    /**
     * None of the funds can be withdrawn yet because the bonding duration has not passed.
     **/
    CannotWithdrawAny: GenericPalletError<Rv>;

    /**
     * The amount does not meet the minimum bond to either join or create a pool.
     *
     * The depositor can never unbond to a value less than `Pallet::depositor_min_bond`. The
     * caller does not have nominating permissions for the pool. Members can never unbond to a
     * value below `MinJoinBond`.
     **/
    MinimumBondNotMet: GenericPalletError<Rv>;

    /**
     * The transaction could not be executed due to overflow risk for the pool.
     **/
    OverflowRisk: GenericPalletError<Rv>;

    /**
     * A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
     * other members to be permissionlessly unbonded.
     **/
    NotDestroying: GenericPalletError<Rv>;

    /**
     * The caller does not have nominating permissions for the pool.
     **/
    NotNominator: GenericPalletError<Rv>;

    /**
     * Either a) the caller cannot make a valid kick or b) the pool is not destroying.
     **/
    NotKickerOrDestroying: GenericPalletError<Rv>;

    /**
     * The pool is not open to join
     **/
    NotOpen: GenericPalletError<Rv>;

    /**
     * The system is maxed out on pools.
     **/
    MaxPools: GenericPalletError<Rv>;

    /**
     * Too many members in the pool or system.
     **/
    MaxPoolMembers: GenericPalletError<Rv>;

    /**
     * The pools state cannot be changed.
     **/
    CanNotChangeState: GenericPalletError<Rv>;

    /**
     * The caller does not have adequate permissions.
     **/
    DoesNotHavePermission: GenericPalletError<Rv>;

    /**
     * Metadata exceeds [`Config::MaxMetadataLen`]
     **/
    MetadataExceedsMaxLen: GenericPalletError<Rv>;

    /**
     * Some error occurred that should never happen. This should be reported to the
     * maintainers.
     **/
    Defensive: GenericPalletError<Rv>;

    /**
     * Partial unbonding now allowed permissionlessly.
     **/
    PartialUnbondNotAllowedPermissionlessly: GenericPalletError<Rv>;

    /**
     * The pool's max commission cannot be set higher than the existing value.
     **/
    MaxCommissionRestricted: GenericPalletError<Rv>;

    /**
     * The supplied commission exceeds the max allowed commission.
     **/
    CommissionExceedsMaximum: GenericPalletError<Rv>;

    /**
     * The supplied commission exceeds global maximum commission.
     **/
    CommissionExceedsGlobalMaximum: GenericPalletError<Rv>;

    /**
     * Not enough blocks have surpassed since the last commission update.
     **/
    CommissionChangeThrottled: GenericPalletError<Rv>;

    /**
     * The submitted changes to commission change rate are not allowed.
     **/
    CommissionChangeRateNotAllowed: GenericPalletError<Rv>;

    /**
     * There is no pending commission to claim.
     **/
    NoPendingCommission: GenericPalletError<Rv>;

    /**
     * No commission current has been set.
     **/
    NoCommissionCurrentSet: GenericPalletError<Rv>;

    /**
     * Pool id currently in use.
     **/
    PoolIdInUse: GenericPalletError<Rv>;

    /**
     * Pool id provided is not correct/usable.
     **/
    InvalidPoolId: GenericPalletError<Rv>;

    /**
     * Bonding extra is restricted to the exact pending reward amount.
     **/
    BondExtraRestricted: GenericPalletError<Rv>;

    /**
     * No imbalance in the ED deposit for the pool.
     **/
    NothingToAdjust: GenericPalletError<Rv>;

    /**
     * No slash pending that can be applied to the member.
     **/
    NothingToSlash: GenericPalletError<Rv>;

    /**
     * The slash amount is too low to be applied.
     **/
    SlashTooLow: GenericPalletError<Rv>;

    /**
     * The pool or member delegation has already migrated to delegate stake.
     **/
    AlreadyMigrated: GenericPalletError<Rv>;

    /**
     * The pool or member delegation has not migrated yet to delegate stake.
     **/
    NotMigrated: GenericPalletError<Rv>;

    /**
     * This call is not allowed in the current state of the pallet.
     **/
    NotSupported: GenericPalletError<Rv>;

    /**
     * Account is restricted from participation in pools. This may happen if the account is
     * staking in another way already.
     **/
    Restricted: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `RankedPolls`'s errors
   **/
  rankedPolls: {
    /**
     * Referendum is not ongoing.
     **/
    NotOngoing: GenericPalletError<Rv>;

    /**
     * Referendum's decision deposit is already paid.
     **/
    HasDeposit: GenericPalletError<Rv>;

    /**
     * The track identifier given was invalid.
     **/
    BadTrack: GenericPalletError<Rv>;

    /**
     * There are already a full complement of referenda in progress for this track.
     **/
    Full: GenericPalletError<Rv>;

    /**
     * The queue of the track is empty.
     **/
    QueueEmpty: GenericPalletError<Rv>;

    /**
     * The referendum index provided is invalid in this context.
     **/
    BadReferendum: GenericPalletError<Rv>;

    /**
     * There was nothing to do in the advancement.
     **/
    NothingToDo: GenericPalletError<Rv>;

    /**
     * No track exists for the proposal origin.
     **/
    NoTrack: GenericPalletError<Rv>;

    /**
     * Any deposit cannot be refunded until after the decision is over.
     **/
    Unfinished: GenericPalletError<Rv>;

    /**
     * The deposit refunder is not the depositor.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * The deposit cannot be refunded since none was made.
     **/
    NoDeposit: GenericPalletError<Rv>;

    /**
     * The referendum status is invalid for this operation.
     **/
    BadStatus: GenericPalletError<Rv>;

    /**
     * The preimage does not exist.
     **/
    PreimageNotExist: GenericPalletError<Rv>;

    /**
     * The preimage is stored with a different length than the one provided.
     **/
    PreimageStoredWithDifferentLength: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `RankedCollective`'s errors
   **/
  rankedCollective: {
    /**
     * Account is already a member.
     **/
    AlreadyMember: GenericPalletError<Rv>;

    /**
     * Account is not a member.
     **/
    NotMember: GenericPalletError<Rv>;

    /**
     * The given poll index is unknown or has closed.
     **/
    NotPolling: GenericPalletError<Rv>;

    /**
     * The given poll is still ongoing.
     **/
    Ongoing: GenericPalletError<Rv>;

    /**
     * There are no further records to be removed.
     **/
    NoneRemaining: GenericPalletError<Rv>;

    /**
     * Unexpected error in state.
     **/
    Corruption: GenericPalletError<Rv>;

    /**
     * The member's rank is too low to vote.
     **/
    RankTooLow: GenericPalletError<Rv>;

    /**
     * The information provided is incorrect.
     **/
    InvalidWitness: GenericPalletError<Rv>;

    /**
     * The origin is not sufficiently privileged to do the operation.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * The new member to exchange is the same as the old member
     **/
    SameMember: GenericPalletError<Rv>;

    /**
     * The max member count for the rank has been reached.
     **/
    TooManyMembers: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `AssetConversion`'s errors
   **/
  assetConversion: {
    /**
     * Provided asset pair is not supported for pool.
     **/
    InvalidAssetPair: GenericPalletError<Rv>;

    /**
     * Pool already exists.
     **/
    PoolExists: GenericPalletError<Rv>;

    /**
     * Desired amount can't be zero.
     **/
    WrongDesiredAmount: GenericPalletError<Rv>;

    /**
     * Provided amount should be greater than or equal to the existential deposit/asset's
     * minimal amount.
     **/
    AmountOneLessThanMinimal: GenericPalletError<Rv>;

    /**
     * Provided amount should be greater than or equal to the existential deposit/asset's
     * minimal amount.
     **/
    AmountTwoLessThanMinimal: GenericPalletError<Rv>;

    /**
     * Reserve needs to always be greater than or equal to the existential deposit/asset's
     * minimal amount.
     **/
    ReserveLeftLessThanMinimal: GenericPalletError<Rv>;

    /**
     * Desired amount can't be equal to the pool reserve.
     **/
    AmountOutTooHigh: GenericPalletError<Rv>;

    /**
     * The pool doesn't exist.
     **/
    PoolNotFound: GenericPalletError<Rv>;

    /**
     * An overflow happened.
     **/
    Overflow: GenericPalletError<Rv>;

    /**
     * The minimal amount requirement for the first token in the pair wasn't met.
     **/
    AssetOneDepositDidNotMeetMinimum: GenericPalletError<Rv>;

    /**
     * The minimal amount requirement for the second token in the pair wasn't met.
     **/
    AssetTwoDepositDidNotMeetMinimum: GenericPalletError<Rv>;

    /**
     * The minimal amount requirement for the first token in the pair wasn't met.
     **/
    AssetOneWithdrawalDidNotMeetMinimum: GenericPalletError<Rv>;

    /**
     * The minimal amount requirement for the second token in the pair wasn't met.
     **/
    AssetTwoWithdrawalDidNotMeetMinimum: GenericPalletError<Rv>;

    /**
     * Optimal calculated amount is less than desired.
     **/
    OptimalAmountLessThanDesired: GenericPalletError<Rv>;

    /**
     * Insufficient liquidity minted.
     **/
    InsufficientLiquidityMinted: GenericPalletError<Rv>;

    /**
     * Requested liquidity can't be zero.
     **/
    ZeroLiquidity: GenericPalletError<Rv>;

    /**
     * Amount can't be zero.
     **/
    ZeroAmount: GenericPalletError<Rv>;

    /**
     * Calculated amount out is less than provided minimum amount.
     **/
    ProvidedMinimumNotSufficientForSwap: GenericPalletError<Rv>;

    /**
     * Provided maximum amount is not sufficient for swap.
     **/
    ProvidedMaximumNotSufficientForSwap: GenericPalletError<Rv>;

    /**
     * The provided path must consists of 2 assets at least.
     **/
    InvalidPath: GenericPalletError<Rv>;

    /**
     * The provided path must consists of unique assets.
     **/
    NonUniquePath: GenericPalletError<Rv>;

    /**
     * It was not possible to get or increment the Id of the pool.
     **/
    IncorrectPoolAssetId: GenericPalletError<Rv>;

    /**
     * The destination account cannot exist with the swapped funds.
     **/
    BelowMinimum: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `FastUnstake`'s errors
   **/
  fastUnstake: {
    /**
     * The provided Controller account was not found.
     *
     * This means that the given account is not bonded.
     **/
    NotController: GenericPalletError<Rv>;

    /**
     * The bonded account has already been queued.
     **/
    AlreadyQueued: GenericPalletError<Rv>;

    /**
     * The bonded account has active unlocking chunks.
     **/
    NotFullyBonded: GenericPalletError<Rv>;

    /**
     * The provided un-staker is not in the `Queue`.
     **/
    NotQueued: GenericPalletError<Rv>;

    /**
     * The provided un-staker is already in Head, and cannot deregister.
     **/
    AlreadyHead: GenericPalletError<Rv>;

    /**
     * The call is not allowed at this point because the pallet is not active.
     **/
    CallNotAllowed: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `MessageQueue`'s errors
   **/
  messageQueue: {
    /**
     * Page is not reapable because it has items remaining to be processed and is not old
     * enough.
     **/
    NotReapable: GenericPalletError<Rv>;

    /**
     * Page to be reaped does not exist.
     **/
    NoPage: GenericPalletError<Rv>;

    /**
     * The referenced message could not be found.
     **/
    NoMessage: GenericPalletError<Rv>;

    /**
     * The message was already processed and cannot be processed again.
     **/
    AlreadyProcessed: GenericPalletError<Rv>;

    /**
     * The message is queued for future execution.
     **/
    Queued: GenericPalletError<Rv>;

    /**
     * There is temporarily not enough weight to continue servicing messages.
     **/
    InsufficientWeight: GenericPalletError<Rv>;

    /**
     * This message is temporarily unprocessable.
     *
     * Such errors are expected, but not guaranteed, to resolve themselves eventually through
     * retrying.
     **/
    TemporarilyUnprocessable: GenericPalletError<Rv>;

    /**
     * The queue is paused and no message can be executed from it.
     *
     * This can change at any time and may resolve in the future by re-trying.
     **/
    QueuePaused: GenericPalletError<Rv>;

    /**
     * Another call is in progress and needs to finish before this call can happen.
     **/
    RecursiveDisallowed: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `TxPause`'s errors
   **/
  txPause: {
    /**
     * The call is paused.
     **/
    IsPaused: GenericPalletError<Rv>;

    /**
     * The call is unpaused.
     **/
    IsUnpaused: GenericPalletError<Rv>;

    /**
     * The call is whitelisted and cannot be paused.
     **/
    Unpausable: GenericPalletError<Rv>;
    NotFound: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `SafeMode`'s errors
   **/
  safeMode: {
    /**
     * The safe-mode is (already or still) entered.
     **/
    Entered: GenericPalletError<Rv>;

    /**
     * The safe-mode is (already or still) exited.
     **/
    Exited: GenericPalletError<Rv>;

    /**
     * This functionality of the pallet is disabled by the configuration.
     **/
    NotConfigured: GenericPalletError<Rv>;

    /**
     * There is no balance reserved.
     **/
    NoDeposit: GenericPalletError<Rv>;

    /**
     * The account already has a deposit reserved and can therefore not enter or extend again.
     **/
    AlreadyDeposited: GenericPalletError<Rv>;

    /**
     * This deposit cannot be released yet.
     **/
    CannotReleaseYet: GenericPalletError<Rv>;

    /**
     * An error from the underlying `Currency`.
     **/
    CurrencyError: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `MultiBlockMigrations`'s errors
   **/
  multiBlockMigrations: {
    /**
     * The operation cannot complete since some MBMs are ongoing.
     **/
    Ongoing: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Broker`'s errors
   **/
  broker: {
    /**
     * The given region identity is not known.
     **/
    UnknownRegion: GenericPalletError<Rv>;

    /**
     * The owner of the region is not the origin.
     **/
    NotOwner: GenericPalletError<Rv>;

    /**
     * The pivot point of the partition at or after the end of the region.
     **/
    PivotTooLate: GenericPalletError<Rv>;

    /**
     * The pivot point of the partition at the beginning of the region.
     **/
    PivotTooEarly: GenericPalletError<Rv>;

    /**
     * The pivot mask for the interlacing is not contained within the region's interlace mask.
     **/
    ExteriorPivot: GenericPalletError<Rv>;

    /**
     * The pivot mask for the interlacing is void (and therefore unschedulable).
     **/
    VoidPivot: GenericPalletError<Rv>;

    /**
     * The pivot mask for the interlacing is complete (and therefore not a strict subset).
     **/
    CompletePivot: GenericPalletError<Rv>;

    /**
     * The workplan of the pallet's state is invalid. This indicates a state corruption.
     **/
    CorruptWorkplan: GenericPalletError<Rv>;

    /**
     * There is no sale happening currently.
     **/
    NoSales: GenericPalletError<Rv>;

    /**
     * The price limit is exceeded.
     **/
    Overpriced: GenericPalletError<Rv>;

    /**
     * There are no cores available.
     **/
    Unavailable: GenericPalletError<Rv>;

    /**
     * The sale limit has been reached.
     **/
    SoldOut: GenericPalletError<Rv>;

    /**
     * The renewal operation is not valid at the current time (it may become valid in the next
     * sale).
     **/
    WrongTime: GenericPalletError<Rv>;

    /**
     * Invalid attempt to renew.
     **/
    NotAllowed: GenericPalletError<Rv>;

    /**
     * This pallet has not yet been initialized.
     **/
    Uninitialized: GenericPalletError<Rv>;

    /**
     * The purchase cannot happen yet as the sale period is yet to begin.
     **/
    TooEarly: GenericPalletError<Rv>;

    /**
     * There is no work to be done.
     **/
    NothingToDo: GenericPalletError<Rv>;

    /**
     * The maximum amount of reservations has already been reached.
     **/
    TooManyReservations: GenericPalletError<Rv>;

    /**
     * The maximum amount of leases has already been reached.
     **/
    TooManyLeases: GenericPalletError<Rv>;

    /**
     * The lease does not exist.
     **/
    LeaseNotFound: GenericPalletError<Rv>;

    /**
     * The revenue for the Instantaneous Core Sales of this period is not (yet) known and thus
     * this operation cannot proceed.
     **/
    UnknownRevenue: GenericPalletError<Rv>;

    /**
     * The identified contribution to the Instantaneous Core Pool is unknown.
     **/
    UnknownContribution: GenericPalletError<Rv>;

    /**
     * The workload assigned for renewal is incomplete. This is unexpected and indicates a
     * logic error.
     **/
    IncompleteAssignment: GenericPalletError<Rv>;

    /**
     * An item cannot be dropped because it is still valid.
     **/
    StillValid: GenericPalletError<Rv>;

    /**
     * The history item does not exist.
     **/
    NoHistory: GenericPalletError<Rv>;

    /**
     * No reservation of the given index exists.
     **/
    UnknownReservation: GenericPalletError<Rv>;

    /**
     * The renewal record cannot be found.
     **/
    UnknownRenewal: GenericPalletError<Rv>;

    /**
     * The lease expiry time has already passed.
     **/
    AlreadyExpired: GenericPalletError<Rv>;

    /**
     * The configuration could not be applied because it is invalid.
     **/
    InvalidConfig: GenericPalletError<Rv>;

    /**
     * The revenue must be claimed for 1 or more timeslices.
     **/
    NoClaimTimeslices: GenericPalletError<Rv>;

    /**
     * The caller doesn't have the permission to enable or disable auto-renewal.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * We reached the limit for auto-renewals.
     **/
    TooManyAutoRenewals: GenericPalletError<Rv>;

    /**
     * Only cores which are assigned to a task can be auto-renewed.
     **/
    NonTaskAutoRenewal: GenericPalletError<Rv>;

    /**
     * Failed to get the sovereign account of a task.
     **/
    SovereignAccountNotFound: GenericPalletError<Rv>;

    /**
     * Attempted to disable auto-renewal for a core that didn't have it enabled.
     **/
    AutoRenewalNotEnabled: GenericPalletError<Rv>;

    /**
     * Attempted to force remove an assignment that doesn't exist.
     **/
    AssignmentNotFound: GenericPalletError<Rv>;

    /**
     * Needed to prevent spam attacks.The amount of credits the user attempted to purchase is
     * below `T::MinimumCreditPurchase`.
     **/
    CreditPurchaseTooSmall: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `TasksExample`'s errors
   **/
  tasksExample: {
    /**
     * The referenced task was not found.
     **/
    NotFound: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `AssetConversionMigration`'s errors
   **/
  assetConversionMigration: {
    /**
     * Provided asset pair is not supported for pool.
     **/
    InvalidAssetPair: GenericPalletError<Rv>;

    /**
     * The pool doesn't exist.
     **/
    PoolNotFound: GenericPalletError<Rv>;

    /**
     * Pool's balance cannot be zero.
     **/
    ZeroBalance: GenericPalletError<Rv>;

    /**
     * Indicates a partial transfer of balance to the new account during a migration.
     **/
    PartialTransfer: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Revive`'s errors
   **/
  revive: {
    /**
     * Invalid schedule supplied, e.g. with zero weight of a basic operation.
     **/
    InvalidSchedule: GenericPalletError<Rv>;

    /**
     * Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`.
     **/
    InvalidCallFlags: GenericPalletError<Rv>;

    /**
     * The executed contract exhausted its gas limit.
     **/
    OutOfGas: GenericPalletError<Rv>;

    /**
     * Performing the requested transfer failed. Probably because there isn't enough
     * free balance in the sender's account.
     **/
    TransferFailed: GenericPalletError<Rv>;

    /**
     * Performing a call was denied because the calling depth reached the limit
     * of what is specified in the schedule.
     **/
    MaxCallDepthReached: GenericPalletError<Rv>;

    /**
     * No contract was found at the specified address.
     **/
    ContractNotFound: GenericPalletError<Rv>;

    /**
     * No code could be found at the supplied code hash.
     **/
    CodeNotFound: GenericPalletError<Rv>;

    /**
     * No code info could be found at the supplied code hash.
     **/
    CodeInfoNotFound: GenericPalletError<Rv>;

    /**
     * A buffer outside of sandbox memory was passed to a contract API function.
     **/
    OutOfBounds: GenericPalletError<Rv>;

    /**
     * Input passed to a contract API function failed to decode as expected type.
     **/
    DecodingFailed: GenericPalletError<Rv>;

    /**
     * Contract trapped during execution.
     **/
    ContractTrapped: GenericPalletError<Rv>;

    /**
     * The size defined in `T::MaxValueSize` was exceeded.
     **/
    ValueTooLarge: GenericPalletError<Rv>;

    /**
     * Termination of a contract is not allowed while the contract is already
     * on the call stack. Can be triggered by `seal_terminate`.
     **/
    TerminatedWhileReentrant: GenericPalletError<Rv>;

    /**
     * `seal_call` forwarded this contracts input. It therefore is no longer available.
     **/
    InputForwarded: GenericPalletError<Rv>;

    /**
     * The amount of topics passed to `seal_deposit_events` exceeds the limit.
     **/
    TooManyTopics: GenericPalletError<Rv>;

    /**
     * The chain does not provide a chain extension. Calling the chain extension results
     * in this error. Note that this usually shouldn't happen as deploying such contracts
     * is rejected.
     **/
    NoChainExtension: GenericPalletError<Rv>;

    /**
     * Failed to decode the XCM program.
     **/
    XcmDecodeFailed: GenericPalletError<Rv>;

    /**
     * A contract with the same AccountId already exists.
     **/
    DuplicateContract: GenericPalletError<Rv>;

    /**
     * A contract self destructed in its constructor.
     *
     * This can be triggered by a call to `seal_terminate`.
     **/
    TerminatedInConstructor: GenericPalletError<Rv>;

    /**
     * A call tried to invoke a contract that is flagged as non-reentrant.
     **/
    ReentranceDenied: GenericPalletError<Rv>;

    /**
     * A contract called into the runtime which then called back into this pallet.
     **/
    ReenteredPallet: GenericPalletError<Rv>;

    /**
     * A contract attempted to invoke a state modifying API while being in read-only mode.
     **/
    StateChangeDenied: GenericPalletError<Rv>;

    /**
     * Origin doesn't have enough balance to pay the required storage deposits.
     **/
    StorageDepositNotEnoughFunds: GenericPalletError<Rv>;

    /**
     * More storage was created than allowed by the storage deposit limit.
     **/
    StorageDepositLimitExhausted: GenericPalletError<Rv>;

    /**
     * Code removal was denied because the code is still in use by at least one contract.
     **/
    CodeInUse: GenericPalletError<Rv>;

    /**
     * The contract ran to completion but decided to revert its storage changes.
     * Please note that this error is only returned from extrinsics. When called directly
     * or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags
     * to determine whether a reversion has taken place.
     **/
    ContractReverted: GenericPalletError<Rv>;

    /**
     * The contract failed to compile or is missing the correct entry points.
     *
     * A more detailed error can be found on the node console if debug messages are enabled
     * by supplying `-lruntime::revive=debug`.
     **/
    CodeRejected: GenericPalletError<Rv>;

    /**
     * The code blob supplied is larger than [`limits::code::BLOB_BYTES`].
     **/
    BlobTooLarge: GenericPalletError<Rv>;

    /**
     * The static memory consumption of the blob will be larger than
     * [`limits::code::STATIC_MEMORY_BYTES`].
     **/
    StaticMemoryTooLarge: GenericPalletError<Rv>;

    /**
     * The program contains a basic block that is larger than allowed.
     **/
    BasicBlockTooLarge: GenericPalletError<Rv>;

    /**
     * The program contains an invalid instruction.
     **/
    InvalidInstruction: GenericPalletError<Rv>;

    /**
     * The contract has reached its maximum number of delegate dependencies.
     **/
    MaxDelegateDependenciesReached: GenericPalletError<Rv>;

    /**
     * The dependency was not found in the contract's delegate dependencies.
     **/
    DelegateDependencyNotFound: GenericPalletError<Rv>;

    /**
     * The contract already depends on the given delegate dependency.
     **/
    DelegateDependencyAlreadyExists: GenericPalletError<Rv>;

    /**
     * Can not add a delegate dependency to the code hash of the contract itself.
     **/
    CannotAddSelfAsDelegateDependency: GenericPalletError<Rv>;

    /**
     * Can not add more data to transient storage.
     **/
    OutOfTransientStorage: GenericPalletError<Rv>;

    /**
     * The contract tried to call a syscall which does not exist (at its current api level).
     **/
    InvalidSyscall: GenericPalletError<Rv>;

    /**
     * Invalid storage flags were passed to one of the storage syscalls.
     **/
    InvalidStorageFlags: GenericPalletError<Rv>;

    /**
     * PolkaVM failed during code execution. Probably due to a malformed program.
     **/
    ExecutionFailed: GenericPalletError<Rv>;

    /**
     * Failed to convert a U256 to a Balance.
     **/
    BalanceConversionFailed: GenericPalletError<Rv>;

    /**
     * Failed to convert an EVM balance to a native balance.
     **/
    DecimalPrecisionLoss: GenericPalletError<Rv>;

    /**
     * Immutable data can only be set during deploys and only be read during calls.
     * Additionally, it is only valid to set the data once and it must not be empty.
     **/
    InvalidImmutableAccess: GenericPalletError<Rv>;

    /**
     * An `AccountID32` account tried to interact with the pallet without having a mapping.
     *
     * Call [`Pallet::map_account`] in order to create a mapping for the account.
     **/
    AccountUnmapped: GenericPalletError<Rv>;

    /**
     * Tried to map an account that is already mapped.
     **/
    AccountAlreadyMapped: GenericPalletError<Rv>;

    /**
     * The transaction used to dry-run a contract is invalid.
     **/
    InvalidGenericTransaction: GenericPalletError<Rv>;

    /**
     * The refcount of a code either over or underflowed.
     **/
    RefcountOverOrUnderflow: GenericPalletError<Rv>;

    /**
     * Unsupported precompile address
     **/
    UnsupportedPrecompileAddress: GenericPalletError<Rv>;

    /**
     * Precompile Error
     **/
    PrecompileFailure: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `DelegatedStaking`'s errors
   **/
  delegatedStaking: {
    /**
     * The account cannot perform this operation.
     **/
    NotAllowed: GenericPalletError<Rv>;

    /**
     * An existing staker cannot perform this action.
     **/
    AlreadyStaking: GenericPalletError<Rv>;

    /**
     * Reward Destination cannot be same as `Agent` account.
     **/
    InvalidRewardDestination: GenericPalletError<Rv>;

    /**
     * Delegation conditions are not met.
     *
     * Possible issues are
     * 1) Cannot delegate to self,
     * 2) Cannot delegate to multiple delegates.
     **/
    InvalidDelegation: GenericPalletError<Rv>;

    /**
     * The account does not have enough funds to perform the operation.
     **/
    NotEnoughFunds: GenericPalletError<Rv>;

    /**
     * Not an existing `Agent` account.
     **/
    NotAgent: GenericPalletError<Rv>;

    /**
     * Not a Delegator account.
     **/
    NotDelegator: GenericPalletError<Rv>;

    /**
     * Some corruption in internal state.
     **/
    BadState: GenericPalletError<Rv>;

    /**
     * Unapplied pending slash restricts operation on `Agent`.
     **/
    UnappliedSlash: GenericPalletError<Rv>;

    /**
     * `Agent` has no pending slash to be applied.
     **/
    NothingToSlash: GenericPalletError<Rv>;

    /**
     * Failed to withdraw amount from Core Staking.
     **/
    WithdrawFailed: GenericPalletError<Rv>;

    /**
     * Operation not supported by this pallet.
     **/
    NotSupported: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `AssetRewards`'s errors
   **/
  assetRewards: {
    /**
     * The staker does not have enough tokens to perform the operation.
     **/
    NotEnoughTokens: GenericPalletError<Rv>;

    /**
     * An operation was attempted on a non-existent pool.
     **/
    NonExistentPool: GenericPalletError<Rv>;

    /**
     * An operation was attempted for a non-existent staker.
     **/
    NonExistentStaker: GenericPalletError<Rv>;

    /**
     * An operation was attempted with a non-existent asset.
     **/
    NonExistentAsset: GenericPalletError<Rv>;

    /**
     * There was an error converting a block number.
     **/
    BlockNumberConversionError: GenericPalletError<Rv>;

    /**
     * The expiry block must be in the future.
     **/
    ExpiryBlockMustBeInTheFuture: GenericPalletError<Rv>;

    /**
     * Insufficient funds to create the freeze.
     **/
    InsufficientFunds: GenericPalletError<Rv>;

    /**
     * The expiry block can be only extended.
     **/
    ExpiryCut: GenericPalletError<Rv>;

    /**
     * The reward rate per block can be only increased.
     **/
    RewardRateCut: GenericPalletError<Rv>;

    /**
     * The pool still has staked tokens or rewards.
     **/
    NonEmptyPool: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `AssetsFreezer`'s errors
   **/
  assetsFreezer: {
    /**
     * Number of freezes on an account would exceed `MaxFreezes`.
     **/
    TooManyFreezes: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `MetaTx`'s errors
   **/
  metaTx: {
    /**
     * Invalid proof (e.g. signature).
     **/
    BadProof: GenericPalletError<Rv>;

    /**
     * The meta transaction is not yet valid (e.g. nonce too high).
     **/
    Future: GenericPalletError<Rv>;

    /**
     * The meta transaction is outdated (e.g. nonce too low).
     **/
    Stale: GenericPalletError<Rv>;

    /**
     * The meta transactions's birth block is ancient.
     **/
    AncientBirthBlock: GenericPalletError<Rv>;

    /**
     * The transaction extension did not authorize any origin.
     **/
    UnknownOrigin: GenericPalletError<Rv>;

    /**
     * The meta transaction is invalid.
     **/
    Invalid: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
}
